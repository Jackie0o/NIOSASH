(() => {
    var __webpack_modules__ = {
        495: (module, __unused_webpack_exports, __webpack_require__) => {
            "use strict";
            var window = __webpack_require__(840);
            var httpResponseHandler = function httpResponseHandler(callback, decodeResponseBody) {
                if (decodeResponseBody === void 0) decodeResponseBody = false;
                return function(err, response, responseBody) {
                    if (err) {
                        callback(err);
                        return;
                    }
                    if (response.statusCode >= 400 && response.statusCode <= 599) {
                        var cause = responseBody;
                        if (decodeResponseBody) if (window.TextDecoder) {
                            var charset = getCharset(response.headers && response.headers["content-type"]);
                            try {
                                cause = new TextDecoder(charset).decode(responseBody);
                            } catch (e) {}
                        } else cause = String.fromCharCode.apply(null, new Uint8Array(responseBody));
                        callback({
                            cause
                        });
                        return;
                    }
                    callback(null, responseBody);
                };
            };
            function getCharset(contentTypeHeader) {
                if (contentTypeHeader === void 0) contentTypeHeader = "";
                return contentTypeHeader.toLowerCase().split(";").reduce((function(charset, contentType) {
                    var _contentType$split = contentType.split("="), type = _contentType$split[0], value = _contentType$split[1];
                    if (type.trim() === "charset") return value.trim();
                    return charset;
                }), "utf-8");
            }
            module.exports = httpResponseHandler;
        },
        36: (module, __unused_webpack_exports, __webpack_require__) => {
            "use strict";
            var window = __webpack_require__(840);
            var _extends = __webpack_require__(634);
            var isFunction = __webpack_require__(56);
            var InterceptorsStorage = __webpack_require__(162);
            var RetryManager = __webpack_require__(670);
            createXHR.httpHandler = __webpack_require__(495);
            createXHR.requestInterceptorsStorage = new InterceptorsStorage;
            createXHR.responseInterceptorsStorage = new InterceptorsStorage;
            createXHR.retryManager = new RetryManager;
            /**
 * @license
 * slighly modified parse-headers 2.0.2 <https://github.com/kesla/parse-headers/>
 * Copyright (c) 2014 David Bj√∂rklund
 * Available under the MIT license
 * <https://github.com/kesla/parse-headers/blob/master/LICENCE>
 */            var parseHeaders = function parseHeaders(headers) {
                var result = {};
                if (!headers) return result;
                headers.trim().split("\n").forEach((function(row) {
                    var index = row.indexOf(":");
                    var key = row.slice(0, index).trim().toLowerCase();
                    var value = row.slice(index + 1).trim();
                    if (typeof result[key] === "undefined") result[key] = value; else if (Array.isArray(result[key])) result[key].push(value); else result[key] = [ result[key], value ];
                }));
                return result;
            };
            module.exports = createXHR;
            module.exports["default"] = createXHR;
            createXHR.XMLHttpRequest = window.XMLHttpRequest || noop;
            createXHR.XDomainRequest = "withCredentials" in new createXHR.XMLHttpRequest ? createXHR.XMLHttpRequest : window.XDomainRequest;
            forEachArray([ "get", "put", "post", "patch", "head", "delete" ], (function(method) {
                createXHR[method === "delete" ? "del" : method] = function(uri, options, callback) {
                    options = initParams(uri, options, callback);
                    options.method = method.toUpperCase();
                    return _createXHR(options);
                };
            }));
            function forEachArray(array, iterator) {
                for (var i = 0; i < array.length; i++) iterator(array[i]);
            }
            function isEmpty(obj) {
                for (var i in obj) if (obj.hasOwnProperty(i)) return false;
                return true;
            }
            function initParams(uri, options, callback) {
                var params = uri;
                if (isFunction(options)) {
                    callback = options;
                    if (typeof uri === "string") params = {
                        uri
                    };
                } else params = _extends({}, options, {
                    uri
                });
                params.callback = callback;
                return params;
            }
            function createXHR(uri, options, callback) {
                options = initParams(uri, options, callback);
                return _createXHR(options);
            }
            function _createXHR(options) {
                if (typeof options.callback === "undefined") throw new Error("callback argument missing");
                if (options.requestType && createXHR.requestInterceptorsStorage.getIsEnabled()) {
                    var requestInterceptorPayload = {
                        uri: options.uri || options.url,
                        headers: options.headers || {},
                        body: options.body,
                        metadata: options.metadata || {},
                        retry: options.retry,
                        timeout: options.timeout
                    };
                    var updatedPayload = createXHR.requestInterceptorsStorage.execute(options.requestType, requestInterceptorPayload);
                    options.uri = updatedPayload.uri;
                    options.headers = updatedPayload.headers;
                    options.body = updatedPayload.body;
                    options.metadata = updatedPayload.metadata;
                    options.retry = updatedPayload.retry;
                    options.timeout = updatedPayload.timeout;
                }
                var called = false;
                var callback = function cbOnce(err, response, body) {
                    if (!called) {
                        called = true;
                        options.callback(err, response, body);
                    }
                };
                function readystatechange() {
                    if (xhr.readyState === 4 && !createXHR.responseInterceptorsStorage.getIsEnabled()) setTimeout(loadFunc, 0);
                }
                function getBody() {
                    var body = void 0;
                    if (xhr.response) body = xhr.response; else body = xhr.responseText || getXml(xhr);
                    if (isJson) try {
                        body = JSON.parse(body);
                    } catch (e) {}
                    return body;
                }
                function errorFunc(evt) {
                    clearTimeout(timeoutTimer);
                    clearTimeout(options.retryTimeout);
                    if (!(evt instanceof Error)) evt = new Error("" + (evt || "Unknown XMLHttpRequest Error"));
                    evt.statusCode = 0;
                    if (!aborted && createXHR.retryManager.getIsEnabled() && options.retry && options.retry.shouldRetry()) {
                        options.retryTimeout = setTimeout((function() {
                            options.retry.moveToNextAttempt();
                            options.xhr = xhr;
                            _createXHR(options);
                        }), options.retry.getCurrentFuzzedDelay());
                        return;
                    }
                    if (options.requestType && createXHR.responseInterceptorsStorage.getIsEnabled()) {
                        var responseInterceptorPayload = {
                            headers: failureResponse.headers || {},
                            body: failureResponse.body,
                            responseUrl: xhr.responseURL,
                            responseType: xhr.responseType
                        };
                        var _updatedPayload = createXHR.responseInterceptorsStorage.execute(options.requestType, responseInterceptorPayload);
                        failureResponse.body = _updatedPayload.body;
                        failureResponse.headers = _updatedPayload.headers;
                    }
                    return callback(evt, failureResponse);
                }
                function loadFunc() {
                    if (aborted) return;
                    var status;
                    clearTimeout(timeoutTimer);
                    clearTimeout(options.retryTimeout);
                    if (options.useXDR && xhr.status === void 0) status = 200; else status = xhr.status === 1223 ? 204 : xhr.status;
                    var response = failureResponse;
                    var err = null;
                    if (status !== 0) {
                        response = {
                            body: getBody(),
                            statusCode: status,
                            method,
                            headers: {},
                            url: uri,
                            rawRequest: xhr
                        };
                        if (xhr.getAllResponseHeaders) response.headers = parseHeaders(xhr.getAllResponseHeaders());
                    } else err = new Error("Internal XMLHttpRequest Error");
                    if (options.requestType && createXHR.responseInterceptorsStorage.getIsEnabled()) {
                        var responseInterceptorPayload = {
                            headers: response.headers || {},
                            body: response.body,
                            responseUrl: xhr.responseURL,
                            responseType: xhr.responseType
                        };
                        var _updatedPayload2 = createXHR.responseInterceptorsStorage.execute(options.requestType, responseInterceptorPayload);
                        response.body = _updatedPayload2.body;
                        response.headers = _updatedPayload2.headers;
                    }
                    return callback(err, response, response.body);
                }
                var xhr = options.xhr || null;
                if (!xhr) if (options.cors || options.useXDR) xhr = new createXHR.XDomainRequest; else xhr = new createXHR.XMLHttpRequest;
                var key;
                var aborted;
                var uri = xhr.url = options.uri || options.url;
                var method = xhr.method = options.method || "GET";
                var body = options.body || options.data;
                var headers = xhr.headers = options.headers || {};
                var sync = !!options.sync;
                var isJson = false;
                var timeoutTimer;
                var failureResponse = {
                    body: void 0,
                    headers: {},
                    statusCode: 0,
                    method,
                    url: uri,
                    rawRequest: xhr
                };
                if ("json" in options && options.json !== false) {
                    isJson = true;
                    headers["accept"] || headers["Accept"] || (headers["Accept"] = "application/json");
                    if (method !== "GET" && method !== "HEAD") {
                        headers["content-type"] || headers["Content-Type"] || (headers["Content-Type"] = "application/json");
                        body = JSON.stringify(options.json === true ? body : options.json);
                    }
                }
                xhr.onreadystatechange = readystatechange;
                xhr.onload = loadFunc;
                xhr.onerror = errorFunc;
                xhr.onprogress = function() {};
                xhr.onabort = function() {
                    aborted = true;
                    clearTimeout(options.retryTimeout);
                };
                xhr.ontimeout = errorFunc;
                xhr.open(method, uri, !sync, options.username, options.password);
                if (!sync) xhr.withCredentials = !!options.withCredentials;
                if (!sync && options.timeout > 0) timeoutTimer = setTimeout((function() {
                    if (aborted) return;
                    aborted = true;
                    xhr.abort("timeout");
                    var e = new Error("XMLHttpRequest timeout");
                    e.code = "ETIMEDOUT";
                    errorFunc(e);
                }), options.timeout);
                if (xhr.setRequestHeader) {
                    for (key in headers) if (headers.hasOwnProperty(key)) xhr.setRequestHeader(key, headers[key]);
                } else if (options.headers && !isEmpty(options.headers)) throw new Error("Headers cannot be set on an XDomainRequest object");
                if ("responseType" in options) xhr.responseType = options.responseType;
                if ("beforeSend" in options && typeof options.beforeSend === "function") options.beforeSend(xhr);
                xhr.send(body || null);
                return xhr;
            }
            function getXml(xhr) {
                try {
                    if (xhr.responseType === "document") return xhr.responseXML;
                    var firefoxBugTakenEffect = xhr.responseXML && xhr.responseXML.documentElement.nodeName === "parsererror";
                    if (xhr.responseType === "" && !firefoxBugTakenEffect) return xhr.responseXML;
                } catch (e) {}
                return null;
            }
            function noop() {}
        },
        162: module => {
            "use strict";
            function _createForOfIteratorHelperLoose(o, allowArrayLike) {
                var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
                if (it) return (it = it.call(o)).next.bind(it);
                if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
                    if (it) o = it;
                    var i = 0;
                    return function() {
                        if (i >= o.length) return {
                            done: true
                        };
                        return {
                            done: false,
                            value: o[i++]
                        };
                    };
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function _unsupportedIterableToArray(o, minLen) {
                if (!o) return;
                if (typeof o === "string") return _arrayLikeToArray(o, minLen);
                var n = Object.prototype.toString.call(o).slice(8, -1);
                if (n === "Object" && o.constructor) n = o.constructor.name;
                if (n === "Map" || n === "Set") return Array.from(o);
                if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
            }
            function _arrayLikeToArray(arr, len) {
                if (len == null || len > arr.length) len = arr.length;
                for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
                return arr2;
            }
            var InterceptorsStorage = function() {
                function InterceptorsStorage() {
                    this.typeToInterceptorsMap_ = new Map;
                    this.enabled_ = false;
                }
                var _proto = InterceptorsStorage.prototype;
                _proto.getIsEnabled = function getIsEnabled() {
                    return this.enabled_;
                };
                _proto.enable = function enable() {
                    this.enabled_ = true;
                };
                _proto.disable = function disable() {
                    this.enabled_ = false;
                };
                _proto.reset = function reset() {
                    this.typeToInterceptorsMap_ = new Map;
                    this.enabled_ = false;
                };
                _proto.addInterceptor = function addInterceptor(type, interceptor) {
                    if (!this.typeToInterceptorsMap_.has(type)) this.typeToInterceptorsMap_.set(type, new Set);
                    var interceptorsSet = this.typeToInterceptorsMap_.get(type);
                    if (interceptorsSet.has(interceptor)) return false;
                    interceptorsSet.add(interceptor);
                    return true;
                };
                _proto.removeInterceptor = function removeInterceptor(type, interceptor) {
                    var interceptorsSet = this.typeToInterceptorsMap_.get(type);
                    if (interceptorsSet && interceptorsSet.has(interceptor)) {
                        interceptorsSet.delete(interceptor);
                        return true;
                    }
                    return false;
                };
                _proto.clearInterceptorsByType = function clearInterceptorsByType(type) {
                    var interceptorsSet = this.typeToInterceptorsMap_.get(type);
                    if (!interceptorsSet) return false;
                    this.typeToInterceptorsMap_.delete(type);
                    this.typeToInterceptorsMap_.set(type, new Set);
                    return true;
                };
                _proto.clear = function clear() {
                    if (!this.typeToInterceptorsMap_.size) return false;
                    this.typeToInterceptorsMap_ = new Map;
                    return true;
                };
                _proto.getForType = function getForType(type) {
                    return this.typeToInterceptorsMap_.get(type) || new Set;
                };
                _proto.execute = function execute(type, payload) {
                    var interceptors = this.getForType(type);
                    for (var _step, _iterator = _createForOfIteratorHelperLoose(interceptors); !(_step = _iterator()).done; ) {
                        var interceptor = _step.value;
                        try {
                            payload = interceptor(payload);
                        } catch (e) {}
                    }
                    return payload;
                };
                return InterceptorsStorage;
            }();
            module.exports = InterceptorsStorage;
        },
        670: module => {
            "use strict";
            var RetryManager = function() {
                function RetryManager() {
                    this.maxAttempts_ = 1;
                    this.delayFactor_ = .1;
                    this.fuzzFactor_ = .1;
                    this.initialDelay_ = 1e3;
                    this.enabled_ = false;
                }
                var _proto = RetryManager.prototype;
                _proto.getIsEnabled = function getIsEnabled() {
                    return this.enabled_;
                };
                _proto.enable = function enable() {
                    this.enabled_ = true;
                };
                _proto.disable = function disable() {
                    this.enabled_ = false;
                };
                _proto.reset = function reset() {
                    this.maxAttempts_ = 1;
                    this.delayFactor_ = .1;
                    this.fuzzFactor_ = .1;
                    this.initialDelay_ = 1e3;
                    this.enabled_ = false;
                };
                _proto.getMaxAttempts = function getMaxAttempts() {
                    return this.maxAttempts_;
                };
                _proto.setMaxAttempts = function setMaxAttempts(maxAttempts) {
                    this.maxAttempts_ = maxAttempts;
                };
                _proto.getDelayFactor = function getDelayFactor() {
                    return this.delayFactor_;
                };
                _proto.setDelayFactor = function setDelayFactor(delayFactor) {
                    this.delayFactor_ = delayFactor;
                };
                _proto.getFuzzFactor = function getFuzzFactor() {
                    return this.fuzzFactor_;
                };
                _proto.setFuzzFactor = function setFuzzFactor(fuzzFactor) {
                    this.fuzzFactor_ = fuzzFactor;
                };
                _proto.getInitialDelay = function getInitialDelay() {
                    return this.initialDelay_;
                };
                _proto.setInitialDelay = function setInitialDelay(initialDelay) {
                    this.initialDelay_ = initialDelay;
                };
                _proto.createRetry = function createRetry(_temp) {
                    var _ref = _temp === void 0 ? {} : _temp, maxAttempts = _ref.maxAttempts, delayFactor = _ref.delayFactor, fuzzFactor = _ref.fuzzFactor, initialDelay = _ref.initialDelay;
                    return new Retry({
                        maxAttempts: maxAttempts || this.maxAttempts_,
                        delayFactor: delayFactor || this.delayFactor_,
                        fuzzFactor: fuzzFactor || this.fuzzFactor_,
                        initialDelay: initialDelay || this.initialDelay_
                    });
                };
                return RetryManager;
            }();
            var Retry = function() {
                function Retry(options) {
                    this.maxAttempts_ = options.maxAttempts;
                    this.delayFactor_ = options.delayFactor;
                    this.fuzzFactor_ = options.fuzzFactor;
                    this.currentDelay_ = options.initialDelay;
                    this.currentAttempt_ = 1;
                }
                var _proto2 = Retry.prototype;
                _proto2.moveToNextAttempt = function moveToNextAttempt() {
                    this.currentAttempt_++;
                    var delayDelta = this.currentDelay_ * this.delayFactor_;
                    this.currentDelay_ = this.currentDelay_ + delayDelta;
                };
                _proto2.shouldRetry = function shouldRetry() {
                    return this.currentAttempt_ < this.maxAttempts_;
                };
                _proto2.getCurrentDelay = function getCurrentDelay() {
                    return this.currentDelay_;
                };
                _proto2.getCurrentMinPossibleDelay = function getCurrentMinPossibleDelay() {
                    return (1 - this.fuzzFactor_) * this.currentDelay_;
                };
                _proto2.getCurrentMaxPossibleDelay = function getCurrentMaxPossibleDelay() {
                    return (1 + this.fuzzFactor_) * this.currentDelay_;
                };
                _proto2.getCurrentFuzzedDelay = function getCurrentFuzzedDelay() {
                    var lowValue = this.getCurrentMinPossibleDelay();
                    var highValue = this.getCurrentMaxPossibleDelay();
                    return lowValue + Math.random() * (highValue - lowValue);
                };
                return Retry;
            }();
            module.exports = RetryManager;
        },
        582: (__unused_webpack_module, exports) => {
            "use strict";
            function find(list, predicate, ac) {
                if (ac === void 0) ac = Array.prototype;
                if (list && typeof ac.find === "function") return ac.find.call(list, predicate);
                for (var i = 0; i < list.length; i++) if (Object.prototype.hasOwnProperty.call(list, i)) {
                    var item = list[i];
                    if (predicate.call(void 0, item, i, list)) return item;
                }
            }
            function freeze(object, oc) {
                if (oc === void 0) oc = Object;
                return oc && typeof oc.freeze === "function" ? oc.freeze(object) : object;
            }
            function assign(target, source) {
                if (target === null || typeof target !== "object") throw new TypeError("target is not an object");
                for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
                return target;
            }
            var MIME_TYPE = freeze({
                HTML: "text/html",
                isHTML: function(value) {
                    return value === MIME_TYPE.HTML;
                },
                XML_APPLICATION: "application/xml",
                XML_TEXT: "text/xml",
                XML_XHTML_APPLICATION: "application/xhtml+xml",
                XML_SVG_IMAGE: "image/svg+xml"
            });
            var NAMESPACE = freeze({
                HTML: "http://www.w3.org/1999/xhtml",
                isHTML: function(uri) {
                    return uri === NAMESPACE.HTML;
                },
                SVG: "http://www.w3.org/2000/svg",
                XML: "http://www.w3.org/XML/1998/namespace",
                XMLNS: "http://www.w3.org/2000/xmlns/"
            });
            exports.assign = assign;
            exports.find = find;
            exports.freeze = freeze;
            exports.MIME_TYPE = MIME_TYPE;
            exports.NAMESPACE = NAMESPACE;
        },
        752: (__unused_webpack_module, exports, __webpack_require__) => {
            var conventions = __webpack_require__(582);
            var dom = __webpack_require__(722);
            var entities = __webpack_require__(559);
            var sax = __webpack_require__(466);
            var DOMImplementation = dom.DOMImplementation;
            var NAMESPACE = conventions.NAMESPACE;
            var ParseError = sax.ParseError;
            var XMLReader = sax.XMLReader;
            function normalizeLineEndings(input) {
                return input.replace(/\r[\n\u0085]/g, "\n").replace(/[\r\u0085\u2028]/g, "\n");
            }
            function DOMParser(options) {
                this.options = options || {
                    locator: {}
                };
            }
            DOMParser.prototype.parseFromString = function(source, mimeType) {
                var options = this.options;
                var sax = new XMLReader;
                var domBuilder = options.domBuilder || new DOMHandler;
                var errorHandler = options.errorHandler;
                var locator = options.locator;
                var defaultNSMap = options.xmlns || {};
                var isHTML = /\/x?html?$/.test(mimeType);
                var entityMap = isHTML ? entities.HTML_ENTITIES : entities.XML_ENTITIES;
                if (locator) domBuilder.setDocumentLocator(locator);
                sax.errorHandler = buildErrorHandler(errorHandler, domBuilder, locator);
                sax.domBuilder = options.domBuilder || domBuilder;
                if (isHTML) defaultNSMap[""] = NAMESPACE.HTML;
                defaultNSMap.xml = defaultNSMap.xml || NAMESPACE.XML;
                var normalize = options.normalizeLineEndings || normalizeLineEndings;
                if (source && typeof source === "string") sax.parse(normalize(source), defaultNSMap, entityMap); else sax.errorHandler.error("invalid doc source");
                return domBuilder.doc;
            };
            function buildErrorHandler(errorImpl, domBuilder, locator) {
                if (!errorImpl) {
                    if (domBuilder instanceof DOMHandler) return domBuilder;
                    errorImpl = domBuilder;
                }
                var errorHandler = {};
                var isCallback = errorImpl instanceof Function;
                locator = locator || {};
                function build(key) {
                    var fn = errorImpl[key];
                    if (!fn && isCallback) fn = errorImpl.length == 2 ? function(msg) {
                        errorImpl(key, msg);
                    } : errorImpl;
                    errorHandler[key] = fn && function(msg) {
                        fn("[xmldom " + key + "]\t" + msg + _locator(locator));
                    } || function() {};
                }
                build("warning");
                build("error");
                build("fatalError");
                return errorHandler;
            }
            function DOMHandler() {
                this.cdata = false;
            }
            function position(locator, node) {
                node.lineNumber = locator.lineNumber;
                node.columnNumber = locator.columnNumber;
            }
            DOMHandler.prototype = {
                startDocument: function() {
                    this.doc = (new DOMImplementation).createDocument(null, null, null);
                    if (this.locator) this.doc.documentURI = this.locator.systemId;
                },
                startElement: function(namespaceURI, localName, qName, attrs) {
                    var doc = this.doc;
                    var el = doc.createElementNS(namespaceURI, qName || localName);
                    var len = attrs.length;
                    appendElement(this, el);
                    this.currentElement = el;
                    this.locator && position(this.locator, el);
                    for (var i = 0; i < len; i++) {
                        namespaceURI = attrs.getURI(i);
                        var value = attrs.getValue(i);
                        qName = attrs.getQName(i);
                        var attr = doc.createAttributeNS(namespaceURI, qName);
                        this.locator && position(attrs.getLocator(i), attr);
                        attr.value = attr.nodeValue = value;
                        el.setAttributeNode(attr);
                    }
                },
                endElement: function(namespaceURI, localName, qName) {
                    var current = this.currentElement;
                    current.tagName;
                    this.currentElement = current.parentNode;
                },
                startPrefixMapping: function(prefix, uri) {},
                endPrefixMapping: function(prefix) {},
                processingInstruction: function(target, data) {
                    var ins = this.doc.createProcessingInstruction(target, data);
                    this.locator && position(this.locator, ins);
                    appendElement(this, ins);
                },
                ignorableWhitespace: function(ch, start, length) {},
                characters: function(chars, start, length) {
                    chars = _toString.apply(this, arguments);
                    if (chars) {
                        if (this.cdata) var charNode = this.doc.createCDATASection(chars); else charNode = this.doc.createTextNode(chars);
                        if (this.currentElement) this.currentElement.appendChild(charNode); else if (/^\s*$/.test(chars)) this.doc.appendChild(charNode);
                        this.locator && position(this.locator, charNode);
                    }
                },
                skippedEntity: function(name) {},
                endDocument: function() {
                    this.doc.normalize();
                },
                setDocumentLocator: function(locator) {
                    if (this.locator = locator) locator.lineNumber = 0;
                },
                comment: function(chars, start, length) {
                    chars = _toString.apply(this, arguments);
                    var comm = this.doc.createComment(chars);
                    this.locator && position(this.locator, comm);
                    appendElement(this, comm);
                },
                startCDATA: function() {
                    this.cdata = true;
                },
                endCDATA: function() {
                    this.cdata = false;
                },
                startDTD: function(name, publicId, systemId) {
                    var impl = this.doc.implementation;
                    if (impl && impl.createDocumentType) {
                        var dt = impl.createDocumentType(name, publicId, systemId);
                        this.locator && position(this.locator, dt);
                        appendElement(this, dt);
                        this.doc.doctype = dt;
                    }
                },
                warning: function(error) {
                    console.warn("[xmldom warning]\t" + error, _locator(this.locator));
                },
                error: function(error) {
                    console.error("[xmldom error]\t" + error, _locator(this.locator));
                },
                fatalError: function(error) {
                    throw new ParseError(error, this.locator);
                }
            };
            function _locator(l) {
                if (l) return "\n@" + (l.systemId || "") + "#[line:" + l.lineNumber + ",col:" + l.columnNumber + "]";
            }
            function _toString(chars, start, length) {
                if (typeof chars == "string") return chars.substr(start, length); else {
                    if (chars.length >= start + length || start) return new java.lang.String(chars, start, length) + "";
                    return chars;
                }
            }
            "endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g, (function(key) {
                DOMHandler.prototype[key] = function() {
                    return null;
                };
            }));
            function appendElement(hander, node) {
                if (!hander.currentElement) hander.doc.appendChild(node); else hander.currentElement.appendChild(node);
            }
            0;
            0;
            exports.DOMParser = DOMParser;
        },
        722: (__unused_webpack_module, exports, __webpack_require__) => {
            var conventions = __webpack_require__(582);
            var find = conventions.find;
            var NAMESPACE = conventions.NAMESPACE;
            function notEmptyString(input) {
                return input !== "";
            }
            function splitOnASCIIWhitespace(input) {
                return input ? input.split(/[\t\n\f\r ]+/).filter(notEmptyString) : [];
            }
            function orderedSetReducer(current, element) {
                if (!current.hasOwnProperty(element)) current[element] = true;
                return current;
            }
            function toOrderedSet(input) {
                if (!input) return [];
                var list = splitOnASCIIWhitespace(input);
                return Object.keys(list.reduce(orderedSetReducer, {}));
            }
            function arrayIncludes(list) {
                return function(element) {
                    return list && list.indexOf(element) !== -1;
                };
            }
            function copy(src, dest) {
                for (var p in src) if (Object.prototype.hasOwnProperty.call(src, p)) dest[p] = src[p];
            }
            function _extends(Class, Super) {
                var pt = Class.prototype;
                if (!(pt instanceof Super)) {
                    function t() {}
                    t.prototype = Super.prototype;
                    t = new t;
                    copy(pt, t);
                    Class.prototype = pt = t;
                }
                if (pt.constructor != Class) {
                    if (typeof Class != "function") console.error("unknown Class:" + Class);
                    pt.constructor = Class;
                }
            }
            var NodeType = {};
            var ELEMENT_NODE = NodeType.ELEMENT_NODE = 1;
            var ATTRIBUTE_NODE = NodeType.ATTRIBUTE_NODE = 2;
            var TEXT_NODE = NodeType.TEXT_NODE = 3;
            var CDATA_SECTION_NODE = NodeType.CDATA_SECTION_NODE = 4;
            var ENTITY_REFERENCE_NODE = NodeType.ENTITY_REFERENCE_NODE = 5;
            var ENTITY_NODE = NodeType.ENTITY_NODE = 6;
            var PROCESSING_INSTRUCTION_NODE = NodeType.PROCESSING_INSTRUCTION_NODE = 7;
            var COMMENT_NODE = NodeType.COMMENT_NODE = 8;
            var DOCUMENT_NODE = NodeType.DOCUMENT_NODE = 9;
            var DOCUMENT_TYPE_NODE = NodeType.DOCUMENT_TYPE_NODE = 10;
            var DOCUMENT_FRAGMENT_NODE = NodeType.DOCUMENT_FRAGMENT_NODE = 11;
            var NOTATION_NODE = NodeType.NOTATION_NODE = 12;
            var ExceptionCode = {};
            var ExceptionMessage = {};
            ExceptionCode.INDEX_SIZE_ERR = (ExceptionMessage[1] = "Index size error", 1);
            ExceptionCode.DOMSTRING_SIZE_ERR = (ExceptionMessage[2] = "DOMString size error", 
            2);
            var HIERARCHY_REQUEST_ERR = ExceptionCode.HIERARCHY_REQUEST_ERR = (ExceptionMessage[3] = "Hierarchy request error", 
            3);
            ExceptionCode.WRONG_DOCUMENT_ERR = (ExceptionMessage[4] = "Wrong document", 4);
            ExceptionCode.INVALID_CHARACTER_ERR = (ExceptionMessage[5] = "Invalid character", 
            5);
            ExceptionCode.NO_DATA_ALLOWED_ERR = (ExceptionMessage[6] = "No data allowed", 6);
            ExceptionCode.NO_MODIFICATION_ALLOWED_ERR = (ExceptionMessage[7] = "No modification allowed", 
            7);
            var NOT_FOUND_ERR = ExceptionCode.NOT_FOUND_ERR = (ExceptionMessage[8] = "Not found", 
            8);
            ExceptionCode.NOT_SUPPORTED_ERR = (ExceptionMessage[9] = "Not supported", 9);
            var INUSE_ATTRIBUTE_ERR = ExceptionCode.INUSE_ATTRIBUTE_ERR = (ExceptionMessage[10] = "Attribute in use", 
            10);
            ExceptionCode.INVALID_STATE_ERR = (ExceptionMessage[11] = "Invalid state", 11);
            ExceptionCode.SYNTAX_ERR = (ExceptionMessage[12] = "Syntax error", 12);
            ExceptionCode.INVALID_MODIFICATION_ERR = (ExceptionMessage[13] = "Invalid modification", 
            13);
            ExceptionCode.NAMESPACE_ERR = (ExceptionMessage[14] = "Invalid namespace", 14);
            ExceptionCode.INVALID_ACCESS_ERR = (ExceptionMessage[15] = "Invalid access", 15);
            function DOMException(code, message) {
                if (message instanceof Error) var error = message; else {
                    error = this;
                    Error.call(this, ExceptionMessage[code]);
                    this.message = ExceptionMessage[code];
                    if (Error.captureStackTrace) Error.captureStackTrace(this, DOMException);
                }
                error.code = code;
                if (message) this.message = this.message + ": " + message;
                return error;
            }
            DOMException.prototype = Error.prototype;
            copy(ExceptionCode, DOMException);
            function NodeList() {}
            NodeList.prototype = {
                length: 0,
                item: function(index) {
                    return index >= 0 && index < this.length ? this[index] : null;
                },
                toString: function(isHTML, nodeFilter) {
                    for (var buf = [], i = 0; i < this.length; i++) serializeToString(this[i], buf, isHTML, nodeFilter);
                    return buf.join("");
                },
                filter: function(predicate) {
                    return Array.prototype.filter.call(this, predicate);
                },
                indexOf: function(item) {
                    return Array.prototype.indexOf.call(this, item);
                }
            };
            function LiveNodeList(node, refresh) {
                this._node = node;
                this._refresh = refresh;
                _updateLiveList(this);
            }
            function _updateLiveList(list) {
                var inc = list._node._inc || list._node.ownerDocument._inc;
                if (list._inc !== inc) {
                    var ls = list._refresh(list._node);
                    __set__(list, "length", ls.length);
                    if (!list.$$length || ls.length < list.$$length) for (var i = ls.length; i in list; i++) if (Object.prototype.hasOwnProperty.call(list, i)) delete list[i];
                    copy(ls, list);
                    list._inc = inc;
                }
            }
            LiveNodeList.prototype.item = function(i) {
                _updateLiveList(this);
                return this[i] || null;
            };
            _extends(LiveNodeList, NodeList);
            function NamedNodeMap() {}
            function _findNodeIndex(list, node) {
                var i = list.length;
                while (i--) if (list[i] === node) return i;
            }
            function _addNamedNode(el, list, newAttr, oldAttr) {
                if (oldAttr) list[_findNodeIndex(list, oldAttr)] = newAttr; else list[list.length++] = newAttr;
                if (el) {
                    newAttr.ownerElement = el;
                    var doc = el.ownerDocument;
                    if (doc) {
                        oldAttr && _onRemoveAttribute(doc, el, oldAttr);
                        _onAddAttribute(doc, el, newAttr);
                    }
                }
            }
            function _removeNamedNode(el, list, attr) {
                var i = _findNodeIndex(list, attr);
                if (i >= 0) {
                    var lastIndex = list.length - 1;
                    while (i < lastIndex) list[i] = list[++i];
                    list.length = lastIndex;
                    if (el) {
                        var doc = el.ownerDocument;
                        if (doc) {
                            _onRemoveAttribute(doc, el, attr);
                            attr.ownerElement = null;
                        }
                    }
                } else throw new DOMException(NOT_FOUND_ERR, new Error(el.tagName + "@" + attr));
            }
            NamedNodeMap.prototype = {
                length: 0,
                item: NodeList.prototype.item,
                getNamedItem: function(key) {
                    var i = this.length;
                    while (i--) {
                        var attr = this[i];
                        if (attr.nodeName == key) return attr;
                    }
                },
                setNamedItem: function(attr) {
                    var el = attr.ownerElement;
                    if (el && el != this._ownerElement) throw new DOMException(INUSE_ATTRIBUTE_ERR);
                    var oldAttr = this.getNamedItem(attr.nodeName);
                    _addNamedNode(this._ownerElement, this, attr, oldAttr);
                    return oldAttr;
                },
                setNamedItemNS: function(attr) {
                    var oldAttr, el = attr.ownerElement;
                    if (el && el != this._ownerElement) throw new DOMException(INUSE_ATTRIBUTE_ERR);
                    oldAttr = this.getNamedItemNS(attr.namespaceURI, attr.localName);
                    _addNamedNode(this._ownerElement, this, attr, oldAttr);
                    return oldAttr;
                },
                removeNamedItem: function(key) {
                    var attr = this.getNamedItem(key);
                    _removeNamedNode(this._ownerElement, this, attr);
                    return attr;
                },
                removeNamedItemNS: function(namespaceURI, localName) {
                    var attr = this.getNamedItemNS(namespaceURI, localName);
                    _removeNamedNode(this._ownerElement, this, attr);
                    return attr;
                },
                getNamedItemNS: function(namespaceURI, localName) {
                    var i = this.length;
                    while (i--) {
                        var node = this[i];
                        if (node.localName == localName && node.namespaceURI == namespaceURI) return node;
                    }
                    return null;
                }
            };
            function DOMImplementation() {}
            DOMImplementation.prototype = {
                hasFeature: function(feature, version) {
                    return true;
                },
                createDocument: function(namespaceURI, qualifiedName, doctype) {
                    var doc = new Document;
                    doc.implementation = this;
                    doc.childNodes = new NodeList;
                    doc.doctype = doctype || null;
                    if (doctype) doc.appendChild(doctype);
                    if (qualifiedName) {
                        var root = doc.createElementNS(namespaceURI, qualifiedName);
                        doc.appendChild(root);
                    }
                    return doc;
                },
                createDocumentType: function(qualifiedName, publicId, systemId) {
                    var node = new DocumentType;
                    node.name = qualifiedName;
                    node.nodeName = qualifiedName;
                    node.publicId = publicId || "";
                    node.systemId = systemId || "";
                    return node;
                }
            };
            function Node() {}
            Node.prototype = {
                firstChild: null,
                lastChild: null,
                previousSibling: null,
                nextSibling: null,
                attributes: null,
                parentNode: null,
                childNodes: null,
                ownerDocument: null,
                nodeValue: null,
                namespaceURI: null,
                prefix: null,
                localName: null,
                insertBefore: function(newChild, refChild) {
                    return _insertBefore(this, newChild, refChild);
                },
                replaceChild: function(newChild, oldChild) {
                    _insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);
                    if (oldChild) this.removeChild(oldChild);
                },
                removeChild: function(oldChild) {
                    return _removeChild(this, oldChild);
                },
                appendChild: function(newChild) {
                    return this.insertBefore(newChild, null);
                },
                hasChildNodes: function() {
                    return this.firstChild != null;
                },
                cloneNode: function(deep) {
                    return cloneNode(this.ownerDocument || this, this, deep);
                },
                normalize: function() {
                    var child = this.firstChild;
                    while (child) {
                        var next = child.nextSibling;
                        if (next && next.nodeType == TEXT_NODE && child.nodeType == TEXT_NODE) {
                            this.removeChild(next);
                            child.appendData(next.data);
                        } else {
                            child.normalize();
                            child = next;
                        }
                    }
                },
                isSupported: function(feature, version) {
                    return this.ownerDocument.implementation.hasFeature(feature, version);
                },
                hasAttributes: function() {
                    return this.attributes.length > 0;
                },
                lookupPrefix: function(namespaceURI) {
                    var el = this;
                    while (el) {
                        var map = el._nsMap;
                        if (map) for (var n in map) if (Object.prototype.hasOwnProperty.call(map, n) && map[n] === namespaceURI) return n;
                        el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;
                    }
                    return null;
                },
                lookupNamespaceURI: function(prefix) {
                    var el = this;
                    while (el) {
                        var map = el._nsMap;
                        if (map) if (Object.prototype.hasOwnProperty.call(map, prefix)) return map[prefix];
                        el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;
                    }
                    return null;
                },
                isDefaultNamespace: function(namespaceURI) {
                    var prefix = this.lookupPrefix(namespaceURI);
                    return prefix == null;
                }
            };
            function _xmlEncoder(c) {
                return c == "<" && "&lt;" || c == ">" && "&gt;" || c == "&" && "&amp;" || c == '"' && "&quot;" || "&#" + c.charCodeAt() + ";";
            }
            copy(NodeType, Node);
            copy(NodeType, Node.prototype);
            function _visitNode(node, callback) {
                if (callback(node)) return true;
                if (node = node.firstChild) do {
                    if (_visitNode(node, callback)) return true;
                } while (node = node.nextSibling);
            }
            function Document() {
                this.ownerDocument = this;
            }
            function _onAddAttribute(doc, el, newAttr) {
                doc && doc._inc++;
                var ns = newAttr.namespaceURI;
                if (ns === NAMESPACE.XMLNS) el._nsMap[newAttr.prefix ? newAttr.localName : ""] = newAttr.value;
            }
            function _onRemoveAttribute(doc, el, newAttr, remove) {
                doc && doc._inc++;
                var ns = newAttr.namespaceURI;
                if (ns === NAMESPACE.XMLNS) delete el._nsMap[newAttr.prefix ? newAttr.localName : ""];
            }
            function _onUpdateChild(doc, el, newChild) {
                if (doc && doc._inc) {
                    doc._inc++;
                    var cs = el.childNodes;
                    if (newChild) cs[cs.length++] = newChild; else {
                        var child = el.firstChild;
                        var i = 0;
                        while (child) {
                            cs[i++] = child;
                            child = child.nextSibling;
                        }
                        cs.length = i;
                        delete cs[cs.length];
                    }
                }
            }
            function _removeChild(parentNode, child) {
                var previous = child.previousSibling;
                var next = child.nextSibling;
                if (previous) previous.nextSibling = next; else parentNode.firstChild = next;
                if (next) next.previousSibling = previous; else parentNode.lastChild = previous;
                child.parentNode = null;
                child.previousSibling = null;
                child.nextSibling = null;
                _onUpdateChild(parentNode.ownerDocument, parentNode);
                return child;
            }
            function hasValidParentNodeType(node) {
                return node && (node.nodeType === Node.DOCUMENT_NODE || node.nodeType === Node.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node.ELEMENT_NODE);
            }
            function hasInsertableNodeType(node) {
                return node && (isElementNode(node) || isTextNode(node) || isDocTypeNode(node) || node.nodeType === Node.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node.COMMENT_NODE || node.nodeType === Node.PROCESSING_INSTRUCTION_NODE);
            }
            function isDocTypeNode(node) {
                return node && node.nodeType === Node.DOCUMENT_TYPE_NODE;
            }
            function isElementNode(node) {
                return node && node.nodeType === Node.ELEMENT_NODE;
            }
            function isTextNode(node) {
                return node && node.nodeType === Node.TEXT_NODE;
            }
            function isElementInsertionPossible(doc, child) {
                var parentChildNodes = doc.childNodes || [];
                if (find(parentChildNodes, isElementNode) || isDocTypeNode(child)) return false;
                var docTypeNode = find(parentChildNodes, isDocTypeNode);
                return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));
            }
            function isElementReplacementPossible(doc, child) {
                var parentChildNodes = doc.childNodes || [];
                function hasElementChildThatIsNotChild(node) {
                    return isElementNode(node) && node !== child;
                }
                if (find(parentChildNodes, hasElementChildThatIsNotChild)) return false;
                var docTypeNode = find(parentChildNodes, isDocTypeNode);
                return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));
            }
            function assertPreInsertionValidity1to5(parent, node, child) {
                if (!hasValidParentNodeType(parent)) throw new DOMException(HIERARCHY_REQUEST_ERR, "Unexpected parent node type " + parent.nodeType);
                if (child && child.parentNode !== parent) throw new DOMException(NOT_FOUND_ERR, "child not in parent");
                if (!hasInsertableNodeType(node) || isDocTypeNode(node) && parent.nodeType !== Node.DOCUMENT_NODE) throw new DOMException(HIERARCHY_REQUEST_ERR, "Unexpected node type " + node.nodeType + " for parent node type " + parent.nodeType);
            }
            function assertPreInsertionValidityInDocument(parent, node, child) {
                var parentChildNodes = parent.childNodes || [];
                var nodeChildNodes = node.childNodes || [];
                if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
                    var nodeChildElements = nodeChildNodes.filter(isElementNode);
                    if (nodeChildElements.length > 1 || find(nodeChildNodes, isTextNode)) throw new DOMException(HIERARCHY_REQUEST_ERR, "More than one element or text in fragment");
                    if (nodeChildElements.length === 1 && !isElementInsertionPossible(parent, child)) throw new DOMException(HIERARCHY_REQUEST_ERR, "Element in fragment can not be inserted before doctype");
                }
                if (isElementNode(node)) if (!isElementInsertionPossible(parent, child)) throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one element can be added and only after doctype");
                if (isDocTypeNode(node)) {
                    if (find(parentChildNodes, isDocTypeNode)) throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one doctype is allowed");
                    var parentElementChild = find(parentChildNodes, isElementNode);
                    if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) throw new DOMException(HIERARCHY_REQUEST_ERR, "Doctype can only be inserted before an element");
                    if (!child && parentElementChild) throw new DOMException(HIERARCHY_REQUEST_ERR, "Doctype can not be appended since element is present");
                }
            }
            function assertPreReplacementValidityInDocument(parent, node, child) {
                var parentChildNodes = parent.childNodes || [];
                var nodeChildNodes = node.childNodes || [];
                if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
                    var nodeChildElements = nodeChildNodes.filter(isElementNode);
                    if (nodeChildElements.length > 1 || find(nodeChildNodes, isTextNode)) throw new DOMException(HIERARCHY_REQUEST_ERR, "More than one element or text in fragment");
                    if (nodeChildElements.length === 1 && !isElementReplacementPossible(parent, child)) throw new DOMException(HIERARCHY_REQUEST_ERR, "Element in fragment can not be inserted before doctype");
                }
                if (isElementNode(node)) if (!isElementReplacementPossible(parent, child)) throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one element can be added and only after doctype");
                if (isDocTypeNode(node)) {
                    function hasDoctypeChildThatIsNotChild(node) {
                        return isDocTypeNode(node) && node !== child;
                    }
                    if (find(parentChildNodes, hasDoctypeChildThatIsNotChild)) throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one doctype is allowed");
                    var parentElementChild = find(parentChildNodes, isElementNode);
                    if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) throw new DOMException(HIERARCHY_REQUEST_ERR, "Doctype can only be inserted before an element");
                }
            }
            function _insertBefore(parent, node, child, _inDocumentAssertion) {
                assertPreInsertionValidity1to5(parent, node, child);
                if (parent.nodeType === Node.DOCUMENT_NODE) (_inDocumentAssertion || assertPreInsertionValidityInDocument)(parent, node, child);
                var cp = node.parentNode;
                if (cp) cp.removeChild(node);
                if (node.nodeType === DOCUMENT_FRAGMENT_NODE) {
                    var newFirst = node.firstChild;
                    if (newFirst == null) return node;
                    var newLast = node.lastChild;
                } else newFirst = newLast = node;
                var pre = child ? child.previousSibling : parent.lastChild;
                newFirst.previousSibling = pre;
                newLast.nextSibling = child;
                if (pre) pre.nextSibling = newFirst; else parent.firstChild = newFirst;
                if (child == null) parent.lastChild = newLast; else child.previousSibling = newLast;
                do {
                    newFirst.parentNode = parent;
                } while (newFirst !== newLast && (newFirst = newFirst.nextSibling));
                _onUpdateChild(parent.ownerDocument || parent, parent);
                if (node.nodeType == DOCUMENT_FRAGMENT_NODE) node.firstChild = node.lastChild = null;
                return node;
            }
            function _appendSingleChild(parentNode, newChild) {
                if (newChild.parentNode) newChild.parentNode.removeChild(newChild);
                newChild.parentNode = parentNode;
                newChild.previousSibling = parentNode.lastChild;
                newChild.nextSibling = null;
                if (newChild.previousSibling) newChild.previousSibling.nextSibling = newChild; else parentNode.firstChild = newChild;
                parentNode.lastChild = newChild;
                _onUpdateChild(parentNode.ownerDocument, parentNode, newChild);
                return newChild;
            }
            Document.prototype = {
                nodeName: "#document",
                nodeType: DOCUMENT_NODE,
                doctype: null,
                documentElement: null,
                _inc: 1,
                insertBefore: function(newChild, refChild) {
                    if (newChild.nodeType == DOCUMENT_FRAGMENT_NODE) {
                        var child = newChild.firstChild;
                        while (child) {
                            var next = child.nextSibling;
                            this.insertBefore(child, refChild);
                            child = next;
                        }
                        return newChild;
                    }
                    _insertBefore(this, newChild, refChild);
                    newChild.ownerDocument = this;
                    if (this.documentElement === null && newChild.nodeType === ELEMENT_NODE) this.documentElement = newChild;
                    return newChild;
                },
                removeChild: function(oldChild) {
                    if (this.documentElement == oldChild) this.documentElement = null;
                    return _removeChild(this, oldChild);
                },
                replaceChild: function(newChild, oldChild) {
                    _insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);
                    newChild.ownerDocument = this;
                    if (oldChild) this.removeChild(oldChild);
                    if (isElementNode(newChild)) this.documentElement = newChild;
                },
                importNode: function(importedNode, deep) {
                    return importNode(this, importedNode, deep);
                },
                getElementById: function(id) {
                    var rtv = null;
                    _visitNode(this.documentElement, (function(node) {
                        if (node.nodeType == ELEMENT_NODE) if (node.getAttribute("id") == id) {
                            rtv = node;
                            return true;
                        }
                    }));
                    return rtv;
                },
                getElementsByClassName: function(classNames) {
                    var classNamesSet = toOrderedSet(classNames);
                    return new LiveNodeList(this, (function(base) {
                        var ls = [];
                        if (classNamesSet.length > 0) _visitNode(base.documentElement, (function(node) {
                            if (node !== base && node.nodeType === ELEMENT_NODE) {
                                var nodeClassNames = node.getAttribute("class");
                                if (nodeClassNames) {
                                    var matches = classNames === nodeClassNames;
                                    if (!matches) {
                                        var nodeClassNamesSet = toOrderedSet(nodeClassNames);
                                        matches = classNamesSet.every(arrayIncludes(nodeClassNamesSet));
                                    }
                                    if (matches) ls.push(node);
                                }
                            }
                        }));
                        return ls;
                    }));
                },
                createElement: function(tagName) {
                    var node = new Element;
                    node.ownerDocument = this;
                    node.nodeName = tagName;
                    node.tagName = tagName;
                    node.localName = tagName;
                    node.childNodes = new NodeList;
                    var attrs = node.attributes = new NamedNodeMap;
                    attrs._ownerElement = node;
                    return node;
                },
                createDocumentFragment: function() {
                    var node = new DocumentFragment;
                    node.ownerDocument = this;
                    node.childNodes = new NodeList;
                    return node;
                },
                createTextNode: function(data) {
                    var node = new Text;
                    node.ownerDocument = this;
                    node.appendData(data);
                    return node;
                },
                createComment: function(data) {
                    var node = new Comment;
                    node.ownerDocument = this;
                    node.appendData(data);
                    return node;
                },
                createCDATASection: function(data) {
                    var node = new CDATASection;
                    node.ownerDocument = this;
                    node.appendData(data);
                    return node;
                },
                createProcessingInstruction: function(target, data) {
                    var node = new ProcessingInstruction;
                    node.ownerDocument = this;
                    node.tagName = node.nodeName = node.target = target;
                    node.nodeValue = node.data = data;
                    return node;
                },
                createAttribute: function(name) {
                    var node = new Attr;
                    node.ownerDocument = this;
                    node.name = name;
                    node.nodeName = name;
                    node.localName = name;
                    node.specified = true;
                    return node;
                },
                createEntityReference: function(name) {
                    var node = new EntityReference;
                    node.ownerDocument = this;
                    node.nodeName = name;
                    return node;
                },
                createElementNS: function(namespaceURI, qualifiedName) {
                    var node = new Element;
                    var pl = qualifiedName.split(":");
                    var attrs = node.attributes = new NamedNodeMap;
                    node.childNodes = new NodeList;
                    node.ownerDocument = this;
                    node.nodeName = qualifiedName;
                    node.tagName = qualifiedName;
                    node.namespaceURI = namespaceURI;
                    if (pl.length == 2) {
                        node.prefix = pl[0];
                        node.localName = pl[1];
                    } else node.localName = qualifiedName;
                    attrs._ownerElement = node;
                    return node;
                },
                createAttributeNS: function(namespaceURI, qualifiedName) {
                    var node = new Attr;
                    var pl = qualifiedName.split(":");
                    node.ownerDocument = this;
                    node.nodeName = qualifiedName;
                    node.name = qualifiedName;
                    node.namespaceURI = namespaceURI;
                    node.specified = true;
                    if (pl.length == 2) {
                        node.prefix = pl[0];
                        node.localName = pl[1];
                    } else node.localName = qualifiedName;
                    return node;
                }
            };
            _extends(Document, Node);
            function Element() {
                this._nsMap = {};
            }
            Element.prototype = {
                nodeType: ELEMENT_NODE,
                hasAttribute: function(name) {
                    return this.getAttributeNode(name) != null;
                },
                getAttribute: function(name) {
                    var attr = this.getAttributeNode(name);
                    return attr && attr.value || "";
                },
                getAttributeNode: function(name) {
                    return this.attributes.getNamedItem(name);
                },
                setAttribute: function(name, value) {
                    var attr = this.ownerDocument.createAttribute(name);
                    attr.value = attr.nodeValue = "" + value;
                    this.setAttributeNode(attr);
                },
                removeAttribute: function(name) {
                    var attr = this.getAttributeNode(name);
                    attr && this.removeAttributeNode(attr);
                },
                appendChild: function(newChild) {
                    if (newChild.nodeType === DOCUMENT_FRAGMENT_NODE) return this.insertBefore(newChild, null); else return _appendSingleChild(this, newChild);
                },
                setAttributeNode: function(newAttr) {
                    return this.attributes.setNamedItem(newAttr);
                },
                setAttributeNodeNS: function(newAttr) {
                    return this.attributes.setNamedItemNS(newAttr);
                },
                removeAttributeNode: function(oldAttr) {
                    return this.attributes.removeNamedItem(oldAttr.nodeName);
                },
                removeAttributeNS: function(namespaceURI, localName) {
                    var old = this.getAttributeNodeNS(namespaceURI, localName);
                    old && this.removeAttributeNode(old);
                },
                hasAttributeNS: function(namespaceURI, localName) {
                    return this.getAttributeNodeNS(namespaceURI, localName) != null;
                },
                getAttributeNS: function(namespaceURI, localName) {
                    var attr = this.getAttributeNodeNS(namespaceURI, localName);
                    return attr && attr.value || "";
                },
                setAttributeNS: function(namespaceURI, qualifiedName, value) {
                    var attr = this.ownerDocument.createAttributeNS(namespaceURI, qualifiedName);
                    attr.value = attr.nodeValue = "" + value;
                    this.setAttributeNode(attr);
                },
                getAttributeNodeNS: function(namespaceURI, localName) {
                    return this.attributes.getNamedItemNS(namespaceURI, localName);
                },
                getElementsByTagName: function(tagName) {
                    return new LiveNodeList(this, (function(base) {
                        var ls = [];
                        _visitNode(base, (function(node) {
                            if (node !== base && node.nodeType == ELEMENT_NODE && (tagName === "*" || node.tagName == tagName)) ls.push(node);
                        }));
                        return ls;
                    }));
                },
                getElementsByTagNameNS: function(namespaceURI, localName) {
                    return new LiveNodeList(this, (function(base) {
                        var ls = [];
                        _visitNode(base, (function(node) {
                            if (node !== base && node.nodeType === ELEMENT_NODE && (namespaceURI === "*" || node.namespaceURI === namespaceURI) && (localName === "*" || node.localName == localName)) ls.push(node);
                        }));
                        return ls;
                    }));
                }
            };
            Document.prototype.getElementsByTagName = Element.prototype.getElementsByTagName;
            Document.prototype.getElementsByTagNameNS = Element.prototype.getElementsByTagNameNS;
            _extends(Element, Node);
            function Attr() {}
            Attr.prototype.nodeType = ATTRIBUTE_NODE;
            _extends(Attr, Node);
            function CharacterData() {}
            CharacterData.prototype = {
                data: "",
                substringData: function(offset, count) {
                    return this.data.substring(offset, offset + count);
                },
                appendData: function(text) {
                    text = this.data + text;
                    this.nodeValue = this.data = text;
                    this.length = text.length;
                },
                insertData: function(offset, text) {
                    this.replaceData(offset, 0, text);
                },
                appendChild: function(newChild) {
                    throw new Error(ExceptionMessage[HIERARCHY_REQUEST_ERR]);
                },
                deleteData: function(offset, count) {
                    this.replaceData(offset, count, "");
                },
                replaceData: function(offset, count, text) {
                    var start = this.data.substring(0, offset);
                    var end = this.data.substring(offset + count);
                    text = start + text + end;
                    this.nodeValue = this.data = text;
                    this.length = text.length;
                }
            };
            _extends(CharacterData, Node);
            function Text() {}
            Text.prototype = {
                nodeName: "#text",
                nodeType: TEXT_NODE,
                splitText: function(offset) {
                    var text = this.data;
                    var newText = text.substring(offset);
                    text = text.substring(0, offset);
                    this.data = this.nodeValue = text;
                    this.length = text.length;
                    var newNode = this.ownerDocument.createTextNode(newText);
                    if (this.parentNode) this.parentNode.insertBefore(newNode, this.nextSibling);
                    return newNode;
                }
            };
            _extends(Text, CharacterData);
            function Comment() {}
            Comment.prototype = {
                nodeName: "#comment",
                nodeType: COMMENT_NODE
            };
            _extends(Comment, CharacterData);
            function CDATASection() {}
            CDATASection.prototype = {
                nodeName: "#cdata-section",
                nodeType: CDATA_SECTION_NODE
            };
            _extends(CDATASection, CharacterData);
            function DocumentType() {}
            DocumentType.prototype.nodeType = DOCUMENT_TYPE_NODE;
            _extends(DocumentType, Node);
            function Notation() {}
            Notation.prototype.nodeType = NOTATION_NODE;
            _extends(Notation, Node);
            function Entity() {}
            Entity.prototype.nodeType = ENTITY_NODE;
            _extends(Entity, Node);
            function EntityReference() {}
            EntityReference.prototype.nodeType = ENTITY_REFERENCE_NODE;
            _extends(EntityReference, Node);
            function DocumentFragment() {}
            DocumentFragment.prototype.nodeName = "#document-fragment";
            DocumentFragment.prototype.nodeType = DOCUMENT_FRAGMENT_NODE;
            _extends(DocumentFragment, Node);
            function ProcessingInstruction() {}
            ProcessingInstruction.prototype.nodeType = PROCESSING_INSTRUCTION_NODE;
            _extends(ProcessingInstruction, Node);
            function XMLSerializer() {}
            XMLSerializer.prototype.serializeToString = function(node, isHtml, nodeFilter) {
                return nodeSerializeToString.call(node, isHtml, nodeFilter);
            };
            Node.prototype.toString = nodeSerializeToString;
            function nodeSerializeToString(isHtml, nodeFilter) {
                var buf = [];
                var refNode = this.nodeType == 9 && this.documentElement || this;
                var prefix = refNode.prefix;
                var uri = refNode.namespaceURI;
                if (uri && prefix == null) {
                    prefix = refNode.lookupPrefix(uri);
                    if (prefix == null) var visibleNamespaces = [ {
                        namespace: uri,
                        prefix: null
                    } ];
                }
                serializeToString(this, buf, isHtml, nodeFilter, visibleNamespaces);
                return buf.join("");
            }
            function needNamespaceDefine(node, isHTML, visibleNamespaces) {
                var prefix = node.prefix || "";
                var uri = node.namespaceURI;
                if (!uri) return false;
                if (prefix === "xml" && uri === NAMESPACE.XML || uri === NAMESPACE.XMLNS) return false;
                var i = visibleNamespaces.length;
                while (i--) {
                    var ns = visibleNamespaces[i];
                    if (ns.prefix === prefix) return ns.namespace !== uri;
                }
                return true;
            }
            function addSerializedAttribute(buf, qualifiedName, value) {
                buf.push(" ", qualifiedName, '="', value.replace(/[<>&"\t\n\r]/g, _xmlEncoder), '"');
            }
            function serializeToString(node, buf, isHTML, nodeFilter, visibleNamespaces) {
                if (!visibleNamespaces) visibleNamespaces = [];
                if (nodeFilter) {
                    node = nodeFilter(node);
                    if (node) {
                        if (typeof node == "string") {
                            buf.push(node);
                            return;
                        }
                    } else return;
                }
                switch (node.nodeType) {
                  case ELEMENT_NODE:
                    var attrs = node.attributes;
                    var len = attrs.length;
                    var child = node.firstChild;
                    var nodeName = node.tagName;
                    isHTML = NAMESPACE.isHTML(node.namespaceURI) || isHTML;
                    var prefixedNodeName = nodeName;
                    if (!isHTML && !node.prefix && node.namespaceURI) {
                        var defaultNS;
                        for (var ai = 0; ai < attrs.length; ai++) if (attrs.item(ai).name === "xmlns") {
                            defaultNS = attrs.item(ai).value;
                            break;
                        }
                        if (!defaultNS) for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
                            var namespace = visibleNamespaces[nsi];
                            if (namespace.prefix === "" && namespace.namespace === node.namespaceURI) {
                                defaultNS = namespace.namespace;
                                break;
                            }
                        }
                        if (defaultNS !== node.namespaceURI) for (nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
                            namespace = visibleNamespaces[nsi];
                            if (namespace.namespace === node.namespaceURI) {
                                if (namespace.prefix) prefixedNodeName = namespace.prefix + ":" + nodeName;
                                break;
                            }
                        }
                    }
                    buf.push("<", prefixedNodeName);
                    for (var i = 0; i < len; i++) {
                        var attr = attrs.item(i);
                        if (attr.prefix == "xmlns") visibleNamespaces.push({
                            prefix: attr.localName,
                            namespace: attr.value
                        }); else if (attr.nodeName == "xmlns") visibleNamespaces.push({
                            prefix: "",
                            namespace: attr.value
                        });
                    }
                    for (i = 0; i < len; i++) {
                        attr = attrs.item(i);
                        if (needNamespaceDefine(attr, isHTML, visibleNamespaces)) {
                            var prefix = attr.prefix || "";
                            var uri = attr.namespaceURI;
                            addSerializedAttribute(buf, prefix ? "xmlns:" + prefix : "xmlns", uri);
                            visibleNamespaces.push({
                                prefix,
                                namespace: uri
                            });
                        }
                        serializeToString(attr, buf, isHTML, nodeFilter, visibleNamespaces);
                    }
                    if (nodeName === prefixedNodeName && needNamespaceDefine(node, isHTML, visibleNamespaces)) {
                        prefix = node.prefix || "";
                        uri = node.namespaceURI;
                        addSerializedAttribute(buf, prefix ? "xmlns:" + prefix : "xmlns", uri);
                        visibleNamespaces.push({
                            prefix,
                            namespace: uri
                        });
                    }
                    if (child || isHTML && !/^(?:meta|link|img|br|hr|input)$/i.test(nodeName)) {
                        buf.push(">");
                        if (isHTML && /^script$/i.test(nodeName)) while (child) {
                            if (child.data) buf.push(child.data); else serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
                            child = child.nextSibling;
                        } else while (child) {
                            serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
                            child = child.nextSibling;
                        }
                        buf.push("</", prefixedNodeName, ">");
                    } else buf.push("/>");
                    return;

                  case DOCUMENT_NODE:
                  case DOCUMENT_FRAGMENT_NODE:
                    child = node.firstChild;
                    while (child) {
                        serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
                        child = child.nextSibling;
                    }
                    return;

                  case ATTRIBUTE_NODE:
                    return addSerializedAttribute(buf, node.name, node.value);

                  case TEXT_NODE:
                    return buf.push(node.data.replace(/[<&>]/g, _xmlEncoder));

                  case CDATA_SECTION_NODE:
                    return buf.push("<![CDATA[", node.data, "]]>");

                  case COMMENT_NODE:
                    return buf.push("\x3c!--", node.data, "--\x3e");

                  case DOCUMENT_TYPE_NODE:
                    var pubid = node.publicId;
                    var sysid = node.systemId;
                    buf.push("<!DOCTYPE ", node.name);
                    if (pubid) {
                        buf.push(" PUBLIC ", pubid);
                        if (sysid && sysid != ".") buf.push(" ", sysid);
                        buf.push(">");
                    } else if (sysid && sysid != ".") buf.push(" SYSTEM ", sysid, ">"); else {
                        var sub = node.internalSubset;
                        if (sub) buf.push(" [", sub, "]");
                        buf.push(">");
                    }
                    return;

                  case PROCESSING_INSTRUCTION_NODE:
                    return buf.push("<?", node.target, " ", node.data, "?>");

                  case ENTITY_REFERENCE_NODE:
                    return buf.push("&", node.nodeName, ";");

                  default:
                    buf.push("??", node.nodeName);
                }
            }
            function importNode(doc, node, deep) {
                var node2;
                switch (node.nodeType) {
                  case ELEMENT_NODE:
                    node2 = node.cloneNode(false);
                    node2.ownerDocument = doc;

                  case DOCUMENT_FRAGMENT_NODE:
                    break;

                  case ATTRIBUTE_NODE:
                    deep = true;
                    break;
                }
                if (!node2) node2 = node.cloneNode(false);
                node2.ownerDocument = doc;
                node2.parentNode = null;
                if (deep) {
                    var child = node.firstChild;
                    while (child) {
                        node2.appendChild(importNode(doc, child, deep));
                        child = child.nextSibling;
                    }
                }
                return node2;
            }
            function cloneNode(doc, node, deep) {
                var node2 = new node.constructor;
                for (var n in node) if (Object.prototype.hasOwnProperty.call(node, n)) {
                    var v = node[n];
                    if (typeof v != "object") if (v != node2[n]) node2[n] = v;
                }
                if (node.childNodes) node2.childNodes = new NodeList;
                node2.ownerDocument = doc;
                switch (node2.nodeType) {
                  case ELEMENT_NODE:
                    var attrs = node.attributes;
                    var attrs2 = node2.attributes = new NamedNodeMap;
                    var len = attrs.length;
                    attrs2._ownerElement = node2;
                    for (var i = 0; i < len; i++) node2.setAttributeNode(cloneNode(doc, attrs.item(i), true));
                    break;

                  case ATTRIBUTE_NODE:
                    deep = true;
                }
                if (deep) {
                    var child = node.firstChild;
                    while (child) {
                        node2.appendChild(cloneNode(doc, child, deep));
                        child = child.nextSibling;
                    }
                }
                return node2;
            }
            function __set__(object, key, value) {
                object[key] = value;
            }
            try {
                if (Object.defineProperty) {
                    Object.defineProperty(LiveNodeList.prototype, "length", {
                        get: function() {
                            _updateLiveList(this);
                            return this.$$length;
                        }
                    });
                    Object.defineProperty(Node.prototype, "textContent", {
                        get: function() {
                            return getTextContent(this);
                        },
                        set: function(data) {
                            switch (this.nodeType) {
                              case ELEMENT_NODE:
                              case DOCUMENT_FRAGMENT_NODE:
                                while (this.firstChild) this.removeChild(this.firstChild);
                                if (data || String(data)) this.appendChild(this.ownerDocument.createTextNode(data));
                                break;

                              default:
                                this.data = data;
                                this.value = data;
                                this.nodeValue = data;
                            }
                        }
                    });
                    function getTextContent(node) {
                        switch (node.nodeType) {
                          case ELEMENT_NODE:
                          case DOCUMENT_FRAGMENT_NODE:
                            var buf = [];
                            node = node.firstChild;
                            while (node) {
                                if (node.nodeType !== 7 && node.nodeType !== 8) buf.push(getTextContent(node));
                                node = node.nextSibling;
                            }
                            return buf.join("");

                          default:
                            return node.nodeValue;
                        }
                    }
                    __set__ = function(object, key, value) {
                        object["$$" + key] = value;
                    };
                }
            } catch (e) {}
            exports.DocumentType = DocumentType;
            exports.DOMException = DOMException;
            exports.DOMImplementation = DOMImplementation;
            exports.Element = Element;
            exports.Node = Node;
            exports.NodeList = NodeList;
            exports.XMLSerializer = XMLSerializer;
        },
        559: (__unused_webpack_module, exports, __webpack_require__) => {
            "use strict";
            var freeze = __webpack_require__(582).freeze;
            exports.XML_ENTITIES = freeze({
                amp: "&",
                apos: "'",
                gt: ">",
                lt: "<",
                quot: '"'
            });
            exports.HTML_ENTITIES = freeze({
                Aacute: "√Å",
                aacute: "√°",
                Abreve: "ƒÇ",
                abreve: "ƒÉ",
                ac: "‚àæ",
                acd: "‚àø",
                acE: "‚àæÃ≥",
                Acirc: "√Ç",
                acirc: "√¢",
                acute: "¬¥",
                Acy: "–ê",
                acy: "–∞",
                AElig: "√Ü",
                aelig: "√¶",
                af: "‚Å°",
                Afr: "ùîÑ",
                afr: "ùîû",
                Agrave: "√Ä",
                agrave: "√†",
                alefsym: "‚Ñµ",
                aleph: "‚Ñµ",
                Alpha: "Œë",
                alpha: "Œ±",
                Amacr: "ƒÄ",
                amacr: "ƒÅ",
                amalg: "‚®ø",
                AMP: "&",
                amp: "&",
                And: "‚©ì",
                and: "‚àß",
                andand: "‚©ï",
                andd: "‚©ú",
                andslope: "‚©ò",
                andv: "‚©ö",
                ang: "‚à†",
                ange: "‚¶§",
                angle: "‚à†",
                angmsd: "‚à°",
                angmsdaa: "‚¶®",
                angmsdab: "‚¶©",
                angmsdac: "‚¶™",
                angmsdad: "‚¶´",
                angmsdae: "‚¶¨",
                angmsdaf: "‚¶≠",
                angmsdag: "‚¶Æ",
                angmsdah: "‚¶Ø",
                angrt: "‚àü",
                angrtvb: "‚äæ",
                angrtvbd: "‚¶ù",
                angsph: "‚à¢",
                angst: "√Ö",
                angzarr: "‚çº",
                Aogon: "ƒÑ",
                aogon: "ƒÖ",
                Aopf: "ùî∏",
                aopf: "ùïí",
                ap: "‚âà",
                apacir: "‚©Ø",
                apE: "‚©∞",
                ape: "‚âä",
                apid: "‚âã",
                apos: "'",
                ApplyFunction: "‚Å°",
                approx: "‚âà",
                approxeq: "‚âä",
                Aring: "√Ö",
                aring: "√•",
                Ascr: "ùíú",
                ascr: "ùí∂",
                Assign: "‚âî",
                ast: "*",
                asymp: "‚âà",
                asympeq: "‚âç",
                Atilde: "√É",
                atilde: "√£",
                Auml: "√Ñ",
                auml: "√§",
                awconint: "‚à≥",
                awint: "‚®ë",
                backcong: "‚âå",
                backepsilon: "œ∂",
                backprime: "‚Äµ",
                backsim: "‚àΩ",
                backsimeq: "‚ãç",
                Backslash: "‚àñ",
                Barv: "‚´ß",
                barvee: "‚äΩ",
                Barwed: "‚åÜ",
                barwed: "‚åÖ",
                barwedge: "‚åÖ",
                bbrk: "‚éµ",
                bbrktbrk: "‚é∂",
                bcong: "‚âå",
                Bcy: "–ë",
                bcy: "–±",
                bdquo: "‚Äû",
                becaus: "‚àµ",
                Because: "‚àµ",
                because: "‚àµ",
                bemptyv: "‚¶∞",
                bepsi: "œ∂",
                bernou: "‚Ñ¨",
                Bernoullis: "‚Ñ¨",
                Beta: "Œí",
                beta: "Œ≤",
                beth: "‚Ñ∂",
                between: "‚â¨",
                Bfr: "ùîÖ",
                bfr: "ùîü",
                bigcap: "‚ãÇ",
                bigcirc: "‚óØ",
                bigcup: "‚ãÉ",
                bigodot: "‚®Ä",
                bigoplus: "‚®Å",
                bigotimes: "‚®Ç",
                bigsqcup: "‚®Ü",
                bigstar: "‚òÖ",
                bigtriangledown: "‚ñΩ",
                bigtriangleup: "‚ñ≥",
                biguplus: "‚®Ñ",
                bigvee: "‚ãÅ",
                bigwedge: "‚ãÄ",
                bkarow: "‚§ç",
                blacklozenge: "‚ß´",
                blacksquare: "‚ñ™",
                blacktriangle: "‚ñ¥",
                blacktriangledown: "‚ñæ",
                blacktriangleleft: "‚óÇ",
                blacktriangleright: "‚ñ∏",
                blank: "‚ê£",
                blk12: "‚ñí",
                blk14: "‚ñë",
                blk34: "‚ñì",
                block: "‚ñà",
                bne: "=‚É•",
                bnequiv: "‚â°‚É•",
                bNot: "‚´≠",
                bnot: "‚åê",
                Bopf: "ùîπ",
                bopf: "ùïì",
                bot: "‚ä•",
                bottom: "‚ä•",
                bowtie: "‚ãà",
                boxbox: "‚ßâ",
                boxDL: "‚ïó",
                boxDl: "‚ïñ",
                boxdL: "‚ïï",
                boxdl: "‚îê",
                boxDR: "‚ïî",
                boxDr: "‚ïì",
                boxdR: "‚ïí",
                boxdr: "‚îå",
                boxH: "‚ïê",
                boxh: "‚îÄ",
                boxHD: "‚ï¶",
                boxHd: "‚ï§",
                boxhD: "‚ï•",
                boxhd: "‚î¨",
                boxHU: "‚ï©",
                boxHu: "‚ïß",
                boxhU: "‚ï®",
                boxhu: "‚î¥",
                boxminus: "‚äü",
                boxplus: "‚äû",
                boxtimes: "‚ä†",
                boxUL: "‚ïù",
                boxUl: "‚ïú",
                boxuL: "‚ïõ",
                boxul: "‚îò",
                boxUR: "‚ïö",
                boxUr: "‚ïô",
                boxuR: "‚ïò",
                boxur: "‚îî",
                boxV: "‚ïë",
                boxv: "‚îÇ",
                boxVH: "‚ï¨",
                boxVh: "‚ï´",
                boxvH: "‚ï™",
                boxvh: "‚îº",
                boxVL: "‚ï£",
                boxVl: "‚ï¢",
                boxvL: "‚ï°",
                boxvl: "‚î§",
                boxVR: "‚ï†",
                boxVr: "‚ïü",
                boxvR: "‚ïû",
                boxvr: "‚îú",
                bprime: "‚Äµ",
                Breve: "Àò",
                breve: "Àò",
                brvbar: "¬¶",
                Bscr: "‚Ñ¨",
                bscr: "ùí∑",
                bsemi: "‚Åè",
                bsim: "‚àΩ",
                bsime: "‚ãç",
                bsol: "\\",
                bsolb: "‚ßÖ",
                bsolhsub: "‚üà",
                bull: "‚Ä¢",
                bullet: "‚Ä¢",
                bump: "‚âé",
                bumpE: "‚™Æ",
                bumpe: "‚âè",
                Bumpeq: "‚âé",
                bumpeq: "‚âè",
                Cacute: "ƒÜ",
                cacute: "ƒá",
                Cap: "‚ãí",
                cap: "‚à©",
                capand: "‚©Ñ",
                capbrcup: "‚©â",
                capcap: "‚©ã",
                capcup: "‚©á",
                capdot: "‚©Ä",
                CapitalDifferentialD: "‚ÖÖ",
                caps: "‚à©Ô∏Ä",
                caret: "‚ÅÅ",
                caron: "Àá",
                Cayleys: "‚Ñ≠",
                ccaps: "‚©ç",
                Ccaron: "ƒå",
                ccaron: "ƒç",
                Ccedil: "√á",
                ccedil: "√ß",
                Ccirc: "ƒà",
                ccirc: "ƒâ",
                Cconint: "‚à∞",
                ccups: "‚©å",
                ccupssm: "‚©ê",
                Cdot: "ƒä",
                cdot: "ƒã",
                cedil: "¬∏",
                Cedilla: "¬∏",
                cemptyv: "‚¶≤",
                cent: "¬¢",
                CenterDot: "¬∑",
                centerdot: "¬∑",
                Cfr: "‚Ñ≠",
                cfr: "ùî†",
                CHcy: "–ß",
                chcy: "—á",
                check: "‚úì",
                checkmark: "‚úì",
                Chi: "Œß",
                chi: "œá",
                cir: "‚óã",
                circ: "ÀÜ",
                circeq: "‚âó",
                circlearrowleft: "‚Ü∫",
                circlearrowright: "‚Üª",
                circledast: "‚äõ",
                circledcirc: "‚äö",
                circleddash: "‚äù",
                CircleDot: "‚äô",
                circledR: "¬Æ",
                circledS: "‚ìà",
                CircleMinus: "‚äñ",
                CirclePlus: "‚äï",
                CircleTimes: "‚äó",
                cirE: "‚ßÉ",
                cire: "‚âó",
                cirfnint: "‚®ê",
                cirmid: "‚´Ø",
                cirscir: "‚ßÇ",
                ClockwiseContourIntegral: "‚à≤",
                CloseCurlyDoubleQuote: "‚Äù",
                CloseCurlyQuote: "‚Äô",
                clubs: "‚ô£",
                clubsuit: "‚ô£",
                Colon: "‚à∑",
                colon: ":",
                Colone: "‚©¥",
                colone: "‚âî",
                coloneq: "‚âî",
                comma: ",",
                commat: "@",
                comp: "‚àÅ",
                compfn: "‚àò",
                complement: "‚àÅ",
                complexes: "‚ÑÇ",
                cong: "‚âÖ",
                congdot: "‚©≠",
                Congruent: "‚â°",
                Conint: "‚àØ",
                conint: "‚àÆ",
                ContourIntegral: "‚àÆ",
                Copf: "‚ÑÇ",
                copf: "ùïî",
                coprod: "‚àê",
                Coproduct: "‚àê",
                COPY: "¬©",
                copy: "¬©",
                copysr: "‚Ñó",
                CounterClockwiseContourIntegral: "‚à≥",
                crarr: "‚Üµ",
                Cross: "‚®Ø",
                cross: "‚úó",
                Cscr: "ùíû",
                cscr: "ùí∏",
                csub: "‚´è",
                csube: "‚´ë",
                csup: "‚´ê",
                csupe: "‚´í",
                ctdot: "‚ãØ",
                cudarrl: "‚§∏",
                cudarrr: "‚§µ",
                cuepr: "‚ãû",
                cuesc: "‚ãü",
                cularr: "‚Ü∂",
                cularrp: "‚§Ω",
                Cup: "‚ãì",
                cup: "‚à™",
                cupbrcap: "‚©à",
                CupCap: "‚âç",
                cupcap: "‚©Ü",
                cupcup: "‚©ä",
                cupdot: "‚äç",
                cupor: "‚©Ö",
                cups: "‚à™Ô∏Ä",
                curarr: "‚Ü∑",
                curarrm: "‚§º",
                curlyeqprec: "‚ãû",
                curlyeqsucc: "‚ãü",
                curlyvee: "‚ãé",
                curlywedge: "‚ãè",
                curren: "¬§",
                curvearrowleft: "‚Ü∂",
                curvearrowright: "‚Ü∑",
                cuvee: "‚ãé",
                cuwed: "‚ãè",
                cwconint: "‚à≤",
                cwint: "‚à±",
                cylcty: "‚å≠",
                Dagger: "‚Ä°",
                dagger: "‚Ä†",
                daleth: "‚Ñ∏",
                Darr: "‚Ü°",
                dArr: "‚áì",
                darr: "‚Üì",
                dash: "‚Äê",
                Dashv: "‚´§",
                dashv: "‚ä£",
                dbkarow: "‚§è",
                dblac: "Àù",
                Dcaron: "ƒé",
                dcaron: "ƒè",
                Dcy: "–î",
                dcy: "–¥",
                DD: "‚ÖÖ",
                dd: "‚ÖÜ",
                ddagger: "‚Ä°",
                ddarr: "‚áä",
                DDotrahd: "‚§ë",
                ddotseq: "‚©∑",
                deg: "¬∞",
                Del: "‚àá",
                Delta: "Œî",
                delta: "Œ¥",
                demptyv: "‚¶±",
                dfisht: "‚•ø",
                Dfr: "ùîá",
                dfr: "ùî°",
                dHar: "‚••",
                dharl: "‚áÉ",
                dharr: "‚áÇ",
                DiacriticalAcute: "¬¥",
                DiacriticalDot: "Àô",
                DiacriticalDoubleAcute: "Àù",
                DiacriticalGrave: "`",
                DiacriticalTilde: "Àú",
                diam: "‚ãÑ",
                Diamond: "‚ãÑ",
                diamond: "‚ãÑ",
                diamondsuit: "‚ô¶",
                diams: "‚ô¶",
                die: "¬®",
                DifferentialD: "‚ÖÜ",
                digamma: "œù",
                disin: "‚ã≤",
                div: "√∑",
                divide: "√∑",
                divideontimes: "‚ãá",
                divonx: "‚ãá",
                DJcy: "–Ç",
                djcy: "—í",
                dlcorn: "‚åû",
                dlcrop: "‚åç",
                dollar: "$",
                Dopf: "ùîª",
                dopf: "ùïï",
                Dot: "¬®",
                dot: "Àô",
                DotDot: "‚Éú",
                doteq: "‚âê",
                doteqdot: "‚âë",
                DotEqual: "‚âê",
                dotminus: "‚à∏",
                dotplus: "‚àî",
                dotsquare: "‚ä°",
                doublebarwedge: "‚åÜ",
                DoubleContourIntegral: "‚àØ",
                DoubleDot: "¬®",
                DoubleDownArrow: "‚áì",
                DoubleLeftArrow: "‚áê",
                DoubleLeftRightArrow: "‚áî",
                DoubleLeftTee: "‚´§",
                DoubleLongLeftArrow: "‚ü∏",
                DoubleLongLeftRightArrow: "‚ü∫",
                DoubleLongRightArrow: "‚üπ",
                DoubleRightArrow: "‚áí",
                DoubleRightTee: "‚ä®",
                DoubleUpArrow: "‚áë",
                DoubleUpDownArrow: "‚áï",
                DoubleVerticalBar: "‚à•",
                DownArrow: "‚Üì",
                Downarrow: "‚áì",
                downarrow: "‚Üì",
                DownArrowBar: "‚§ì",
                DownArrowUpArrow: "‚áµ",
                DownBreve: "Ãë",
                downdownarrows: "‚áä",
                downharpoonleft: "‚áÉ",
                downharpoonright: "‚áÇ",
                DownLeftRightVector: "‚•ê",
                DownLeftTeeVector: "‚•û",
                DownLeftVector: "‚ÜΩ",
                DownLeftVectorBar: "‚•ñ",
                DownRightTeeVector: "‚•ü",
                DownRightVector: "‚áÅ",
                DownRightVectorBar: "‚•ó",
                DownTee: "‚ä§",
                DownTeeArrow: "‚Üß",
                drbkarow: "‚§ê",
                drcorn: "‚åü",
                drcrop: "‚åå",
                Dscr: "ùíü",
                dscr: "ùíπ",
                DScy: "–Ö",
                dscy: "—ï",
                dsol: "‚ß∂",
                Dstrok: "ƒê",
                dstrok: "ƒë",
                dtdot: "‚ã±",
                dtri: "‚ñø",
                dtrif: "‚ñæ",
                duarr: "‚áµ",
                duhar: "‚•Ø",
                dwangle: "‚¶¶",
                DZcy: "–è",
                dzcy: "—ü",
                dzigrarr: "‚üø",
                Eacute: "√â",
                eacute: "√©",
                easter: "‚©Æ",
                Ecaron: "ƒö",
                ecaron: "ƒõ",
                ecir: "‚âñ",
                Ecirc: "√ä",
                ecirc: "√™",
                ecolon: "‚âï",
                Ecy: "–≠",
                ecy: "—ç",
                eDDot: "‚©∑",
                Edot: "ƒñ",
                eDot: "‚âë",
                edot: "ƒó",
                ee: "‚Öá",
                efDot: "‚âí",
                Efr: "ùîà",
                efr: "ùî¢",
                eg: "‚™ö",
                Egrave: "√à",
                egrave: "√®",
                egs: "‚™ñ",
                egsdot: "‚™ò",
                el: "‚™ô",
                Element: "‚àà",
                elinters: "‚èß",
                ell: "‚Ñì",
                els: "‚™ï",
                elsdot: "‚™ó",
                Emacr: "ƒí",
                emacr: "ƒì",
                empty: "‚àÖ",
                emptyset: "‚àÖ",
                EmptySmallSquare: "‚óª",
                emptyv: "‚àÖ",
                EmptyVerySmallSquare: "‚ñ´",
                emsp: "‚ÄÉ",
                emsp13: "‚ÄÑ",
                emsp14: "‚ÄÖ",
                ENG: "≈ä",
                eng: "≈ã",
                ensp: "‚ÄÇ",
                Eogon: "ƒò",
                eogon: "ƒô",
                Eopf: "ùîº",
                eopf: "ùïñ",
                epar: "‚ãï",
                eparsl: "‚ß£",
                eplus: "‚©±",
                epsi: "Œµ",
                Epsilon: "Œï",
                epsilon: "Œµ",
                epsiv: "œµ",
                eqcirc: "‚âñ",
                eqcolon: "‚âï",
                eqsim: "‚âÇ",
                eqslantgtr: "‚™ñ",
                eqslantless: "‚™ï",
                Equal: "‚©µ",
                equals: "=",
                EqualTilde: "‚âÇ",
                equest: "‚âü",
                Equilibrium: "‚áå",
                equiv: "‚â°",
                equivDD: "‚©∏",
                eqvparsl: "‚ß•",
                erarr: "‚•±",
                erDot: "‚âì",
                Escr: "‚Ñ∞",
                escr: "‚ÑØ",
                esdot: "‚âê",
                Esim: "‚©≥",
                esim: "‚âÇ",
                Eta: "Œó",
                eta: "Œ∑",
                ETH: "√ê",
                eth: "√∞",
                Euml: "√ã",
                euml: "√´",
                euro: "‚Ç¨",
                excl: "!",
                exist: "‚àÉ",
                Exists: "‚àÉ",
                expectation: "‚Ñ∞",
                ExponentialE: "‚Öá",
                exponentiale: "‚Öá",
                fallingdotseq: "‚âí",
                Fcy: "–§",
                fcy: "—Ñ",
                female: "‚ôÄ",
                ffilig: "Ô¨É",
                fflig: "Ô¨Ä",
                ffllig: "Ô¨Ñ",
                Ffr: "ùîâ",
                ffr: "ùî£",
                filig: "Ô¨Å",
                FilledSmallSquare: "‚óº",
                FilledVerySmallSquare: "‚ñ™",
                fjlig: "fj",
                flat: "‚ô≠",
                fllig: "Ô¨Ç",
                fltns: "‚ñ±",
                fnof: "∆í",
                Fopf: "ùîΩ",
                fopf: "ùïó",
                ForAll: "‚àÄ",
                forall: "‚àÄ",
                fork: "‚ãî",
                forkv: "‚´ô",
                Fouriertrf: "‚Ñ±",
                fpartint: "‚®ç",
                frac12: "¬Ω",
                frac13: "‚Öì",
                frac14: "¬º",
                frac15: "‚Öï",
                frac16: "‚Öô",
                frac18: "‚Öõ",
                frac23: "‚Öî",
                frac25: "‚Öñ",
                frac34: "¬æ",
                frac35: "‚Öó",
                frac38: "‚Öú",
                frac45: "‚Öò",
                frac56: "‚Öö",
                frac58: "‚Öù",
                frac78: "‚Öû",
                frasl: "‚ÅÑ",
                frown: "‚å¢",
                Fscr: "‚Ñ±",
                fscr: "ùíª",
                gacute: "«µ",
                Gamma: "Œì",
                gamma: "Œ≥",
                Gammad: "œú",
                gammad: "œù",
                gap: "‚™Ü",
                Gbreve: "ƒû",
                gbreve: "ƒü",
                Gcedil: "ƒ¢",
                Gcirc: "ƒú",
                gcirc: "ƒù",
                Gcy: "–ì",
                gcy: "–≥",
                Gdot: "ƒ†",
                gdot: "ƒ°",
                gE: "‚âß",
                ge: "‚â•",
                gEl: "‚™å",
                gel: "‚ãõ",
                geq: "‚â•",
                geqq: "‚âß",
                geqslant: "‚©æ",
                ges: "‚©æ",
                gescc: "‚™©",
                gesdot: "‚™Ä",
                gesdoto: "‚™Ç",
                gesdotol: "‚™Ñ",
                gesl: "‚ãõÔ∏Ä",
                gesles: "‚™î",
                Gfr: "ùîä",
                gfr: "ùî§",
                Gg: "‚ãô",
                gg: "‚â´",
                ggg: "‚ãô",
                gimel: "‚Ñ∑",
                GJcy: "–É",
                gjcy: "—ì",
                gl: "‚â∑",
                gla: "‚™•",
                glE: "‚™í",
                glj: "‚™§",
                gnap: "‚™ä",
                gnapprox: "‚™ä",
                gnE: "‚â©",
                gne: "‚™à",
                gneq: "‚™à",
                gneqq: "‚â©",
                gnsim: "‚ãß",
                Gopf: "ùîæ",
                gopf: "ùïò",
                grave: "`",
                GreaterEqual: "‚â•",
                GreaterEqualLess: "‚ãõ",
                GreaterFullEqual: "‚âß",
                GreaterGreater: "‚™¢",
                GreaterLess: "‚â∑",
                GreaterSlantEqual: "‚©æ",
                GreaterTilde: "‚â≥",
                Gscr: "ùí¢",
                gscr: "‚Ñä",
                gsim: "‚â≥",
                gsime: "‚™é",
                gsiml: "‚™ê",
                Gt: "‚â´",
                GT: ">",
                gt: ">",
                gtcc: "‚™ß",
                gtcir: "‚©∫",
                gtdot: "‚ãó",
                gtlPar: "‚¶ï",
                gtquest: "‚©º",
                gtrapprox: "‚™Ü",
                gtrarr: "‚•∏",
                gtrdot: "‚ãó",
                gtreqless: "‚ãõ",
                gtreqqless: "‚™å",
                gtrless: "‚â∑",
                gtrsim: "‚â≥",
                gvertneqq: "‚â©Ô∏Ä",
                gvnE: "‚â©Ô∏Ä",
                Hacek: "Àá",
                hairsp: "‚Ää",
                half: "¬Ω",
                hamilt: "‚Ñã",
                HARDcy: "–™",
                hardcy: "—ä",
                hArr: "‚áî",
                harr: "‚Üî",
                harrcir: "‚•à",
                harrw: "‚Ü≠",
                Hat: "^",
                hbar: "‚Ñè",
                Hcirc: "ƒ§",
                hcirc: "ƒ•",
                hearts: "‚ô•",
                heartsuit: "‚ô•",
                hellip: "‚Ä¶",
                hercon: "‚äπ",
                Hfr: "‚Ñå",
                hfr: "ùî•",
                HilbertSpace: "‚Ñã",
                hksearow: "‚§•",
                hkswarow: "‚§¶",
                hoarr: "‚áø",
                homtht: "‚àª",
                hookleftarrow: "‚Ü©",
                hookrightarrow: "‚Ü™",
                Hopf: "‚Ñç",
                hopf: "ùïô",
                horbar: "‚Äï",
                HorizontalLine: "‚îÄ",
                Hscr: "‚Ñã",
                hscr: "ùíΩ",
                hslash: "‚Ñè",
                Hstrok: "ƒ¶",
                hstrok: "ƒß",
                HumpDownHump: "‚âé",
                HumpEqual: "‚âè",
                hybull: "‚ÅÉ",
                hyphen: "‚Äê",
                Iacute: "√ç",
                iacute: "√≠",
                ic: "‚Å£",
                Icirc: "√é",
                icirc: "√Æ",
                Icy: "–ò",
                icy: "–∏",
                Idot: "ƒ∞",
                IEcy: "–ï",
                iecy: "–µ",
                iexcl: "¬°",
                iff: "‚áî",
                Ifr: "‚Ñë",
                ifr: "ùî¶",
                Igrave: "√å",
                igrave: "√¨",
                ii: "‚Öà",
                iiiint: "‚®å",
                iiint: "‚à≠",
                iinfin: "‚ßú",
                iiota: "‚Ñ©",
                IJlig: "ƒ≤",
                ijlig: "ƒ≥",
                Im: "‚Ñë",
                Imacr: "ƒ™",
                imacr: "ƒ´",
                image: "‚Ñë",
                ImaginaryI: "‚Öà",
                imagline: "‚Ñê",
                imagpart: "‚Ñë",
                imath: "ƒ±",
                imof: "‚ä∑",
                imped: "∆µ",
                Implies: "‚áí",
                in: "‚àà",
                incare: "‚ÑÖ",
                infin: "‚àû",
                infintie: "‚ßù",
                inodot: "ƒ±",
                Int: "‚à¨",
                int: "‚à´",
                intcal: "‚ä∫",
                integers: "‚Ñ§",
                Integral: "‚à´",
                intercal: "‚ä∫",
                Intersection: "‚ãÇ",
                intlarhk: "‚®ó",
                intprod: "‚®º",
                InvisibleComma: "‚Å£",
                InvisibleTimes: "‚Å¢",
                IOcy: "–Å",
                iocy: "—ë",
                Iogon: "ƒÆ",
                iogon: "ƒØ",
                Iopf: "ùïÄ",
                iopf: "ùïö",
                Iota: "Œô",
                iota: "Œπ",
                iprod: "‚®º",
                iquest: "¬ø",
                Iscr: "‚Ñê",
                iscr: "ùíæ",
                isin: "‚àà",
                isindot: "‚ãµ",
                isinE: "‚ãπ",
                isins: "‚ã¥",
                isinsv: "‚ã≥",
                isinv: "‚àà",
                it: "‚Å¢",
                Itilde: "ƒ®",
                itilde: "ƒ©",
                Iukcy: "–Ü",
                iukcy: "—ñ",
                Iuml: "√è",
                iuml: "√Ø",
                Jcirc: "ƒ¥",
                jcirc: "ƒµ",
                Jcy: "–ô",
                jcy: "–π",
                Jfr: "ùîç",
                jfr: "ùîß",
                jmath: "»∑",
                Jopf: "ùïÅ",
                jopf: "ùïõ",
                Jscr: "ùí•",
                jscr: "ùíø",
                Jsercy: "–à",
                jsercy: "—ò",
                Jukcy: "–Ñ",
                jukcy: "—î",
                Kappa: "Œö",
                kappa: "Œ∫",
                kappav: "œ∞",
                Kcedil: "ƒ∂",
                kcedil: "ƒ∑",
                Kcy: "–ö",
                kcy: "–∫",
                Kfr: "ùîé",
                kfr: "ùî®",
                kgreen: "ƒ∏",
                KHcy: "–•",
                khcy: "—Ö",
                KJcy: "–å",
                kjcy: "—ú",
                Kopf: "ùïÇ",
                kopf: "ùïú",
                Kscr: "ùí¶",
                kscr: "ùìÄ",
                lAarr: "‚áö",
                Lacute: "ƒπ",
                lacute: "ƒ∫",
                laemptyv: "‚¶¥",
                lagran: "‚Ñí",
                Lambda: "Œõ",
                lambda: "Œª",
                Lang: "‚ü™",
                lang: "‚ü®",
                langd: "‚¶ë",
                langle: "‚ü®",
                lap: "‚™Ö",
                Laplacetrf: "‚Ñí",
                laquo: "¬´",
                Larr: "‚Üû",
                lArr: "‚áê",
                larr: "‚Üê",
                larrb: "‚á§",
                larrbfs: "‚§ü",
                larrfs: "‚§ù",
                larrhk: "‚Ü©",
                larrlp: "‚Ü´",
                larrpl: "‚§π",
                larrsim: "‚•≥",
                larrtl: "‚Ü¢",
                lat: "‚™´",
                lAtail: "‚§õ",
                latail: "‚§ô",
                late: "‚™≠",
                lates: "‚™≠Ô∏Ä",
                lBarr: "‚§é",
                lbarr: "‚§å",
                lbbrk: "‚ù≤",
                lbrace: "{",
                lbrack: "[",
                lbrke: "‚¶ã",
                lbrksld: "‚¶è",
                lbrkslu: "‚¶ç",
                Lcaron: "ƒΩ",
                lcaron: "ƒæ",
                Lcedil: "ƒª",
                lcedil: "ƒº",
                lceil: "‚åà",
                lcub: "{",
                Lcy: "–õ",
                lcy: "–ª",
                ldca: "‚§∂",
                ldquo: "‚Äú",
                ldquor: "‚Äû",
                ldrdhar: "‚•ß",
                ldrushar: "‚•ã",
                ldsh: "‚Ü≤",
                lE: "‚â¶",
                le: "‚â§",
                LeftAngleBracket: "‚ü®",
                LeftArrow: "‚Üê",
                Leftarrow: "‚áê",
                leftarrow: "‚Üê",
                LeftArrowBar: "‚á§",
                LeftArrowRightArrow: "‚áÜ",
                leftarrowtail: "‚Ü¢",
                LeftCeiling: "‚åà",
                LeftDoubleBracket: "‚ü¶",
                LeftDownTeeVector: "‚•°",
                LeftDownVector: "‚áÉ",
                LeftDownVectorBar: "‚•ô",
                LeftFloor: "‚åä",
                leftharpoondown: "‚ÜΩ",
                leftharpoonup: "‚Üº",
                leftleftarrows: "‚áá",
                LeftRightArrow: "‚Üî",
                Leftrightarrow: "‚áî",
                leftrightarrow: "‚Üî",
                leftrightarrows: "‚áÜ",
                leftrightharpoons: "‚áã",
                leftrightsquigarrow: "‚Ü≠",
                LeftRightVector: "‚•é",
                LeftTee: "‚ä£",
                LeftTeeArrow: "‚Ü§",
                LeftTeeVector: "‚•ö",
                leftthreetimes: "‚ãã",
                LeftTriangle: "‚ä≤",
                LeftTriangleBar: "‚ßè",
                LeftTriangleEqual: "‚ä¥",
                LeftUpDownVector: "‚•ë",
                LeftUpTeeVector: "‚•†",
                LeftUpVector: "‚Üø",
                LeftUpVectorBar: "‚•ò",
                LeftVector: "‚Üº",
                LeftVectorBar: "‚•í",
                lEg: "‚™ã",
                leg: "‚ãö",
                leq: "‚â§",
                leqq: "‚â¶",
                leqslant: "‚©Ω",
                les: "‚©Ω",
                lescc: "‚™®",
                lesdot: "‚©ø",
                lesdoto: "‚™Å",
                lesdotor: "‚™É",
                lesg: "‚ãöÔ∏Ä",
                lesges: "‚™ì",
                lessapprox: "‚™Ö",
                lessdot: "‚ãñ",
                lesseqgtr: "‚ãö",
                lesseqqgtr: "‚™ã",
                LessEqualGreater: "‚ãö",
                LessFullEqual: "‚â¶",
                LessGreater: "‚â∂",
                lessgtr: "‚â∂",
                LessLess: "‚™°",
                lesssim: "‚â≤",
                LessSlantEqual: "‚©Ω",
                LessTilde: "‚â≤",
                lfisht: "‚•º",
                lfloor: "‚åä",
                Lfr: "ùîè",
                lfr: "ùî©",
                lg: "‚â∂",
                lgE: "‚™ë",
                lHar: "‚•¢",
                lhard: "‚ÜΩ",
                lharu: "‚Üº",
                lharul: "‚•™",
                lhblk: "‚ñÑ",
                LJcy: "–â",
                ljcy: "—ô",
                Ll: "‚ãò",
                ll: "‚â™",
                llarr: "‚áá",
                llcorner: "‚åû",
                Lleftarrow: "‚áö",
                llhard: "‚•´",
                lltri: "‚ó∫",
                Lmidot: "ƒø",
                lmidot: "≈Ä",
                lmoust: "‚é∞",
                lmoustache: "‚é∞",
                lnap: "‚™â",
                lnapprox: "‚™â",
                lnE: "‚â®",
                lne: "‚™á",
                lneq: "‚™á",
                lneqq: "‚â®",
                lnsim: "‚ã¶",
                loang: "‚ü¨",
                loarr: "‚áΩ",
                lobrk: "‚ü¶",
                LongLeftArrow: "‚üµ",
                Longleftarrow: "‚ü∏",
                longleftarrow: "‚üµ",
                LongLeftRightArrow: "‚ü∑",
                Longleftrightarrow: "‚ü∫",
                longleftrightarrow: "‚ü∑",
                longmapsto: "‚üº",
                LongRightArrow: "‚ü∂",
                Longrightarrow: "‚üπ",
                longrightarrow: "‚ü∂",
                looparrowleft: "‚Ü´",
                looparrowright: "‚Ü¨",
                lopar: "‚¶Ö",
                Lopf: "ùïÉ",
                lopf: "ùïù",
                loplus: "‚®≠",
                lotimes: "‚®¥",
                lowast: "‚àó",
                lowbar: "_",
                LowerLeftArrow: "‚Üô",
                LowerRightArrow: "‚Üò",
                loz: "‚óä",
                lozenge: "‚óä",
                lozf: "‚ß´",
                lpar: "(",
                lparlt: "‚¶ì",
                lrarr: "‚áÜ",
                lrcorner: "‚åü",
                lrhar: "‚áã",
                lrhard: "‚•≠",
                lrm: "‚Äé",
                lrtri: "‚äø",
                lsaquo: "‚Äπ",
                Lscr: "‚Ñí",
                lscr: "ùìÅ",
                Lsh: "‚Ü∞",
                lsh: "‚Ü∞",
                lsim: "‚â≤",
                lsime: "‚™ç",
                lsimg: "‚™è",
                lsqb: "[",
                lsquo: "‚Äò",
                lsquor: "‚Äö",
                Lstrok: "≈Å",
                lstrok: "≈Ç",
                Lt: "‚â™",
                LT: "<",
                lt: "<",
                ltcc: "‚™¶",
                ltcir: "‚©π",
                ltdot: "‚ãñ",
                lthree: "‚ãã",
                ltimes: "‚ãâ",
                ltlarr: "‚•∂",
                ltquest: "‚©ª",
                ltri: "‚óÉ",
                ltrie: "‚ä¥",
                ltrif: "‚óÇ",
                ltrPar: "‚¶ñ",
                lurdshar: "‚•ä",
                luruhar: "‚•¶",
                lvertneqq: "‚â®Ô∏Ä",
                lvnE: "‚â®Ô∏Ä",
                macr: "¬Ø",
                male: "‚ôÇ",
                malt: "‚ú†",
                maltese: "‚ú†",
                Map: "‚§Ö",
                map: "‚Ü¶",
                mapsto: "‚Ü¶",
                mapstodown: "‚Üß",
                mapstoleft: "‚Ü§",
                mapstoup: "‚Ü•",
                marker: "‚ñÆ",
                mcomma: "‚®©",
                Mcy: "–ú",
                mcy: "–º",
                mdash: "‚Äî",
                mDDot: "‚à∫",
                measuredangle: "‚à°",
                MediumSpace: "‚Åü",
                Mellintrf: "‚Ñ≥",
                Mfr: "ùîê",
                mfr: "ùî™",
                mho: "‚Ñß",
                micro: "¬µ",
                mid: "‚à£",
                midast: "*",
                midcir: "‚´∞",
                middot: "¬∑",
                minus: "‚àí",
                minusb: "‚äü",
                minusd: "‚à∏",
                minusdu: "‚®™",
                MinusPlus: "‚àì",
                mlcp: "‚´õ",
                mldr: "‚Ä¶",
                mnplus: "‚àì",
                models: "‚äß",
                Mopf: "ùïÑ",
                mopf: "ùïû",
                mp: "‚àì",
                Mscr: "‚Ñ≥",
                mscr: "ùìÇ",
                mstpos: "‚àæ",
                Mu: "Œú",
                mu: "Œº",
                multimap: "‚ä∏",
                mumap: "‚ä∏",
                nabla: "‚àá",
                Nacute: "≈É",
                nacute: "≈Ñ",
                nang: "‚à†‚Éí",
                nap: "‚ââ",
                napE: "‚©∞Ã∏",
                napid: "‚âãÃ∏",
                napos: "≈â",
                napprox: "‚ââ",
                natur: "‚ôÆ",
                natural: "‚ôÆ",
                naturals: "‚Ñï",
                nbsp: "¬†",
                nbump: "‚âéÃ∏",
                nbumpe: "‚âèÃ∏",
                ncap: "‚©É",
                Ncaron: "≈á",
                ncaron: "≈à",
                Ncedil: "≈Ö",
                ncedil: "≈Ü",
                ncong: "‚âá",
                ncongdot: "‚©≠Ã∏",
                ncup: "‚©Ç",
                Ncy: "–ù",
                ncy: "–Ω",
                ndash: "‚Äì",
                ne: "‚â†",
                nearhk: "‚§§",
                neArr: "‚áó",
                nearr: "‚Üó",
                nearrow: "‚Üó",
                nedot: "‚âêÃ∏",
                NegativeMediumSpace: "‚Äã",
                NegativeThickSpace: "‚Äã",
                NegativeThinSpace: "‚Äã",
                NegativeVeryThinSpace: "‚Äã",
                nequiv: "‚â¢",
                nesear: "‚§®",
                nesim: "‚âÇÃ∏",
                NestedGreaterGreater: "‚â´",
                NestedLessLess: "‚â™",
                NewLine: "\n",
                nexist: "‚àÑ",
                nexists: "‚àÑ",
                Nfr: "ùîë",
                nfr: "ùî´",
                ngE: "‚âßÃ∏",
                nge: "‚â±",
                ngeq: "‚â±",
                ngeqq: "‚âßÃ∏",
                ngeqslant: "‚©æÃ∏",
                nges: "‚©æÃ∏",
                nGg: "‚ãôÃ∏",
                ngsim: "‚âµ",
                nGt: "‚â´‚Éí",
                ngt: "‚âØ",
                ngtr: "‚âØ",
                nGtv: "‚â´Ã∏",
                nhArr: "‚áé",
                nharr: "‚ÜÆ",
                nhpar: "‚´≤",
                ni: "‚àã",
                nis: "‚ãº",
                nisd: "‚ã∫",
                niv: "‚àã",
                NJcy: "–ä",
                njcy: "—ö",
                nlArr: "‚áç",
                nlarr: "‚Üö",
                nldr: "‚Ä•",
                nlE: "‚â¶Ã∏",
                nle: "‚â∞",
                nLeftarrow: "‚áç",
                nleftarrow: "‚Üö",
                nLeftrightarrow: "‚áé",
                nleftrightarrow: "‚ÜÆ",
                nleq: "‚â∞",
                nleqq: "‚â¶Ã∏",
                nleqslant: "‚©ΩÃ∏",
                nles: "‚©ΩÃ∏",
                nless: "‚âÆ",
                nLl: "‚ãòÃ∏",
                nlsim: "‚â¥",
                nLt: "‚â™‚Éí",
                nlt: "‚âÆ",
                nltri: "‚ã™",
                nltrie: "‚ã¨",
                nLtv: "‚â™Ã∏",
                nmid: "‚à§",
                NoBreak: "‚Å†",
                NonBreakingSpace: "¬†",
                Nopf: "‚Ñï",
                nopf: "ùïü",
                Not: "‚´¨",
                not: "¬¨",
                NotCongruent: "‚â¢",
                NotCupCap: "‚â≠",
                NotDoubleVerticalBar: "‚à¶",
                NotElement: "‚àâ",
                NotEqual: "‚â†",
                NotEqualTilde: "‚âÇÃ∏",
                NotExists: "‚àÑ",
                NotGreater: "‚âØ",
                NotGreaterEqual: "‚â±",
                NotGreaterFullEqual: "‚âßÃ∏",
                NotGreaterGreater: "‚â´Ã∏",
                NotGreaterLess: "‚âπ",
                NotGreaterSlantEqual: "‚©æÃ∏",
                NotGreaterTilde: "‚âµ",
                NotHumpDownHump: "‚âéÃ∏",
                NotHumpEqual: "‚âèÃ∏",
                notin: "‚àâ",
                notindot: "‚ãµÃ∏",
                notinE: "‚ãπÃ∏",
                notinva: "‚àâ",
                notinvb: "‚ã∑",
                notinvc: "‚ã∂",
                NotLeftTriangle: "‚ã™",
                NotLeftTriangleBar: "‚ßèÃ∏",
                NotLeftTriangleEqual: "‚ã¨",
                NotLess: "‚âÆ",
                NotLessEqual: "‚â∞",
                NotLessGreater: "‚â∏",
                NotLessLess: "‚â™Ã∏",
                NotLessSlantEqual: "‚©ΩÃ∏",
                NotLessTilde: "‚â¥",
                NotNestedGreaterGreater: "‚™¢Ã∏",
                NotNestedLessLess: "‚™°Ã∏",
                notni: "‚àå",
                notniva: "‚àå",
                notnivb: "‚ãæ",
                notnivc: "‚ãΩ",
                NotPrecedes: "‚äÄ",
                NotPrecedesEqual: "‚™ØÃ∏",
                NotPrecedesSlantEqual: "‚ã†",
                NotReverseElement: "‚àå",
                NotRightTriangle: "‚ã´",
                NotRightTriangleBar: "‚ßêÃ∏",
                NotRightTriangleEqual: "‚ã≠",
                NotSquareSubset: "‚äèÃ∏",
                NotSquareSubsetEqual: "‚ã¢",
                NotSquareSuperset: "‚äêÃ∏",
                NotSquareSupersetEqual: "‚ã£",
                NotSubset: "‚äÇ‚Éí",
                NotSubsetEqual: "‚äà",
                NotSucceeds: "‚äÅ",
                NotSucceedsEqual: "‚™∞Ã∏",
                NotSucceedsSlantEqual: "‚ã°",
                NotSucceedsTilde: "‚âøÃ∏",
                NotSuperset: "‚äÉ‚Éí",
                NotSupersetEqual: "‚äâ",
                NotTilde: "‚âÅ",
                NotTildeEqual: "‚âÑ",
                NotTildeFullEqual: "‚âá",
                NotTildeTilde: "‚ââ",
                NotVerticalBar: "‚à§",
                npar: "‚à¶",
                nparallel: "‚à¶",
                nparsl: "‚´Ω‚É•",
                npart: "‚àÇÃ∏",
                npolint: "‚®î",
                npr: "‚äÄ",
                nprcue: "‚ã†",
                npre: "‚™ØÃ∏",
                nprec: "‚äÄ",
                npreceq: "‚™ØÃ∏",
                nrArr: "‚áè",
                nrarr: "‚Üõ",
                nrarrc: "‚§≥Ã∏",
                nrarrw: "‚ÜùÃ∏",
                nRightarrow: "‚áè",
                nrightarrow: "‚Üõ",
                nrtri: "‚ã´",
                nrtrie: "‚ã≠",
                nsc: "‚äÅ",
                nsccue: "‚ã°",
                nsce: "‚™∞Ã∏",
                Nscr: "ùí©",
                nscr: "ùìÉ",
                nshortmid: "‚à§",
                nshortparallel: "‚à¶",
                nsim: "‚âÅ",
                nsime: "‚âÑ",
                nsimeq: "‚âÑ",
                nsmid: "‚à§",
                nspar: "‚à¶",
                nsqsube: "‚ã¢",
                nsqsupe: "‚ã£",
                nsub: "‚äÑ",
                nsubE: "‚´ÖÃ∏",
                nsube: "‚äà",
                nsubset: "‚äÇ‚Éí",
                nsubseteq: "‚äà",
                nsubseteqq: "‚´ÖÃ∏",
                nsucc: "‚äÅ",
                nsucceq: "‚™∞Ã∏",
                nsup: "‚äÖ",
                nsupE: "‚´ÜÃ∏",
                nsupe: "‚äâ",
                nsupset: "‚äÉ‚Éí",
                nsupseteq: "‚äâ",
                nsupseteqq: "‚´ÜÃ∏",
                ntgl: "‚âπ",
                Ntilde: "√ë",
                ntilde: "√±",
                ntlg: "‚â∏",
                ntriangleleft: "‚ã™",
                ntrianglelefteq: "‚ã¨",
                ntriangleright: "‚ã´",
                ntrianglerighteq: "‚ã≠",
                Nu: "Œù",
                nu: "ŒΩ",
                num: "#",
                numero: "‚Ññ",
                numsp: "‚Äá",
                nvap: "‚âç‚Éí",
                nVDash: "‚äØ",
                nVdash: "‚äÆ",
                nvDash: "‚ä≠",
                nvdash: "‚ä¨",
                nvge: "‚â•‚Éí",
                nvgt: ">‚Éí",
                nvHarr: "‚§Ñ",
                nvinfin: "‚ßû",
                nvlArr: "‚§Ç",
                nvle: "‚â§‚Éí",
                nvlt: "<‚Éí",
                nvltrie: "‚ä¥‚Éí",
                nvrArr: "‚§É",
                nvrtrie: "‚äµ‚Éí",
                nvsim: "‚àº‚Éí",
                nwarhk: "‚§£",
                nwArr: "‚áñ",
                nwarr: "‚Üñ",
                nwarrow: "‚Üñ",
                nwnear: "‚§ß",
                Oacute: "√ì",
                oacute: "√≥",
                oast: "‚äõ",
                ocir: "‚äö",
                Ocirc: "√î",
                ocirc: "√¥",
                Ocy: "–û",
                ocy: "–æ",
                odash: "‚äù",
                Odblac: "≈ê",
                odblac: "≈ë",
                odiv: "‚®∏",
                odot: "‚äô",
                odsold: "‚¶º",
                OElig: "≈í",
                oelig: "≈ì",
                ofcir: "‚¶ø",
                Ofr: "ùîí",
                ofr: "ùî¨",
                ogon: "Àõ",
                Ograve: "√í",
                ograve: "√≤",
                ogt: "‚ßÅ",
                ohbar: "‚¶µ",
                ohm: "Œ©",
                oint: "‚àÆ",
                olarr: "‚Ü∫",
                olcir: "‚¶æ",
                olcross: "‚¶ª",
                oline: "‚Äæ",
                olt: "‚ßÄ",
                Omacr: "≈å",
                omacr: "≈ç",
                Omega: "Œ©",
                omega: "œâ",
                Omicron: "Œü",
                omicron: "Œø",
                omid: "‚¶∂",
                ominus: "‚äñ",
                Oopf: "ùïÜ",
                oopf: "ùï†",
                opar: "‚¶∑",
                OpenCurlyDoubleQuote: "‚Äú",
                OpenCurlyQuote: "‚Äò",
                operp: "‚¶π",
                oplus: "‚äï",
                Or: "‚©î",
                or: "‚à®",
                orarr: "‚Üª",
                ord: "‚©ù",
                order: "‚Ñ¥",
                orderof: "‚Ñ¥",
                ordf: "¬™",
                ordm: "¬∫",
                origof: "‚ä∂",
                oror: "‚©ñ",
                orslope: "‚©ó",
                orv: "‚©õ",
                oS: "‚ìà",
                Oscr: "ùí™",
                oscr: "‚Ñ¥",
                Oslash: "√ò",
                oslash: "√∏",
                osol: "‚äò",
                Otilde: "√ï",
                otilde: "√µ",
                Otimes: "‚®∑",
                otimes: "‚äó",
                otimesas: "‚®∂",
                Ouml: "√ñ",
                ouml: "√∂",
                ovbar: "‚åΩ",
                OverBar: "‚Äæ",
                OverBrace: "‚èû",
                OverBracket: "‚é¥",
                OverParenthesis: "‚èú",
                par: "‚à•",
                para: "¬∂",
                parallel: "‚à•",
                parsim: "‚´≥",
                parsl: "‚´Ω",
                part: "‚àÇ",
                PartialD: "‚àÇ",
                Pcy: "–ü",
                pcy: "–ø",
                percnt: "%",
                period: ".",
                permil: "‚Ä∞",
                perp: "‚ä•",
                pertenk: "‚Ä±",
                Pfr: "ùîì",
                pfr: "ùî≠",
                Phi: "Œ¶",
                phi: "œÜ",
                phiv: "œï",
                phmmat: "‚Ñ≥",
                phone: "‚òé",
                Pi: "Œ†",
                pi: "œÄ",
                pitchfork: "‚ãî",
                piv: "œñ",
                planck: "‚Ñè",
                planckh: "‚Ñé",
                plankv: "‚Ñè",
                plus: "+",
                plusacir: "‚®£",
                plusb: "‚äû",
                pluscir: "‚®¢",
                plusdo: "‚àî",
                plusdu: "‚®•",
                pluse: "‚©≤",
                PlusMinus: "¬±",
                plusmn: "¬±",
                plussim: "‚®¶",
                plustwo: "‚®ß",
                pm: "¬±",
                Poincareplane: "‚Ñå",
                pointint: "‚®ï",
                Popf: "‚Ñô",
                popf: "ùï°",
                pound: "¬£",
                Pr: "‚™ª",
                pr: "‚â∫",
                prap: "‚™∑",
                prcue: "‚âº",
                prE: "‚™≥",
                pre: "‚™Ø",
                prec: "‚â∫",
                precapprox: "‚™∑",
                preccurlyeq: "‚âº",
                Precedes: "‚â∫",
                PrecedesEqual: "‚™Ø",
                PrecedesSlantEqual: "‚âº",
                PrecedesTilde: "‚âæ",
                preceq: "‚™Ø",
                precnapprox: "‚™π",
                precneqq: "‚™µ",
                precnsim: "‚ã®",
                precsim: "‚âæ",
                Prime: "‚Ä≥",
                prime: "‚Ä≤",
                primes: "‚Ñô",
                prnap: "‚™π",
                prnE: "‚™µ",
                prnsim: "‚ã®",
                prod: "‚àè",
                Product: "‚àè",
                profalar: "‚åÆ",
                profline: "‚åí",
                profsurf: "‚åì",
                prop: "‚àù",
                Proportion: "‚à∑",
                Proportional: "‚àù",
                propto: "‚àù",
                prsim: "‚âæ",
                prurel: "‚ä∞",
                Pscr: "ùí´",
                pscr: "ùìÖ",
                Psi: "Œ®",
                psi: "œà",
                puncsp: "‚Äà",
                Qfr: "ùîî",
                qfr: "ùîÆ",
                qint: "‚®å",
                Qopf: "‚Ñö",
                qopf: "ùï¢",
                qprime: "‚Åó",
                Qscr: "ùí¨",
                qscr: "ùìÜ",
                quaternions: "‚Ñç",
                quatint: "‚®ñ",
                quest: "?",
                questeq: "‚âü",
                QUOT: '"',
                quot: '"',
                rAarr: "‚áõ",
                race: "‚àΩÃ±",
                Racute: "≈î",
                racute: "≈ï",
                radic: "‚àö",
                raemptyv: "‚¶≥",
                Rang: "‚ü´",
                rang: "‚ü©",
                rangd: "‚¶í",
                range: "‚¶•",
                rangle: "‚ü©",
                raquo: "¬ª",
                Rarr: "‚Ü†",
                rArr: "‚áí",
                rarr: "‚Üí",
                rarrap: "‚•µ",
                rarrb: "‚á•",
                rarrbfs: "‚§†",
                rarrc: "‚§≥",
                rarrfs: "‚§û",
                rarrhk: "‚Ü™",
                rarrlp: "‚Ü¨",
                rarrpl: "‚•Ö",
                rarrsim: "‚•¥",
                Rarrtl: "‚§ñ",
                rarrtl: "‚Ü£",
                rarrw: "‚Üù",
                rAtail: "‚§ú",
                ratail: "‚§ö",
                ratio: "‚à∂",
                rationals: "‚Ñö",
                RBarr: "‚§ê",
                rBarr: "‚§è",
                rbarr: "‚§ç",
                rbbrk: "‚ù≥",
                rbrace: "}",
                rbrack: "]",
                rbrke: "‚¶å",
                rbrksld: "‚¶é",
                rbrkslu: "‚¶ê",
                Rcaron: "≈ò",
                rcaron: "≈ô",
                Rcedil: "≈ñ",
                rcedil: "≈ó",
                rceil: "‚åâ",
                rcub: "}",
                Rcy: "–†",
                rcy: "—Ä",
                rdca: "‚§∑",
                rdldhar: "‚•©",
                rdquo: "‚Äù",
                rdquor: "‚Äù",
                rdsh: "‚Ü≥",
                Re: "‚Ñú",
                real: "‚Ñú",
                realine: "‚Ñõ",
                realpart: "‚Ñú",
                reals: "‚Ñù",
                rect: "‚ñ≠",
                REG: "¬Æ",
                reg: "¬Æ",
                ReverseElement: "‚àã",
                ReverseEquilibrium: "‚áã",
                ReverseUpEquilibrium: "‚•Ø",
                rfisht: "‚•Ω",
                rfloor: "‚åã",
                Rfr: "‚Ñú",
                rfr: "ùîØ",
                rHar: "‚•§",
                rhard: "‚áÅ",
                rharu: "‚áÄ",
                rharul: "‚•¨",
                Rho: "Œ°",
                rho: "œÅ",
                rhov: "œ±",
                RightAngleBracket: "‚ü©",
                RightArrow: "‚Üí",
                Rightarrow: "‚áí",
                rightarrow: "‚Üí",
                RightArrowBar: "‚á•",
                RightArrowLeftArrow: "‚áÑ",
                rightarrowtail: "‚Ü£",
                RightCeiling: "‚åâ",
                RightDoubleBracket: "‚üß",
                RightDownTeeVector: "‚•ù",
                RightDownVector: "‚áÇ",
                RightDownVectorBar: "‚•ï",
                RightFloor: "‚åã",
                rightharpoondown: "‚áÅ",
                rightharpoonup: "‚áÄ",
                rightleftarrows: "‚áÑ",
                rightleftharpoons: "‚áå",
                rightrightarrows: "‚áâ",
                rightsquigarrow: "‚Üù",
                RightTee: "‚ä¢",
                RightTeeArrow: "‚Ü¶",
                RightTeeVector: "‚•õ",
                rightthreetimes: "‚ãå",
                RightTriangle: "‚ä≥",
                RightTriangleBar: "‚ßê",
                RightTriangleEqual: "‚äµ",
                RightUpDownVector: "‚•è",
                RightUpTeeVector: "‚•ú",
                RightUpVector: "‚Üæ",
                RightUpVectorBar: "‚•î",
                RightVector: "‚áÄ",
                RightVectorBar: "‚•ì",
                ring: "Àö",
                risingdotseq: "‚âì",
                rlarr: "‚áÑ",
                rlhar: "‚áå",
                rlm: "‚Äè",
                rmoust: "‚é±",
                rmoustache: "‚é±",
                rnmid: "‚´Æ",
                roang: "‚ü≠",
                roarr: "‚áæ",
                robrk: "‚üß",
                ropar: "‚¶Ü",
                Ropf: "‚Ñù",
                ropf: "ùï£",
                roplus: "‚®Æ",
                rotimes: "‚®µ",
                RoundImplies: "‚•∞",
                rpar: ")",
                rpargt: "‚¶î",
                rppolint: "‚®í",
                rrarr: "‚áâ",
                Rrightarrow: "‚áõ",
                rsaquo: "‚Ä∫",
                Rscr: "‚Ñõ",
                rscr: "ùìá",
                Rsh: "‚Ü±",
                rsh: "‚Ü±",
                rsqb: "]",
                rsquo: "‚Äô",
                rsquor: "‚Äô",
                rthree: "‚ãå",
                rtimes: "‚ãä",
                rtri: "‚ñπ",
                rtrie: "‚äµ",
                rtrif: "‚ñ∏",
                rtriltri: "‚ßé",
                RuleDelayed: "‚ß¥",
                ruluhar: "‚•®",
                rx: "‚Ñû",
                Sacute: "≈ö",
                sacute: "≈õ",
                sbquo: "‚Äö",
                Sc: "‚™º",
                sc: "‚âª",
                scap: "‚™∏",
                Scaron: "≈†",
                scaron: "≈°",
                sccue: "‚âΩ",
                scE: "‚™¥",
                sce: "‚™∞",
                Scedil: "≈û",
                scedil: "≈ü",
                Scirc: "≈ú",
                scirc: "≈ù",
                scnap: "‚™∫",
                scnE: "‚™∂",
                scnsim: "‚ã©",
                scpolint: "‚®ì",
                scsim: "‚âø",
                Scy: "–°",
                scy: "—Å",
                sdot: "‚ãÖ",
                sdotb: "‚ä°",
                sdote: "‚©¶",
                searhk: "‚§•",
                seArr: "‚áò",
                searr: "‚Üò",
                searrow: "‚Üò",
                sect: "¬ß",
                semi: ";",
                seswar: "‚§©",
                setminus: "‚àñ",
                setmn: "‚àñ",
                sext: "‚ú∂",
                Sfr: "ùîñ",
                sfr: "ùî∞",
                sfrown: "‚å¢",
                sharp: "‚ôØ",
                SHCHcy: "–©",
                shchcy: "—â",
                SHcy: "–®",
                shcy: "—à",
                ShortDownArrow: "‚Üì",
                ShortLeftArrow: "‚Üê",
                shortmid: "‚à£",
                shortparallel: "‚à•",
                ShortRightArrow: "‚Üí",
                ShortUpArrow: "‚Üë",
                shy: "¬≠",
                Sigma: "Œ£",
                sigma: "œÉ",
                sigmaf: "œÇ",
                sigmav: "œÇ",
                sim: "‚àº",
                simdot: "‚©™",
                sime: "‚âÉ",
                simeq: "‚âÉ",
                simg: "‚™û",
                simgE: "‚™†",
                siml: "‚™ù",
                simlE: "‚™ü",
                simne: "‚âÜ",
                simplus: "‚®§",
                simrarr: "‚•≤",
                slarr: "‚Üê",
                SmallCircle: "‚àò",
                smallsetminus: "‚àñ",
                smashp: "‚®≥",
                smeparsl: "‚ß§",
                smid: "‚à£",
                smile: "‚å£",
                smt: "‚™™",
                smte: "‚™¨",
                smtes: "‚™¨Ô∏Ä",
                SOFTcy: "–¨",
                softcy: "—å",
                sol: "/",
                solb: "‚ßÑ",
                solbar: "‚åø",
                Sopf: "ùïä",
                sopf: "ùï§",
                spades: "‚ô†",
                spadesuit: "‚ô†",
                spar: "‚à•",
                sqcap: "‚äì",
                sqcaps: "‚äìÔ∏Ä",
                sqcup: "‚äî",
                sqcups: "‚äîÔ∏Ä",
                Sqrt: "‚àö",
                sqsub: "‚äè",
                sqsube: "‚äë",
                sqsubset: "‚äè",
                sqsubseteq: "‚äë",
                sqsup: "‚äê",
                sqsupe: "‚äí",
                sqsupset: "‚äê",
                sqsupseteq: "‚äí",
                squ: "‚ñ°",
                Square: "‚ñ°",
                square: "‚ñ°",
                SquareIntersection: "‚äì",
                SquareSubset: "‚äè",
                SquareSubsetEqual: "‚äë",
                SquareSuperset: "‚äê",
                SquareSupersetEqual: "‚äí",
                SquareUnion: "‚äî",
                squarf: "‚ñ™",
                squf: "‚ñ™",
                srarr: "‚Üí",
                Sscr: "ùíÆ",
                sscr: "ùìà",
                ssetmn: "‚àñ",
                ssmile: "‚å£",
                sstarf: "‚ãÜ",
                Star: "‚ãÜ",
                star: "‚òÜ",
                starf: "‚òÖ",
                straightepsilon: "œµ",
                straightphi: "œï",
                strns: "¬Ø",
                Sub: "‚ãê",
                sub: "‚äÇ",
                subdot: "‚™Ω",
                subE: "‚´Ö",
                sube: "‚äÜ",
                subedot: "‚´É",
                submult: "‚´Å",
                subnE: "‚´ã",
                subne: "‚ää",
                subplus: "‚™ø",
                subrarr: "‚•π",
                Subset: "‚ãê",
                subset: "‚äÇ",
                subseteq: "‚äÜ",
                subseteqq: "‚´Ö",
                SubsetEqual: "‚äÜ",
                subsetneq: "‚ää",
                subsetneqq: "‚´ã",
                subsim: "‚´á",
                subsub: "‚´ï",
                subsup: "‚´ì",
                succ: "‚âª",
                succapprox: "‚™∏",
                succcurlyeq: "‚âΩ",
                Succeeds: "‚âª",
                SucceedsEqual: "‚™∞",
                SucceedsSlantEqual: "‚âΩ",
                SucceedsTilde: "‚âø",
                succeq: "‚™∞",
                succnapprox: "‚™∫",
                succneqq: "‚™∂",
                succnsim: "‚ã©",
                succsim: "‚âø",
                SuchThat: "‚àã",
                Sum: "‚àë",
                sum: "‚àë",
                sung: "‚ô™",
                Sup: "‚ãë",
                sup: "‚äÉ",
                sup1: "¬π",
                sup2: "¬≤",
                sup3: "¬≥",
                supdot: "‚™æ",
                supdsub: "‚´ò",
                supE: "‚´Ü",
                supe: "‚äá",
                supedot: "‚´Ñ",
                Superset: "‚äÉ",
                SupersetEqual: "‚äá",
                suphsol: "‚üâ",
                suphsub: "‚´ó",
                suplarr: "‚•ª",
                supmult: "‚´Ç",
                supnE: "‚´å",
                supne: "‚äã",
                supplus: "‚´Ä",
                Supset: "‚ãë",
                supset: "‚äÉ",
                supseteq: "‚äá",
                supseteqq: "‚´Ü",
                supsetneq: "‚äã",
                supsetneqq: "‚´å",
                supsim: "‚´à",
                supsub: "‚´î",
                supsup: "‚´ñ",
                swarhk: "‚§¶",
                swArr: "‚áô",
                swarr: "‚Üô",
                swarrow: "‚Üô",
                swnwar: "‚§™",
                szlig: "√ü",
                Tab: "\t",
                target: "‚åñ",
                Tau: "Œ§",
                tau: "œÑ",
                tbrk: "‚é¥",
                Tcaron: "≈§",
                tcaron: "≈•",
                Tcedil: "≈¢",
                tcedil: "≈£",
                Tcy: "–¢",
                tcy: "—Ç",
                tdot: "‚Éõ",
                telrec: "‚åï",
                Tfr: "ùîó",
                tfr: "ùî±",
                there4: "‚à¥",
                Therefore: "‚à¥",
                therefore: "‚à¥",
                Theta: "Œò",
                theta: "Œ∏",
                thetasym: "œë",
                thetav: "œë",
                thickapprox: "‚âà",
                thicksim: "‚àº",
                ThickSpace: "‚Åü‚Ää",
                thinsp: "‚Äâ",
                ThinSpace: "‚Äâ",
                thkap: "‚âà",
                thksim: "‚àº",
                THORN: "√û",
                thorn: "√æ",
                Tilde: "‚àº",
                tilde: "Àú",
                TildeEqual: "‚âÉ",
                TildeFullEqual: "‚âÖ",
                TildeTilde: "‚âà",
                times: "√ó",
                timesb: "‚ä†",
                timesbar: "‚®±",
                timesd: "‚®∞",
                tint: "‚à≠",
                toea: "‚§®",
                top: "‚ä§",
                topbot: "‚å∂",
                topcir: "‚´±",
                Topf: "ùïã",
                topf: "ùï•",
                topfork: "‚´ö",
                tosa: "‚§©",
                tprime: "‚Ä¥",
                TRADE: "‚Ñ¢",
                trade: "‚Ñ¢",
                triangle: "‚ñµ",
                triangledown: "‚ñø",
                triangleleft: "‚óÉ",
                trianglelefteq: "‚ä¥",
                triangleq: "‚âú",
                triangleright: "‚ñπ",
                trianglerighteq: "‚äµ",
                tridot: "‚ó¨",
                trie: "‚âú",
                triminus: "‚®∫",
                TripleDot: "‚Éõ",
                triplus: "‚®π",
                trisb: "‚ßç",
                tritime: "‚®ª",
                trpezium: "‚è¢",
                Tscr: "ùíØ",
                tscr: "ùìâ",
                TScy: "–¶",
                tscy: "—Ü",
                TSHcy: "–ã",
                tshcy: "—õ",
                Tstrok: "≈¶",
                tstrok: "≈ß",
                twixt: "‚â¨",
                twoheadleftarrow: "‚Üû",
                twoheadrightarrow: "‚Ü†",
                Uacute: "√ö",
                uacute: "√∫",
                Uarr: "‚Üü",
                uArr: "‚áë",
                uarr: "‚Üë",
                Uarrocir: "‚•â",
                Ubrcy: "–é",
                ubrcy: "—û",
                Ubreve: "≈¨",
                ubreve: "≈≠",
                Ucirc: "√õ",
                ucirc: "√ª",
                Ucy: "–£",
                ucy: "—É",
                udarr: "‚áÖ",
                Udblac: "≈∞",
                udblac: "≈±",
                udhar: "‚•Æ",
                ufisht: "‚•æ",
                Ufr: "ùîò",
                ufr: "ùî≤",
                Ugrave: "√ô",
                ugrave: "√π",
                uHar: "‚•£",
                uharl: "‚Üø",
                uharr: "‚Üæ",
                uhblk: "‚ñÄ",
                ulcorn: "‚åú",
                ulcorner: "‚åú",
                ulcrop: "‚åè",
                ultri: "‚ó∏",
                Umacr: "≈™",
                umacr: "≈´",
                uml: "¬®",
                UnderBar: "_",
                UnderBrace: "‚èü",
                UnderBracket: "‚éµ",
                UnderParenthesis: "‚èù",
                Union: "‚ãÉ",
                UnionPlus: "‚äé",
                Uogon: "≈≤",
                uogon: "≈≥",
                Uopf: "ùïå",
                uopf: "ùï¶",
                UpArrow: "‚Üë",
                Uparrow: "‚áë",
                uparrow: "‚Üë",
                UpArrowBar: "‚§í",
                UpArrowDownArrow: "‚áÖ",
                UpDownArrow: "‚Üï",
                Updownarrow: "‚áï",
                updownarrow: "‚Üï",
                UpEquilibrium: "‚•Æ",
                upharpoonleft: "‚Üø",
                upharpoonright: "‚Üæ",
                uplus: "‚äé",
                UpperLeftArrow: "‚Üñ",
                UpperRightArrow: "‚Üó",
                Upsi: "œí",
                upsi: "œÖ",
                upsih: "œí",
                Upsilon: "Œ•",
                upsilon: "œÖ",
                UpTee: "‚ä•",
                UpTeeArrow: "‚Ü•",
                upuparrows: "‚áà",
                urcorn: "‚åù",
                urcorner: "‚åù",
                urcrop: "‚åé",
                Uring: "≈Æ",
                uring: "≈Ø",
                urtri: "‚óπ",
                Uscr: "ùí∞",
                uscr: "ùìä",
                utdot: "‚ã∞",
                Utilde: "≈®",
                utilde: "≈©",
                utri: "‚ñµ",
                utrif: "‚ñ¥",
                uuarr: "‚áà",
                Uuml: "√ú",
                uuml: "√º",
                uwangle: "‚¶ß",
                vangrt: "‚¶ú",
                varepsilon: "œµ",
                varkappa: "œ∞",
                varnothing: "‚àÖ",
                varphi: "œï",
                varpi: "œñ",
                varpropto: "‚àù",
                vArr: "‚áï",
                varr: "‚Üï",
                varrho: "œ±",
                varsigma: "œÇ",
                varsubsetneq: "‚ääÔ∏Ä",
                varsubsetneqq: "‚´ãÔ∏Ä",
                varsupsetneq: "‚äãÔ∏Ä",
                varsupsetneqq: "‚´åÔ∏Ä",
                vartheta: "œë",
                vartriangleleft: "‚ä≤",
                vartriangleright: "‚ä≥",
                Vbar: "‚´´",
                vBar: "‚´®",
                vBarv: "‚´©",
                Vcy: "–í",
                vcy: "–≤",
                VDash: "‚ä´",
                Vdash: "‚ä©",
                vDash: "‚ä®",
                vdash: "‚ä¢",
                Vdashl: "‚´¶",
                Vee: "‚ãÅ",
                vee: "‚à®",
                veebar: "‚äª",
                veeeq: "‚âö",
                vellip: "‚ãÆ",
                Verbar: "‚Äñ",
                verbar: "|",
                Vert: "‚Äñ",
                vert: "|",
                VerticalBar: "‚à£",
                VerticalLine: "|",
                VerticalSeparator: "‚ùò",
                VerticalTilde: "‚âÄ",
                VeryThinSpace: "‚Ää",
                Vfr: "ùîô",
                vfr: "ùî≥",
                vltri: "‚ä≤",
                vnsub: "‚äÇ‚Éí",
                vnsup: "‚äÉ‚Éí",
                Vopf: "ùïç",
                vopf: "ùïß",
                vprop: "‚àù",
                vrtri: "‚ä≥",
                Vscr: "ùí±",
                vscr: "ùìã",
                vsubnE: "‚´ãÔ∏Ä",
                vsubne: "‚ääÔ∏Ä",
                vsupnE: "‚´åÔ∏Ä",
                vsupne: "‚äãÔ∏Ä",
                Vvdash: "‚ä™",
                vzigzag: "‚¶ö",
                Wcirc: "≈¥",
                wcirc: "≈µ",
                wedbar: "‚©ü",
                Wedge: "‚ãÄ",
                wedge: "‚àß",
                wedgeq: "‚âô",
                weierp: "‚Ñò",
                Wfr: "ùîö",
                wfr: "ùî¥",
                Wopf: "ùïé",
                wopf: "ùï®",
                wp: "‚Ñò",
                wr: "‚âÄ",
                wreath: "‚âÄ",
                Wscr: "ùí≤",
                wscr: "ùìå",
                xcap: "‚ãÇ",
                xcirc: "‚óØ",
                xcup: "‚ãÉ",
                xdtri: "‚ñΩ",
                Xfr: "ùîõ",
                xfr: "ùîµ",
                xhArr: "‚ü∫",
                xharr: "‚ü∑",
                Xi: "Œû",
                xi: "Œæ",
                xlArr: "‚ü∏",
                xlarr: "‚üµ",
                xmap: "‚üº",
                xnis: "‚ãª",
                xodot: "‚®Ä",
                Xopf: "ùïè",
                xopf: "ùï©",
                xoplus: "‚®Å",
                xotime: "‚®Ç",
                xrArr: "‚üπ",
                xrarr: "‚ü∂",
                Xscr: "ùí≥",
                xscr: "ùìç",
                xsqcup: "‚®Ü",
                xuplus: "‚®Ñ",
                xutri: "‚ñ≥",
                xvee: "‚ãÅ",
                xwedge: "‚ãÄ",
                Yacute: "√ù",
                yacute: "√Ω",
                YAcy: "–Ø",
                yacy: "—è",
                Ycirc: "≈∂",
                ycirc: "≈∑",
                Ycy: "–´",
                ycy: "—ã",
                yen: "¬•",
                Yfr: "ùîú",
                yfr: "ùî∂",
                YIcy: "–á",
                yicy: "—ó",
                Yopf: "ùïê",
                yopf: "ùï™",
                Yscr: "ùí¥",
                yscr: "ùìé",
                YUcy: "–Æ",
                yucy: "—é",
                Yuml: "≈∏",
                yuml: "√ø",
                Zacute: "≈π",
                zacute: "≈∫",
                Zcaron: "≈Ω",
                zcaron: "≈æ",
                Zcy: "–ó",
                zcy: "–∑",
                Zdot: "≈ª",
                zdot: "≈º",
                zeetrf: "‚Ñ®",
                ZeroWidthSpace: "‚Äã",
                Zeta: "Œñ",
                zeta: "Œ∂",
                Zfr: "‚Ñ®",
                zfr: "ùî∑",
                ZHcy: "–ñ",
                zhcy: "–∂",
                zigrarr: "‚áù",
                Zopf: "‚Ñ§",
                zopf: "ùï´",
                Zscr: "ùíµ",
                zscr: "ùìè",
                zwj: "‚Äç",
                zwnj: "‚Äå"
            });
            exports.entityMap = exports.HTML_ENTITIES;
        },
        978: (__unused_webpack_module, exports, __webpack_require__) => {
            var dom = __webpack_require__(722);
            dom.DOMImplementation;
            dom.XMLSerializer;
            exports.DOMParser = __webpack_require__(752).DOMParser;
        },
        466: (__unused_webpack_module, exports, __webpack_require__) => {
            var NAMESPACE = __webpack_require__(582).NAMESPACE;
            var nameStartChar = /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
            var nameChar = new RegExp("[\\-\\.0-9" + nameStartChar.source.slice(1, -1) + "\\u00B7\\u0300-\\u036F\\u203F-\\u2040]");
            var tagNamePattern = new RegExp("^" + nameStartChar.source + nameChar.source + "*(?::" + nameStartChar.source + nameChar.source + "*)?$");
            var S_TAG = 0;
            var S_ATTR = 1;
            var S_ATTR_SPACE = 2;
            var S_EQ = 3;
            var S_ATTR_NOQUOT_VALUE = 4;
            var S_ATTR_END = 5;
            var S_TAG_SPACE = 6;
            var S_TAG_CLOSE = 7;
            function ParseError(message, locator) {
                this.message = message;
                this.locator = locator;
                if (Error.captureStackTrace) Error.captureStackTrace(this, ParseError);
            }
            ParseError.prototype = new Error;
            ParseError.prototype.name = ParseError.name;
            function XMLReader() {}
            XMLReader.prototype = {
                parse: function(source, defaultNSMap, entityMap) {
                    var domBuilder = this.domBuilder;
                    domBuilder.startDocument();
                    _copy(defaultNSMap, defaultNSMap = {});
                    parse(source, defaultNSMap, entityMap, domBuilder, this.errorHandler);
                    domBuilder.endDocument();
                }
            };
            function parse(source, defaultNSMapCopy, entityMap, domBuilder, errorHandler) {
                function fixedFromCharCode(code) {
                    if (code > 65535) {
                        code -= 65536;
                        var surrogate1 = 55296 + (code >> 10), surrogate2 = 56320 + (code & 1023);
                        return String.fromCharCode(surrogate1, surrogate2);
                    } else return String.fromCharCode(code);
                }
                function entityReplacer(a) {
                    var k = a.slice(1, -1);
                    if (Object.hasOwnProperty.call(entityMap, k)) return entityMap[k]; else if (k.charAt(0) === "#") return fixedFromCharCode(parseInt(k.substr(1).replace("x", "0x"))); else {
                        errorHandler.error("entity not found:" + a);
                        return a;
                    }
                }
                function appendText(end) {
                    if (end > start) {
                        var xt = source.substring(start, end).replace(/&#?\w+;/g, entityReplacer);
                        locator && position(start);
                        domBuilder.characters(xt, 0, end - start);
                        start = end;
                    }
                }
                function position(p, m) {
                    while (p >= lineEnd && (m = linePattern.exec(source))) {
                        lineStart = m.index;
                        lineEnd = lineStart + m[0].length;
                        locator.lineNumber++;
                    }
                    locator.columnNumber = p - lineStart + 1;
                }
                var lineStart = 0;
                var lineEnd = 0;
                var linePattern = /.*(?:\r\n?|\n)|.*$/g;
                var locator = domBuilder.locator;
                var parseStack = [ {
                    currentNSMap: defaultNSMapCopy
                } ];
                var closeMap = {};
                var start = 0;
                while (true) {
                    try {
                        var tagStart = source.indexOf("<", start);
                        if (tagStart < 0) {
                            if (!source.substr(start).match(/^\s*$/)) {
                                var doc = domBuilder.doc;
                                var text = doc.createTextNode(source.substr(start));
                                doc.appendChild(text);
                                domBuilder.currentElement = text;
                            }
                            return;
                        }
                        if (tagStart > start) appendText(tagStart);
                        switch (source.charAt(tagStart + 1)) {
                          case "/":
                            var end = source.indexOf(">", tagStart + 3);
                            var tagName = source.substring(tagStart + 2, end).replace(/[ \t\n\r]+$/g, "");
                            var config = parseStack.pop();
                            if (end < 0) {
                                tagName = source.substring(tagStart + 2).replace(/[\s<].*/, "");
                                errorHandler.error("end tag name: " + tagName + " is not complete:" + config.tagName);
                                end = tagStart + 1 + tagName.length;
                            } else if (tagName.match(/\s</)) {
                                tagName = tagName.replace(/[\s<].*/, "");
                                errorHandler.error("end tag name: " + tagName + " maybe not complete");
                                end = tagStart + 1 + tagName.length;
                            }
                            var localNSMap = config.localNSMap;
                            var endMatch = config.tagName == tagName;
                            var endIgnoreCaseMach = endMatch || config.tagName && config.tagName.toLowerCase() == tagName.toLowerCase();
                            if (endIgnoreCaseMach) {
                                domBuilder.endElement(config.uri, config.localName, tagName);
                                if (localNSMap) for (var prefix in localNSMap) if (Object.prototype.hasOwnProperty.call(localNSMap, prefix)) domBuilder.endPrefixMapping(prefix);
                                if (!endMatch) errorHandler.fatalError("end tag name: " + tagName + " is not match the current start tagName:" + config.tagName);
                            } else parseStack.push(config);
                            end++;
                            break;

                          case "?":
                            locator && position(tagStart);
                            end = parseInstruction(source, tagStart, domBuilder);
                            break;

                          case "!":
                            locator && position(tagStart);
                            end = parseDCC(source, tagStart, domBuilder, errorHandler);
                            break;

                          default:
                            locator && position(tagStart);
                            var el = new ElementAttributes;
                            var currentNSMap = parseStack[parseStack.length - 1].currentNSMap;
                            end = parseElementStartPart(source, tagStart, el, currentNSMap, entityReplacer, errorHandler);
                            var len = el.length;
                            if (!el.closed && fixSelfClosed(source, end, el.tagName, closeMap)) {
                                el.closed = true;
                                if (!entityMap.nbsp) errorHandler.warning("unclosed xml attribute");
                            }
                            if (locator && len) {
                                var locator2 = copyLocator(locator, {});
                                for (var i = 0; i < len; i++) {
                                    var a = el[i];
                                    position(a.offset);
                                    a.locator = copyLocator(locator, {});
                                }
                                domBuilder.locator = locator2;
                                if (appendElement(el, domBuilder, currentNSMap)) parseStack.push(el);
                                domBuilder.locator = locator;
                            } else if (appendElement(el, domBuilder, currentNSMap)) parseStack.push(el);
                            if (NAMESPACE.isHTML(el.uri) && !el.closed) end = parseHtmlSpecialContent(source, end, el.tagName, entityReplacer, domBuilder); else end++;
                        }
                    } catch (e) {
                        if (e instanceof ParseError) throw e;
                        errorHandler.error("element parse error: " + e);
                        end = -1;
                    }
                    if (end > start) start = end; else appendText(Math.max(tagStart, start) + 1);
                }
            }
            function copyLocator(f, t) {
                t.lineNumber = f.lineNumber;
                t.columnNumber = f.columnNumber;
                return t;
            }
            function parseElementStartPart(source, start, el, currentNSMap, entityReplacer, errorHandler) {
                function addAttribute(qname, value, startIndex) {
                    if (el.attributeNames.hasOwnProperty(qname)) errorHandler.fatalError("Attribute " + qname + " redefined");
                    el.addValue(qname, value.replace(/[\t\n\r]/g, " ").replace(/&#?\w+;/g, entityReplacer), startIndex);
                }
                var attrName;
                var p = ++start;
                var s = S_TAG;
                while (true) {
                    var c = source.charAt(p);
                    switch (c) {
                      case "=":
                        if (s === S_ATTR) {
                            attrName = source.slice(start, p);
                            s = S_EQ;
                        } else if (s === S_ATTR_SPACE) s = S_EQ; else throw new Error("attribute equal must after attrName");
                        break;

                      case "'":
                      case '"':
                        if (s === S_EQ || s === S_ATTR) {
                            if (s === S_ATTR) {
                                errorHandler.warning('attribute value must after "="');
                                attrName = source.slice(start, p);
                            }
                            start = p + 1;
                            p = source.indexOf(c, start);
                            if (p > 0) {
                                value = source.slice(start, p);
                                addAttribute(attrName, value, start - 1);
                                s = S_ATTR_END;
                            } else throw new Error("attribute value no end '" + c + "' match");
                        } else if (s == S_ATTR_NOQUOT_VALUE) {
                            value = source.slice(start, p);
                            addAttribute(attrName, value, start);
                            errorHandler.warning('attribute "' + attrName + '" missed start quot(' + c + ")!!");
                            start = p + 1;
                            s = S_ATTR_END;
                        } else throw new Error('attribute value must after "="');
                        break;

                      case "/":
                        switch (s) {
                          case S_TAG:
                            el.setTagName(source.slice(start, p));

                          case S_ATTR_END:
                          case S_TAG_SPACE:
                          case S_TAG_CLOSE:
                            s = S_TAG_CLOSE;
                            el.closed = true;

                          case S_ATTR_NOQUOT_VALUE:
                          case S_ATTR:
                            break;

                          case S_ATTR_SPACE:
                            el.closed = true;
                            break;

                          default:
                            throw new Error("attribute invalid close char('/')");
                        }
                        break;

                      case "":
                        errorHandler.error("unexpected end of input");
                        if (s == S_TAG) el.setTagName(source.slice(start, p));
                        return p;

                      case ">":
                        switch (s) {
                          case S_TAG:
                            el.setTagName(source.slice(start, p));

                          case S_ATTR_END:
                          case S_TAG_SPACE:
                          case S_TAG_CLOSE:
                            break;

                          case S_ATTR_NOQUOT_VALUE:
                          case S_ATTR:
                            value = source.slice(start, p);
                            if (value.slice(-1) === "/") {
                                el.closed = true;
                                value = value.slice(0, -1);
                            }

                          case S_ATTR_SPACE:
                            if (s === S_ATTR_SPACE) value = attrName;
                            if (s == S_ATTR_NOQUOT_VALUE) {
                                errorHandler.warning('attribute "' + value + '" missed quot(")!');
                                addAttribute(attrName, value, start);
                            } else {
                                if (!NAMESPACE.isHTML(currentNSMap[""]) || !value.match(/^(?:disabled|checked|selected)$/i)) errorHandler.warning('attribute "' + value + '" missed value!! "' + value + '" instead!!');
                                addAttribute(value, value, start);
                            }
                            break;

                          case S_EQ:
                            throw new Error("attribute value missed!!");
                        }
                        return p;

                      case "¬Ä":
                        c = " ";

                      default:
                        if (c <= " ") switch (s) {
                          case S_TAG:
                            el.setTagName(source.slice(start, p));
                            s = S_TAG_SPACE;
                            break;

                          case S_ATTR:
                            attrName = source.slice(start, p);
                            s = S_ATTR_SPACE;
                            break;

                          case S_ATTR_NOQUOT_VALUE:
                            var value = source.slice(start, p);
                            errorHandler.warning('attribute "' + value + '" missed quot(")!!');
                            addAttribute(attrName, value, start);

                          case S_ATTR_END:
                            s = S_TAG_SPACE;
                            break;
                        } else switch (s) {
                          case S_ATTR_SPACE:
                            el.tagName;
                            if (!NAMESPACE.isHTML(currentNSMap[""]) || !attrName.match(/^(?:disabled|checked|selected)$/i)) errorHandler.warning('attribute "' + attrName + '" missed value!! "' + attrName + '" instead2!!');
                            addAttribute(attrName, attrName, start);
                            start = p;
                            s = S_ATTR;
                            break;

                          case S_ATTR_END:
                            errorHandler.warning('attribute space is required"' + attrName + '"!!');

                          case S_TAG_SPACE:
                            s = S_ATTR;
                            start = p;
                            break;

                          case S_EQ:
                            s = S_ATTR_NOQUOT_VALUE;
                            start = p;
                            break;

                          case S_TAG_CLOSE:
                            throw new Error("elements closed character '/' and '>' must be connected to");
                        }
                    }
                    p++;
                }
            }
            function appendElement(el, domBuilder, currentNSMap) {
                var tagName = el.tagName;
                var localNSMap = null;
                var i = el.length;
                while (i--) {
                    var a = el[i];
                    var qName = a.qName;
                    var value = a.value;
                    var nsp = qName.indexOf(":");
                    if (nsp > 0) {
                        var prefix = a.prefix = qName.slice(0, nsp);
                        var localName = qName.slice(nsp + 1);
                        var nsPrefix = prefix === "xmlns" && localName;
                    } else {
                        localName = qName;
                        prefix = null;
                        nsPrefix = qName === "xmlns" && "";
                    }
                    a.localName = localName;
                    if (nsPrefix !== false) {
                        if (localNSMap == null) {
                            localNSMap = {};
                            _copy(currentNSMap, currentNSMap = {});
                        }
                        currentNSMap[nsPrefix] = localNSMap[nsPrefix] = value;
                        a.uri = NAMESPACE.XMLNS;
                        domBuilder.startPrefixMapping(nsPrefix, value);
                    }
                }
                i = el.length;
                while (i--) {
                    a = el[i];
                    prefix = a.prefix;
                    if (prefix) {
                        if (prefix === "xml") a.uri = NAMESPACE.XML;
                        if (prefix !== "xmlns") a.uri = currentNSMap[prefix || ""];
                    }
                }
                nsp = tagName.indexOf(":");
                if (nsp > 0) {
                    prefix = el.prefix = tagName.slice(0, nsp);
                    localName = el.localName = tagName.slice(nsp + 1);
                } else {
                    prefix = null;
                    localName = el.localName = tagName;
                }
                var ns = el.uri = currentNSMap[prefix || ""];
                domBuilder.startElement(ns, localName, tagName, el);
                if (el.closed) {
                    domBuilder.endElement(ns, localName, tagName);
                    if (localNSMap) for (prefix in localNSMap) if (Object.prototype.hasOwnProperty.call(localNSMap, prefix)) domBuilder.endPrefixMapping(prefix);
                } else {
                    el.currentNSMap = currentNSMap;
                    el.localNSMap = localNSMap;
                    return true;
                }
            }
            function parseHtmlSpecialContent(source, elStartEnd, tagName, entityReplacer, domBuilder) {
                if (/^(?:script|textarea)$/i.test(tagName)) {
                    var elEndStart = source.indexOf("</" + tagName + ">", elStartEnd);
                    var text = source.substring(elStartEnd + 1, elEndStart);
                    if (/[&<]/.test(text)) {
                        if (/^script$/i.test(tagName)) {
                            domBuilder.characters(text, 0, text.length);
                            return elEndStart;
                        }
                        text = text.replace(/&#?\w+;/g, entityReplacer);
                        domBuilder.characters(text, 0, text.length);
                        return elEndStart;
                    }
                }
                return elStartEnd + 1;
            }
            function fixSelfClosed(source, elStartEnd, tagName, closeMap) {
                var pos = closeMap[tagName];
                if (pos == null) {
                    pos = source.lastIndexOf("</" + tagName + ">");
                    if (pos < elStartEnd) pos = source.lastIndexOf("</" + tagName);
                    closeMap[tagName] = pos;
                }
                return pos < elStartEnd;
            }
            function _copy(source, target) {
                for (var n in source) if (Object.prototype.hasOwnProperty.call(source, n)) target[n] = source[n];
            }
            function parseDCC(source, start, domBuilder, errorHandler) {
                var next = source.charAt(start + 2);
                switch (next) {
                  case "-":
                    if (source.charAt(start + 3) === "-") {
                        var end = source.indexOf("--\x3e", start + 4);
                        if (end > start) {
                            domBuilder.comment(source, start + 4, end - start - 4);
                            return end + 3;
                        } else {
                            errorHandler.error("Unclosed comment");
                            return -1;
                        }
                    } else return -1;

                  default:
                    if (source.substr(start + 3, 6) == "CDATA[") {
                        end = source.indexOf("]]>", start + 9);
                        domBuilder.startCDATA();
                        domBuilder.characters(source, start + 9, end - start - 9);
                        domBuilder.endCDATA();
                        return end + 3;
                    }
                    var matchs = split(source, start);
                    var len = matchs.length;
                    if (len > 1 && /!doctype/i.test(matchs[0][0])) {
                        var name = matchs[1][0];
                        var pubid = false;
                        var sysid = false;
                        if (len > 3) if (/^public$/i.test(matchs[2][0])) {
                            pubid = matchs[3][0];
                            sysid = len > 4 && matchs[4][0];
                        } else if (/^system$/i.test(matchs[2][0])) sysid = matchs[3][0];
                        var lastMatch = matchs[len - 1];
                        domBuilder.startDTD(name, pubid, sysid);
                        domBuilder.endDTD();
                        return lastMatch.index + lastMatch[0].length;
                    }
                }
                return -1;
            }
            function parseInstruction(source, start, domBuilder) {
                var end = source.indexOf("?>", start);
                if (end) {
                    var match = source.substring(start, end).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);
                    if (match) {
                        match[0].length;
                        domBuilder.processingInstruction(match[1], match[2]);
                        return end + 2;
                    } else return -1;
                }
                return -1;
            }
            function ElementAttributes() {
                this.attributeNames = {};
            }
            ElementAttributes.prototype = {
                setTagName: function(tagName) {
                    if (!tagNamePattern.test(tagName)) throw new Error("invalid tagName:" + tagName);
                    this.tagName = tagName;
                },
                addValue: function(qName, value, offset) {
                    if (!tagNamePattern.test(qName)) throw new Error("invalid attribute:" + qName);
                    this.attributeNames[qName] = this.length;
                    this[this.length++] = {
                        qName,
                        value,
                        offset
                    };
                },
                length: 0,
                getLocalName: function(i) {
                    return this[i].localName;
                },
                getLocator: function(i) {
                    return this[i].locator;
                },
                getQName: function(i) {
                    return this[i].qName;
                },
                getURI: function(i) {
                    return this[i].uri;
                },
                getValue: function(i) {
                    return this[i].value;
                }
            };
            function split(source, start) {
                var match;
                var buf = [];
                var reg = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;
                reg.lastIndex = start;
                reg.exec(source);
                while (match = reg.exec(source)) {
                    buf.push(match);
                    if (match[1]) return buf;
                }
            }
            exports.XMLReader = XMLReader;
            exports.ParseError = ParseError;
        },
        697: (module, __unused_webpack_exports, __webpack_require__) => {
            var topLevel = typeof __webpack_require__.g !== "undefined" ? __webpack_require__.g : typeof window !== "undefined" ? window : {};
            var minDoc = __webpack_require__(542);
            var doccy;
            if (typeof document !== "undefined") doccy = document; else {
                doccy = topLevel["__GLOBAL_DOCUMENT_CACHE@4"];
                if (!doccy) doccy = topLevel["__GLOBAL_DOCUMENT_CACHE@4"] = minDoc;
            }
            module.exports = doccy;
        },
        840: (module, __unused_webpack_exports, __webpack_require__) => {
            var win;
            if (typeof window !== "undefined") win = window; else if (typeof __webpack_require__.g !== "undefined") win = __webpack_require__.g; else if (typeof self !== "undefined") win = self; else win = {};
            module.exports = win;
        },
        56: module => {
            module.exports = isFunction;
            var toString = Object.prototype.toString;
            function isFunction(fn) {
                if (!fn) return false;
                var string = toString.call(fn);
                return string === "[object Function]" || typeof fn === "function" && string !== "[object RegExp]" || typeof window !== "undefined" && (fn === window.setTimeout || fn === window.alert || fn === window.confirm || fn === window.prompt);
            }
        },
        757: function(module) {
            /**
 * lightgallery | 2.8.2 | November 28th 2024
 * http://www.lightgalleryjs.com/
 * Copyright (c) 2020 Sachin Neravath;
 * @license GPLv3
 */
            !function(t, e) {
                true ? module.exports = e() : 0;
            }(0, (function() {
                "use strict";
                var t = function() {
                    return (t = Object.assign || function(t) {
                        for (var e, i = 1, s = arguments.length; i < s; i++) for (var h in e = arguments[i]) Object.prototype.hasOwnProperty.call(e, h) && (t[h] = e[h]);
                        return t;
                    }).apply(this, arguments);
                }, e = {
                    thumbnail: !0,
                    animateThumb: !0,
                    currentPagerPosition: "middle",
                    alignThumbnails: "middle",
                    thumbWidth: 100,
                    thumbHeight: "80px",
                    thumbMargin: 5,
                    appendThumbnailsTo: ".lg-components",
                    toggleThumb: !1,
                    enableThumbDrag: !0,
                    enableThumbSwipe: !0,
                    thumbnailSwipeThreshold: 10,
                    loadYouTubeThumbnail: !0,
                    youTubeThumbSize: 1,
                    thumbnailPluginStrings: {
                        toggleThumbnails: "Toggle thumbnails"
                    }
                }, i = "lgContainerResize", s = "lgUpdateSlides", h = "lgBeforeOpen", n = "lgBeforeSlide";
                return function() {
                    function o(t, e) {
                        return this.thumbOuterWidth = 0, this.thumbTotalWidth = 0, this.translateX = 0, 
                        this.thumbClickable = !1, this.core = t, this.$LG = e, this;
                    }
                    return o.prototype.init = function() {
                        this.settings = t(t({}, e), this.core.settings), this.thumbOuterWidth = 0, this.thumbTotalWidth = this.core.galleryItems.length * (this.settings.thumbWidth + this.settings.thumbMargin), 
                        this.translateX = 0, this.setAnimateThumbStyles(), this.core.settings.allowMediaOverlap || (this.settings.toggleThumb = !1), 
                        this.settings.thumbnail && (this.build(), this.settings.animateThumb ? (this.settings.enableThumbDrag && this.enableThumbDrag(), 
                        this.settings.enableThumbSwipe && this.enableThumbSwipe(), this.thumbClickable = !1) : this.thumbClickable = !0, 
                        this.toggleThumbBar(), this.thumbKeyPress());
                    }, o.prototype.build = function() {
                        var t = this;
                        this.setThumbMarkup(), this.manageActiveClassOnSlideChange(), this.$lgThumb.first().on("click.lg touchend.lg", (function(e) {
                            var i = t.$LG(e.target);
                            i.hasAttribute("data-lg-item-id") && setTimeout((function() {
                                if (t.thumbClickable && !t.core.lgBusy) {
                                    var e = parseInt(i.attr("data-lg-item-id"));
                                    t.core.slide(e, !1, !0, !1);
                                }
                            }), 50);
                        })), this.core.LGel.on(n + ".thumb", (function(e) {
                            var i = e.detail.index;
                            t.animateThumb(i);
                        })), this.core.LGel.on(h + ".thumb", (function() {
                            t.thumbOuterWidth = t.core.outer.get().offsetWidth;
                        })), this.core.LGel.on(s + ".thumb", (function() {
                            t.rebuildThumbnails();
                        })), this.core.LGel.on(i + ".thumb", (function() {
                            t.core.lgOpened && setTimeout((function() {
                                t.thumbOuterWidth = t.core.outer.get().offsetWidth, t.animateThumb(t.core.index), 
                                t.thumbOuterWidth = t.core.outer.get().offsetWidth;
                            }), 50);
                        }));
                    }, o.prototype.setThumbMarkup = function() {
                        var t = "lg-thumb-outer ";
                        this.settings.alignThumbnails && (t += "lg-thumb-align-" + this.settings.alignThumbnails);
                        var e = '<div class="' + t + '">\n        <div class="lg-thumb lg-group">\n        </div>\n        </div>';
                        this.core.outer.addClass("lg-has-thumb"), ".lg-components" === this.settings.appendThumbnailsTo ? this.core.$lgComponents.append(e) : this.core.outer.append(e), 
                        this.$thumbOuter = this.core.outer.find(".lg-thumb-outer").first(), this.$lgThumb = this.core.outer.find(".lg-thumb").first(), 
                        this.settings.animateThumb && this.core.outer.find(".lg-thumb").css("transition-duration", this.core.settings.speed + "ms").css("width", this.thumbTotalWidth + "px").css("position", "relative"), 
                        this.setThumbItemHtml(this.core.galleryItems);
                    }, o.prototype.enableThumbDrag = function() {
                        var t = this, e = {
                            cords: {
                                startX: 0,
                                endX: 0
                            },
                            isMoved: !1,
                            newTranslateX: 0,
                            startTime: new Date,
                            endTime: new Date,
                            touchMoveTime: 0
                        }, i = !1;
                        this.$thumbOuter.addClass("lg-grab"), this.core.outer.find(".lg-thumb").first().on("mousedown.lg.thumb", (function(s) {
                            t.thumbTotalWidth > t.thumbOuterWidth && (s.preventDefault(), e.cords.startX = s.pageX, 
                            e.startTime = new Date, t.thumbClickable = !1, i = !0, t.core.outer.get().scrollLeft += 1, 
                            t.core.outer.get().scrollLeft -= 1, t.$thumbOuter.removeClass("lg-grab").addClass("lg-grabbing"));
                        })), this.$LG(window).on("mousemove.lg.thumb.global" + this.core.lgId, (function(s) {
                            t.core.lgOpened && i && (e.cords.endX = s.pageX, e = t.onThumbTouchMove(e));
                        })), this.$LG(window).on("mouseup.lg.thumb.global" + this.core.lgId, (function() {
                            t.core.lgOpened && (e.isMoved ? e = t.onThumbTouchEnd(e) : t.thumbClickable = !0, 
                            i && (i = !1, t.$thumbOuter.removeClass("lg-grabbing").addClass("lg-grab")));
                        }));
                    }, o.prototype.enableThumbSwipe = function() {
                        var t = this, e = {
                            cords: {
                                startX: 0,
                                endX: 0
                            },
                            isMoved: !1,
                            newTranslateX: 0,
                            startTime: new Date,
                            endTime: new Date,
                            touchMoveTime: 0
                        };
                        this.$lgThumb.on("touchstart.lg", (function(i) {
                            t.thumbTotalWidth > t.thumbOuterWidth && (i.preventDefault(), e.cords.startX = i.targetTouches[0].pageX, 
                            t.thumbClickable = !1, e.startTime = new Date);
                        })), this.$lgThumb.on("touchmove.lg", (function(i) {
                            t.thumbTotalWidth > t.thumbOuterWidth && (i.preventDefault(), e.cords.endX = i.targetTouches[0].pageX, 
                            e = t.onThumbTouchMove(e));
                        })), this.$lgThumb.on("touchend.lg", (function() {
                            e.isMoved ? e = t.onThumbTouchEnd(e) : t.thumbClickable = !0;
                        }));
                    }, o.prototype.rebuildThumbnails = function() {
                        var t = this;
                        this.$thumbOuter.addClass("lg-rebuilding-thumbnails"), setTimeout((function() {
                            t.thumbTotalWidth = t.core.galleryItems.length * (t.settings.thumbWidth + t.settings.thumbMargin), 
                            t.$lgThumb.css("width", t.thumbTotalWidth + "px"), t.$lgThumb.empty(), t.setThumbItemHtml(t.core.galleryItems), 
                            t.animateThumb(t.core.index);
                        }), 50), setTimeout((function() {
                            t.$thumbOuter.removeClass("lg-rebuilding-thumbnails");
                        }), 200);
                    }, o.prototype.setTranslate = function(t) {
                        this.$lgThumb.css("transform", "translate3d(-" + t + "px, 0px, 0px)");
                    }, o.prototype.getPossibleTransformX = function(t) {
                        return t > this.thumbTotalWidth - this.thumbOuterWidth && (t = this.thumbTotalWidth - this.thumbOuterWidth), 
                        t < 0 && (t = 0), t;
                    }, o.prototype.animateThumb = function(t) {
                        if (this.$lgThumb.css("transition-duration", this.core.settings.speed + "ms"), this.settings.animateThumb) {
                            var e = 0;
                            switch (this.settings.currentPagerPosition) {
                              case "left":
                                e = 0;
                                break;

                              case "middle":
                                e = this.thumbOuterWidth / 2 - this.settings.thumbWidth / 2;
                                break;

                              case "right":
                                e = this.thumbOuterWidth - this.settings.thumbWidth;
                            }
                            this.translateX = (this.settings.thumbWidth + this.settings.thumbMargin) * t - 1 - e, 
                            this.translateX > this.thumbTotalWidth - this.thumbOuterWidth && (this.translateX = this.thumbTotalWidth - this.thumbOuterWidth), 
                            this.translateX < 0 && (this.translateX = 0), this.setTranslate(this.translateX);
                        }
                    }, o.prototype.onThumbTouchMove = function(t) {
                        return t.newTranslateX = this.translateX, t.isMoved = !0, t.touchMoveTime = (new Date).valueOf(), 
                        t.newTranslateX -= t.cords.endX - t.cords.startX, t.newTranslateX = this.getPossibleTransformX(t.newTranslateX), 
                        this.setTranslate(t.newTranslateX), this.$thumbOuter.addClass("lg-dragging"), t;
                    }, o.prototype.onThumbTouchEnd = function(t) {
                        t.isMoved = !1, t.endTime = new Date, this.$thumbOuter.removeClass("lg-dragging");
                        var e = t.endTime.valueOf() - t.startTime.valueOf(), i = t.cords.endX - t.cords.startX, s = Math.abs(i) / e;
                        return s > .15 && t.endTime.valueOf() - t.touchMoveTime < 30 ? ((s += 1) > 2 && (s += 1), 
                        s += s * (Math.abs(i) / this.thumbOuterWidth), this.$lgThumb.css("transition-duration", Math.min(s - 1, 2) + "settings"), 
                        i *= s, this.translateX = this.getPossibleTransformX(this.translateX - i), this.setTranslate(this.translateX)) : this.translateX = t.newTranslateX, 
                        Math.abs(t.cords.endX - t.cords.startX) < this.settings.thumbnailSwipeThreshold && (this.thumbClickable = !0), 
                        t;
                    }, o.prototype.getThumbHtml = function(t, e, i) {
                        var s, h = this.core.galleryItems[e].__slideVideoInfo || {};
                        s = h.youtube && this.settings.loadYouTubeThumbnail ? "//img.youtube.com/vi/" + h.youtube[1] + "/" + this.settings.youTubeThumbSize + ".jpg" : t;
                        var n = document.createElement("div");
                        n.setAttribute("data-lg-item-id", e + ""), n.className = "lg-thumb-item " + (e === this.core.index ? "active" : ""), 
                        n.style.cssText = "width: " + this.settings.thumbWidth + "px; height: " + this.settings.thumbHeight + "; margin-right: " + this.settings.thumbMargin + "px;";
                        var o = document.createElement("img");
                        return o.alt = i || "", o.setAttribute("data-lg-item-id", e + ""), o.src = s, n.appendChild(o), 
                        n;
                    }, o.prototype.setThumbItemHtml = function(t) {
                        for (var e = 0; e < t.length; e++) {
                            var i = this.getThumbHtml(t[e].thumb, e, t[e].alt);
                            this.$lgThumb.append(i);
                        }
                    }, o.prototype.setAnimateThumbStyles = function() {
                        this.settings.animateThumb && this.core.outer.addClass("lg-animate-thumb");
                    }, o.prototype.manageActiveClassOnSlideChange = function() {
                        var t = this;
                        this.core.LGel.on(n + ".thumb", (function(e) {
                            var i = t.core.outer.find(".lg-thumb-item"), s = e.detail.index;
                            i.removeClass("active"), i.eq(s).addClass("active");
                        }));
                    }, o.prototype.toggleThumbBar = function() {
                        var t = this;
                        this.settings.toggleThumb && (this.core.outer.addClass("lg-can-toggle"), this.core.$toolbar.append('<button type="button" aria-label="' + this.settings.thumbnailPluginStrings.toggleThumbnails + '" class="lg-toggle-thumb lg-icon"></button>'), 
                        this.core.outer.find(".lg-toggle-thumb").first().on("click.lg", (function() {
                            t.core.outer.toggleClass("lg-components-open");
                        })));
                    }, o.prototype.thumbKeyPress = function() {
                        var t = this;
                        this.$LG(window).on("keydown.lg.thumb.global" + this.core.lgId, (function(e) {
                            t.core.lgOpened && t.settings.toggleThumb && (38 === e.keyCode ? (e.preventDefault(), 
                            t.core.outer.addClass("lg-components-open")) : 40 === e.keyCode && (e.preventDefault(), 
                            t.core.outer.removeClass("lg-components-open")));
                        }));
                    }, o.prototype.destroy = function() {
                        this.settings.thumbnail && (this.$LG(window).off(".lg.thumb.global" + this.core.lgId), 
                        this.core.LGel.off(".lg.thumb"), this.core.LGel.off(".thumb"), this.$thumbOuter.remove(), 
                        this.core.outer.removeClass("lg-has-thumb"));
                    }, o;
                }();
            }));
        },
        43: function(module) {
            /**
 * lightgallery | 2.8.2 | November 28th 2024
 * http://www.lightgalleryjs.com/
 * Copyright (c) 2020 Sachin Neravath;
 * @license GPLv3
 */
            !function(e, o) {
                true ? module.exports = o() : 0;
            }(0, (function() {
                "use strict";
                var e = function() {
                    return (e = Object.assign || function(e) {
                        for (var o, i = 1, t = arguments.length; i < t; i++) for (var s in o = arguments[i]) Object.prototype.hasOwnProperty.call(o, s) && (e[s] = o[s]);
                        return e;
                    }).apply(this, arguments);
                }, o = {
                    autoplayFirstVideo: !0,
                    youTubePlayerParams: !1,
                    vimeoPlayerParams: !1,
                    wistiaPlayerParams: !1,
                    gotoNextSlideOnVideoEnd: !0,
                    autoplayVideoOnSlide: !1,
                    videojs: !1,
                    videojsTheme: "",
                    videojsOptions: {}
                }, i = "lgHasVideo", t = "lgSlideItemLoad", s = "lgBeforeSlide", n = "lgAfterSlide", l = "lgPosterClick", r = function(e) {
                    return Object.keys(e).map((function(o) {
                        return encodeURIComponent(o) + "=" + encodeURIComponent(e[o]);
                    })).join("&");
                }, d = function(o, i) {
                    if (!o.youtube) return "";
                    var t = o.youtube[2] ? o.youtube[2].slice(1).split("&").map((function(e) {
                        return e.split("=");
                    })).reduce((function(e, o) {
                        var i = o.map(decodeURIComponent), t = i[0], s = i[1];
                        return e[t] = s, e;
                    }), {}) : "", s = i || {}, n = e(e(e({}, {
                        wmode: "opaque",
                        autoplay: 0,
                        mute: 1,
                        enablejsapi: 1
                    }), s), t);
                    return "?" + r(n);
                };
                return function() {
                    function a(i) {
                        return this.core = i, this.settings = e(e({}, o), this.core.settings), this;
                    }
                    return a.prototype.init = function() {
                        var e = this;
                        this.core.LGel.on(i + ".video", this.onHasVideo.bind(this)), this.core.LGel.on(l + ".video", (function() {
                            var o = e.core.getSlideItem(e.core.index);
                            e.loadVideoOnPosterClick(o);
                        })), this.core.LGel.on(t + ".video", this.onSlideItemLoad.bind(this)), this.core.LGel.on(s + ".video", this.onBeforeSlide.bind(this)), 
                        this.core.LGel.on(n + ".video", this.onAfterSlide.bind(this));
                    }, a.prototype.onSlideItemLoad = function(e) {
                        var o = this, i = e.detail, t = i.isFirstSlide, s = i.index;
                        this.settings.autoplayFirstVideo && t && s === this.core.index && setTimeout((function() {
                            o.loadAndPlayVideo(s);
                        }), 200), !t && this.settings.autoplayVideoOnSlide && s === this.core.index && this.loadAndPlayVideo(s);
                    }, a.prototype.onHasVideo = function(e) {
                        var o = e.detail, i = o.index, t = o.src, s = o.html5Video;
                        o.hasPoster || (this.appendVideos(this.core.getSlideItem(i), {
                            src: t,
                            addClass: "lg-object",
                            index: i,
                            html5Video: s
                        }), this.gotoNextSlideOnVideoEnd(t, i));
                    }, a.prototype.onBeforeSlide = function(e) {
                        if (this.core.lGalleryOn) {
                            var o = e.detail.prevIndex;
                            this.pauseVideo(o);
                        }
                    }, a.prototype.onAfterSlide = function(e) {
                        var o = this, i = e.detail, t = i.index, s = i.prevIndex, n = this.core.getSlideItem(t);
                        this.settings.autoplayVideoOnSlide && t !== s && n.hasClass("lg-complete") && setTimeout((function() {
                            o.loadAndPlayVideo(t);
                        }), 100);
                    }, a.prototype.loadAndPlayVideo = function(e) {
                        var o = this.core.getSlideItem(e);
                        this.core.galleryItems[e].poster ? this.loadVideoOnPosterClick(o, !0) : this.playVideo(e);
                    }, a.prototype.playVideo = function(e) {
                        this.controlVideo(e, "play");
                    }, a.prototype.pauseVideo = function(e) {
                        this.controlVideo(e, "pause");
                    }, a.prototype.getVideoHtml = function(e, o, i, t) {
                        var s = "", n = this.core.galleryItems[i].__slideVideoInfo || {}, l = this.core.galleryItems[i], a = l.title || l.alt;
                        a = a ? 'title="' + a + '"' : "";
                        var c = 'allowtransparency="true"\n            frameborder="0"\n            scrolling="no"\n            allowfullscreen\n            mozallowfullscreen\n            webkitallowfullscreen\n            oallowfullscreen\n            msallowfullscreen';
                        if (n.youtube) {
                            var u = "lg-youtube" + i, f = d(n, this.settings.youTubePlayerParams);
                            s = '<iframe allow="autoplay" id=' + u + ' class="lg-video-object lg-youtube ' + o + '" ' + a + ' src="' + (e.includes("youtube-nocookie.com") ? "//www.youtube-nocookie.com/" : "//www.youtube.com/") + "embed/" + (n.youtube[1] + f) + '" ' + c + "></iframe>";
                        } else if (n.vimeo) {
                            u = "lg-vimeo" + i;
                            var h = function(e, o) {
                                if (!o || !o.vimeo) return "";
                                var i = o.vimeo[2] || "", t = Object.assign({}, {
                                    autoplay: 0,
                                    muted: 1
                                }, e), s = t && 0 !== Object.keys(t).length ? r(t) : "", n = ((o.vimeo[0].split("/").pop() || "").split("?")[0] || "").split("#")[0], l = o.vimeo[1] !== n;
                                l && (i = i.replace("/" + n, ""));
                                var d = l ? "h=" + n : "";
                                return "?" + d + (s = d ? "&" + s : s) + ("?" == i[0] ? "&" + i.slice(1) : i || "");
                            }(this.settings.vimeoPlayerParams, n);
                            s = '<iframe allow="autoplay" id=' + u + ' class="lg-video-object lg-vimeo ' + o + '" ' + a + ' src="//player.vimeo.com/video/' + (n.vimeo[1] + h) + '" ' + c + "></iframe>";
                        } else if (n.wistia) {
                            var g = "lg-wistia" + i;
                            h = (h = r(this.settings.wistiaPlayerParams)) ? "?" + h : "", s = '<iframe allow="autoplay" id="' + g + '" src="//fast.wistia.net/embed/iframe/' + (n.wistia[4] + h) + '" ' + a + ' class="wistia_embed lg-video-object lg-wistia ' + o + '" name="wistia_embed" ' + c + "></iframe>";
                        } else if (n.html5) {
                            for (var p = "", y = 0; y < t.source.length; y++) {
                                var v = t.source[y].type, m = v ? 'type="' + v + '"' : "";
                                p += '<source src="' + t.source[y].src + '" ' + m + ">";
                            }
                            if (t.tracks) {
                                var w = function(e) {
                                    var o = "", i = t.tracks[e];
                                    Object.keys(i || {}).forEach((function(e) {
                                        o += e + '="' + i[e] + '" ';
                                    })), p += "<track " + o + ">";
                                };
                                for (y = 0; y < t.tracks.length; y++) w(y);
                            }
                            var V = "", b = t.attributes || {};
                            Object.keys(b || {}).forEach((function(e) {
                                V += e + '="' + b[e] + '" ';
                            })), s = '<video class="lg-video-object lg-html5 ' + (this.settings.videojs && this.settings.videojsTheme ? this.settings.videojsTheme + " " : "") + " " + (this.settings.videojs ? " video-js" : "") + '" ' + V + ">\n                " + p + "\n                Your browser does not support HTML5 video.\n            </video>";
                        }
                        return s;
                    }, a.prototype.appendVideos = function(e, o) {
                        var i, t = this.getVideoHtml(o.src, o.addClass, o.index, o.html5Video);
                        e.find(".lg-video-cont").append(t);
                        var s = e.find(".lg-video-object").first();
                        if (o.html5Video && s.on("mousedown.lg.video", (function(e) {
                            e.stopPropagation();
                        })), this.settings.videojs && (null === (i = this.core.galleryItems[o.index].__slideVideoInfo) || void 0 === i ? void 0 : i.html5)) try {
                            return videojs(s.get(), this.settings.videojsOptions);
                        } catch (e) {
                            console.error("lightGallery:- Make sure you have included videojs");
                        }
                    }, a.prototype.gotoNextSlideOnVideoEnd = function(e, o) {
                        var i = this, t = this.core.getSlideItem(o).find(".lg-video-object").first(), s = this.core.galleryItems[o].__slideVideoInfo || {};
                        if (this.settings.gotoNextSlideOnVideoEnd) if (s.html5) t.on("ended", (function() {
                            i.core.goToNextSlide();
                        })); else if (s.vimeo) try {
                            new Vimeo.Player(t.get()).on("ended", (function() {
                                i.core.goToNextSlide();
                            }));
                        } catch (e) {
                            console.error("lightGallery:- Make sure you have included //github.com/vimeo/player.js");
                        } else if (s.wistia) try {
                            window._wq = window._wq || [], window._wq.push({
                                id: t.attr("id"),
                                onReady: function(e) {
                                    e.bind("end", (function() {
                                        i.core.goToNextSlide();
                                    }));
                                }
                            });
                        } catch (e) {
                            console.error("lightGallery:- Make sure you have included //fast.wistia.com/assets/external/E-v1.js");
                        }
                    }, a.prototype.controlVideo = function(e, o) {
                        var i = this.core.getSlideItem(e).find(".lg-video-object").first(), t = this.core.galleryItems[e].__slideVideoInfo || {};
                        if (i.get()) if (t.youtube) try {
                            i.get().contentWindow.postMessage('{"event":"command","func":"' + o + 'Video","args":""}', "*");
                        } catch (e) {
                            console.error("lightGallery:- " + e);
                        } else if (t.vimeo) try {
                            new Vimeo.Player(i.get())[o]();
                        } catch (e) {
                            console.error("lightGallery:- Make sure you have included //github.com/vimeo/player.js");
                        } else if (t.html5) if (this.settings.videojs) try {
                            videojs(i.get())[o]();
                        } catch (e) {
                            console.error("lightGallery:- Make sure you have included videojs");
                        } else i.get()[o](); else if (t.wistia) try {
                            window._wq = window._wq || [], window._wq.push({
                                id: i.attr("id"),
                                onReady: function(e) {
                                    e[o]();
                                }
                            });
                        } catch (e) {
                            console.error("lightGallery:- Make sure you have included //fast.wistia.com/assets/external/E-v1.js");
                        }
                    }, a.prototype.loadVideoOnPosterClick = function(e, o) {
                        var i = this;
                        if (e.hasClass("lg-video-loaded")) o && this.playVideo(this.core.index); else if (e.hasClass("lg-has-video")) this.playVideo(this.core.index); else {
                            e.addClass("lg-has-video");
                            var t = void 0, s = this.core.galleryItems[this.core.index].src, n = this.core.galleryItems[this.core.index].video;
                            n && (t = "string" == typeof n ? JSON.parse(n) : n);
                            var l = this.appendVideos(e, {
                                src: s,
                                addClass: "",
                                index: this.core.index,
                                html5Video: t
                            });
                            this.gotoNextSlideOnVideoEnd(s, this.core.index);
                            var r = e.find(".lg-object").first().get();
                            e.find(".lg-video-cont").first().append(r), e.addClass("lg-video-loading"), l && l.ready((function() {
                                l.on("loadedmetadata", (function() {
                                    i.onVideoLoadAfterPosterClick(e, i.core.index);
                                }));
                            })), e.find(".lg-video-object").first().on("load.lg error.lg loadedmetadata.lg", (function() {
                                setTimeout((function() {
                                    i.onVideoLoadAfterPosterClick(e, i.core.index);
                                }), 50);
                            }));
                        }
                    }, a.prototype.onVideoLoadAfterPosterClick = function(e, o) {
                        e.addClass("lg-video-loaded"), this.playVideo(o);
                    }, a.prototype.destroy = function() {
                        this.core.LGel.off(".lg.video"), this.core.LGel.off(".video");
                    }, a;
                }();
            }));
        },
        227: function(module) {
            /**
 * lightgallery | 2.8.2 | November 28th 2024
 * http://www.lightgalleryjs.com/
 * Copyright (c) 2020 Sachin Neravath;
 * @license GPLv3
 */
            !function(e, t) {
                true ? module.exports = t() : 0;
            }(0, (function() {
                "use strict";
                var e = function() {
                    return (e = Object.assign || function(e) {
                        for (var t, o = 1, i = arguments.length; o < i; o++) for (var s in t = arguments[o]) Object.prototype.hasOwnProperty.call(t, s) && (e[s] = t[s]);
                        return e;
                    }).apply(this, arguments);
                }, t = {
                    scale: 1,
                    zoom: !0,
                    infiniteZoom: !0,
                    actualSize: !0,
                    showZoomInOutIcons: !1,
                    actualSizeIcons: {
                        zoomIn: "lg-zoom-in",
                        zoomOut: "lg-zoom-out"
                    },
                    enableZoomAfter: 300,
                    zoomPluginStrings: {
                        zoomIn: "Zoom in",
                        zoomOut: "Zoom out",
                        viewActualSize: "View actual size"
                    }
                }, o = "lgContainerResize", i = "lgBeforeOpen", s = "lgAfterOpen", a = "lgSlideItemLoad", n = "lgAfterSlide", r = "lgRotateLeft", l = "lgRotateRight", c = "lgFlipHorizontal", g = "lgFlipVertical";
                return function() {
                    function h(o, i) {
                        return this.core = o, this.$LG = i, this.settings = e(e({}, t), this.core.settings), 
                        this;
                    }
                    return h.prototype.buildTemplates = function() {
                        var e = this.settings.showZoomInOutIcons ? '<button id="' + this.core.getIdName("lg-zoom-in") + '" type="button" aria-label="' + this.settings.zoomPluginStrings.zoomIn + '" class="lg-zoom-in lg-icon"></button><button id="' + this.core.getIdName("lg-zoom-out") + '" type="button" aria-label="' + this.settings.zoomPluginStrings.zoomOut + '" class="lg-zoom-out lg-icon"></button>' : "";
                        this.settings.actualSize && (e += '<button id="' + this.core.getIdName("lg-actual-size") + '" type="button" aria-label="' + this.settings.zoomPluginStrings.viewActualSize + '" class="' + this.settings.actualSizeIcons.zoomIn + ' lg-icon"></button>'), 
                        this.core.outer.addClass("lg-use-transition-for-zoom"), this.core.$toolbar.first().append(e);
                    }, h.prototype.enableZoom = function(e) {
                        var t = this, o = this.settings.enableZoomAfter + e.detail.delay;
                        this.$LG("body").first().hasClass("lg-from-hash") && e.detail.delay ? o = 0 : this.$LG("body").first().removeClass("lg-from-hash"), 
                        this.zoomableTimeout = setTimeout((function() {
                            t.isImageSlide(t.core.index) && (t.core.getSlideItem(e.detail.index).addClass("lg-zoomable"), 
                            e.detail.index === t.core.index && t.setZoomEssentials());
                        }), o + 30);
                    }, h.prototype.enableZoomOnSlideItemLoad = function() {
                        this.core.LGel.on(a + ".zoom", this.enableZoom.bind(this));
                    }, h.prototype.getDragCords = function(e) {
                        return {
                            x: e.pageX,
                            y: e.pageY
                        };
                    }, h.prototype.getSwipeCords = function(e) {
                        return {
                            x: e.touches[0].pageX,
                            y: e.touches[0].pageY
                        };
                    }, h.prototype.getDragAllowedAxises = function(e, t) {
                        if (!this.containerRect) return {
                            allowX: !1,
                            allowY: !1
                        };
                        var o = this.core.getSlideItem(this.core.index).find(".lg-image").first().get(), i = 0, s = 0, a = o.getBoundingClientRect();
                        e ? (i = o.offsetHeight * e, s = o.offsetWidth * e) : t ? (i = a.height + t * a.height, 
                        s = a.width + t * a.width) : (i = a.height, s = a.width);
                        var n = i > this.containerRect.height;
                        return {
                            allowX: s > this.containerRect.width,
                            allowY: n
                        };
                    }, h.prototype.setZoomEssentials = function() {
                        this.containerRect = this.core.$content.get().getBoundingClientRect();
                    }, h.prototype.zoomImage = function(e, t, o, i) {
                        if (!(Math.abs(t) <= 0)) {
                            var s, a, n = this.containerRect.width / 2 + this.containerRect.left, r = this.containerRect.height / 2 + this.containerRect.top + this.scrollTop;
                            1 === e && (this.positionChanged = !1);
                            var l = this.getDragAllowedAxises(0, t), c = l.allowY, g = l.allowX;
                            this.positionChanged && (s = this.left / (this.scale - t), a = this.top / (this.scale - t), 
                            this.pageX = n - s, this.pageY = r - a, this.positionChanged = !1);
                            var h, m, u = this.getPossibleSwipeDragCords(t), d = n - this.pageX, f = r - this.pageY;
                            if (e - t > 1) {
                                var p = (e - t) / Math.abs(t);
                                h = (d = (t < 0 ? -d : d) + this.left * (p + (t < 0 ? -1 : 1))) / p, m = (f = (t < 0 ? -f : f) + this.top * (p + (t < 0 ? -1 : 1))) / p;
                            } else h = d * (p = (e - t) * t), m = f * p;
                            o && (g ? this.isBeyondPossibleLeft(h, u.minX) ? h = u.minX : this.isBeyondPossibleRight(h, u.maxX) && (h = u.maxX) : e > 1 && (h < u.minX ? h = u.minX : h > u.maxX && (h = u.maxX)), 
                            c ? this.isBeyondPossibleTop(m, u.minY) ? m = u.minY : this.isBeyondPossibleBottom(m, u.maxY) && (m = u.maxY) : e > 1 && (m < u.minY ? m = u.minY : m > u.maxY && (m = u.maxY))), 
                            this.setZoomStyles({
                                x: h,
                                y: m,
                                scale: e
                            }), this.left = h, this.top = m, i && this.setZoomImageSize();
                        }
                    }, h.prototype.resetImageTranslate = function(e) {
                        if (this.isImageSlide(e)) {
                            var t = this.core.getSlideItem(e).find(".lg-image").first();
                            this.imageReset = !1, t.removeClass("reset-transition reset-transition-y reset-transition-x"), 
                            this.core.outer.removeClass("lg-actual-size"), t.css("width", "auto").css("height", "auto"), 
                            setTimeout((function() {
                                t.removeClass("no-transition");
                            }), 10);
                        }
                    }, h.prototype.setZoomImageSize = function() {
                        var e = this, t = this.core.getSlideItem(this.core.index).find(".lg-image").first();
                        setTimeout((function() {
                            var o = e.getCurrentImageActualSizeScale();
                            e.scale >= o && (t.addClass("no-transition"), e.imageReset = !0);
                        }), 500), setTimeout((function() {
                            var o = e.getCurrentImageActualSizeScale();
                            if (e.scale >= o) {
                                var i = e.getDragAllowedAxises(e.scale);
                                t.css("width", t.get().naturalWidth + "px").css("height", t.get().naturalHeight + "px"), 
                                e.core.outer.addClass("lg-actual-size"), i.allowX && i.allowY ? t.addClass("reset-transition") : i.allowX && !i.allowY ? t.addClass("reset-transition-x") : !i.allowX && i.allowY && t.addClass("reset-transition-y");
                            }
                        }), 550);
                    }, h.prototype.setZoomStyles = function(e) {
                        var t = this.core.getSlideItem(this.core.index).find(".lg-img-wrap").first(), o = this.core.getSlideItem(this.core.index).find(".lg-image").first(), i = this.core.outer.find(".lg-current .lg-dummy-img").first();
                        this.scale = e.scale, o.css("transform", "scale3d(" + e.scale + ", " + e.scale + ", 1)"), 
                        i.css("transform", "scale3d(" + e.scale + ", " + e.scale + ", 1)");
                        var s = "translate3d(" + e.x + "px, " + e.y + "px, 0)";
                        t.css("transform", s);
                    }, h.prototype.setActualSize = function(e, t) {
                        var o = this;
                        if (!this.zoomInProgress) {
                            this.zoomInProgress = !0;
                            var i = this.core.galleryItems[this.core.index];
                            this.resetImageTranslate(e), setTimeout((function() {
                                if (i.src && !o.core.outer.hasClass("lg-first-slide-loading")) {
                                    var e = o.getCurrentImageActualSizeScale(), s = o.scale;
                                    o.core.outer.hasClass("lg-zoomed") ? o.scale = 1 : o.scale = o.getScale(e), o.setPageCords(t), 
                                    o.beginZoom(o.scale), o.zoomImage(o.scale, o.scale - s, !0, !0);
                                }
                            }), 50), setTimeout((function() {
                                o.core.outer.removeClass("lg-grabbing").addClass("lg-grab");
                            }), 60), setTimeout((function() {
                                o.zoomInProgress = !1;
                            }), 610);
                        }
                    }, h.prototype.getNaturalWidth = function(e) {
                        var t = this.core.getSlideItem(e).find(".lg-image").first(), o = this.core.galleryItems[e].width;
                        return o ? parseFloat(o) : t.get().naturalWidth;
                    }, h.prototype.getActualSizeScale = function(e, t) {
                        return e >= t ? e / t || 2 : 1;
                    }, h.prototype.getCurrentImageActualSizeScale = function() {
                        var e = this.core.getSlideItem(this.core.index).find(".lg-image").first().get().offsetWidth, t = this.getNaturalWidth(this.core.index) || e;
                        return this.getActualSizeScale(t, e);
                    }, h.prototype.getPageCords = function(e) {
                        var t = {};
                        if (e) t.x = e.pageX || e.touches[0].pageX, t.y = e.pageY || e.touches[0].pageY; else {
                            var o = this.core.$content.get().getBoundingClientRect();
                            t.x = o.width / 2 + o.left, t.y = o.height / 2 + this.scrollTop + o.top;
                        }
                        return t;
                    }, h.prototype.setPageCords = function(e) {
                        var t = this.getPageCords(e);
                        this.pageX = t.x, this.pageY = t.y;
                    }, h.prototype.manageActualPixelClassNames = function() {
                        this.core.getElementById("lg-actual-size").removeClass(this.settings.actualSizeIcons.zoomIn).addClass(this.settings.actualSizeIcons.zoomOut);
                    }, h.prototype.beginZoom = function(e) {
                        return this.core.outer.removeClass("lg-zoom-drag-transition lg-zoom-dragging"), 
                        e > 1 ? (this.core.outer.addClass("lg-zoomed"), this.manageActualPixelClassNames()) : this.resetZoom(), 
                        e > 1;
                    }, h.prototype.getScale = function(e) {
                        var t = this.getCurrentImageActualSizeScale();
                        return e < 1 ? e = 1 : e > t && (e = t), e;
                    }, h.prototype.init = function() {
                        var e = this;
                        if (this.settings.zoom) {
                            this.buildTemplates(), this.enableZoomOnSlideItemLoad();
                            var t = null;
                            this.core.outer.on("dblclick.lg", (function(t) {
                                e.$LG(t.target).hasClass("lg-image") && e.setActualSize(e.core.index, t);
                            })), this.core.outer.on("touchstart.lg", (function(o) {
                                var i = e.$LG(o.target);
                                1 === o.touches.length && i.hasClass("lg-image") && (t ? (clearTimeout(t), t = null, 
                                o.preventDefault(), e.setActualSize(e.core.index, o)) : t = setTimeout((function() {
                                    t = null;
                                }), 300));
                            })), this.core.LGel.on(o + ".zoom " + l + ".zoom " + r + ".zoom " + c + ".zoom " + g + ".zoom", (function() {
                                if (e.core.lgOpened && e.isImageSlide(e.core.index) && !e.core.touchAction) {
                                    var t = e.core.getSlideItem(e.core.index).find(".lg-img-wrap").first();
                                    e.top = 0, e.left = 0, e.setZoomEssentials(), e.setZoomSwipeStyles(t, {
                                        x: 0,
                                        y: 0
                                    }), e.positionChanged = !0;
                                }
                            })), this.$LG(window).on("scroll.lg.zoom.global" + this.core.lgId, (function() {
                                e.core.lgOpened && (e.scrollTop = e.$LG(window).scrollTop());
                            })), this.core.getElementById("lg-zoom-out").on("click.lg", (function() {
                                if (e.isImageSlide(e.core.index)) {
                                    var t = 0;
                                    e.imageReset && (e.resetImageTranslate(e.core.index), t = 50), setTimeout((function() {
                                        var t = e.scale - e.settings.scale;
                                        t < 1 && (t = 1), e.beginZoom(t), e.zoomImage(t, -e.settings.scale, !0, !e.settings.infiniteZoom);
                                    }), t);
                                }
                            })), this.core.getElementById("lg-zoom-in").on("click.lg", (function() {
                                e.zoomIn();
                            })), this.core.getElementById("lg-actual-size").on("click.lg", (function() {
                                e.setActualSize(e.core.index);
                            })), this.core.LGel.on(i + ".zoom", (function() {
                                e.core.outer.find(".lg-item").removeClass("lg-zoomable");
                            })), this.core.LGel.on(s + ".zoom", (function() {
                                e.scrollTop = e.$LG(window).scrollTop(), e.pageX = e.core.outer.width() / 2, e.pageY = e.core.outer.height() / 2 + e.scrollTop, 
                                e.scale = 1;
                            })), this.core.LGel.on(n + ".zoom", (function(t) {
                                var o = t.detail.prevIndex;
                                e.scale = 1, e.positionChanged = !1, e.zoomInProgress = !1, e.resetZoom(o), e.resetImageTranslate(o), 
                                e.isImageSlide(e.core.index) && e.setZoomEssentials();
                            })), this.zoomDrag(), this.pinchZoom(), this.zoomSwipe(), this.zoomableTimeout = !1, 
                            this.positionChanged = !1, this.zoomInProgress = !1;
                        }
                    }, h.prototype.zoomIn = function() {
                        if (this.isImageSlide(this.core.index)) {
                            var e = this.scale + this.settings.scale;
                            this.settings.infiniteZoom || (e = this.getScale(e)), this.beginZoom(e), this.zoomImage(e, Math.min(this.settings.scale, e - this.scale), !0, !this.settings.infiniteZoom);
                        }
                    }, h.prototype.resetZoom = function(e) {
                        this.core.outer.removeClass("lg-zoomed lg-zoom-drag-transition");
                        var t = this.core.getElementById("lg-actual-size"), o = this.core.getSlideItem(void 0 !== e ? e : this.core.index);
                        t.removeClass(this.settings.actualSizeIcons.zoomOut).addClass(this.settings.actualSizeIcons.zoomIn), 
                        o.find(".lg-img-wrap").first().removeAttr("style"), o.find(".lg-image").first().removeAttr("style"), 
                        this.scale = 1, this.left = 0, this.top = 0, this.setPageCords();
                    }, h.prototype.getTouchDistance = function(e) {
                        return Math.sqrt((e.touches[0].pageX - e.touches[1].pageX) * (e.touches[0].pageX - e.touches[1].pageX) + (e.touches[0].pageY - e.touches[1].pageY) * (e.touches[0].pageY - e.touches[1].pageY));
                    }, h.prototype.pinchZoom = function() {
                        var e = this, t = 0, o = !1, i = 1, s = 0, a = this.core.getSlideItem(this.core.index);
                        this.core.outer.on("touchstart.lg", (function(o) {
                            if (a = e.core.getSlideItem(e.core.index), e.isImageSlide(e.core.index) && 2 === o.touches.length) {
                                if (o.preventDefault(), e.core.outer.hasClass("lg-first-slide-loading")) return;
                                i = e.scale || 1, e.core.outer.removeClass("lg-zoom-drag-transition lg-zoom-dragging"), 
                                e.setPageCords(o), e.resetImageTranslate(e.core.index), e.core.touchAction = "pinch", 
                                t = e.getTouchDistance(o);
                            }
                        })), this.core.$inner.on("touchmove.lg", (function(n) {
                            if (2 === n.touches.length && "pinch" === e.core.touchAction && (e.$LG(n.target).hasClass("lg-item") || a.get().contains(n.target))) {
                                n.preventDefault();
                                var r = e.getTouchDistance(n), l = t - r;
                                if (!o && Math.abs(l) > 5 && (o = !0), o) {
                                    s = e.scale;
                                    var c = Math.max(1, i + .02 * -l);
                                    e.scale = Math.round(100 * (c + Number.EPSILON)) / 100;
                                    var g = e.scale - s;
                                    e.zoomImage(e.scale, Math.round(100 * (g + Number.EPSILON)) / 100, !1, !1);
                                }
                            }
                        })), this.core.$inner.on("touchend.lg", (function(i) {
                            if ("pinch" === e.core.touchAction && (e.$LG(i.target).hasClass("lg-item") || a.get().contains(i.target))) {
                                if (o = !1, t = 0, e.scale <= 1) e.resetZoom(); else {
                                    var s = e.getCurrentImageActualSizeScale();
                                    if (e.scale >= s) {
                                        var n = s - e.scale;
                                        0 === n && (n = .01), e.zoomImage(s, n, !1, !0);
                                    }
                                    e.manageActualPixelClassNames(), e.core.outer.addClass("lg-zoomed");
                                }
                                e.core.touchAction = void 0;
                            }
                        }));
                    }, h.prototype.touchendZoom = function(e, t, o, i, s) {
                        var a = t.x - e.x, n = t.y - e.y, r = Math.abs(a) / s + 1, l = Math.abs(n) / s + 1;
                        r > 2 && (r += 1), l > 2 && (l += 1), a *= r, n *= l;
                        var c = this.core.getSlideItem(this.core.index).find(".lg-img-wrap").first(), g = {};
                        g.x = this.left + a, g.y = this.top + n;
                        var h = this.getPossibleSwipeDragCords();
                        (Math.abs(a) > 15 || Math.abs(n) > 15) && (i && (this.isBeyondPossibleTop(g.y, h.minY) ? g.y = h.minY : this.isBeyondPossibleBottom(g.y, h.maxY) && (g.y = h.maxY)), 
                        o && (this.isBeyondPossibleLeft(g.x, h.minX) ? g.x = h.minX : this.isBeyondPossibleRight(g.x, h.maxX) && (g.x = h.maxX)), 
                        i ? this.top = g.y : g.y = this.top, o ? this.left = g.x : g.x = this.left, this.setZoomSwipeStyles(c, g), 
                        this.positionChanged = !0);
                    }, h.prototype.getZoomSwipeCords = function(e, t, o, i, s) {
                        var a = {};
                        if (i) {
                            if (a.y = this.top + (t.y - e.y), this.isBeyondPossibleTop(a.y, s.minY)) {
                                var n = s.minY - a.y;
                                a.y = s.minY - n / 6;
                            } else if (this.isBeyondPossibleBottom(a.y, s.maxY)) {
                                var r = a.y - s.maxY;
                                a.y = s.maxY + r / 6;
                            }
                        } else a.y = this.top;
                        if (o) {
                            if (a.x = this.left + (t.x - e.x), this.isBeyondPossibleLeft(a.x, s.minX)) {
                                var l = s.minX - a.x;
                                a.x = s.minX - l / 6;
                            } else if (this.isBeyondPossibleRight(a.x, s.maxX)) {
                                var c = a.x - s.maxX;
                                a.x = s.maxX + c / 6;
                            }
                        } else a.x = this.left;
                        return a;
                    }, h.prototype.isBeyondPossibleLeft = function(e, t) {
                        return e >= t;
                    }, h.prototype.isBeyondPossibleRight = function(e, t) {
                        return e <= t;
                    }, h.prototype.isBeyondPossibleTop = function(e, t) {
                        return e >= t;
                    }, h.prototype.isBeyondPossibleBottom = function(e, t) {
                        return e <= t;
                    }, h.prototype.isImageSlide = function(e) {
                        var t = this.core.galleryItems[e];
                        return "image" === this.core.getSlideType(t);
                    }, h.prototype.getPossibleSwipeDragCords = function(e) {
                        var t = this.core.getSlideItem(this.core.index).find(".lg-image").first(), o = this.core.mediaContainerPosition.bottom, i = t.get().getBoundingClientRect(), s = i.height, a = i.width;
                        return e && (s += e * s, a += e * a), {
                            minY: (s - this.containerRect.height) / 2,
                            maxY: (this.containerRect.height - s) / 2 + o,
                            minX: (a - this.containerRect.width) / 2,
                            maxX: (this.containerRect.width - a) / 2
                        };
                    }, h.prototype.setZoomSwipeStyles = function(e, t) {
                        e.css("transform", "translate3d(" + t.x + "px, " + t.y + "px, 0)");
                    }, h.prototype.zoomSwipe = function() {
                        var e, t, o = this, i = {}, s = {}, a = !1, n = !1, r = !1, l = new Date, c = (new Date, 
                        this.core.getSlideItem(this.core.index));
                        this.core.$inner.on("touchstart.lg", (function(s) {
                            if (o.isImageSlide(o.core.index) && (c = o.core.getSlideItem(o.core.index), (o.$LG(s.target).hasClass("lg-item") || c.get().contains(s.target)) && 1 === s.touches.length && o.core.outer.hasClass("lg-zoomed"))) {
                                s.preventDefault(), l = new Date, o.core.touchAction = "zoomSwipe", t = o.core.getSlideItem(o.core.index).find(".lg-img-wrap").first();
                                var a = o.getDragAllowedAxises(0);
                                r = a.allowY, ((n = a.allowX) || r) && (i = o.getSwipeCords(s)), e = o.getPossibleSwipeDragCords(), 
                                o.core.outer.addClass("lg-zoom-dragging lg-zoom-drag-transition");
                            }
                        })), this.core.$inner.on("touchmove.lg", (function(l) {
                            if (1 === l.touches.length && "zoomSwipe" === o.core.touchAction && (o.$LG(l.target).hasClass("lg-item") || c.get().contains(l.target))) {
                                l.preventDefault(), o.core.touchAction = "zoomSwipe", s = o.getSwipeCords(l);
                                var g = o.getZoomSwipeCords(i, s, n, r, e);
                                (Math.abs(s.x - i.x) > 15 || Math.abs(s.y - i.y) > 15) && (a = !0, o.setZoomSwipeStyles(t, g));
                            }
                        })), this.core.$inner.on("touchend.lg", (function(e) {
                            if ("zoomSwipe" === o.core.touchAction && (o.$LG(e.target).hasClass("lg-item") || c.get().contains(e.target))) {
                                if (e.preventDefault(), o.core.touchAction = void 0, o.core.outer.removeClass("lg-zoom-dragging"), 
                                !a) return;
                                a = !1;
                                var t = (new Date).valueOf() - l.valueOf();
                                o.touchendZoom(i, s, n, r, t);
                            }
                        }));
                    }, h.prototype.zoomDrag = function() {
                        var e, t, o, i, s = this, a = {}, n = {}, r = !1, l = !1, c = !1, g = !1;
                        this.core.outer.on("mousedown.lg.zoom", (function(t) {
                            if (s.isImageSlide(s.core.index)) {
                                var n = s.core.getSlideItem(s.core.index);
                                if (s.$LG(t.target).hasClass("lg-item") || n.get().contains(t.target)) {
                                    e = new Date, i = s.core.getSlideItem(s.core.index).find(".lg-img-wrap").first();
                                    var l = s.getDragAllowedAxises(0);
                                    g = l.allowY, c = l.allowX, s.core.outer.hasClass("lg-zoomed") && s.$LG(t.target).hasClass("lg-object") && (c || g) && (t.preventDefault(), 
                                    a = s.getDragCords(t), o = s.getPossibleSwipeDragCords(), r = !0, s.core.outer.removeClass("lg-grab").addClass("lg-grabbing lg-zoom-drag-transition lg-zoom-dragging"));
                                }
                            }
                        })), this.$LG(window).on("mousemove.lg.zoom.global" + this.core.lgId, (function(e) {
                            if (r) {
                                l = !0, n = s.getDragCords(e);
                                var t = s.getZoomSwipeCords(a, n, c, g, o);
                                s.setZoomSwipeStyles(i, t);
                            }
                        })), this.$LG(window).on("mouseup.lg.zoom.global" + this.core.lgId, (function(o) {
                            if (r) {
                                if (t = new Date, r = !1, s.core.outer.removeClass("lg-zoom-dragging"), l && (a.x !== n.x || a.y !== n.y)) {
                                    n = s.getDragCords(o);
                                    var i = t.valueOf() - e.valueOf();
                                    s.touchendZoom(a, n, c, g, i);
                                }
                                l = !1;
                            }
                            s.core.outer.removeClass("lg-grabbing").addClass("lg-grab");
                        }));
                    }, h.prototype.closeGallery = function() {
                        this.resetZoom(), this.zoomInProgress = !1;
                    }, h.prototype.destroy = function() {
                        this.$LG(window).off(".lg.zoom.global" + this.core.lgId), this.core.LGel.off(".lg.zoom"), 
                        this.core.LGel.off(".zoom"), clearTimeout(this.zoomableTimeout), this.zoomableTimeout = !1;
                    }, h;
                }();
            }));
        },
        962: (module, __unused_webpack_exports, __webpack_require__) => {
            var getUint64 = __webpack_require__(626).getUint64;
            var parseSidx = function(data) {
                var view = new DataView(data.buffer, data.byteOffset, data.byteLength), result = {
                    version: data[0],
                    flags: new Uint8Array(data.subarray(1, 4)),
                    references: [],
                    referenceId: view.getUint32(4),
                    timescale: view.getUint32(8)
                }, i = 12;
                if (result.version === 0) {
                    result.earliestPresentationTime = view.getUint32(i);
                    result.firstOffset = view.getUint32(i + 4);
                    i += 8;
                } else {
                    result.earliestPresentationTime = getUint64(data.subarray(i));
                    result.firstOffset = getUint64(data.subarray(i + 8));
                    i += 16;
                }
                i += 2;
                var referenceCount = view.getUint16(i);
                i += 2;
                for (;referenceCount > 0; i += 12, referenceCount--) result.references.push({
                    referenceType: (data[i] & 128) >>> 7,
                    referencedSize: view.getUint32(i) & 2147483647,
                    subsegmentDuration: view.getUint32(i + 4),
                    startsWithSap: !!(data[i + 8] & 128),
                    sapType: (data[i + 8] & 112) >>> 4,
                    sapDeltaTime: view.getUint32(i + 8) & 268435455
                });
                return result;
            };
            module.exports = parseSidx;
        },
        622: module => {
            var secondsToVideoTs, secondsToAudioTs, videoTsToSeconds, audioTsToSeconds, audioTsToVideoTs, videoTsToAudioTs, metadataTsToSeconds, ONE_SECOND_IN_TS = 9e4;
            secondsToVideoTs = function(seconds) {
                return seconds * ONE_SECOND_IN_TS;
            };
            secondsToAudioTs = function(seconds, sampleRate) {
                return seconds * sampleRate;
            };
            videoTsToSeconds = function(timestamp) {
                return timestamp / ONE_SECOND_IN_TS;
            };
            audioTsToSeconds = function(timestamp, sampleRate) {
                return timestamp / sampleRate;
            };
            audioTsToVideoTs = function(timestamp, sampleRate) {
                return secondsToVideoTs(audioTsToSeconds(timestamp, sampleRate));
            };
            videoTsToAudioTs = function(timestamp, sampleRate) {
                return secondsToAudioTs(videoTsToSeconds(timestamp), sampleRate);
            };
            metadataTsToSeconds = function(timestamp, timelineStartPts, keepOriginalTimestamps) {
                return videoTsToSeconds(keepOriginalTimestamps ? timestamp : timestamp - timelineStartPts);
            };
            module.exports = {
                ONE_SECOND_IN_TS,
                secondsToVideoTs,
                secondsToAudioTs,
                videoTsToSeconds,
                audioTsToSeconds,
                audioTsToVideoTs,
                videoTsToAudioTs,
                metadataTsToSeconds
            };
        },
        626: module => {
            var MAX_UINT32 = Math.pow(2, 32);
            var getUint64 = function(uint8) {
                var dv = new DataView(uint8.buffer, uint8.byteOffset, uint8.byteLength);
                var value;
                if (dv.getBigUint64) {
                    value = dv.getBigUint64(0);
                    if (value < Number.MAX_SAFE_INTEGER) return Number(value);
                    return value;
                }
                return dv.getUint32(0) * MAX_UINT32 + dv.getUint32(4);
            };
            module.exports = {
                getUint64,
                MAX_UINT32
            };
        },
        784: (module, __unused_webpack_exports, __webpack_require__) => {
            var window = __webpack_require__(840);
            var vttjs = module.exports = {
                WebVTT: __webpack_require__(311),
                VTTCue: __webpack_require__(184),
                VTTRegion: __webpack_require__(891)
            };
            window.vttjs = vttjs;
            window.WebVTT = vttjs.WebVTT;
            var cueShim = vttjs.VTTCue;
            var regionShim = vttjs.VTTRegion;
            var nativeVTTCue = window.VTTCue;
            var nativeVTTRegion = window.VTTRegion;
            vttjs.shim = function() {
                window.VTTCue = cueShim;
                window.VTTRegion = regionShim;
            };
            vttjs.restore = function() {
                window.VTTCue = nativeVTTCue;
                window.VTTRegion = nativeVTTRegion;
            };
            if (!window.VTTCue) vttjs.shim();
        },
        311: (module, __unused_webpack_exports, __webpack_require__) => {
            var document = __webpack_require__(697);
            var _objCreate = Object.create || function() {
                function F() {}
                return function(o) {
                    if (arguments.length !== 1) throw new Error("Object.create shim only accepts one parameter.");
                    F.prototype = o;
                    return new F;
                };
            }();
            function ParsingError(errorData, message) {
                this.name = "ParsingError";
                this.code = errorData.code;
                this.message = message || errorData.message;
            }
            ParsingError.prototype = _objCreate(Error.prototype);
            ParsingError.prototype.constructor = ParsingError;
            ParsingError.Errors = {
                BadSignature: {
                    code: 0,
                    message: "Malformed WebVTT signature."
                },
                BadTimeStamp: {
                    code: 1,
                    message: "Malformed time stamp."
                }
            };
            function parseTimeStamp(input) {
                function computeSeconds(h, m, s, f) {
                    return (h | 0) * 3600 + (m | 0) * 60 + (s | 0) + (f | 0) / 1e3;
                }
                var m = input.match(/^(\d+):(\d{1,2})(:\d{1,2})?\.(\d{3})/);
                if (!m) return null;
                if (m[3]) return computeSeconds(m[1], m[2], m[3].replace(":", ""), m[4]); else if (m[1] > 59) return computeSeconds(m[1], m[2], 0, m[4]); else return computeSeconds(0, m[1], m[2], m[4]);
            }
            function Settings() {
                this.values = _objCreate(null);
            }
            Settings.prototype = {
                set: function(k, v) {
                    if (!this.get(k) && v !== "") this.values[k] = v;
                },
                get: function(k, dflt, defaultKey) {
                    if (defaultKey) return this.has(k) ? this.values[k] : dflt[defaultKey];
                    return this.has(k) ? this.values[k] : dflt;
                },
                has: function(k) {
                    return k in this.values;
                },
                alt: function(k, v, a) {
                    for (var n = 0; n < a.length; ++n) if (v === a[n]) {
                        this.set(k, v);
                        break;
                    }
                },
                integer: function(k, v) {
                    if (/^-?\d+$/.test(v)) this.set(k, parseInt(v, 10));
                },
                percent: function(k, v) {
                    if (v.match(/^([\d]{1,3})(\.[\d]*)?%$/)) {
                        v = parseFloat(v);
                        if (v >= 0 && v <= 100) {
                            this.set(k, v);
                            return true;
                        }
                    }
                    return false;
                }
            };
            function parseOptions(input, callback, keyValueDelim, groupDelim) {
                var groups = groupDelim ? input.split(groupDelim) : [ input ];
                for (var i in groups) {
                    if (typeof groups[i] !== "string") continue;
                    var kv = groups[i].split(keyValueDelim);
                    if (kv.length !== 2) continue;
                    var k = kv[0].trim();
                    var v = kv[1].trim();
                    callback(k, v);
                }
            }
            function parseCue(input, cue, regionList) {
                var oInput = input;
                function consumeTimeStamp() {
                    var ts = parseTimeStamp(input);
                    if (ts === null) throw new ParsingError(ParsingError.Errors.BadTimeStamp, "Malformed timestamp: " + oInput);
                    input = input.replace(/^[^\sa-zA-Z-]+/, "");
                    return ts;
                }
                function consumeCueSettings(input, cue) {
                    var settings = new Settings;
                    parseOptions(input, (function(k, v) {
                        switch (k) {
                          case "region":
                            for (var i = regionList.length - 1; i >= 0; i--) if (regionList[i].id === v) {
                                settings.set(k, regionList[i].region);
                                break;
                            }
                            break;

                          case "vertical":
                            settings.alt(k, v, [ "rl", "lr" ]);
                            break;

                          case "line":
                            var vals = v.split(","), vals0 = vals[0];
                            settings.integer(k, vals0);
                            settings.percent(k, vals0) ? settings.set("snapToLines", false) : null;
                            settings.alt(k, vals0, [ "auto" ]);
                            if (vals.length === 2) settings.alt("lineAlign", vals[1], [ "start", "center", "end" ]);
                            break;

                          case "position":
                            vals = v.split(",");
                            settings.percent(k, vals[0]);
                            if (vals.length === 2) settings.alt("positionAlign", vals[1], [ "start", "center", "end" ]);
                            break;

                          case "size":
                            settings.percent(k, v);
                            break;

                          case "align":
                            settings.alt(k, v, [ "start", "center", "end", "left", "right" ]);
                            break;
                        }
                    }), /:/, /\s/);
                    cue.region = settings.get("region", null);
                    cue.vertical = settings.get("vertical", "");
                    try {
                        cue.line = settings.get("line", "auto");
                    } catch (e) {}
                    cue.lineAlign = settings.get("lineAlign", "start");
                    cue.snapToLines = settings.get("snapToLines", true);
                    cue.size = settings.get("size", 100);
                    try {
                        cue.align = settings.get("align", "center");
                    } catch (e) {
                        cue.align = settings.get("align", "middle");
                    }
                    try {
                        cue.position = settings.get("position", "auto");
                    } catch (e) {
                        cue.position = settings.get("position", {
                            start: 0,
                            left: 0,
                            center: 50,
                            middle: 50,
                            end: 100,
                            right: 100
                        }, cue.align);
                    }
                    cue.positionAlign = settings.get("positionAlign", {
                        start: "start",
                        left: "start",
                        center: "center",
                        middle: "center",
                        end: "end",
                        right: "end"
                    }, cue.align);
                }
                function skipWhitespace() {
                    input = input.replace(/^\s+/, "");
                }
                skipWhitespace();
                cue.startTime = consumeTimeStamp();
                skipWhitespace();
                if (input.substr(0, 3) !== "--\x3e") throw new ParsingError(ParsingError.Errors.BadTimeStamp, "Malformed time stamp (time stamps must be separated by '--\x3e'): " + oInput);
                input = input.substr(3);
                skipWhitespace();
                cue.endTime = consumeTimeStamp();
                skipWhitespace();
                consumeCueSettings(input, cue);
            }
            var TEXTAREA_ELEMENT = document.createElement && document.createElement("textarea");
            var TAG_NAME = {
                c: "span",
                i: "i",
                b: "b",
                u: "u",
                ruby: "ruby",
                rt: "rt",
                v: "span",
                lang: "span"
            };
            var DEFAULT_COLOR_CLASS = {
                white: "rgba(255,255,255,1)",
                lime: "rgba(0,255,0,1)",
                cyan: "rgba(0,255,255,1)",
                red: "rgba(255,0,0,1)",
                yellow: "rgba(255,255,0,1)",
                magenta: "rgba(255,0,255,1)",
                blue: "rgba(0,0,255,1)",
                black: "rgba(0,0,0,1)"
            };
            var TAG_ANNOTATION = {
                v: "title",
                lang: "lang"
            };
            var NEEDS_PARENT = {
                rt: "ruby"
            };
            function parseContent(window, input) {
                function nextToken() {
                    if (!input) return null;
                    function consume(result) {
                        input = input.substr(result.length);
                        return result;
                    }
                    var m = input.match(/^([^<]*)(<[^>]*>?)?/);
                    return consume(m[1] ? m[1] : m[2]);
                }
                function unescape(s) {
                    TEXTAREA_ELEMENT.innerHTML = s;
                    s = TEXTAREA_ELEMENT.textContent;
                    TEXTAREA_ELEMENT.textContent = "";
                    return s;
                }
                function shouldAdd(current, element) {
                    return !NEEDS_PARENT[element.localName] || NEEDS_PARENT[element.localName] === current.localName;
                }
                function createElement(type, annotation) {
                    var tagName = TAG_NAME[type];
                    if (!tagName) return null;
                    var element = window.document.createElement(tagName);
                    var name = TAG_ANNOTATION[type];
                    if (name && annotation) element[name] = annotation.trim();
                    return element;
                }
                var t, rootDiv = window.document.createElement("div"), current = rootDiv, tagStack = [];
                while ((t = nextToken()) !== null) {
                    if (t[0] === "<") {
                        if (t[1] === "/") {
                            if (tagStack.length && tagStack[tagStack.length - 1] === t.substr(2).replace(">", "")) {
                                tagStack.pop();
                                current = current.parentNode;
                            }
                            continue;
                        }
                        var ts = parseTimeStamp(t.substr(1, t.length - 2));
                        var node;
                        if (ts) {
                            node = window.document.createProcessingInstruction("timestamp", ts);
                            current.appendChild(node);
                            continue;
                        }
                        var m = t.match(/^<([^.\s/0-9>]+)(\.[^\s\\>]+)?([^>\\]+)?(\\?)>?$/);
                        if (!m) continue;
                        node = createElement(m[1], m[3]);
                        if (!node) continue;
                        if (!shouldAdd(current, node)) continue;
                        if (m[2]) {
                            var classes = m[2].split(".");
                            classes.forEach((function(cl) {
                                var bgColor = /^bg_/.test(cl);
                                var colorName = bgColor ? cl.slice(3) : cl;
                                if (DEFAULT_COLOR_CLASS.hasOwnProperty(colorName)) {
                                    var propName = bgColor ? "background-color" : "color";
                                    var propValue = DEFAULT_COLOR_CLASS[colorName];
                                    node.style[propName] = propValue;
                                }
                            }));
                            node.className = classes.join(" ");
                        }
                        tagStack.push(m[1]);
                        current.appendChild(node);
                        current = node;
                        continue;
                    }
                    current.appendChild(window.document.createTextNode(unescape(t)));
                }
                return rootDiv;
            }
            var strongRTLRanges = [ [ 1470, 1470 ], [ 1472, 1472 ], [ 1475, 1475 ], [ 1478, 1478 ], [ 1488, 1514 ], [ 1520, 1524 ], [ 1544, 1544 ], [ 1547, 1547 ], [ 1549, 1549 ], [ 1563, 1563 ], [ 1566, 1610 ], [ 1645, 1647 ], [ 1649, 1749 ], [ 1765, 1766 ], [ 1774, 1775 ], [ 1786, 1805 ], [ 1807, 1808 ], [ 1810, 1839 ], [ 1869, 1957 ], [ 1969, 1969 ], [ 1984, 2026 ], [ 2036, 2037 ], [ 2042, 2042 ], [ 2048, 2069 ], [ 2074, 2074 ], [ 2084, 2084 ], [ 2088, 2088 ], [ 2096, 2110 ], [ 2112, 2136 ], [ 2142, 2142 ], [ 2208, 2208 ], [ 2210, 2220 ], [ 8207, 8207 ], [ 64285, 64285 ], [ 64287, 64296 ], [ 64298, 64310 ], [ 64312, 64316 ], [ 64318, 64318 ], [ 64320, 64321 ], [ 64323, 64324 ], [ 64326, 64449 ], [ 64467, 64829 ], [ 64848, 64911 ], [ 64914, 64967 ], [ 65008, 65020 ], [ 65136, 65140 ], [ 65142, 65276 ], [ 67584, 67589 ], [ 67592, 67592 ], [ 67594, 67637 ], [ 67639, 67640 ], [ 67644, 67644 ], [ 67647, 67669 ], [ 67671, 67679 ], [ 67840, 67867 ], [ 67872, 67897 ], [ 67903, 67903 ], [ 67968, 68023 ], [ 68030, 68031 ], [ 68096, 68096 ], [ 68112, 68115 ], [ 68117, 68119 ], [ 68121, 68147 ], [ 68160, 68167 ], [ 68176, 68184 ], [ 68192, 68223 ], [ 68352, 68405 ], [ 68416, 68437 ], [ 68440, 68466 ], [ 68472, 68479 ], [ 68608, 68680 ], [ 126464, 126467 ], [ 126469, 126495 ], [ 126497, 126498 ], [ 126500, 126500 ], [ 126503, 126503 ], [ 126505, 126514 ], [ 126516, 126519 ], [ 126521, 126521 ], [ 126523, 126523 ], [ 126530, 126530 ], [ 126535, 126535 ], [ 126537, 126537 ], [ 126539, 126539 ], [ 126541, 126543 ], [ 126545, 126546 ], [ 126548, 126548 ], [ 126551, 126551 ], [ 126553, 126553 ], [ 126555, 126555 ], [ 126557, 126557 ], [ 126559, 126559 ], [ 126561, 126562 ], [ 126564, 126564 ], [ 126567, 126570 ], [ 126572, 126578 ], [ 126580, 126583 ], [ 126585, 126588 ], [ 126590, 126590 ], [ 126592, 126601 ], [ 126603, 126619 ], [ 126625, 126627 ], [ 126629, 126633 ], [ 126635, 126651 ], [ 1114109, 1114109 ] ];
            function isStrongRTLChar(charCode) {
                for (var i = 0; i < strongRTLRanges.length; i++) {
                    var currentRange = strongRTLRanges[i];
                    if (charCode >= currentRange[0] && charCode <= currentRange[1]) return true;
                }
                return false;
            }
            function determineBidi(cueDiv) {
                var charCode, nodeStack = [], text = "";
                if (!cueDiv || !cueDiv.childNodes) return "ltr";
                function pushNodes(nodeStack, node) {
                    for (var i = node.childNodes.length - 1; i >= 0; i--) nodeStack.push(node.childNodes[i]);
                }
                function nextTextNode(nodeStack) {
                    if (!nodeStack || !nodeStack.length) return null;
                    var node = nodeStack.pop(), text = node.textContent || node.innerText;
                    if (text) {
                        var m = text.match(/^.*(\n|\r)/);
                        if (m) {
                            nodeStack.length = 0;
                            return m[0];
                        }
                        return text;
                    }
                    if (node.tagName === "ruby") return nextTextNode(nodeStack);
                    if (node.childNodes) {
                        pushNodes(nodeStack, node);
                        return nextTextNode(nodeStack);
                    }
                }
                pushNodes(nodeStack, cueDiv);
                while (text = nextTextNode(nodeStack)) for (var i = 0; i < text.length; i++) {
                    charCode = text.charCodeAt(i);
                    if (isStrongRTLChar(charCode)) return "rtl";
                }
                return "ltr";
            }
            function computeLinePos(cue) {
                if (typeof cue.line === "number" && (cue.snapToLines || cue.line >= 0 && cue.line <= 100)) return cue.line;
                if (!cue.track || !cue.track.textTrackList || !cue.track.textTrackList.mediaElement) return -1;
                var track = cue.track, trackList = track.textTrackList, count = 0;
                for (var i = 0; i < trackList.length && trackList[i] !== track; i++) if (trackList[i].mode === "showing") count++;
                return ++count * -1;
            }
            function StyleBox() {}
            StyleBox.prototype.applyStyles = function(styles, div) {
                div = div || this.div;
                for (var prop in styles) if (styles.hasOwnProperty(prop)) div.style[prop] = styles[prop];
            };
            StyleBox.prototype.formatStyle = function(val, unit) {
                return val === 0 ? 0 : val + unit;
            };
            function CueStyleBox(window, cue, styleOptions) {
                StyleBox.call(this);
                this.cue = cue;
                this.cueDiv = parseContent(window, cue.text);
                var styles = {
                    color: "rgba(255, 255, 255, 1)",
                    backgroundColor: "rgba(0, 0, 0, 0.8)",
                    position: "relative",
                    left: 0,
                    right: 0,
                    top: 0,
                    bottom: 0,
                    display: "inline",
                    writingMode: cue.vertical === "" ? "horizontal-tb" : cue.vertical === "lr" ? "vertical-lr" : "vertical-rl",
                    unicodeBidi: "plaintext"
                };
                this.applyStyles(styles, this.cueDiv);
                this.div = window.document.createElement("div");
                styles = {
                    direction: determineBidi(this.cueDiv),
                    writingMode: cue.vertical === "" ? "horizontal-tb" : cue.vertical === "lr" ? "vertical-lr" : "vertical-rl",
                    unicodeBidi: "plaintext",
                    textAlign: cue.align === "middle" ? "center" : cue.align,
                    font: styleOptions.font,
                    whiteSpace: "pre-line",
                    position: "absolute"
                };
                this.applyStyles(styles);
                this.div.appendChild(this.cueDiv);
                var textPos = 0;
                switch (cue.positionAlign) {
                  case "start":
                  case "line-left":
                    textPos = cue.position;
                    break;

                  case "center":
                    textPos = cue.position - cue.size / 2;
                    break;

                  case "end":
                  case "line-right":
                    textPos = cue.position - cue.size;
                    break;
                }
                if (cue.vertical === "") this.applyStyles({
                    left: this.formatStyle(textPos, "%"),
                    width: this.formatStyle(cue.size, "%")
                }); else this.applyStyles({
                    top: this.formatStyle(textPos, "%"),
                    height: this.formatStyle(cue.size, "%")
                });
                this.move = function(box) {
                    this.applyStyles({
                        top: this.formatStyle(box.top, "px"),
                        bottom: this.formatStyle(box.bottom, "px"),
                        left: this.formatStyle(box.left, "px"),
                        right: this.formatStyle(box.right, "px"),
                        height: this.formatStyle(box.height, "px"),
                        width: this.formatStyle(box.width, "px")
                    });
                };
            }
            CueStyleBox.prototype = _objCreate(StyleBox.prototype);
            CueStyleBox.prototype.constructor = CueStyleBox;
            function BoxPosition(obj) {
                var lh, height, width, top;
                if (obj.div) {
                    height = obj.div.offsetHeight;
                    width = obj.div.offsetWidth;
                    top = obj.div.offsetTop;
                    var rects = (rects = obj.div.childNodes) && (rects = rects[0]) && rects.getClientRects && rects.getClientRects();
                    obj = obj.div.getBoundingClientRect();
                    lh = rects ? Math.max(rects[0] && rects[0].height || 0, obj.height / rects.length) : 0;
                }
                this.left = obj.left;
                this.right = obj.right;
                this.top = obj.top || top;
                this.height = obj.height || height;
                this.bottom = obj.bottom || top + (obj.height || height);
                this.width = obj.width || width;
                this.lineHeight = lh !== void 0 ? lh : obj.lineHeight;
            }
            BoxPosition.prototype.move = function(axis, toMove) {
                toMove = toMove !== void 0 ? toMove : this.lineHeight;
                switch (axis) {
                  case "+x":
                    this.left += toMove;
                    this.right += toMove;
                    break;

                  case "-x":
                    this.left -= toMove;
                    this.right -= toMove;
                    break;

                  case "+y":
                    this.top += toMove;
                    this.bottom += toMove;
                    break;

                  case "-y":
                    this.top -= toMove;
                    this.bottom -= toMove;
                    break;
                }
            };
            BoxPosition.prototype.overlaps = function(b2) {
                return this.left < b2.right && this.right > b2.left && this.top < b2.bottom && this.bottom > b2.top;
            };
            BoxPosition.prototype.overlapsAny = function(boxes) {
                for (var i = 0; i < boxes.length; i++) if (this.overlaps(boxes[i])) return true;
                return false;
            };
            BoxPosition.prototype.within = function(container) {
                return this.top >= container.top && this.bottom <= container.bottom && this.left >= container.left && this.right <= container.right;
            };
            BoxPosition.prototype.overlapsOppositeAxis = function(container, axis) {
                switch (axis) {
                  case "+x":
                    return this.left < container.left;

                  case "-x":
                    return this.right > container.right;

                  case "+y":
                    return this.top < container.top;

                  case "-y":
                    return this.bottom > container.bottom;
                }
            };
            BoxPosition.prototype.intersectPercentage = function(b2) {
                var x = Math.max(0, Math.min(this.right, b2.right) - Math.max(this.left, b2.left)), y = Math.max(0, Math.min(this.bottom, b2.bottom) - Math.max(this.top, b2.top)), intersectArea = x * y;
                return intersectArea / (this.height * this.width);
            };
            BoxPosition.prototype.toCSSCompatValues = function(reference) {
                return {
                    top: this.top - reference.top,
                    bottom: reference.bottom - this.bottom,
                    left: this.left - reference.left,
                    right: reference.right - this.right,
                    height: this.height,
                    width: this.width
                };
            };
            BoxPosition.getSimpleBoxPosition = function(obj) {
                var height = obj.div ? obj.div.offsetHeight : obj.tagName ? obj.offsetHeight : 0;
                var width = obj.div ? obj.div.offsetWidth : obj.tagName ? obj.offsetWidth : 0;
                var top = obj.div ? obj.div.offsetTop : obj.tagName ? obj.offsetTop : 0;
                obj = obj.div ? obj.div.getBoundingClientRect() : obj.tagName ? obj.getBoundingClientRect() : obj;
                var ret = {
                    left: obj.left,
                    right: obj.right,
                    top: obj.top || top,
                    height: obj.height || height,
                    bottom: obj.bottom || top + (obj.height || height),
                    width: obj.width || width
                };
                return ret;
            };
            function moveBoxToLinePosition(window, styleBox, containerBox, boxPositions) {
                function findBestPosition(b, axis) {
                    var bestPosition, specifiedPosition = new BoxPosition(b), percentage = 1;
                    for (var i = 0; i < axis.length; i++) {
                        while (b.overlapsOppositeAxis(containerBox, axis[i]) || b.within(containerBox) && b.overlapsAny(boxPositions)) b.move(axis[i]);
                        if (b.within(containerBox)) return b;
                        var p = b.intersectPercentage(containerBox);
                        if (percentage > p) {
                            bestPosition = new BoxPosition(b);
                            percentage = p;
                        }
                        b = new BoxPosition(specifiedPosition);
                    }
                    return bestPosition || specifiedPosition;
                }
                var boxPosition = new BoxPosition(styleBox), cue = styleBox.cue, linePos = computeLinePos(cue), axis = [];
                if (cue.snapToLines) {
                    var size;
                    switch (cue.vertical) {
                      case "":
                        axis = [ "+y", "-y" ];
                        size = "height";
                        break;

                      case "rl":
                        axis = [ "+x", "-x" ];
                        size = "width";
                        break;

                      case "lr":
                        axis = [ "-x", "+x" ];
                        size = "width";
                        break;
                    }
                    var step = boxPosition.lineHeight, position = step * Math.round(linePos), maxPosition = containerBox[size] + step, initialAxis = axis[0];
                    if (Math.abs(position) > maxPosition) {
                        position = position < 0 ? -1 : 1;
                        position *= Math.ceil(maxPosition / step) * step;
                    }
                    if (linePos < 0) {
                        position += cue.vertical === "" ? containerBox.height : containerBox.width;
                        axis = axis.reverse();
                    }
                    boxPosition.move(initialAxis, position);
                } else {
                    var calculatedPercentage = boxPosition.lineHeight / containerBox.height * 100;
                    switch (cue.lineAlign) {
                      case "center":
                        linePos -= calculatedPercentage / 2;
                        break;

                      case "end":
                        linePos -= calculatedPercentage;
                        break;
                    }
                    switch (cue.vertical) {
                      case "":
                        styleBox.applyStyles({
                            top: styleBox.formatStyle(linePos, "%")
                        });
                        break;

                      case "rl":
                        styleBox.applyStyles({
                            left: styleBox.formatStyle(linePos, "%")
                        });
                        break;

                      case "lr":
                        styleBox.applyStyles({
                            right: styleBox.formatStyle(linePos, "%")
                        });
                        break;
                    }
                    axis = [ "+y", "-x", "+x", "-y" ];
                    boxPosition = new BoxPosition(styleBox);
                }
                var bestPosition = findBestPosition(boxPosition, axis);
                styleBox.move(bestPosition.toCSSCompatValues(containerBox));
            }
            function WebVTT() {}
            WebVTT.StringDecoder = function() {
                return {
                    decode: function(data) {
                        if (!data) return "";
                        if (typeof data !== "string") throw new Error("Error - expected string data.");
                        return decodeURIComponent(encodeURIComponent(data));
                    }
                };
            };
            WebVTT.convertCueToDOMTree = function(window, cuetext) {
                if (!window || !cuetext) return null;
                return parseContent(window, cuetext);
            };
            var FONT_SIZE_PERCENT = .05;
            var FONT_STYLE = "sans-serif";
            var CUE_BACKGROUND_PADDING = "1.5%";
            WebVTT.processCues = function(window, cues, overlay) {
                if (!window || !cues || !overlay) return null;
                while (overlay.firstChild) overlay.removeChild(overlay.firstChild);
                var paddedOverlay = window.document.createElement("div");
                paddedOverlay.style.position = "absolute";
                paddedOverlay.style.left = "0";
                paddedOverlay.style.right = "0";
                paddedOverlay.style.top = "0";
                paddedOverlay.style.bottom = "0";
                paddedOverlay.style.margin = CUE_BACKGROUND_PADDING;
                overlay.appendChild(paddedOverlay);
                function shouldCompute(cues) {
                    for (var i = 0; i < cues.length; i++) if (cues[i].hasBeenReset || !cues[i].displayState) return true;
                    return false;
                }
                if (!shouldCompute(cues)) {
                    for (var i = 0; i < cues.length; i++) paddedOverlay.appendChild(cues[i].displayState);
                    return;
                }
                var boxPositions = [], containerBox = BoxPosition.getSimpleBoxPosition(paddedOverlay), fontSize = Math.round(containerBox.height * FONT_SIZE_PERCENT * 100) / 100;
                var styleOptions = {
                    font: fontSize + "px " + FONT_STYLE
                };
                (function() {
                    var styleBox, cue;
                    for (var i = 0; i < cues.length; i++) {
                        cue = cues[i];
                        styleBox = new CueStyleBox(window, cue, styleOptions);
                        paddedOverlay.appendChild(styleBox.div);
                        moveBoxToLinePosition(window, styleBox, containerBox, boxPositions);
                        cue.displayState = styleBox.div;
                        boxPositions.push(BoxPosition.getSimpleBoxPosition(styleBox));
                    }
                })();
            };
            WebVTT.Parser = function(window, vttjs, decoder) {
                if (!decoder) {
                    decoder = vttjs;
                    vttjs = {};
                }
                if (!vttjs) vttjs = {};
                this.window = window;
                this.vttjs = vttjs;
                this.state = "INITIAL";
                this.buffer = "";
                this.decoder = decoder || new TextDecoder("utf8");
                this.regionList = [];
            };
            WebVTT.Parser.prototype = {
                reportOrThrowError: function(e) {
                    if (e instanceof ParsingError) this.onparsingerror && this.onparsingerror(e); else throw e;
                },
                parse: function(data) {
                    var self = this;
                    if (data) self.buffer += self.decoder.decode(data, {
                        stream: true
                    });
                    function collectNextLine() {
                        var buffer = self.buffer;
                        var pos = 0;
                        while (pos < buffer.length && buffer[pos] !== "\r" && buffer[pos] !== "\n") ++pos;
                        var line = buffer.substr(0, pos);
                        if (buffer[pos] === "\r") ++pos;
                        if (buffer[pos] === "\n") ++pos;
                        self.buffer = buffer.substr(pos);
                        return line;
                    }
                    function parseRegion(input) {
                        var settings = new Settings;
                        parseOptions(input, (function(k, v) {
                            switch (k) {
                              case "id":
                                settings.set(k, v);
                                break;

                              case "width":
                                settings.percent(k, v);
                                break;

                              case "lines":
                                settings.integer(k, v);
                                break;

                              case "regionanchor":
                              case "viewportanchor":
                                var xy = v.split(",");
                                if (xy.length !== 2) break;
                                var anchor = new Settings;
                                anchor.percent("x", xy[0]);
                                anchor.percent("y", xy[1]);
                                if (!anchor.has("x") || !anchor.has("y")) break;
                                settings.set(k + "X", anchor.get("x"));
                                settings.set(k + "Y", anchor.get("y"));
                                break;

                              case "scroll":
                                settings.alt(k, v, [ "up" ]);
                                break;
                            }
                        }), /=/, /\s/);
                        if (settings.has("id")) {
                            var region = new (self.vttjs.VTTRegion || self.window.VTTRegion);
                            region.width = settings.get("width", 100);
                            region.lines = settings.get("lines", 3);
                            region.regionAnchorX = settings.get("regionanchorX", 0);
                            region.regionAnchorY = settings.get("regionanchorY", 100);
                            region.viewportAnchorX = settings.get("viewportanchorX", 0);
                            region.viewportAnchorY = settings.get("viewportanchorY", 100);
                            region.scroll = settings.get("scroll", "");
                            self.onregion && self.onregion(region);
                            self.regionList.push({
                                id: settings.get("id"),
                                region
                            });
                        }
                    }
                    function parseTimestampMap(input) {
                        var settings = new Settings;
                        parseOptions(input, (function(k, v) {
                            switch (k) {
                              case "MPEGT":
                                settings.integer(k + "S", v);
                                break;

                              case "LOCA":
                                settings.set(k + "L", parseTimeStamp(v));
                                break;
                            }
                        }), /[^\d]:/, /,/);
                        self.ontimestampmap && self.ontimestampmap({
                            MPEGTS: settings.get("MPEGTS"),
                            LOCAL: settings.get("LOCAL")
                        });
                    }
                    function parseHeader(input) {
                        if (input.match(/X-TIMESTAMP-MAP/)) parseOptions(input, (function(k, v) {
                            switch (k) {
                              case "X-TIMESTAMP-MAP":
                                parseTimestampMap(v);
                                break;
                            }
                        }), /=/); else parseOptions(input, (function(k, v) {
                            switch (k) {
                              case "Region":
                                parseRegion(v);
                                break;
                            }
                        }), /:/);
                    }
                    try {
                        var line;
                        if (self.state === "INITIAL") {
                            if (!/\r\n|\n/.test(self.buffer)) return this;
                            line = collectNextLine();
                            var m = line.match(/^WEBVTT([ \t].*)?$/);
                            if (!m || !m[0]) throw new ParsingError(ParsingError.Errors.BadSignature);
                            self.state = "HEADER";
                        }
                        var alreadyCollectedLine = false;
                        while (self.buffer) {
                            if (!/\r\n|\n/.test(self.buffer)) return this;
                            if (!alreadyCollectedLine) line = collectNextLine(); else alreadyCollectedLine = false;
                            switch (self.state) {
                              case "HEADER":
                                if (/:/.test(line)) parseHeader(line); else if (!line) self.state = "ID";
                                continue;

                              case "NOTE":
                                if (!line) self.state = "ID";
                                continue;

                              case "ID":
                                if (/^NOTE($|[ \t])/.test(line)) {
                                    self.state = "NOTE";
                                    break;
                                }
                                if (!line) continue;
                                self.cue = new (self.vttjs.VTTCue || self.window.VTTCue)(0, 0, "");
                                try {
                                    self.cue.align = "center";
                                } catch (e) {
                                    self.cue.align = "middle";
                                }
                                self.state = "CUE";
                                if (line.indexOf("--\x3e") === -1) {
                                    self.cue.id = line;
                                    continue;
                                }

                              case "CUE":
                                try {
                                    parseCue(line, self.cue, self.regionList);
                                } catch (e) {
                                    self.reportOrThrowError(e);
                                    self.cue = null;
                                    self.state = "BADCUE";
                                    continue;
                                }
                                self.state = "CUETEXT";
                                continue;

                              case "CUETEXT":
                                var hasSubstring = line.indexOf("--\x3e") !== -1;
                                if (!line || hasSubstring && (alreadyCollectedLine = true)) {
                                    self.oncue && self.oncue(self.cue);
                                    self.cue = null;
                                    self.state = "ID";
                                    continue;
                                }
                                if (self.cue.text) self.cue.text += "\n";
                                self.cue.text += line.replace(/\u2028/g, "\n").replace(/u2029/g, "\n");
                                continue;

                              case "BADCUE":
                                if (!line) self.state = "ID";
                                continue;
                            }
                        }
                    } catch (e) {
                        self.reportOrThrowError(e);
                        if (self.state === "CUETEXT" && self.cue && self.oncue) self.oncue(self.cue);
                        self.cue = null;
                        self.state = self.state === "INITIAL" ? "BADWEBVTT" : "BADCUE";
                    }
                    return this;
                },
                flush: function() {
                    var self = this;
                    try {
                        self.buffer += self.decoder.decode();
                        if (self.cue || self.state === "HEADER") {
                            self.buffer += "\n\n";
                            self.parse();
                        }
                        if (self.state === "INITIAL") throw new ParsingError(ParsingError.Errors.BadSignature);
                    } catch (e) {
                        self.reportOrThrowError(e);
                    }
                    self.onflush && self.onflush();
                    return this;
                }
            };
            module.exports = WebVTT;
        },
        184: module => {
            var autoKeyword = "auto";
            var directionSetting = {
                "": 1,
                lr: 1,
                rl: 1
            };
            var alignSetting = {
                start: 1,
                center: 1,
                end: 1,
                left: 1,
                right: 1,
                auto: 1,
                "line-left": 1,
                "line-right": 1
            };
            function findDirectionSetting(value) {
                if (typeof value !== "string") return false;
                var dir = directionSetting[value.toLowerCase()];
                return dir ? value.toLowerCase() : false;
            }
            function findAlignSetting(value) {
                if (typeof value !== "string") return false;
                var align = alignSetting[value.toLowerCase()];
                return align ? value.toLowerCase() : false;
            }
            function VTTCue(startTime, endTime, text) {
                this.hasBeenReset = false;
                var _id = "";
                var _pauseOnExit = false;
                var _startTime = startTime;
                var _endTime = endTime;
                var _text = text;
                var _region = null;
                var _vertical = "";
                var _snapToLines = true;
                var _line = "auto";
                var _lineAlign = "start";
                var _position = "auto";
                var _positionAlign = "auto";
                var _size = 100;
                var _align = "center";
                Object.defineProperties(this, {
                    id: {
                        enumerable: true,
                        get: function() {
                            return _id;
                        },
                        set: function(value) {
                            _id = "" + value;
                        }
                    },
                    pauseOnExit: {
                        enumerable: true,
                        get: function() {
                            return _pauseOnExit;
                        },
                        set: function(value) {
                            _pauseOnExit = !!value;
                        }
                    },
                    startTime: {
                        enumerable: true,
                        get: function() {
                            return _startTime;
                        },
                        set: function(value) {
                            if (typeof value !== "number") throw new TypeError("Start time must be set to a number.");
                            _startTime = value;
                            this.hasBeenReset = true;
                        }
                    },
                    endTime: {
                        enumerable: true,
                        get: function() {
                            return _endTime;
                        },
                        set: function(value) {
                            if (typeof value !== "number") throw new TypeError("End time must be set to a number.");
                            _endTime = value;
                            this.hasBeenReset = true;
                        }
                    },
                    text: {
                        enumerable: true,
                        get: function() {
                            return _text;
                        },
                        set: function(value) {
                            _text = "" + value;
                            this.hasBeenReset = true;
                        }
                    },
                    region: {
                        enumerable: true,
                        get: function() {
                            return _region;
                        },
                        set: function(value) {
                            _region = value;
                            this.hasBeenReset = true;
                        }
                    },
                    vertical: {
                        enumerable: true,
                        get: function() {
                            return _vertical;
                        },
                        set: function(value) {
                            var setting = findDirectionSetting(value);
                            if (setting === false) throw new SyntaxError("Vertical: an invalid or illegal direction string was specified.");
                            _vertical = setting;
                            this.hasBeenReset = true;
                        }
                    },
                    snapToLines: {
                        enumerable: true,
                        get: function() {
                            return _snapToLines;
                        },
                        set: function(value) {
                            _snapToLines = !!value;
                            this.hasBeenReset = true;
                        }
                    },
                    line: {
                        enumerable: true,
                        get: function() {
                            return _line;
                        },
                        set: function(value) {
                            if (typeof value !== "number" && value !== autoKeyword) throw new SyntaxError("Line: an invalid number or illegal string was specified.");
                            _line = value;
                            this.hasBeenReset = true;
                        }
                    },
                    lineAlign: {
                        enumerable: true,
                        get: function() {
                            return _lineAlign;
                        },
                        set: function(value) {
                            var setting = findAlignSetting(value);
                            if (!setting) console.warn("lineAlign: an invalid or illegal string was specified."); else {
                                _lineAlign = setting;
                                this.hasBeenReset = true;
                            }
                        }
                    },
                    position: {
                        enumerable: true,
                        get: function() {
                            return _position;
                        },
                        set: function(value) {
                            if (value < 0 || value > 100) throw new Error("Position must be between 0 and 100.");
                            _position = value;
                            this.hasBeenReset = true;
                        }
                    },
                    positionAlign: {
                        enumerable: true,
                        get: function() {
                            return _positionAlign;
                        },
                        set: function(value) {
                            var setting = findAlignSetting(value);
                            if (!setting) console.warn("positionAlign: an invalid or illegal string was specified."); else {
                                _positionAlign = setting;
                                this.hasBeenReset = true;
                            }
                        }
                    },
                    size: {
                        enumerable: true,
                        get: function() {
                            return _size;
                        },
                        set: function(value) {
                            if (value < 0 || value > 100) throw new Error("Size must be between 0 and 100.");
                            _size = value;
                            this.hasBeenReset = true;
                        }
                    },
                    align: {
                        enumerable: true,
                        get: function() {
                            return _align;
                        },
                        set: function(value) {
                            var setting = findAlignSetting(value);
                            if (!setting) throw new SyntaxError("align: an invalid or illegal alignment string was specified.");
                            _align = setting;
                            this.hasBeenReset = true;
                        }
                    }
                });
                this.displayState = void 0;
            }
            VTTCue.prototype.getCueAsHTML = function() {
                return WebVTT.convertCueToDOMTree(window, this.text);
            };
            module.exports = VTTCue;
        },
        891: module => {
            var scrollSetting = {
                "": true,
                up: true
            };
            function findScrollSetting(value) {
                if (typeof value !== "string") return false;
                var scroll = scrollSetting[value.toLowerCase()];
                return scroll ? value.toLowerCase() : false;
            }
            function isValidPercentValue(value) {
                return typeof value === "number" && value >= 0 && value <= 100;
            }
            function VTTRegion() {
                var _width = 100;
                var _lines = 3;
                var _regionAnchorX = 0;
                var _regionAnchorY = 100;
                var _viewportAnchorX = 0;
                var _viewportAnchorY = 100;
                var _scroll = "";
                Object.defineProperties(this, {
                    width: {
                        enumerable: true,
                        get: function() {
                            return _width;
                        },
                        set: function(value) {
                            if (!isValidPercentValue(value)) throw new Error("Width must be between 0 and 100.");
                            _width = value;
                        }
                    },
                    lines: {
                        enumerable: true,
                        get: function() {
                            return _lines;
                        },
                        set: function(value) {
                            if (typeof value !== "number") throw new TypeError("Lines must be set to a number.");
                            _lines = value;
                        }
                    },
                    regionAnchorY: {
                        enumerable: true,
                        get: function() {
                            return _regionAnchorY;
                        },
                        set: function(value) {
                            if (!isValidPercentValue(value)) throw new Error("RegionAnchorX must be between 0 and 100.");
                            _regionAnchorY = value;
                        }
                    },
                    regionAnchorX: {
                        enumerable: true,
                        get: function() {
                            return _regionAnchorX;
                        },
                        set: function(value) {
                            if (!isValidPercentValue(value)) throw new Error("RegionAnchorY must be between 0 and 100.");
                            _regionAnchorX = value;
                        }
                    },
                    viewportAnchorY: {
                        enumerable: true,
                        get: function() {
                            return _viewportAnchorY;
                        },
                        set: function(value) {
                            if (!isValidPercentValue(value)) throw new Error("ViewportAnchorY must be between 0 and 100.");
                            _viewportAnchorY = value;
                        }
                    },
                    viewportAnchorX: {
                        enumerable: true,
                        get: function() {
                            return _viewportAnchorX;
                        },
                        set: function(value) {
                            if (!isValidPercentValue(value)) throw new Error("ViewportAnchorX must be between 0 and 100.");
                            _viewportAnchorX = value;
                        }
                    },
                    scroll: {
                        enumerable: true,
                        get: function() {
                            return _scroll;
                        },
                        set: function(value) {
                            var setting = findScrollSetting(value);
                            if (setting === false) console.warn("Scroll: an invalid or illegal string was specified."); else _scroll = setting;
                        }
                    }
                });
            }
            module.exports = VTTRegion;
        },
        542: () => {},
        634: module => {
            function _extends() {
                return module.exports = _extends = Object.assign ? Object.assign.bind() : function(n) {
                    for (var e = 1; e < arguments.length; e++) {
                        var t = arguments[e];
                        for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
                    }
                    return n;
                }, module.exports.__esModule = true, module.exports["default"] = module.exports, 
                _extends.apply(null, arguments);
            }
            module.exports = _extends, module.exports.__esModule = true, module.exports["default"] = module.exports;
        }
    };
    var __webpack_module_cache__ = {};
    function __webpack_require__(moduleId) {
        var cachedModule = __webpack_module_cache__[moduleId];
        if (cachedModule !== void 0) return cachedModule.exports;
        var module = __webpack_module_cache__[moduleId] = {
            exports: {}
        };
        __webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
        return module.exports;
    }
    (() => {
        __webpack_require__.n = module => {
            var getter = module && module.__esModule ? () => module["default"] : () => module;
            __webpack_require__.d(getter, {
                a: getter
            });
            return getter;
        };
    })();
    (() => {
        __webpack_require__.d = (exports, definition) => {
            for (var key in definition) if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) Object.defineProperty(exports, key, {
                enumerable: true,
                get: definition[key]
            });
        };
    })();
    (() => {
        __webpack_require__.g = function() {
            if (typeof globalThis === "object") return globalThis;
            try {
                return this || new Function("return this")();
            } catch (e) {
                if (typeof window === "object") return window;
            }
        }();
    })();
    (() => {
        __webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
    })();
    (() => {
        "use strict";
        const app_modules_flsModules = {};
        function app_addLoadedClass() {
            if (!document.documentElement.classList.contains("loading")) window.addEventListener("load", (function() {
                setTimeout((function() {
                    document.documentElement.classList.add("loaded");
                }), 0);
            }));
        }
        function app_getHash() {
            if (location.hash) return location.hash.replace("#", "");
        }
        function app_setHash(hash) {
            hash = hash ? `#${hash}` : window.location.href.split("#")[0];
            history.pushState("", "", hash);
        }
        let app_slideUp = (target, duration = 500, showmore = 0) => {
            if (!target.classList.contains("_slide")) {
                target.classList.add("_slide");
                target.style.transitionProperty = "height, margin, padding";
                target.style.transitionDuration = duration + "ms";
                target.style.height = `${target.offsetHeight}px`;
                target.offsetHeight;
                target.style.overflow = "hidden";
                target.style.height = showmore ? `${showmore}px` : `0px`;
                target.style.paddingTop = 0;
                target.style.paddingBottom = 0;
                target.style.marginTop = 0;
                target.style.marginBottom = 0;
                window.setTimeout((() => {
                    target.hidden = !showmore ? true : false;
                    !showmore ? target.style.removeProperty("height") : null;
                    target.style.removeProperty("padding-top");
                    target.style.removeProperty("padding-bottom");
                    target.style.removeProperty("margin-top");
                    target.style.removeProperty("margin-bottom");
                    !showmore ? target.style.removeProperty("overflow") : null;
                    target.style.removeProperty("transition-duration");
                    target.style.removeProperty("transition-property");
                    target.classList.remove("_slide");
                    document.dispatchEvent(new CustomEvent("slideUpDone", {
                        detail: {
                            target
                        }
                    }));
                }), duration);
            }
        };
        let app_slideDown = (target, duration = 500, showmore = 0) => {
            if (!target.classList.contains("_slide")) {
                target.classList.add("_slide");
                target.hidden = target.hidden ? false : null;
                showmore ? target.style.removeProperty("height") : null;
                let height = target.offsetHeight;
                target.style.overflow = "hidden";
                target.style.height = showmore ? `${showmore}px` : `0px`;
                target.style.paddingTop = 0;
                target.style.paddingBottom = 0;
                target.style.marginTop = 0;
                target.style.marginBottom = 0;
                target.offsetHeight;
                target.style.transitionProperty = "height, margin, padding";
                target.style.transitionDuration = duration + "ms";
                target.style.height = height + "px";
                target.style.removeProperty("padding-top");
                target.style.removeProperty("padding-bottom");
                target.style.removeProperty("margin-top");
                target.style.removeProperty("margin-bottom");
                window.setTimeout((() => {
                    target.style.removeProperty("height");
                    target.style.removeProperty("overflow");
                    target.style.removeProperty("transition-duration");
                    target.style.removeProperty("transition-property");
                    target.classList.remove("_slide");
                    document.dispatchEvent(new CustomEvent("slideDownDone", {
                        detail: {
                            target
                        }
                    }));
                }), duration);
            }
        };
        let app_bodyLockStatus = true;
        let app_bodyLockToggle = (delay = 500) => {
            if (document.documentElement.classList.contains("lock")) app_bodyUnlock(delay); else app_bodyLock(delay);
        };
        let app_bodyUnlock = (delay = 500) => {
            if (app_bodyLockStatus) {
                const lockPaddingElements = document.querySelectorAll("[data-lp]");
                setTimeout((() => {
                    lockPaddingElements.forEach((lockPaddingElement => {
                        lockPaddingElement.style.paddingRight = "";
                    }));
                    document.body.style.paddingRight = "";
                    document.documentElement.classList.remove("lock");
                }), delay);
                app_bodyLockStatus = false;
                setTimeout((function() {
                    app_bodyLockStatus = true;
                }), delay);
            }
        };
        let app_bodyLock = (delay = 500) => {
            if (app_bodyLockStatus) {
                const lockPaddingElements = document.querySelectorAll("[data-lp]");
                const lockPaddingValue = window.innerWidth - document.body.offsetWidth + "px";
                lockPaddingElements.forEach((lockPaddingElement => {
                    lockPaddingElement.style.paddingRight = lockPaddingValue;
                }));
                document.body.style.paddingRight = lockPaddingValue;
                document.documentElement.classList.add("lock");
                app_bodyLockStatus = false;
                setTimeout((function() {
                    app_bodyLockStatus = true;
                }), delay);
            }
        };
        function app_tabs() {
            const tabs = document.querySelectorAll("[data-tabs]");
            let tabsActiveHash = [];
            if (tabs.length > 0) {
                const hash = app_getHash();
                if (hash && hash.startsWith("tab-")) tabsActiveHash = hash.replace("tab-", "").split("-");
                tabs.forEach(((tabsBlock, index) => {
                    tabsBlock.classList.add("_tab-init");
                    tabsBlock.setAttribute("data-tabs-index", index);
                    tabsBlock.addEventListener("click", setTabsAction);
                    initTabs(tabsBlock);
                }));
                let mdQueriesArray = app_dataMediaQueries(tabs, "tabs");
                if (mdQueriesArray && mdQueriesArray.length) mdQueriesArray.forEach((mdQueriesItem => {
                    mdQueriesItem.matchMedia.addEventListener("change", (function() {
                        setTitlePosition(mdQueriesItem.itemsArray, mdQueriesItem.matchMedia);
                    }));
                    setTitlePosition(mdQueriesItem.itemsArray, mdQueriesItem.matchMedia);
                }));
            }
            function setTitlePosition(tabsMediaArray, matchMedia) {
                tabsMediaArray.forEach((tabsMediaItem => {
                    tabsMediaItem = tabsMediaItem.item;
                    let tabsTitles = tabsMediaItem.querySelector("[data-tabs-titles]");
                    let tabsTitleItems = tabsMediaItem.querySelectorAll("[data-tabs-title]");
                    let tabsContent = tabsMediaItem.querySelector("[data-tabs-body]");
                    let tabsContentItems = tabsMediaItem.querySelectorAll("[data-tabs-item]");
                    tabsTitleItems = Array.from(tabsTitleItems).filter((item => item.closest("[data-tabs]") === tabsMediaItem));
                    tabsContentItems = Array.from(tabsContentItems).filter((item => item.closest("[data-tabs]") === tabsMediaItem));
                    tabsContentItems.forEach(((tabsContentItem, index) => {
                        if (matchMedia.matches) {
                            tabsContent.append(tabsTitleItems[index]);
                            tabsContent.append(tabsContentItem);
                            tabsMediaItem.classList.add("_tab-spoller");
                        } else {
                            tabsTitles.append(tabsTitleItems[index]);
                            tabsMediaItem.classList.remove("_tab-spoller");
                        }
                    }));
                }));
            }
            function initTabs(tabsBlock) {
                let tabsTitles = tabsBlock.querySelectorAll("[data-tabs-titles]>*");
                let tabsContent = tabsBlock.querySelectorAll("[data-tabs-body]>*");
                const tabsBlockIndex = tabsBlock.dataset.tabsIndex;
                const tabsActiveHashBlock = tabsActiveHash[0] == tabsBlockIndex;
                if (tabsActiveHashBlock) {
                    const tabsActiveTitle = tabsBlock.querySelector("[data-tabs-titles]>._tab-active");
                    tabsActiveTitle ? tabsActiveTitle.classList.remove("_tab-active") : null;
                }
                if (tabsContent.length) tabsContent.forEach(((tabsContentItem, index) => {
                    tabsTitles[index].setAttribute("data-tabs-title", "");
                    tabsContentItem.setAttribute("data-tabs-item", "");
                    if (tabsActiveHashBlock && index == tabsActiveHash[1]) tabsTitles[index].classList.add("_tab-active");
                    tabsContentItem.hidden = !tabsTitles[index].classList.contains("_tab-active");
                }));
            }
            function setTabsStatus(tabsBlock) {
                let tabsTitles = tabsBlock.querySelectorAll("[data-tabs-title]");
                let tabsContent = tabsBlock.querySelectorAll("[data-tabs-item]");
                const tabsBlockIndex = tabsBlock.dataset.tabsIndex;
                function isTabsAnamate(tabsBlock) {
                    if (tabsBlock.hasAttribute("data-tabs-animate")) return tabsBlock.dataset.tabsAnimate > 0 ? Number(tabsBlock.dataset.tabsAnimate) : 500;
                }
                const tabsBlockAnimate = isTabsAnamate(tabsBlock);
                if (tabsContent.length > 0) {
                    const isHash = tabsBlock.hasAttribute("data-tabs-hash");
                    tabsContent = Array.from(tabsContent).filter((item => item.closest("[data-tabs]") === tabsBlock));
                    tabsTitles = Array.from(tabsTitles).filter((item => item.closest("[data-tabs]") === tabsBlock));
                    tabsContent.forEach(((tabsContentItem, index) => {
                        if (tabsTitles[index].classList.contains("_tab-active")) {
                            if (tabsBlockAnimate) app_slideDown(tabsContentItem, tabsBlockAnimate); else tabsContentItem.hidden = false;
                            if (isHash && !tabsContentItem.closest(".popup")) app_setHash(`tab-${tabsBlockIndex}-${index}`);
                        } else if (tabsBlockAnimate) app_slideUp(tabsContentItem, tabsBlockAnimate); else tabsContentItem.hidden = true;
                    }));
                }
            }
            function setTabsAction(e) {
                const el = e.target;
                if (el.closest("[data-tabs-title]")) {
                    const tabTitle = el.closest("[data-tabs-title]");
                    const tabsBlock = tabTitle.closest("[data-tabs]");
                    if (!tabTitle.classList.contains("_tab-active") && !tabsBlock.querySelector("._slide")) {
                        let tabActiveTitle = tabsBlock.querySelectorAll("[data-tabs-title]._tab-active");
                        tabActiveTitle.length ? tabActiveTitle = Array.from(tabActiveTitle).filter((item => item.closest("[data-tabs]") === tabsBlock)) : null;
                        tabActiveTitle.length ? tabActiveTitle[0].classList.remove("_tab-active") : null;
                        tabTitle.classList.add("_tab-active");
                        setTabsStatus(tabsBlock);
                    }
                    e.preventDefault();
                }
            }
        }
        function app_menuInit() {
            if (document.querySelector(".icon-menu")) document.addEventListener("click", (function(e) {
                if (app_bodyLockStatus && e.target.closest(".icon-menu")) {
                    app_bodyLockToggle();
                    document.documentElement.classList.toggle("menu-open");
                }
            }));
        }
        function app_menuClose() {
            app_bodyUnlock();
            document.documentElement.classList.remove("menu-open");
        }
        function app_functions_FLS(message) {
            setTimeout((() => {
                if (window.FLS) console.log(message);
            }), 0);
        }
        function app_uniqArray(array) {
            return array.filter((function(item, index, self) {
                return self.indexOf(item) === index;
            }));
        }
        function app_dataMediaQueries(array, dataSetValue) {
            const media = Array.from(array).filter((function(item, index, self) {
                if (item.dataset[dataSetValue]) return item.dataset[dataSetValue].split(",")[0];
            }));
            if (media.length) {
                const breakpointsArray = [];
                media.forEach((item => {
                    const params = item.dataset[dataSetValue];
                    const breakpoint = {};
                    const paramsArray = params.split(",");
                    breakpoint.value = paramsArray[0];
                    breakpoint.type = paramsArray[1] ? paramsArray[1].trim() : "max";
                    breakpoint.item = item;
                    breakpointsArray.push(breakpoint);
                }));
                let mdQueries = breakpointsArray.map((function(item) {
                    return "(" + item.type + "-width: " + item.value + "px)," + item.value + "," + item.type;
                }));
                mdQueries = app_uniqArray(mdQueries);
                const mdQueriesArray = [];
                if (mdQueries.length) {
                    mdQueries.forEach((breakpoint => {
                        const paramsArray = breakpoint.split(",");
                        const mediaBreakpoint = paramsArray[1];
                        const mediaType = paramsArray[2];
                        const matchMedia = window.matchMedia(paramsArray[0]);
                        const itemsArray = breakpointsArray.filter((function(item) {
                            if (item.value === mediaBreakpoint && item.type === mediaType) return true;
                        }));
                        mdQueriesArray.push({
                            itemsArray,
                            matchMedia
                        });
                    }));
                    return mdQueriesArray;
                }
            }
        }
        let app_gotoblock_gotoBlock = (targetBlock, noHeader = false, speed = 500, offsetTop = 0) => {
            const targetBlockElement = document.querySelector(targetBlock);
            if (targetBlockElement) {
                let headerItem = "";
                let headerItemHeight = 0;
                if (noHeader) {
                    headerItem = "header.header";
                    const headerElement = document.querySelector(headerItem);
                    if (!headerElement.classList.contains("_header-scroll")) {
                        headerElement.style.cssText = `transition-duration: 0s;`;
                        headerElement.classList.add("_header-scroll");
                        headerItemHeight = headerElement.offsetHeight;
                        headerElement.classList.remove("_header-scroll");
                        setTimeout((() => {
                            headerElement.style.cssText = ``;
                        }), 0);
                    } else headerItemHeight = headerElement.offsetHeight;
                }
                let options = {
                    speedAsDuration: true,
                    speed,
                    header: headerItem,
                    offset: offsetTop,
                    easing: "easeOutQuad"
                };
                document.documentElement.classList.contains("menu-open") ? app_menuClose() : null;
                if (typeof SmoothScroll !== "undefined") (new SmoothScroll).animateScroll(targetBlockElement, "", options); else {
                    let targetBlockElementPosition = targetBlockElement.getBoundingClientRect().top + scrollY;
                    targetBlockElementPosition = headerItemHeight ? targetBlockElementPosition - headerItemHeight : targetBlockElementPosition;
                    targetBlockElementPosition = offsetTop ? targetBlockElementPosition - offsetTop : targetBlockElementPosition;
                    window.scrollTo({
                        top: targetBlockElementPosition,
                        behavior: "smooth"
                    });
                }
                app_functions_FLS(`[gotoBlock]: –Æ—Ö—É—É...—ó–¥–µ–º–æ –¥–æ ${targetBlock}`);
            } else app_functions_FLS(`[gotoBlock]: –ô–æ–π... –¢–∞–∫–æ–≥–æ –±–ª–æ–∫—É –Ω–µ–º–∞—î –Ω–∞ —Å—Ç–æ—Ä—ñ–Ω—Ü—ñ: ${targetBlock}`);
        };
        function app_isObject(obj) {
            return obj !== null && typeof obj === "object" && "constructor" in obj && obj.constructor === Object;
        }
        function app_extend(target, src) {
            if (target === void 0) target = {};
            if (src === void 0) src = {};
            Object.keys(src).forEach((key => {
                if (typeof target[key] === "undefined") target[key] = src[key]; else if (app_isObject(src[key]) && app_isObject(target[key]) && Object.keys(src[key]).length > 0) app_extend(target[key], src[key]);
            }));
        }
        const app_ssrDocument = {
            body: {},
            addEventListener() {},
            removeEventListener() {},
            activeElement: {
                blur() {},
                nodeName: ""
            },
            querySelector() {
                return null;
            },
            querySelectorAll() {
                return [];
            },
            getElementById() {
                return null;
            },
            createEvent() {
                return {
                    initEvent() {}
                };
            },
            createElement() {
                return {
                    children: [],
                    childNodes: [],
                    style: {},
                    setAttribute() {},
                    getElementsByTagName() {
                        return [];
                    }
                };
            },
            createElementNS() {
                return {};
            },
            importNode() {
                return null;
            },
            location: {
                hash: "",
                host: "",
                hostname: "",
                href: "",
                origin: "",
                pathname: "",
                protocol: "",
                search: ""
            }
        };
        function app_ssr_window_esm_getDocument() {
            const doc = typeof document !== "undefined" ? document : {};
            app_extend(doc, app_ssrDocument);
            return doc;
        }
        const app_ssrWindow = {
            document: app_ssrDocument,
            navigator: {
                userAgent: ""
            },
            location: {
                hash: "",
                host: "",
                hostname: "",
                href: "",
                origin: "",
                pathname: "",
                protocol: "",
                search: ""
            },
            history: {
                replaceState() {},
                pushState() {},
                go() {},
                back() {}
            },
            CustomEvent: function CustomEvent() {
                return this;
            },
            addEventListener() {},
            removeEventListener() {},
            getComputedStyle() {
                return {
                    getPropertyValue() {
                        return "";
                    }
                };
            },
            Image() {},
            Date() {},
            screen: {},
            setTimeout() {},
            clearTimeout() {},
            matchMedia() {
                return {};
            },
            requestAnimationFrame(callback) {
                if (typeof setTimeout === "undefined") {
                    callback();
                    return null;
                }
                return setTimeout(callback, 0);
            },
            cancelAnimationFrame(id) {
                if (typeof setTimeout === "undefined") return;
                clearTimeout(id);
            }
        };
        function app_ssr_window_esm_getWindow() {
            const win = typeof window !== "undefined" ? window : {};
            app_extend(win, app_ssrWindow);
            return win;
        }
        function app_utils_classesToTokens(classes) {
            if (classes === void 0) classes = "";
            return classes.trim().split(" ").filter((c => !!c.trim()));
        }
        function app_deleteProps(obj) {
            const object = obj;
            Object.keys(object).forEach((key => {
                try {
                    object[key] = null;
                } catch (e) {}
                try {
                    delete object[key];
                } catch (e) {}
            }));
        }
        function app_utils_nextTick(callback, delay) {
            if (delay === void 0) delay = 0;
            return setTimeout(callback, delay);
        }
        function app_now() {
            return Date.now();
        }
        function app_utils_getComputedStyle(el) {
            const window = app_ssr_window_esm_getWindow();
            let style;
            if (window.getComputedStyle) style = window.getComputedStyle(el, null);
            if (!style && el.currentStyle) style = el.currentStyle;
            if (!style) style = el.style;
            return style;
        }
        function app_utils_getTranslate(el, axis) {
            if (axis === void 0) axis = "x";
            const window = app_ssr_window_esm_getWindow();
            let matrix;
            let curTransform;
            let transformMatrix;
            const curStyle = app_utils_getComputedStyle(el);
            if (window.WebKitCSSMatrix) {
                curTransform = curStyle.transform || curStyle.webkitTransform;
                if (curTransform.split(",").length > 6) curTransform = curTransform.split(", ").map((a => a.replace(",", "."))).join(", ");
                transformMatrix = new window.WebKitCSSMatrix(curTransform === "none" ? "" : curTransform);
            } else {
                transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,");
                matrix = transformMatrix.toString().split(",");
            }
            if (axis === "x") if (window.WebKitCSSMatrix) curTransform = transformMatrix.m41; else if (matrix.length === 16) curTransform = parseFloat(matrix[12]); else curTransform = parseFloat(matrix[4]);
            if (axis === "y") if (window.WebKitCSSMatrix) curTransform = transformMatrix.m42; else if (matrix.length === 16) curTransform = parseFloat(matrix[13]); else curTransform = parseFloat(matrix[5]);
            return curTransform || 0;
        }
        function app_utils_isObject(o) {
            return typeof o === "object" && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === "Object";
        }
        function app_isNode(node) {
            if (typeof window !== "undefined" && typeof window.HTMLElement !== "undefined") return node instanceof HTMLElement;
            return node && (node.nodeType === 1 || node.nodeType === 11);
        }
        function app_utils_extend() {
            const to = Object(arguments.length <= 0 ? void 0 : arguments[0]);
            const noExtend = [ "__proto__", "constructor", "prototype" ];
            for (let i = 1; i < arguments.length; i += 1) {
                const nextSource = i < 0 || arguments.length <= i ? void 0 : arguments[i];
                if (nextSource !== void 0 && nextSource !== null && !app_isNode(nextSource)) {
                    const keysArray = Object.keys(Object(nextSource)).filter((key => noExtend.indexOf(key) < 0));
                    for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
                        const nextKey = keysArray[nextIndex];
                        const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
                        if (desc !== void 0 && desc.enumerable) if (app_utils_isObject(to[nextKey]) && app_utils_isObject(nextSource[nextKey])) if (nextSource[nextKey].__swiper__) to[nextKey] = nextSource[nextKey]; else app_utils_extend(to[nextKey], nextSource[nextKey]); else if (!app_utils_isObject(to[nextKey]) && app_utils_isObject(nextSource[nextKey])) {
                            to[nextKey] = {};
                            if (nextSource[nextKey].__swiper__) to[nextKey] = nextSource[nextKey]; else app_utils_extend(to[nextKey], nextSource[nextKey]);
                        } else to[nextKey] = nextSource[nextKey];
                    }
                }
            }
            return to;
        }
        function app_utils_setCSSProperty(el, varName, varValue) {
            el.style.setProperty(varName, varValue);
        }
        function app_animateCSSModeScroll(_ref) {
            let {swiper, targetPosition, side} = _ref;
            const window = app_ssr_window_esm_getWindow();
            const startPosition = -swiper.translate;
            let startTime = null;
            let time;
            const duration = swiper.params.speed;
            swiper.wrapperEl.style.scrollSnapType = "none";
            window.cancelAnimationFrame(swiper.cssModeFrameID);
            const dir = targetPosition > startPosition ? "next" : "prev";
            const isOutOfBound = (current, target) => dir === "next" && current >= target || dir === "prev" && current <= target;
            const animate = () => {
                time = (new Date).getTime();
                if (startTime === null) startTime = time;
                const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);
                const easeProgress = .5 - Math.cos(progress * Math.PI) / 2;
                let currentPosition = startPosition + easeProgress * (targetPosition - startPosition);
                if (isOutOfBound(currentPosition, targetPosition)) currentPosition = targetPosition;
                swiper.wrapperEl.scrollTo({
                    [side]: currentPosition
                });
                if (isOutOfBound(currentPosition, targetPosition)) {
                    swiper.wrapperEl.style.overflow = "hidden";
                    swiper.wrapperEl.style.scrollSnapType = "";
                    setTimeout((() => {
                        swiper.wrapperEl.style.overflow = "";
                        swiper.wrapperEl.scrollTo({
                            [side]: currentPosition
                        });
                    }));
                    window.cancelAnimationFrame(swiper.cssModeFrameID);
                    return;
                }
                swiper.cssModeFrameID = window.requestAnimationFrame(animate);
            };
            animate();
        }
        function app_utils_getSlideTransformEl(slideEl) {
            return slideEl.querySelector(".swiper-slide-transform") || slideEl.shadowRoot && slideEl.shadowRoot.querySelector(".swiper-slide-transform") || slideEl;
        }
        function app_utils_elementChildren(element, selector) {
            if (selector === void 0) selector = "";
            const children = [ ...element.children ];
            if (element instanceof HTMLSlotElement) children.push(...element.assignedElements());
            if (!selector) return children;
            return children.filter((el => el.matches(selector)));
        }
        function app_elementIsChildOf(el, parent) {
            const isChild = parent.contains(el);
            if (!isChild && parent instanceof HTMLSlotElement) {
                const children = [ ...parent.assignedElements() ];
                return children.includes(el);
            }
            return isChild;
        }
        function app_showWarning(text) {
            try {
                console.warn(text);
                return;
            } catch (err) {}
        }
        function app_utils_createElement(tag, classes) {
            if (classes === void 0) classes = [];
            const el = document.createElement(tag);
            el.classList.add(...Array.isArray(classes) ? classes : app_utils_classesToTokens(classes));
            return el;
        }
        function app_elementPrevAll(el, selector) {
            const prevEls = [];
            while (el.previousElementSibling) {
                const prev = el.previousElementSibling;
                if (selector) {
                    if (prev.matches(selector)) prevEls.push(prev);
                } else prevEls.push(prev);
                el = prev;
            }
            return prevEls;
        }
        function app_elementNextAll(el, selector) {
            const nextEls = [];
            while (el.nextElementSibling) {
                const next = el.nextElementSibling;
                if (selector) {
                    if (next.matches(selector)) nextEls.push(next);
                } else nextEls.push(next);
                el = next;
            }
            return nextEls;
        }
        function app_elementStyle(el, prop) {
            const window = app_ssr_window_esm_getWindow();
            return window.getComputedStyle(el, null).getPropertyValue(prop);
        }
        function app_utils_elementIndex(el) {
            let child = el;
            let i;
            if (child) {
                i = 0;
                while ((child = child.previousSibling) !== null) if (child.nodeType === 1) i += 1;
                return i;
            }
            return;
        }
        function app_utils_elementParents(el, selector) {
            const parents = [];
            let parent = el.parentElement;
            while (parent) {
                if (selector) {
                    if (parent.matches(selector)) parents.push(parent);
                } else parents.push(parent);
                parent = parent.parentElement;
            }
            return parents;
        }
        function app_utils_elementTransitionEnd(el, callback) {
            function fireCallBack(e) {
                if (e.target !== el) return;
                callback.call(el, e);
                el.removeEventListener("transitionend", fireCallBack);
            }
            if (callback) el.addEventListener("transitionend", fireCallBack);
        }
        function app_elementOuterSize(el, size, includeMargins) {
            const window = app_ssr_window_esm_getWindow();
            if (includeMargins) return el[size === "width" ? "offsetWidth" : "offsetHeight"] + parseFloat(window.getComputedStyle(el, null).getPropertyValue(size === "width" ? "margin-right" : "margin-top")) + parseFloat(window.getComputedStyle(el, null).getPropertyValue(size === "width" ? "margin-left" : "margin-bottom"));
            return el.offsetWidth;
        }
        function app_utils_makeElementsArray(el) {
            return (Array.isArray(el) ? el : [ el ]).filter((e => !!e));
        }
        let app_support;
        function app_calcSupport() {
            const window = app_ssr_window_esm_getWindow();
            const document = app_ssr_window_esm_getDocument();
            return {
                smoothScroll: document.documentElement && document.documentElement.style && "scrollBehavior" in document.documentElement.style,
                touch: !!("ontouchstart" in window || window.DocumentTouch && document instanceof window.DocumentTouch)
            };
        }
        function app_getSupport() {
            if (!app_support) app_support = app_calcSupport();
            return app_support;
        }
        let app_deviceCached;
        function app_calcDevice(_temp) {
            let {userAgent} = _temp === void 0 ? {} : _temp;
            const support = app_getSupport();
            const window = app_ssr_window_esm_getWindow();
            const platform = window.navigator.platform;
            const ua = userAgent || window.navigator.userAgent;
            const device = {
                ios: false,
                android: false
            };
            const screenWidth = window.screen.width;
            const screenHeight = window.screen.height;
            const android = ua.match(/(Android);?[\s\/]+([\d.]+)?/);
            let ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
            const ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
            const iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
            const windows = platform === "Win32";
            let macos = platform === "MacIntel";
            const iPadScreens = [ "1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810" ];
            if (!ipad && macos && support.touch && iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0) {
                ipad = ua.match(/(Version)\/([\d.]+)/);
                if (!ipad) ipad = [ 0, 1, "13_0_0" ];
                macos = false;
            }
            if (android && !windows) {
                device.os = "android";
                device.android = true;
            }
            if (ipad || iphone || ipod) {
                device.os = "ios";
                device.ios = true;
            }
            return device;
        }
        function app_getDevice(overrides) {
            if (overrides === void 0) overrides = {};
            if (!app_deviceCached) app_deviceCached = app_calcDevice(overrides);
            return app_deviceCached;
        }
        let app_browser;
        function app_calcBrowser() {
            const window = app_ssr_window_esm_getWindow();
            const device = app_getDevice();
            let needPerspectiveFix = false;
            function isSafari() {
                const ua = window.navigator.userAgent.toLowerCase();
                return ua.indexOf("safari") >= 0 && ua.indexOf("chrome") < 0 && ua.indexOf("android") < 0;
            }
            if (isSafari()) {
                const ua = String(window.navigator.userAgent);
                if (ua.includes("Version/")) {
                    const [major, minor] = ua.split("Version/")[1].split(" ")[0].split(".").map((num => Number(num)));
                    needPerspectiveFix = major < 16 || major === 16 && minor < 2;
                }
            }
            const isWebView = /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window.navigator.userAgent);
            const isSafariBrowser = isSafari();
            const need3dFix = isSafariBrowser || isWebView && device.ios;
            return {
                isSafari: needPerspectiveFix || isSafariBrowser,
                needPerspectiveFix,
                need3dFix,
                isWebView
            };
        }
        function app_getBrowser() {
            if (!app_browser) app_browser = app_calcBrowser();
            return app_browser;
        }
        function app_Resize(_ref) {
            let {swiper, on, emit} = _ref;
            const window = app_ssr_window_esm_getWindow();
            let observer = null;
            let animationFrame = null;
            const resizeHandler = () => {
                if (!swiper || swiper.destroyed || !swiper.initialized) return;
                emit("beforeResize");
                emit("resize");
            };
            const createObserver = () => {
                if (!swiper || swiper.destroyed || !swiper.initialized) return;
                observer = new ResizeObserver((entries => {
                    animationFrame = window.requestAnimationFrame((() => {
                        const {width, height} = swiper;
                        let newWidth = width;
                        let newHeight = height;
                        entries.forEach((_ref2 => {
                            let {contentBoxSize, contentRect, target} = _ref2;
                            if (target && target !== swiper.el) return;
                            newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;
                            newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;
                        }));
                        if (newWidth !== width || newHeight !== height) resizeHandler();
                    }));
                }));
                observer.observe(swiper.el);
            };
            const removeObserver = () => {
                if (animationFrame) window.cancelAnimationFrame(animationFrame);
                if (observer && observer.unobserve && swiper.el) {
                    observer.unobserve(swiper.el);
                    observer = null;
                }
            };
            const orientationChangeHandler = () => {
                if (!swiper || swiper.destroyed || !swiper.initialized) return;
                emit("orientationchange");
            };
            on("init", (() => {
                if (swiper.params.resizeObserver && typeof window.ResizeObserver !== "undefined") {
                    createObserver();
                    return;
                }
                window.addEventListener("resize", resizeHandler);
                window.addEventListener("orientationchange", orientationChangeHandler);
            }));
            on("destroy", (() => {
                removeObserver();
                window.removeEventListener("resize", resizeHandler);
                window.removeEventListener("orientationchange", orientationChangeHandler);
            }));
        }
        function app_Observer(_ref) {
            let {swiper, extendParams, on, emit} = _ref;
            const observers = [];
            const window = app_ssr_window_esm_getWindow();
            const attach = function(target, options) {
                if (options === void 0) options = {};
                const ObserverFunc = window.MutationObserver || window.WebkitMutationObserver;
                const observer = new ObserverFunc((mutations => {
                    if (swiper.__preventObserver__) return;
                    if (mutations.length === 1) {
                        emit("observerUpdate", mutations[0]);
                        return;
                    }
                    const observerUpdate = function observerUpdate() {
                        emit("observerUpdate", mutations[0]);
                    };
                    if (window.requestAnimationFrame) window.requestAnimationFrame(observerUpdate); else window.setTimeout(observerUpdate, 0);
                }));
                observer.observe(target, {
                    attributes: typeof options.attributes === "undefined" ? true : options.attributes,
                    childList: swiper.isElement || (typeof options.childList === "undefined" ? true : options).childList,
                    characterData: typeof options.characterData === "undefined" ? true : options.characterData
                });
                observers.push(observer);
            };
            const init = () => {
                if (!swiper.params.observer) return;
                if (swiper.params.observeParents) {
                    const containerParents = app_utils_elementParents(swiper.hostEl);
                    for (let i = 0; i < containerParents.length; i += 1) attach(containerParents[i]);
                }
                attach(swiper.hostEl, {
                    childList: swiper.params.observeSlideChildren
                });
                attach(swiper.wrapperEl, {
                    attributes: false
                });
            };
            const destroy = () => {
                observers.forEach((observer => {
                    observer.disconnect();
                }));
                observers.splice(0, observers.length);
            };
            extendParams({
                observer: false,
                observeParents: false,
                observeSlideChildren: false
            });
            on("init", init);
            on("destroy", destroy);
        }
        var app_eventsEmitter = {
            on(events, handler, priority) {
                const self = this;
                if (!self.eventsListeners || self.destroyed) return self;
                if (typeof handler !== "function") return self;
                const method = priority ? "unshift" : "push";
                events.split(" ").forEach((event => {
                    if (!self.eventsListeners[event]) self.eventsListeners[event] = [];
                    self.eventsListeners[event][method](handler);
                }));
                return self;
            },
            once(events, handler, priority) {
                const self = this;
                if (!self.eventsListeners || self.destroyed) return self;
                if (typeof handler !== "function") return self;
                function onceHandler() {
                    self.off(events, onceHandler);
                    if (onceHandler.__emitterProxy) delete onceHandler.__emitterProxy;
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                    handler.apply(self, args);
                }
                onceHandler.__emitterProxy = handler;
                return self.on(events, onceHandler, priority);
            },
            onAny(handler, priority) {
                const self = this;
                if (!self.eventsListeners || self.destroyed) return self;
                if (typeof handler !== "function") return self;
                const method = priority ? "unshift" : "push";
                if (self.eventsAnyListeners.indexOf(handler) < 0) self.eventsAnyListeners[method](handler);
                return self;
            },
            offAny(handler) {
                const self = this;
                if (!self.eventsListeners || self.destroyed) return self;
                if (!self.eventsAnyListeners) return self;
                const index = self.eventsAnyListeners.indexOf(handler);
                if (index >= 0) self.eventsAnyListeners.splice(index, 1);
                return self;
            },
            off(events, handler) {
                const self = this;
                if (!self.eventsListeners || self.destroyed) return self;
                if (!self.eventsListeners) return self;
                events.split(" ").forEach((event => {
                    if (typeof handler === "undefined") self.eventsListeners[event] = []; else if (self.eventsListeners[event]) self.eventsListeners[event].forEach(((eventHandler, index) => {
                        if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) self.eventsListeners[event].splice(index, 1);
                    }));
                }));
                return self;
            },
            emit() {
                const self = this;
                if (!self.eventsListeners || self.destroyed) return self;
                if (!self.eventsListeners) return self;
                let events;
                let data;
                let context;
                for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) args[_key2] = arguments[_key2];
                if (typeof args[0] === "string" || Array.isArray(args[0])) {
                    events = args[0];
                    data = args.slice(1, args.length);
                    context = self;
                } else {
                    events = args[0].events;
                    data = args[0].data;
                    context = args[0].context || self;
                }
                data.unshift(context);
                const eventsArray = Array.isArray(events) ? events : events.split(" ");
                eventsArray.forEach((event => {
                    if (self.eventsAnyListeners && self.eventsAnyListeners.length) self.eventsAnyListeners.forEach((eventHandler => {
                        eventHandler.apply(context, [ event, ...data ]);
                    }));
                    if (self.eventsListeners && self.eventsListeners[event]) self.eventsListeners[event].forEach((eventHandler => {
                        eventHandler.apply(context, data);
                    }));
                }));
                return self;
            }
        };
        function app_updateSize() {
            const swiper = this;
            let width;
            let height;
            const el = swiper.el;
            if (typeof swiper.params.width !== "undefined" && swiper.params.width !== null) width = swiper.params.width; else width = el.clientWidth;
            if (typeof swiper.params.height !== "undefined" && swiper.params.height !== null) height = swiper.params.height; else height = el.clientHeight;
            if (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) return;
            width = width - parseInt(app_elementStyle(el, "padding-left") || 0, 10) - parseInt(app_elementStyle(el, "padding-right") || 0, 10);
            height = height - parseInt(app_elementStyle(el, "padding-top") || 0, 10) - parseInt(app_elementStyle(el, "padding-bottom") || 0, 10);
            if (Number.isNaN(width)) width = 0;
            if (Number.isNaN(height)) height = 0;
            Object.assign(swiper, {
                width,
                height,
                size: swiper.isHorizontal() ? width : height
            });
        }
        function app_updateSlides() {
            const swiper = this;
            function getDirectionPropertyValue(node, label) {
                return parseFloat(node.getPropertyValue(swiper.getDirectionLabel(label)) || 0);
            }
            const params = swiper.params;
            const {wrapperEl, slidesEl, size: swiperSize, rtlTranslate: rtl, wrongRTL} = swiper;
            const isVirtual = swiper.virtual && params.virtual.enabled;
            const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;
            const slides = app_utils_elementChildren(slidesEl, `.${swiper.params.slideClass}, swiper-slide`);
            const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
            let snapGrid = [];
            const slidesGrid = [];
            const slidesSizesGrid = [];
            let offsetBefore = params.slidesOffsetBefore;
            if (typeof offsetBefore === "function") offsetBefore = params.slidesOffsetBefore.call(swiper);
            let offsetAfter = params.slidesOffsetAfter;
            if (typeof offsetAfter === "function") offsetAfter = params.slidesOffsetAfter.call(swiper);
            const previousSnapGridLength = swiper.snapGrid.length;
            const previousSlidesGridLength = swiper.slidesGrid.length;
            let spaceBetween = params.spaceBetween;
            let slidePosition = -offsetBefore;
            let prevSlideSize = 0;
            let index = 0;
            if (typeof swiperSize === "undefined") return;
            if (typeof spaceBetween === "string" && spaceBetween.indexOf("%") >= 0) spaceBetween = parseFloat(spaceBetween.replace("%", "")) / 100 * swiperSize; else if (typeof spaceBetween === "string") spaceBetween = parseFloat(spaceBetween);
            swiper.virtualSize = -spaceBetween;
            slides.forEach((slideEl => {
                if (rtl) slideEl.style.marginLeft = ""; else slideEl.style.marginRight = "";
                slideEl.style.marginBottom = "";
                slideEl.style.marginTop = "";
            }));
            if (params.centeredSlides && params.cssMode) {
                app_utils_setCSSProperty(wrapperEl, "--swiper-centered-offset-before", "");
                app_utils_setCSSProperty(wrapperEl, "--swiper-centered-offset-after", "");
            }
            const gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;
            if (gridEnabled) swiper.grid.initSlides(slides); else if (swiper.grid) swiper.grid.unsetSlides();
            let slideSize;
            const shouldResetSlideSize = params.slidesPerView === "auto" && params.breakpoints && Object.keys(params.breakpoints).filter((key => typeof params.breakpoints[key].slidesPerView !== "undefined")).length > 0;
            for (let i = 0; i < slidesLength; i += 1) {
                slideSize = 0;
                let slide;
                if (slides[i]) slide = slides[i];
                if (gridEnabled) swiper.grid.updateSlide(i, slide, slides);
                if (slides[i] && app_elementStyle(slide, "display") === "none") continue;
                if (params.slidesPerView === "auto") {
                    if (shouldResetSlideSize) slides[i].style[swiper.getDirectionLabel("width")] = ``;
                    const slideStyles = getComputedStyle(slide);
                    const currentTransform = slide.style.transform;
                    const currentWebKitTransform = slide.style.webkitTransform;
                    if (currentTransform) slide.style.transform = "none";
                    if (currentWebKitTransform) slide.style.webkitTransform = "none";
                    if (params.roundLengths) slideSize = swiper.isHorizontal() ? app_elementOuterSize(slide, "width", true) : app_elementOuterSize(slide, "height", true); else {
                        const width = getDirectionPropertyValue(slideStyles, "width");
                        const paddingLeft = getDirectionPropertyValue(slideStyles, "padding-left");
                        const paddingRight = getDirectionPropertyValue(slideStyles, "padding-right");
                        const marginLeft = getDirectionPropertyValue(slideStyles, "margin-left");
                        const marginRight = getDirectionPropertyValue(slideStyles, "margin-right");
                        const boxSizing = slideStyles.getPropertyValue("box-sizing");
                        if (boxSizing && boxSizing === "border-box") slideSize = width + marginLeft + marginRight; else {
                            const {clientWidth, offsetWidth} = slide;
                            slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);
                        }
                    }
                    if (currentTransform) slide.style.transform = currentTransform;
                    if (currentWebKitTransform) slide.style.webkitTransform = currentWebKitTransform;
                    if (params.roundLengths) slideSize = Math.floor(slideSize);
                } else {
                    slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;
                    if (params.roundLengths) slideSize = Math.floor(slideSize);
                    if (slides[i]) slides[i].style[swiper.getDirectionLabel("width")] = `${slideSize}px`;
                }
                if (slides[i]) slides[i].swiperSlideSize = slideSize;
                slidesSizesGrid.push(slideSize);
                if (params.centeredSlides) {
                    slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
                    if (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
                    if (i === 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
                    if (Math.abs(slidePosition) < 1 / 1e3) slidePosition = 0;
                    if (params.roundLengths) slidePosition = Math.floor(slidePosition);
                    if (index % params.slidesPerGroup === 0) snapGrid.push(slidePosition);
                    slidesGrid.push(slidePosition);
                } else {
                    if (params.roundLengths) slidePosition = Math.floor(slidePosition);
                    if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0) snapGrid.push(slidePosition);
                    slidesGrid.push(slidePosition);
                    slidePosition = slidePosition + slideSize + spaceBetween;
                }
                swiper.virtualSize += slideSize + spaceBetween;
                prevSlideSize = slideSize;
                index += 1;
            }
            swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;
            if (rtl && wrongRTL && (params.effect === "slide" || params.effect === "coverflow")) wrapperEl.style.width = `${swiper.virtualSize + spaceBetween}px`;
            if (params.setWrapperSize) wrapperEl.style[swiper.getDirectionLabel("width")] = `${swiper.virtualSize + spaceBetween}px`;
            if (gridEnabled) swiper.grid.updateWrapperSize(slideSize, snapGrid);
            if (!params.centeredSlides) {
                const newSlidesGrid = [];
                for (let i = 0; i < snapGrid.length; i += 1) {
                    let slidesGridItem = snapGrid[i];
                    if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);
                    if (snapGrid[i] <= swiper.virtualSize - swiperSize) newSlidesGrid.push(slidesGridItem);
                }
                snapGrid = newSlidesGrid;
                if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) snapGrid.push(swiper.virtualSize - swiperSize);
            }
            if (isVirtual && params.loop) {
                const size = slidesSizesGrid[0] + spaceBetween;
                if (params.slidesPerGroup > 1) {
                    const groups = Math.ceil((swiper.virtual.slidesBefore + swiper.virtual.slidesAfter) / params.slidesPerGroup);
                    const groupSize = size * params.slidesPerGroup;
                    for (let i = 0; i < groups; i += 1) snapGrid.push(snapGrid[snapGrid.length - 1] + groupSize);
                }
                for (let i = 0; i < swiper.virtual.slidesBefore + swiper.virtual.slidesAfter; i += 1) {
                    if (params.slidesPerGroup === 1) snapGrid.push(snapGrid[snapGrid.length - 1] + size);
                    slidesGrid.push(slidesGrid[slidesGrid.length - 1] + size);
                    swiper.virtualSize += size;
                }
            }
            if (snapGrid.length === 0) snapGrid = [ 0 ];
            if (spaceBetween !== 0) {
                const key = swiper.isHorizontal() && rtl ? "marginLeft" : swiper.getDirectionLabel("marginRight");
                slides.filter(((_, slideIndex) => {
                    if (!params.cssMode || params.loop) return true;
                    if (slideIndex === slides.length - 1) return false;
                    return true;
                })).forEach((slideEl => {
                    slideEl.style[key] = `${spaceBetween}px`;
                }));
            }
            if (params.centeredSlides && params.centeredSlidesBounds) {
                let allSlidesSize = 0;
                slidesSizesGrid.forEach((slideSizeValue => {
                    allSlidesSize += slideSizeValue + (spaceBetween || 0);
                }));
                allSlidesSize -= spaceBetween;
                const maxSnap = allSlidesSize > swiperSize ? allSlidesSize - swiperSize : 0;
                snapGrid = snapGrid.map((snap => {
                    if (snap <= 0) return -offsetBefore;
                    if (snap > maxSnap) return maxSnap + offsetAfter;
                    return snap;
                }));
            }
            if (params.centerInsufficientSlides) {
                let allSlidesSize = 0;
                slidesSizesGrid.forEach((slideSizeValue => {
                    allSlidesSize += slideSizeValue + (spaceBetween || 0);
                }));
                allSlidesSize -= spaceBetween;
                const offsetSize = (params.slidesOffsetBefore || 0) + (params.slidesOffsetAfter || 0);
                if (allSlidesSize + offsetSize < swiperSize) {
                    const allSlidesOffset = (swiperSize - allSlidesSize - offsetSize) / 2;
                    snapGrid.forEach(((snap, snapIndex) => {
                        snapGrid[snapIndex] = snap - allSlidesOffset;
                    }));
                    slidesGrid.forEach(((snap, snapIndex) => {
                        slidesGrid[snapIndex] = snap + allSlidesOffset;
                    }));
                }
            }
            Object.assign(swiper, {
                slides,
                snapGrid,
                slidesGrid,
                slidesSizesGrid
            });
            if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {
                app_utils_setCSSProperty(wrapperEl, "--swiper-centered-offset-before", `${-snapGrid[0]}px`);
                app_utils_setCSSProperty(wrapperEl, "--swiper-centered-offset-after", `${swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2}px`);
                const addToSnapGrid = -swiper.snapGrid[0];
                const addToSlidesGrid = -swiper.slidesGrid[0];
                swiper.snapGrid = swiper.snapGrid.map((v => v + addToSnapGrid));
                swiper.slidesGrid = swiper.slidesGrid.map((v => v + addToSlidesGrid));
            }
            if (slidesLength !== previousSlidesLength) swiper.emit("slidesLengthChange");
            if (snapGrid.length !== previousSnapGridLength) {
                if (swiper.params.watchOverflow) swiper.checkOverflow();
                swiper.emit("snapGridLengthChange");
            }
            if (slidesGrid.length !== previousSlidesGridLength) swiper.emit("slidesGridLengthChange");
            if (params.watchSlidesProgress) swiper.updateSlidesOffset();
            swiper.emit("slidesUpdated");
            if (!isVirtual && !params.cssMode && (params.effect === "slide" || params.effect === "fade")) {
                const backFaceHiddenClass = `${params.containerModifierClass}backface-hidden`;
                const hasClassBackfaceClassAdded = swiper.el.classList.contains(backFaceHiddenClass);
                if (slidesLength <= params.maxBackfaceHiddenSlides) {
                    if (!hasClassBackfaceClassAdded) swiper.el.classList.add(backFaceHiddenClass);
                } else if (hasClassBackfaceClassAdded) swiper.el.classList.remove(backFaceHiddenClass);
            }
        }
        function app_updateAutoHeight(speed) {
            const swiper = this;
            const activeSlides = [];
            const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
            let newHeight = 0;
            let i;
            if (typeof speed === "number") swiper.setTransition(speed); else if (speed === true) swiper.setTransition(swiper.params.speed);
            const getSlideByIndex = index => {
                if (isVirtual) return swiper.slides[swiper.getSlideIndexByData(index)];
                return swiper.slides[index];
            };
            if (swiper.params.slidesPerView !== "auto" && swiper.params.slidesPerView > 1) if (swiper.params.centeredSlides) (swiper.visibleSlides || []).forEach((slide => {
                activeSlides.push(slide);
            })); else for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {
                const index = swiper.activeIndex + i;
                if (index > swiper.slides.length && !isVirtual) break;
                activeSlides.push(getSlideByIndex(index));
            } else activeSlides.push(getSlideByIndex(swiper.activeIndex));
            for (i = 0; i < activeSlides.length; i += 1) if (typeof activeSlides[i] !== "undefined") {
                const height = activeSlides[i].offsetHeight;
                newHeight = height > newHeight ? height : newHeight;
            }
            if (newHeight || newHeight === 0) swiper.wrapperEl.style.height = `${newHeight}px`;
        }
        function app_updateSlidesOffset() {
            const swiper = this;
            const slides = swiper.slides;
            const minusOffset = swiper.isElement ? swiper.isHorizontal() ? swiper.wrapperEl.offsetLeft : swiper.wrapperEl.offsetTop : 0;
            for (let i = 0; i < slides.length; i += 1) slides[i].swiperSlideOffset = (swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop) - minusOffset - swiper.cssOverflowAdjustment();
        }
        const app_toggleSlideClasses$1 = (slideEl, condition, className) => {
            if (condition && !slideEl.classList.contains(className)) slideEl.classList.add(className); else if (!condition && slideEl.classList.contains(className)) slideEl.classList.remove(className);
        };
        function app_updateSlidesProgress(translate) {
            if (translate === void 0) translate = this && this.translate || 0;
            const swiper = this;
            const params = swiper.params;
            const {slides, rtlTranslate: rtl, snapGrid} = swiper;
            if (slides.length === 0) return;
            if (typeof slides[0].swiperSlideOffset === "undefined") swiper.updateSlidesOffset();
            let offsetCenter = -translate;
            if (rtl) offsetCenter = translate;
            swiper.visibleSlidesIndexes = [];
            swiper.visibleSlides = [];
            let spaceBetween = params.spaceBetween;
            if (typeof spaceBetween === "string" && spaceBetween.indexOf("%") >= 0) spaceBetween = parseFloat(spaceBetween.replace("%", "")) / 100 * swiper.size; else if (typeof spaceBetween === "string") spaceBetween = parseFloat(spaceBetween);
            for (let i = 0; i < slides.length; i += 1) {
                const slide = slides[i];
                let slideOffset = slide.swiperSlideOffset;
                if (params.cssMode && params.centeredSlides) slideOffset -= slides[0].swiperSlideOffset;
                const slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + spaceBetween);
                const originalSlideProgress = (offsetCenter - snapGrid[0] + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + spaceBetween);
                const slideBefore = -(offsetCenter - slideOffset);
                const slideAfter = slideBefore + swiper.slidesSizesGrid[i];
                const isFullyVisible = slideBefore >= 0 && slideBefore <= swiper.size - swiper.slidesSizesGrid[i];
                const isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;
                if (isVisible) {
                    swiper.visibleSlides.push(slide);
                    swiper.visibleSlidesIndexes.push(i);
                }
                app_toggleSlideClasses$1(slide, isVisible, params.slideVisibleClass);
                app_toggleSlideClasses$1(slide, isFullyVisible, params.slideFullyVisibleClass);
                slide.progress = rtl ? -slideProgress : slideProgress;
                slide.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress;
            }
        }
        function app_updateProgress(translate) {
            const swiper = this;
            if (typeof translate === "undefined") {
                const multiplier = swiper.rtlTranslate ? -1 : 1;
                translate = swiper && swiper.translate && swiper.translate * multiplier || 0;
            }
            const params = swiper.params;
            const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
            let {progress, isBeginning, isEnd, progressLoop} = swiper;
            const wasBeginning = isBeginning;
            const wasEnd = isEnd;
            if (translatesDiff === 0) {
                progress = 0;
                isBeginning = true;
                isEnd = true;
            } else {
                progress = (translate - swiper.minTranslate()) / translatesDiff;
                const isBeginningRounded = Math.abs(translate - swiper.minTranslate()) < 1;
                const isEndRounded = Math.abs(translate - swiper.maxTranslate()) < 1;
                isBeginning = isBeginningRounded || progress <= 0;
                isEnd = isEndRounded || progress >= 1;
                if (isBeginningRounded) progress = 0;
                if (isEndRounded) progress = 1;
            }
            if (params.loop) {
                const firstSlideIndex = swiper.getSlideIndexByData(0);
                const lastSlideIndex = swiper.getSlideIndexByData(swiper.slides.length - 1);
                const firstSlideTranslate = swiper.slidesGrid[firstSlideIndex];
                const lastSlideTranslate = swiper.slidesGrid[lastSlideIndex];
                const translateMax = swiper.slidesGrid[swiper.slidesGrid.length - 1];
                const translateAbs = Math.abs(translate);
                if (translateAbs >= firstSlideTranslate) progressLoop = (translateAbs - firstSlideTranslate) / translateMax; else progressLoop = (translateAbs + translateMax - lastSlideTranslate) / translateMax;
                if (progressLoop > 1) progressLoop -= 1;
            }
            Object.assign(swiper, {
                progress,
                progressLoop,
                isBeginning,
                isEnd
            });
            if (params.watchSlidesProgress || params.centeredSlides && params.autoHeight) swiper.updateSlidesProgress(translate);
            if (isBeginning && !wasBeginning) swiper.emit("reachBeginning toEdge");
            if (isEnd && !wasEnd) swiper.emit("reachEnd toEdge");
            if (wasBeginning && !isBeginning || wasEnd && !isEnd) swiper.emit("fromEdge");
            swiper.emit("progress", progress);
        }
        const app_toggleSlideClasses = (slideEl, condition, className) => {
            if (condition && !slideEl.classList.contains(className)) slideEl.classList.add(className); else if (!condition && slideEl.classList.contains(className)) slideEl.classList.remove(className);
        };
        function app_updateSlidesClasses() {
            const swiper = this;
            const {slides, params, slidesEl, activeIndex} = swiper;
            const isVirtual = swiper.virtual && params.virtual.enabled;
            const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;
            const getFilteredSlide = selector => app_utils_elementChildren(slidesEl, `.${params.slideClass}${selector}, swiper-slide${selector}`)[0];
            let activeSlide;
            let prevSlide;
            let nextSlide;
            if (isVirtual) if (params.loop) {
                let slideIndex = activeIndex - swiper.virtual.slidesBefore;
                if (slideIndex < 0) slideIndex = swiper.virtual.slides.length + slideIndex;
                if (slideIndex >= swiper.virtual.slides.length) slideIndex -= swiper.virtual.slides.length;
                activeSlide = getFilteredSlide(`[data-swiper-slide-index="${slideIndex}"]`);
            } else activeSlide = getFilteredSlide(`[data-swiper-slide-index="${activeIndex}"]`); else if (gridEnabled) {
                activeSlide = slides.filter((slideEl => slideEl.column === activeIndex))[0];
                nextSlide = slides.filter((slideEl => slideEl.column === activeIndex + 1))[0];
                prevSlide = slides.filter((slideEl => slideEl.column === activeIndex - 1))[0];
            } else activeSlide = slides[activeIndex];
            if (activeSlide) if (!gridEnabled) {
                nextSlide = app_elementNextAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];
                if (params.loop && !nextSlide) nextSlide = slides[0];
                prevSlide = app_elementPrevAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];
                if (params.loop && !prevSlide === 0) prevSlide = slides[slides.length - 1];
            }
            slides.forEach((slideEl => {
                app_toggleSlideClasses(slideEl, slideEl === activeSlide, params.slideActiveClass);
                app_toggleSlideClasses(slideEl, slideEl === nextSlide, params.slideNextClass);
                app_toggleSlideClasses(slideEl, slideEl === prevSlide, params.slidePrevClass);
            }));
            swiper.emitSlidesClasses();
        }
        const app_processLazyPreloader = (swiper, imageEl) => {
            if (!swiper || swiper.destroyed || !swiper.params) return;
            const slideSelector = () => swiper.isElement ? `swiper-slide` : `.${swiper.params.slideClass}`;
            const slideEl = imageEl.closest(slideSelector());
            if (slideEl) {
                let lazyEl = slideEl.querySelector(`.${swiper.params.lazyPreloaderClass}`);
                if (!lazyEl && swiper.isElement) if (slideEl.shadowRoot) lazyEl = slideEl.shadowRoot.querySelector(`.${swiper.params.lazyPreloaderClass}`); else requestAnimationFrame((() => {
                    if (slideEl.shadowRoot) {
                        lazyEl = slideEl.shadowRoot.querySelector(`.${swiper.params.lazyPreloaderClass}`);
                        if (lazyEl) lazyEl.remove();
                    }
                }));
                if (lazyEl) lazyEl.remove();
            }
        };
        const app_unlazy = (swiper, index) => {
            if (!swiper.slides[index]) return;
            const imageEl = swiper.slides[index].querySelector('[loading="lazy"]');
            if (imageEl) imageEl.removeAttribute("loading");
        };
        const app_preload = swiper => {
            if (!swiper || swiper.destroyed || !swiper.params) return;
            let amount = swiper.params.lazyPreloadPrevNext;
            const len = swiper.slides.length;
            if (!len || !amount || amount < 0) return;
            amount = Math.min(amount, len);
            const slidesPerView = swiper.params.slidesPerView === "auto" ? swiper.slidesPerViewDynamic() : Math.ceil(swiper.params.slidesPerView);
            const activeIndex = swiper.activeIndex;
            if (swiper.params.grid && swiper.params.grid.rows > 1) {
                const activeColumn = activeIndex;
                const preloadColumns = [ activeColumn - amount ];
                preloadColumns.push(...Array.from({
                    length: amount
                }).map(((_, i) => activeColumn + slidesPerView + i)));
                swiper.slides.forEach(((slideEl, i) => {
                    if (preloadColumns.includes(slideEl.column)) app_unlazy(swiper, i);
                }));
                return;
            }
            const slideIndexLastInView = activeIndex + slidesPerView - 1;
            if (swiper.params.rewind || swiper.params.loop) for (let i = activeIndex - amount; i <= slideIndexLastInView + amount; i += 1) {
                const realIndex = (i % len + len) % len;
                if (realIndex < activeIndex || realIndex > slideIndexLastInView) app_unlazy(swiper, realIndex);
            } else for (let i = Math.max(activeIndex - amount, 0); i <= Math.min(slideIndexLastInView + amount, len - 1); i += 1) if (i !== activeIndex && (i > slideIndexLastInView || i < activeIndex)) app_unlazy(swiper, i);
        };
        function app_getActiveIndexByTranslate(swiper) {
            const {slidesGrid, params} = swiper;
            const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
            let activeIndex;
            for (let i = 0; i < slidesGrid.length; i += 1) if (typeof slidesGrid[i + 1] !== "undefined") {
                if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) activeIndex = i; else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) activeIndex = i + 1;
            } else if (translate >= slidesGrid[i]) activeIndex = i;
            if (params.normalizeSlideIndex) if (activeIndex < 0 || typeof activeIndex === "undefined") activeIndex = 0;
            return activeIndex;
        }
        function app_updateActiveIndex(newActiveIndex) {
            const swiper = this;
            const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
            const {snapGrid, params, activeIndex: previousIndex, realIndex: previousRealIndex, snapIndex: previousSnapIndex} = swiper;
            let activeIndex = newActiveIndex;
            let snapIndex;
            const getVirtualRealIndex = aIndex => {
                let realIndex = aIndex - swiper.virtual.slidesBefore;
                if (realIndex < 0) realIndex = swiper.virtual.slides.length + realIndex;
                if (realIndex >= swiper.virtual.slides.length) realIndex -= swiper.virtual.slides.length;
                return realIndex;
            };
            if (typeof activeIndex === "undefined") activeIndex = app_getActiveIndexByTranslate(swiper);
            if (snapGrid.indexOf(translate) >= 0) snapIndex = snapGrid.indexOf(translate); else {
                const skip = Math.min(params.slidesPerGroupSkip, activeIndex);
                snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);
            }
            if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
            if (activeIndex === previousIndex && !swiper.params.loop) {
                if (snapIndex !== previousSnapIndex) {
                    swiper.snapIndex = snapIndex;
                    swiper.emit("snapIndexChange");
                }
                return;
            }
            if (activeIndex === previousIndex && swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) {
                swiper.realIndex = getVirtualRealIndex(activeIndex);
                return;
            }
            const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;
            let realIndex;
            if (swiper.virtual && params.virtual.enabled && params.loop) realIndex = getVirtualRealIndex(activeIndex); else if (gridEnabled) {
                const firstSlideInColumn = swiper.slides.filter((slideEl => slideEl.column === activeIndex))[0];
                let activeSlideIndex = parseInt(firstSlideInColumn.getAttribute("data-swiper-slide-index"), 10);
                if (Number.isNaN(activeSlideIndex)) activeSlideIndex = Math.max(swiper.slides.indexOf(firstSlideInColumn), 0);
                realIndex = Math.floor(activeSlideIndex / params.grid.rows);
            } else if (swiper.slides[activeIndex]) {
                const slideIndex = swiper.slides[activeIndex].getAttribute("data-swiper-slide-index");
                if (slideIndex) realIndex = parseInt(slideIndex, 10); else realIndex = activeIndex;
            } else realIndex = activeIndex;
            Object.assign(swiper, {
                previousSnapIndex,
                snapIndex,
                previousRealIndex,
                realIndex,
                previousIndex,
                activeIndex
            });
            if (swiper.initialized) app_preload(swiper);
            swiper.emit("activeIndexChange");
            swiper.emit("snapIndexChange");
            if (swiper.initialized || swiper.params.runCallbacksOnInit) {
                if (previousRealIndex !== realIndex) swiper.emit("realIndexChange");
                swiper.emit("slideChange");
            }
        }
        function app_updateClickedSlide(el, path) {
            const swiper = this;
            const params = swiper.params;
            let slide = el.closest(`.${params.slideClass}, swiper-slide`);
            if (!slide && swiper.isElement && path && path.length > 1 && path.includes(el)) [ ...path.slice(path.indexOf(el) + 1, path.length) ].forEach((pathEl => {
                if (!slide && pathEl.matches && pathEl.matches(`.${params.slideClass}, swiper-slide`)) slide = pathEl;
            }));
            let slideFound = false;
            let slideIndex;
            if (slide) for (let i = 0; i < swiper.slides.length; i += 1) if (swiper.slides[i] === slide) {
                slideFound = true;
                slideIndex = i;
                break;
            }
            if (slide && slideFound) {
                swiper.clickedSlide = slide;
                if (swiper.virtual && swiper.params.virtual.enabled) swiper.clickedIndex = parseInt(slide.getAttribute("data-swiper-slide-index"), 10); else swiper.clickedIndex = slideIndex;
            } else {
                swiper.clickedSlide = void 0;
                swiper.clickedIndex = void 0;
                return;
            }
            if (params.slideToClickedSlide && swiper.clickedIndex !== void 0 && swiper.clickedIndex !== swiper.activeIndex) swiper.slideToClickedSlide();
        }
        var app_update = {
            updateSize: app_updateSize,
            updateSlides: app_updateSlides,
            updateAutoHeight: app_updateAutoHeight,
            updateSlidesOffset: app_updateSlidesOffset,
            updateSlidesProgress: app_updateSlidesProgress,
            updateProgress: app_updateProgress,
            updateSlidesClasses: app_updateSlidesClasses,
            updateActiveIndex: app_updateActiveIndex,
            updateClickedSlide: app_updateClickedSlide
        };
        function app_getSwiperTranslate(axis) {
            if (axis === void 0) axis = this.isHorizontal() ? "x" : "y";
            const swiper = this;
            const {params, rtlTranslate: rtl, translate, wrapperEl} = swiper;
            if (params.virtualTranslate) return rtl ? -translate : translate;
            if (params.cssMode) return translate;
            let currentTranslate = app_utils_getTranslate(wrapperEl, axis);
            currentTranslate += swiper.cssOverflowAdjustment();
            if (rtl) currentTranslate = -currentTranslate;
            return currentTranslate || 0;
        }
        function app_setTranslate(translate, byController) {
            const swiper = this;
            const {rtlTranslate: rtl, params, wrapperEl, progress} = swiper;
            let x = 0;
            let y = 0;
            const z = 0;
            if (swiper.isHorizontal()) x = rtl ? -translate : translate; else y = translate;
            if (params.roundLengths) {
                x = Math.floor(x);
                y = Math.floor(y);
            }
            swiper.previousTranslate = swiper.translate;
            swiper.translate = swiper.isHorizontal() ? x : y;
            if (params.cssMode) wrapperEl[swiper.isHorizontal() ? "scrollLeft" : "scrollTop"] = swiper.isHorizontal() ? -x : -y; else if (!params.virtualTranslate) {
                if (swiper.isHorizontal()) x -= swiper.cssOverflowAdjustment(); else y -= swiper.cssOverflowAdjustment();
                wrapperEl.style.transform = `translate3d(${x}px, ${y}px, ${z}px)`;
            }
            let newProgress;
            const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
            if (translatesDiff === 0) newProgress = 0; else newProgress = (translate - swiper.minTranslate()) / translatesDiff;
            if (newProgress !== progress) swiper.updateProgress(translate);
            swiper.emit("setTranslate", swiper.translate, byController);
        }
        function app_minTranslate() {
            return -this.snapGrid[0];
        }
        function app_maxTranslate() {
            return -this.snapGrid[this.snapGrid.length - 1];
        }
        function app_translateTo(translate, speed, runCallbacks, translateBounds, internal) {
            if (translate === void 0) translate = 0;
            if (speed === void 0) speed = this.params.speed;
            if (runCallbacks === void 0) runCallbacks = true;
            if (translateBounds === void 0) translateBounds = true;
            const swiper = this;
            const {params, wrapperEl} = swiper;
            if (swiper.animating && params.preventInteractionOnTransition) return false;
            const minTranslate = swiper.minTranslate();
            const maxTranslate = swiper.maxTranslate();
            let newTranslate;
            if (translateBounds && translate > minTranslate) newTranslate = minTranslate; else if (translateBounds && translate < maxTranslate) newTranslate = maxTranslate; else newTranslate = translate;
            swiper.updateProgress(newTranslate);
            if (params.cssMode) {
                const isH = swiper.isHorizontal();
                if (speed === 0) wrapperEl[isH ? "scrollLeft" : "scrollTop"] = -newTranslate; else {
                    if (!swiper.support.smoothScroll) {
                        app_animateCSSModeScroll({
                            swiper,
                            targetPosition: -newTranslate,
                            side: isH ? "left" : "top"
                        });
                        return true;
                    }
                    wrapperEl.scrollTo({
                        [isH ? "left" : "top"]: -newTranslate,
                        behavior: "smooth"
                    });
                }
                return true;
            }
            if (speed === 0) {
                swiper.setTransition(0);
                swiper.setTranslate(newTranslate);
                if (runCallbacks) {
                    swiper.emit("beforeTransitionStart", speed, internal);
                    swiper.emit("transitionEnd");
                }
            } else {
                swiper.setTransition(speed);
                swiper.setTranslate(newTranslate);
                if (runCallbacks) {
                    swiper.emit("beforeTransitionStart", speed, internal);
                    swiper.emit("transitionStart");
                }
                if (!swiper.animating) {
                    swiper.animating = true;
                    if (!swiper.onTranslateToWrapperTransitionEnd) swiper.onTranslateToWrapperTransitionEnd = function transitionEnd(e) {
                        if (!swiper || swiper.destroyed) return;
                        if (e.target !== this) return;
                        swiper.wrapperEl.removeEventListener("transitionend", swiper.onTranslateToWrapperTransitionEnd);
                        swiper.onTranslateToWrapperTransitionEnd = null;
                        delete swiper.onTranslateToWrapperTransitionEnd;
                        swiper.animating = false;
                        if (runCallbacks) swiper.emit("transitionEnd");
                    };
                    swiper.wrapperEl.addEventListener("transitionend", swiper.onTranslateToWrapperTransitionEnd);
                }
            }
            return true;
        }
        var app_translate = {
            getTranslate: app_getSwiperTranslate,
            setTranslate: app_setTranslate,
            minTranslate: app_minTranslate,
            maxTranslate: app_maxTranslate,
            translateTo: app_translateTo
        };
        function app_setTransition(duration, byController) {
            const swiper = this;
            if (!swiper.params.cssMode) {
                swiper.wrapperEl.style.transitionDuration = `${duration}ms`;
                swiper.wrapperEl.style.transitionDelay = duration === 0 ? `0ms` : "";
            }
            swiper.emit("setTransition", duration, byController);
        }
        function app_transitionEmit(_ref) {
            let {swiper, runCallbacks, direction, step} = _ref;
            const {activeIndex, previousIndex} = swiper;
            let dir = direction;
            if (!dir) if (activeIndex > previousIndex) dir = "next"; else if (activeIndex < previousIndex) dir = "prev"; else dir = "reset";
            swiper.emit(`transition${step}`);
            if (runCallbacks && activeIndex !== previousIndex) {
                if (dir === "reset") {
                    swiper.emit(`slideResetTransition${step}`);
                    return;
                }
                swiper.emit(`slideChangeTransition${step}`);
                if (dir === "next") swiper.emit(`slideNextTransition${step}`); else swiper.emit(`slidePrevTransition${step}`);
            }
        }
        function app_transitionStart(runCallbacks, direction) {
            if (runCallbacks === void 0) runCallbacks = true;
            const swiper = this;
            const {params} = swiper;
            if (params.cssMode) return;
            if (params.autoHeight) swiper.updateAutoHeight();
            app_transitionEmit({
                swiper,
                runCallbacks,
                direction,
                step: "Start"
            });
        }
        function app_transitionEnd(runCallbacks, direction) {
            if (runCallbacks === void 0) runCallbacks = true;
            const swiper = this;
            const {params} = swiper;
            swiper.animating = false;
            if (params.cssMode) return;
            swiper.setTransition(0);
            app_transitionEmit({
                swiper,
                runCallbacks,
                direction,
                step: "End"
            });
        }
        var app_transition = {
            setTransition: app_setTransition,
            transitionStart: app_transitionStart,
            transitionEnd: app_transitionEnd
        };
        function app_slideTo(index, speed, runCallbacks, internal, initial) {
            if (index === void 0) index = 0;
            if (runCallbacks === void 0) runCallbacks = true;
            if (typeof index === "string") index = parseInt(index, 10);
            const swiper = this;
            let slideIndex = index;
            if (slideIndex < 0) slideIndex = 0;
            const {params, snapGrid, slidesGrid, previousIndex, activeIndex, rtlTranslate: rtl, wrapperEl, enabled} = swiper;
            if (!enabled && !internal && !initial || swiper.destroyed || swiper.animating && params.preventInteractionOnTransition) return false;
            if (typeof speed === "undefined") speed = swiper.params.speed;
            const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);
            let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);
            if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
            const translate = -snapGrid[snapIndex];
            if (params.normalizeSlideIndex) for (let i = 0; i < slidesGrid.length; i += 1) {
                const normalizedTranslate = -Math.floor(translate * 100);
                const normalizedGrid = Math.floor(slidesGrid[i] * 100);
                const normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);
                if (typeof slidesGrid[i + 1] !== "undefined") {
                    if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2) slideIndex = i; else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) slideIndex = i + 1;
                } else if (normalizedTranslate >= normalizedGrid) slideIndex = i;
            }
            if (swiper.initialized && slideIndex !== activeIndex) {
                if (!swiper.allowSlideNext && (rtl ? translate > swiper.translate && translate > swiper.minTranslate() : translate < swiper.translate && translate < swiper.minTranslate())) return false;
                if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) if ((activeIndex || 0) !== slideIndex) return false;
            }
            if (slideIndex !== (previousIndex || 0) && runCallbacks) swiper.emit("beforeSlideChangeStart");
            swiper.updateProgress(translate);
            let direction;
            if (slideIndex > activeIndex) direction = "next"; else if (slideIndex < activeIndex) direction = "prev"; else direction = "reset";
            const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
            const isInitialVirtual = isVirtual && initial;
            if (!isInitialVirtual && (rtl && -translate === swiper.translate || !rtl && translate === swiper.translate)) {
                swiper.updateActiveIndex(slideIndex);
                if (params.autoHeight) swiper.updateAutoHeight();
                swiper.updateSlidesClasses();
                if (params.effect !== "slide") swiper.setTranslate(translate);
                if (direction !== "reset") {
                    swiper.transitionStart(runCallbacks, direction);
                    swiper.transitionEnd(runCallbacks, direction);
                }
                return false;
            }
            if (params.cssMode) {
                const isH = swiper.isHorizontal();
                const t = rtl ? translate : -translate;
                if (speed === 0) {
                    if (isVirtual) {
                        swiper.wrapperEl.style.scrollSnapType = "none";
                        swiper._immediateVirtual = true;
                    }
                    if (isVirtual && !swiper._cssModeVirtualInitialSet && swiper.params.initialSlide > 0) {
                        swiper._cssModeVirtualInitialSet = true;
                        requestAnimationFrame((() => {
                            wrapperEl[isH ? "scrollLeft" : "scrollTop"] = t;
                        }));
                    } else wrapperEl[isH ? "scrollLeft" : "scrollTop"] = t;
                    if (isVirtual) requestAnimationFrame((() => {
                        swiper.wrapperEl.style.scrollSnapType = "";
                        swiper._immediateVirtual = false;
                    }));
                } else {
                    if (!swiper.support.smoothScroll) {
                        app_animateCSSModeScroll({
                            swiper,
                            targetPosition: t,
                            side: isH ? "left" : "top"
                        });
                        return true;
                    }
                    wrapperEl.scrollTo({
                        [isH ? "left" : "top"]: t,
                        behavior: "smooth"
                    });
                }
                return true;
            }
            swiper.setTransition(speed);
            swiper.setTranslate(translate);
            swiper.updateActiveIndex(slideIndex);
            swiper.updateSlidesClasses();
            swiper.emit("beforeTransitionStart", speed, internal);
            swiper.transitionStart(runCallbacks, direction);
            if (speed === 0) swiper.transitionEnd(runCallbacks, direction); else if (!swiper.animating) {
                swiper.animating = true;
                if (!swiper.onSlideToWrapperTransitionEnd) swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {
                    if (!swiper || swiper.destroyed) return;
                    if (e.target !== this) return;
                    swiper.wrapperEl.removeEventListener("transitionend", swiper.onSlideToWrapperTransitionEnd);
                    swiper.onSlideToWrapperTransitionEnd = null;
                    delete swiper.onSlideToWrapperTransitionEnd;
                    swiper.transitionEnd(runCallbacks, direction);
                };
                swiper.wrapperEl.addEventListener("transitionend", swiper.onSlideToWrapperTransitionEnd);
            }
            return true;
        }
        function app_slideToLoop(index, speed, runCallbacks, internal) {
            if (index === void 0) index = 0;
            if (runCallbacks === void 0) runCallbacks = true;
            if (typeof index === "string") {
                const indexAsNumber = parseInt(index, 10);
                index = indexAsNumber;
            }
            const swiper = this;
            if (swiper.destroyed) return;
            if (typeof speed === "undefined") speed = swiper.params.speed;
            const gridEnabled = swiper.grid && swiper.params.grid && swiper.params.grid.rows > 1;
            let newIndex = index;
            if (swiper.params.loop) if (swiper.virtual && swiper.params.virtual.enabled) newIndex += swiper.virtual.slidesBefore; else {
                let targetSlideIndex;
                if (gridEnabled) {
                    const slideIndex = newIndex * swiper.params.grid.rows;
                    targetSlideIndex = swiper.slides.filter((slideEl => slideEl.getAttribute("data-swiper-slide-index") * 1 === slideIndex))[0].column;
                } else targetSlideIndex = swiper.getSlideIndexByData(newIndex);
                const cols = gridEnabled ? Math.ceil(swiper.slides.length / swiper.params.grid.rows) : swiper.slides.length;
                const {centeredSlides} = swiper.params;
                let slidesPerView = swiper.params.slidesPerView;
                if (slidesPerView === "auto") slidesPerView = swiper.slidesPerViewDynamic(); else {
                    slidesPerView = Math.ceil(parseFloat(swiper.params.slidesPerView, 10));
                    if (centeredSlides && slidesPerView % 2 === 0) slidesPerView += 1;
                }
                let needLoopFix = cols - targetSlideIndex < slidesPerView;
                if (centeredSlides) needLoopFix = needLoopFix || targetSlideIndex < Math.ceil(slidesPerView / 2);
                if (internal && centeredSlides && swiper.params.slidesPerView !== "auto" && !gridEnabled) needLoopFix = false;
                if (needLoopFix) {
                    const direction = centeredSlides ? targetSlideIndex < swiper.activeIndex ? "prev" : "next" : targetSlideIndex - swiper.activeIndex - 1 < swiper.params.slidesPerView ? "next" : "prev";
                    swiper.loopFix({
                        direction,
                        slideTo: true,
                        activeSlideIndex: direction === "next" ? targetSlideIndex + 1 : targetSlideIndex - cols + 1,
                        slideRealIndex: direction === "next" ? swiper.realIndex : void 0
                    });
                }
                if (gridEnabled) {
                    const slideIndex = newIndex * swiper.params.grid.rows;
                    newIndex = swiper.slides.filter((slideEl => slideEl.getAttribute("data-swiper-slide-index") * 1 === slideIndex))[0].column;
                } else newIndex = swiper.getSlideIndexByData(newIndex);
            }
            requestAnimationFrame((() => {
                swiper.slideTo(newIndex, speed, runCallbacks, internal);
            }));
            return swiper;
        }
        function app_slideNext(speed, runCallbacks, internal) {
            if (runCallbacks === void 0) runCallbacks = true;
            const swiper = this;
            const {enabled, params, animating} = swiper;
            if (!enabled || swiper.destroyed) return swiper;
            if (typeof speed === "undefined") speed = swiper.params.speed;
            let perGroup = params.slidesPerGroup;
            if (params.slidesPerView === "auto" && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) perGroup = Math.max(swiper.slidesPerViewDynamic("current", true), 1);
            const increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;
            const isVirtual = swiper.virtual && params.virtual.enabled;
            if (params.loop) {
                if (animating && !isVirtual && params.loopPreventsSliding) return false;
                swiper.loopFix({
                    direction: "next"
                });
                swiper._clientLeft = swiper.wrapperEl.clientLeft;
                if (swiper.activeIndex === swiper.slides.length - 1 && params.cssMode) {
                    requestAnimationFrame((() => {
                        swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
                    }));
                    return true;
                }
            }
            if (params.rewind && swiper.isEnd) return swiper.slideTo(0, speed, runCallbacks, internal);
            return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
        }
        function app_slidePrev(speed, runCallbacks, internal) {
            if (runCallbacks === void 0) runCallbacks = true;
            const swiper = this;
            const {params, snapGrid, slidesGrid, rtlTranslate, enabled, animating} = swiper;
            if (!enabled || swiper.destroyed) return swiper;
            if (typeof speed === "undefined") speed = swiper.params.speed;
            const isVirtual = swiper.virtual && params.virtual.enabled;
            if (params.loop) {
                if (animating && !isVirtual && params.loopPreventsSliding) return false;
                swiper.loopFix({
                    direction: "prev"
                });
                swiper._clientLeft = swiper.wrapperEl.clientLeft;
            }
            const translate = rtlTranslate ? swiper.translate : -swiper.translate;
            function normalize(val) {
                if (val < 0) return -Math.floor(Math.abs(val));
                return Math.floor(val);
            }
            const normalizedTranslate = normalize(translate);
            const normalizedSnapGrid = snapGrid.map((val => normalize(val)));
            let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];
            if (typeof prevSnap === "undefined" && params.cssMode) {
                let prevSnapIndex;
                snapGrid.forEach(((snap, snapIndex) => {
                    if (normalizedTranslate >= snap) prevSnapIndex = snapIndex;
                }));
                if (typeof prevSnapIndex !== "undefined") prevSnap = snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];
            }
            let prevIndex = 0;
            if (typeof prevSnap !== "undefined") {
                prevIndex = slidesGrid.indexOf(prevSnap);
                if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;
                if (params.slidesPerView === "auto" && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
                    prevIndex = prevIndex - swiper.slidesPerViewDynamic("previous", true) + 1;
                    prevIndex = Math.max(prevIndex, 0);
                }
            }
            if (params.rewind && swiper.isBeginning) {
                const lastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;
                return swiper.slideTo(lastIndex, speed, runCallbacks, internal);
            } else if (params.loop && swiper.activeIndex === 0 && params.cssMode) {
                requestAnimationFrame((() => {
                    swiper.slideTo(prevIndex, speed, runCallbacks, internal);
                }));
                return true;
            }
            return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
        }
        function app_slideReset(speed, runCallbacks, internal) {
            if (runCallbacks === void 0) runCallbacks = true;
            const swiper = this;
            if (swiper.destroyed) return;
            if (typeof speed === "undefined") speed = swiper.params.speed;
            return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
        }
        function app_slideToClosest(speed, runCallbacks, internal, threshold) {
            if (runCallbacks === void 0) runCallbacks = true;
            if (threshold === void 0) threshold = .5;
            const swiper = this;
            if (swiper.destroyed) return;
            if (typeof speed === "undefined") speed = swiper.params.speed;
            let index = swiper.activeIndex;
            const skip = Math.min(swiper.params.slidesPerGroupSkip, index);
            const snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);
            const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
            if (translate >= swiper.snapGrid[snapIndex]) {
                const currentSnap = swiper.snapGrid[snapIndex];
                const nextSnap = swiper.snapGrid[snapIndex + 1];
                if (translate - currentSnap > (nextSnap - currentSnap) * threshold) index += swiper.params.slidesPerGroup;
            } else {
                const prevSnap = swiper.snapGrid[snapIndex - 1];
                const currentSnap = swiper.snapGrid[snapIndex];
                if (translate - prevSnap <= (currentSnap - prevSnap) * threshold) index -= swiper.params.slidesPerGroup;
            }
            index = Math.max(index, 0);
            index = Math.min(index, swiper.slidesGrid.length - 1);
            return swiper.slideTo(index, speed, runCallbacks, internal);
        }
        function app_slideToClickedSlide() {
            const swiper = this;
            if (swiper.destroyed) return;
            const {params, slidesEl} = swiper;
            const slidesPerView = params.slidesPerView === "auto" ? swiper.slidesPerViewDynamic() : params.slidesPerView;
            let slideToIndex = swiper.clickedIndex;
            let realIndex;
            const slideSelector = swiper.isElement ? `swiper-slide` : `.${params.slideClass}`;
            if (params.loop) {
                if (swiper.animating) return;
                realIndex = parseInt(swiper.clickedSlide.getAttribute("data-swiper-slide-index"), 10);
                if (params.centeredSlides) if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {
                    swiper.loopFix();
                    slideToIndex = swiper.getSlideIndex(app_utils_elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index="${realIndex}"]`)[0]);
                    app_utils_nextTick((() => {
                        swiper.slideTo(slideToIndex);
                    }));
                } else swiper.slideTo(slideToIndex); else if (slideToIndex > swiper.slides.length - slidesPerView) {
                    swiper.loopFix();
                    slideToIndex = swiper.getSlideIndex(app_utils_elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index="${realIndex}"]`)[0]);
                    app_utils_nextTick((() => {
                        swiper.slideTo(slideToIndex);
                    }));
                } else swiper.slideTo(slideToIndex);
            } else swiper.slideTo(slideToIndex);
        }
        var app_slide = {
            slideTo: app_slideTo,
            slideToLoop: app_slideToLoop,
            slideNext: app_slideNext,
            slidePrev: app_slidePrev,
            slideReset: app_slideReset,
            slideToClosest: app_slideToClosest,
            slideToClickedSlide: app_slideToClickedSlide
        };
        function app_loopCreate(slideRealIndex) {
            const swiper = this;
            const {params, slidesEl} = swiper;
            if (!params.loop || swiper.virtual && swiper.params.virtual.enabled) return;
            const initSlides = () => {
                const slides = app_utils_elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);
                slides.forEach(((el, index) => {
                    el.setAttribute("data-swiper-slide-index", index);
                }));
            };
            const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;
            const slidesPerGroup = params.slidesPerGroup * (gridEnabled ? params.grid.rows : 1);
            const shouldFillGroup = swiper.slides.length % slidesPerGroup !== 0;
            const shouldFillGrid = gridEnabled && swiper.slides.length % params.grid.rows !== 0;
            const addBlankSlides = amountOfSlides => {
                for (let i = 0; i < amountOfSlides; i += 1) {
                    const slideEl = swiper.isElement ? app_utils_createElement("swiper-slide", [ params.slideBlankClass ]) : app_utils_createElement("div", [ params.slideClass, params.slideBlankClass ]);
                    swiper.slidesEl.append(slideEl);
                }
            };
            if (shouldFillGroup) {
                if (params.loopAddBlankSlides) {
                    const slidesToAdd = slidesPerGroup - swiper.slides.length % slidesPerGroup;
                    addBlankSlides(slidesToAdd);
                    swiper.recalcSlides();
                    swiper.updateSlides();
                } else app_showWarning("Swiper Loop Warning: The number of slides is not even to slidesPerGroup, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)");
                initSlides();
            } else if (shouldFillGrid) {
                if (params.loopAddBlankSlides) {
                    const slidesToAdd = params.grid.rows - swiper.slides.length % params.grid.rows;
                    addBlankSlides(slidesToAdd);
                    swiper.recalcSlides();
                    swiper.updateSlides();
                } else app_showWarning("Swiper Loop Warning: The number of slides is not even to grid.rows, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)");
                initSlides();
            } else initSlides();
            swiper.loopFix({
                slideRealIndex,
                direction: params.centeredSlides ? void 0 : "next"
            });
        }
        function app_loopFix(_temp) {
            let {slideRealIndex, slideTo = true, direction, setTranslate, activeSlideIndex, byController, byMousewheel} = _temp === void 0 ? {} : _temp;
            const swiper = this;
            if (!swiper.params.loop) return;
            swiper.emit("beforeLoopFix");
            const {slides, allowSlidePrev, allowSlideNext, slidesEl, params} = swiper;
            const {centeredSlides} = params;
            swiper.allowSlidePrev = true;
            swiper.allowSlideNext = true;
            if (swiper.virtual && params.virtual.enabled) {
                if (slideTo) if (!params.centeredSlides && swiper.snapIndex === 0) swiper.slideTo(swiper.virtual.slides.length, 0, false, true); else if (params.centeredSlides && swiper.snapIndex < params.slidesPerView) swiper.slideTo(swiper.virtual.slides.length + swiper.snapIndex, 0, false, true); else if (swiper.snapIndex === swiper.snapGrid.length - 1) swiper.slideTo(swiper.virtual.slidesBefore, 0, false, true);
                swiper.allowSlidePrev = allowSlidePrev;
                swiper.allowSlideNext = allowSlideNext;
                swiper.emit("loopFix");
                return;
            }
            let slidesPerView = params.slidesPerView;
            if (slidesPerView === "auto") slidesPerView = swiper.slidesPerViewDynamic(); else {
                slidesPerView = Math.ceil(parseFloat(params.slidesPerView, 10));
                if (centeredSlides && slidesPerView % 2 === 0) slidesPerView += 1;
            }
            const slidesPerGroup = params.slidesPerGroupAuto ? slidesPerView : params.slidesPerGroup;
            let loopedSlides = slidesPerGroup;
            if (loopedSlides % slidesPerGroup !== 0) loopedSlides += slidesPerGroup - loopedSlides % slidesPerGroup;
            loopedSlides += params.loopAdditionalSlides;
            swiper.loopedSlides = loopedSlides;
            const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;
            if (slides.length < slidesPerView + loopedSlides) app_showWarning("Swiper Loop Warning: The number of slides is not enough for loop mode, it will be disabled and not function properly. You need to add more slides (or make duplicates) or lower the values of slidesPerView and slidesPerGroup parameters"); else if (gridEnabled && params.grid.fill === "row") app_showWarning("Swiper Loop Warning: Loop mode is not compatible with grid.fill = `row`");
            const prependSlidesIndexes = [];
            const appendSlidesIndexes = [];
            let activeIndex = swiper.activeIndex;
            if (typeof activeSlideIndex === "undefined") activeSlideIndex = swiper.getSlideIndex(slides.filter((el => el.classList.contains(params.slideActiveClass)))[0]); else activeIndex = activeSlideIndex;
            const isNext = direction === "next" || !direction;
            const isPrev = direction === "prev" || !direction;
            let slidesPrepended = 0;
            let slidesAppended = 0;
            const cols = gridEnabled ? Math.ceil(slides.length / params.grid.rows) : slides.length;
            const activeColIndex = gridEnabled ? slides[activeSlideIndex].column : activeSlideIndex;
            const activeColIndexWithShift = activeColIndex + (centeredSlides && typeof setTranslate === "undefined" ? -slidesPerView / 2 + .5 : 0);
            if (activeColIndexWithShift < loopedSlides) {
                slidesPrepended = Math.max(loopedSlides - activeColIndexWithShift, slidesPerGroup);
                for (let i = 0; i < loopedSlides - activeColIndexWithShift; i += 1) {
                    const index = i - Math.floor(i / cols) * cols;
                    if (gridEnabled) {
                        const colIndexToPrepend = cols - index - 1;
                        for (let i = slides.length - 1; i >= 0; i -= 1) if (slides[i].column === colIndexToPrepend) prependSlidesIndexes.push(i);
                    } else prependSlidesIndexes.push(cols - index - 1);
                }
            } else if (activeColIndexWithShift + slidesPerView > cols - loopedSlides) {
                slidesAppended = Math.max(activeColIndexWithShift - (cols - loopedSlides * 2), slidesPerGroup);
                for (let i = 0; i < slidesAppended; i += 1) {
                    const index = i - Math.floor(i / cols) * cols;
                    if (gridEnabled) slides.forEach(((slide, slideIndex) => {
                        if (slide.column === index) appendSlidesIndexes.push(slideIndex);
                    })); else appendSlidesIndexes.push(index);
                }
            }
            swiper.__preventObserver__ = true;
            requestAnimationFrame((() => {
                swiper.__preventObserver__ = false;
            }));
            if (isPrev) prependSlidesIndexes.forEach((index => {
                slides[index].swiperLoopMoveDOM = true;
                slidesEl.prepend(slides[index]);
                slides[index].swiperLoopMoveDOM = false;
            }));
            if (isNext) appendSlidesIndexes.forEach((index => {
                slides[index].swiperLoopMoveDOM = true;
                slidesEl.append(slides[index]);
                slides[index].swiperLoopMoveDOM = false;
            }));
            swiper.recalcSlides();
            if (params.slidesPerView === "auto") swiper.updateSlides(); else if (gridEnabled && (prependSlidesIndexes.length > 0 && isPrev || appendSlidesIndexes.length > 0 && isNext)) swiper.slides.forEach(((slide, slideIndex) => {
                swiper.grid.updateSlide(slideIndex, slide, swiper.slides);
            }));
            if (params.watchSlidesProgress) swiper.updateSlidesOffset();
            if (slideTo) if (prependSlidesIndexes.length > 0 && isPrev) {
                if (typeof slideRealIndex === "undefined") {
                    const currentSlideTranslate = swiper.slidesGrid[activeIndex];
                    const newSlideTranslate = swiper.slidesGrid[activeIndex + slidesPrepended];
                    const diff = newSlideTranslate - currentSlideTranslate;
                    if (byMousewheel) swiper.setTranslate(swiper.translate - diff); else {
                        swiper.slideTo(activeIndex + Math.ceil(slidesPrepended), 0, false, true);
                        if (setTranslate) {
                            swiper.touchEventsData.startTranslate = swiper.touchEventsData.startTranslate - diff;
                            swiper.touchEventsData.currentTranslate = swiper.touchEventsData.currentTranslate - diff;
                        }
                    }
                } else if (setTranslate) {
                    const shift = gridEnabled ? prependSlidesIndexes.length / params.grid.rows : prependSlidesIndexes.length;
                    swiper.slideTo(swiper.activeIndex + shift, 0, false, true);
                    swiper.touchEventsData.currentTranslate = swiper.translate;
                }
            } else if (appendSlidesIndexes.length > 0 && isNext) if (typeof slideRealIndex === "undefined") {
                const currentSlideTranslate = swiper.slidesGrid[activeIndex];
                const newSlideTranslate = swiper.slidesGrid[activeIndex - slidesAppended];
                const diff = newSlideTranslate - currentSlideTranslate;
                if (byMousewheel) swiper.setTranslate(swiper.translate - diff); else {
                    swiper.slideTo(activeIndex - slidesAppended, 0, false, true);
                    if (setTranslate) {
                        swiper.touchEventsData.startTranslate = swiper.touchEventsData.startTranslate - diff;
                        swiper.touchEventsData.currentTranslate = swiper.touchEventsData.currentTranslate - diff;
                    }
                }
            } else {
                const shift = gridEnabled ? appendSlidesIndexes.length / params.grid.rows : appendSlidesIndexes.length;
                swiper.slideTo(swiper.activeIndex - shift, 0, false, true);
            }
            swiper.allowSlidePrev = allowSlidePrev;
            swiper.allowSlideNext = allowSlideNext;
            if (swiper.controller && swiper.controller.control && !byController) {
                const loopParams = {
                    slideRealIndex,
                    direction,
                    setTranslate,
                    activeSlideIndex,
                    byController: true
                };
                if (Array.isArray(swiper.controller.control)) swiper.controller.control.forEach((c => {
                    if (!c.destroyed && c.params.loop) c.loopFix({
                        ...loopParams,
                        slideTo: c.params.slidesPerView === params.slidesPerView ? slideTo : false
                    });
                })); else if (swiper.controller.control instanceof swiper.constructor && swiper.controller.control.params.loop) swiper.controller.control.loopFix({
                    ...loopParams,
                    slideTo: swiper.controller.control.params.slidesPerView === params.slidesPerView ? slideTo : false
                });
            }
            swiper.emit("loopFix");
        }
        function app_loopDestroy() {
            const swiper = this;
            const {params, slidesEl} = swiper;
            if (!params.loop || swiper.virtual && swiper.params.virtual.enabled) return;
            swiper.recalcSlides();
            const newSlidesOrder = [];
            swiper.slides.forEach((slideEl => {
                const index = typeof slideEl.swiperSlideIndex === "undefined" ? slideEl.getAttribute("data-swiper-slide-index") * 1 : slideEl.swiperSlideIndex;
                newSlidesOrder[index] = slideEl;
            }));
            swiper.slides.forEach((slideEl => {
                slideEl.removeAttribute("data-swiper-slide-index");
            }));
            newSlidesOrder.forEach((slideEl => {
                slidesEl.append(slideEl);
            }));
            swiper.recalcSlides();
            swiper.slideTo(swiper.realIndex, 0);
        }
        var app_loop = {
            loopCreate: app_loopCreate,
            loopFix: app_loopFix,
            loopDestroy: app_loopDestroy
        };
        function app_setGrabCursor(moving) {
            const swiper = this;
            if (!swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;
            const el = swiper.params.touchEventsTarget === "container" ? swiper.el : swiper.wrapperEl;
            if (swiper.isElement) swiper.__preventObserver__ = true;
            el.style.cursor = "move";
            el.style.cursor = moving ? "grabbing" : "grab";
            if (swiper.isElement) requestAnimationFrame((() => {
                swiper.__preventObserver__ = false;
            }));
        }
        function app_unsetGrabCursor() {
            const swiper = this;
            if (swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;
            if (swiper.isElement) swiper.__preventObserver__ = true;
            swiper[swiper.params.touchEventsTarget === "container" ? "el" : "wrapperEl"].style.cursor = "";
            if (swiper.isElement) requestAnimationFrame((() => {
                swiper.__preventObserver__ = false;
            }));
        }
        var app_grabCursor = {
            setGrabCursor: app_setGrabCursor,
            unsetGrabCursor: app_unsetGrabCursor
        };
        function app_closestElement(selector, base) {
            if (base === void 0) base = this;
            function __closestFrom(el) {
                if (!el || el === app_ssr_window_esm_getDocument() || el === app_ssr_window_esm_getWindow()) return null;
                if (el.assignedSlot) el = el.assignedSlot;
                const found = el.closest(selector);
                if (!found && !el.getRootNode) return null;
                return found || __closestFrom(el.getRootNode().host);
            }
            return __closestFrom(base);
        }
        function app_preventEdgeSwipe(swiper, event, startX) {
            const window = app_ssr_window_esm_getWindow();
            const {params} = swiper;
            const edgeSwipeDetection = params.edgeSwipeDetection;
            const edgeSwipeThreshold = params.edgeSwipeThreshold;
            if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window.innerWidth - edgeSwipeThreshold)) {
                if (edgeSwipeDetection === "prevent") {
                    event.preventDefault();
                    return true;
                }
                return false;
            }
            return true;
        }
        function app_onTouchStart(event) {
            const swiper = this;
            const document = app_ssr_window_esm_getDocument();
            let e = event;
            if (e.originalEvent) e = e.originalEvent;
            const data = swiper.touchEventsData;
            if (e.type === "pointerdown") {
                if (data.pointerId !== null && data.pointerId !== e.pointerId) return;
                data.pointerId = e.pointerId;
            } else if (e.type === "touchstart" && e.targetTouches.length === 1) data.touchId = e.targetTouches[0].identifier;
            if (e.type === "touchstart") {
                app_preventEdgeSwipe(swiper, e, e.targetTouches[0].pageX);
                return;
            }
            const {params, touches, enabled} = swiper;
            if (!enabled) return;
            if (!params.simulateTouch && e.pointerType === "mouse") return;
            if (swiper.animating && params.preventInteractionOnTransition) return;
            if (!swiper.animating && params.cssMode && params.loop) swiper.loopFix();
            let targetEl = e.target;
            if (params.touchEventsTarget === "wrapper") if (!app_elementIsChildOf(targetEl, swiper.wrapperEl)) return;
            if ("which" in e && e.which === 3) return;
            if ("button" in e && e.button > 0) return;
            if (data.isTouched && data.isMoved) return;
            const swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== "";
            const eventPath = e.composedPath ? e.composedPath() : e.path;
            if (swipingClassHasValue && e.target && e.target.shadowRoot && eventPath) targetEl = eventPath[0];
            const noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`;
            const isTargetShadow = !!(e.target && e.target.shadowRoot);
            if (params.noSwiping && (isTargetShadow ? app_closestElement(noSwipingSelector, targetEl) : targetEl.closest(noSwipingSelector))) {
                swiper.allowClick = true;
                return;
            }
            if (params.swipeHandler) if (!targetEl.closest(params.swipeHandler)) return;
            touches.currentX = e.pageX;
            touches.currentY = e.pageY;
            const startX = touches.currentX;
            const startY = touches.currentY;
            if (!app_preventEdgeSwipe(swiper, e, startX)) return;
            Object.assign(data, {
                isTouched: true,
                isMoved: false,
                allowTouchCallbacks: true,
                isScrolling: void 0,
                startMoving: void 0
            });
            touches.startX = startX;
            touches.startY = startY;
            data.touchStartTime = app_now();
            swiper.allowClick = true;
            swiper.updateSize();
            swiper.swipeDirection = void 0;
            if (params.threshold > 0) data.allowThresholdMove = false;
            let preventDefault = true;
            if (targetEl.matches(data.focusableElements)) {
                preventDefault = false;
                if (targetEl.nodeName === "SELECT") data.isTouched = false;
            }
            if (document.activeElement && document.activeElement.matches(data.focusableElements) && document.activeElement !== targetEl && (e.pointerType === "mouse" || e.pointerType !== "mouse" && !targetEl.matches(data.focusableElements))) document.activeElement.blur();
            const shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;
            if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !targetEl.isContentEditable) e.preventDefault();
            if (params.freeMode && params.freeMode.enabled && swiper.freeMode && swiper.animating && !params.cssMode) swiper.freeMode.onTouchStart();
            swiper.emit("touchStart", e);
        }
        function app_onTouchMove(event) {
            const document = app_ssr_window_esm_getDocument();
            const swiper = this;
            const data = swiper.touchEventsData;
            const {params, touches, rtlTranslate: rtl, enabled} = swiper;
            if (!enabled) return;
            if (!params.simulateTouch && event.pointerType === "mouse") return;
            let e = event;
            if (e.originalEvent) e = e.originalEvent;
            if (e.type === "pointermove") {
                if (data.touchId !== null) return;
                const id = e.pointerId;
                if (id !== data.pointerId) return;
            }
            let targetTouch;
            if (e.type === "touchmove") {
                targetTouch = [ ...e.changedTouches ].filter((t => t.identifier === data.touchId))[0];
                if (!targetTouch || targetTouch.identifier !== data.touchId) return;
            } else targetTouch = e;
            if (!data.isTouched) {
                if (data.startMoving && data.isScrolling) swiper.emit("touchMoveOpposite", e);
                return;
            }
            const pageX = targetTouch.pageX;
            const pageY = targetTouch.pageY;
            if (e.preventedByNestedSwiper) {
                touches.startX = pageX;
                touches.startY = pageY;
                return;
            }
            if (!swiper.allowTouchMove) {
                if (!e.target.matches(data.focusableElements)) swiper.allowClick = false;
                if (data.isTouched) {
                    Object.assign(touches, {
                        startX: pageX,
                        startY: pageY,
                        currentX: pageX,
                        currentY: pageY
                    });
                    data.touchStartTime = app_now();
                }
                return;
            }
            if (params.touchReleaseOnEdges && !params.loop) if (swiper.isVertical()) {
                if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {
                    data.isTouched = false;
                    data.isMoved = false;
                    return;
                }
            } else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) return;
            if (document.activeElement && document.activeElement.matches(data.focusableElements) && document.activeElement !== e.target && e.pointerType !== "mouse") document.activeElement.blur();
            if (document.activeElement) if (e.target === document.activeElement && e.target.matches(data.focusableElements)) {
                data.isMoved = true;
                swiper.allowClick = false;
                return;
            }
            if (data.allowTouchCallbacks) swiper.emit("touchMove", e);
            touches.previousX = touches.currentX;
            touches.previousY = touches.currentY;
            touches.currentX = pageX;
            touches.currentY = pageY;
            const diffX = touches.currentX - touches.startX;
            const diffY = touches.currentY - touches.startY;
            if (swiper.params.threshold && Math.sqrt(diffX ** 2 + diffY ** 2) < swiper.params.threshold) return;
            if (typeof data.isScrolling === "undefined") {
                let touchAngle;
                if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) data.isScrolling = false; else if (diffX * diffX + diffY * diffY >= 25) {
                    touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;
                    data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;
                }
            }
            if (data.isScrolling) swiper.emit("touchMoveOpposite", e);
            if (typeof data.startMoving === "undefined") if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) data.startMoving = true;
            if (data.isScrolling || e.type === "touchmove" && data.preventTouchMoveFromPointerMove) {
                data.isTouched = false;
                return;
            }
            if (!data.startMoving) return;
            swiper.allowClick = false;
            if (!params.cssMode && e.cancelable) e.preventDefault();
            if (params.touchMoveStopPropagation && !params.nested) e.stopPropagation();
            let diff = swiper.isHorizontal() ? diffX : diffY;
            let touchesDiff = swiper.isHorizontal() ? touches.currentX - touches.previousX : touches.currentY - touches.previousY;
            if (params.oneWayMovement) {
                diff = Math.abs(diff) * (rtl ? 1 : -1);
                touchesDiff = Math.abs(touchesDiff) * (rtl ? 1 : -1);
            }
            touches.diff = diff;
            diff *= params.touchRatio;
            if (rtl) {
                diff = -diff;
                touchesDiff = -touchesDiff;
            }
            const prevTouchesDirection = swiper.touchesDirection;
            swiper.swipeDirection = diff > 0 ? "prev" : "next";
            swiper.touchesDirection = touchesDiff > 0 ? "prev" : "next";
            const isLoop = swiper.params.loop && !params.cssMode;
            const allowLoopFix = swiper.touchesDirection === "next" && swiper.allowSlideNext || swiper.touchesDirection === "prev" && swiper.allowSlidePrev;
            if (!data.isMoved) {
                if (isLoop && allowLoopFix) swiper.loopFix({
                    direction: swiper.swipeDirection
                });
                data.startTranslate = swiper.getTranslate();
                swiper.setTransition(0);
                if (swiper.animating) {
                    const evt = new window.CustomEvent("transitionend", {
                        bubbles: true,
                        cancelable: true,
                        detail: {
                            bySwiperTouchMove: true
                        }
                    });
                    swiper.wrapperEl.dispatchEvent(evt);
                }
                data.allowMomentumBounce = false;
                if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) swiper.setGrabCursor(true);
                swiper.emit("sliderFirstMove", e);
            }
            let loopFixed;
            (new Date).getTime();
            if (data.isMoved && data.allowThresholdMove && prevTouchesDirection !== swiper.touchesDirection && isLoop && allowLoopFix && Math.abs(diff) >= 1) {
                Object.assign(touches, {
                    startX: pageX,
                    startY: pageY,
                    currentX: pageX,
                    currentY: pageY,
                    startTranslate: data.currentTranslate
                });
                data.loopSwapReset = true;
                data.startTranslate = data.currentTranslate;
                return;
            }
            swiper.emit("sliderMove", e);
            data.isMoved = true;
            data.currentTranslate = diff + data.startTranslate;
            let disableParentSwiper = true;
            let resistanceRatio = params.resistanceRatio;
            if (params.touchReleaseOnEdges) resistanceRatio = 0;
            if (diff > 0) {
                if (isLoop && allowLoopFix && !loopFixed && data.allowThresholdMove && data.currentTranslate > (params.centeredSlides ? swiper.minTranslate() - swiper.slidesSizesGrid[swiper.activeIndex + 1] - (params.slidesPerView !== "auto" && swiper.slides.length - params.slidesPerView >= 2 ? swiper.slidesSizesGrid[swiper.activeIndex + 1] + swiper.params.spaceBetween : 0) - swiper.params.spaceBetween : swiper.minTranslate())) swiper.loopFix({
                    direction: "prev",
                    setTranslate: true,
                    activeSlideIndex: 0
                });
                if (data.currentTranslate > swiper.minTranslate()) {
                    disableParentSwiper = false;
                    if (params.resistance) data.currentTranslate = swiper.minTranslate() - 1 + (-swiper.minTranslate() + data.startTranslate + diff) ** resistanceRatio;
                }
            } else if (diff < 0) {
                if (isLoop && allowLoopFix && !loopFixed && data.allowThresholdMove && data.currentTranslate < (params.centeredSlides ? swiper.maxTranslate() + swiper.slidesSizesGrid[swiper.slidesSizesGrid.length - 1] + swiper.params.spaceBetween + (params.slidesPerView !== "auto" && swiper.slides.length - params.slidesPerView >= 2 ? swiper.slidesSizesGrid[swiper.slidesSizesGrid.length - 1] + swiper.params.spaceBetween : 0) : swiper.maxTranslate())) swiper.loopFix({
                    direction: "next",
                    setTranslate: true,
                    activeSlideIndex: swiper.slides.length - (params.slidesPerView === "auto" ? swiper.slidesPerViewDynamic() : Math.ceil(parseFloat(params.slidesPerView, 10)))
                });
                if (data.currentTranslate < swiper.maxTranslate()) {
                    disableParentSwiper = false;
                    if (params.resistance) data.currentTranslate = swiper.maxTranslate() + 1 - (swiper.maxTranslate() - data.startTranslate - diff) ** resistanceRatio;
                }
            }
            if (disableParentSwiper) e.preventedByNestedSwiper = true;
            if (!swiper.allowSlideNext && swiper.swipeDirection === "next" && data.currentTranslate < data.startTranslate) data.currentTranslate = data.startTranslate;
            if (!swiper.allowSlidePrev && swiper.swipeDirection === "prev" && data.currentTranslate > data.startTranslate) data.currentTranslate = data.startTranslate;
            if (!swiper.allowSlidePrev && !swiper.allowSlideNext) data.currentTranslate = data.startTranslate;
            if (params.threshold > 0) if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
                if (!data.allowThresholdMove) {
                    data.allowThresholdMove = true;
                    touches.startX = touches.currentX;
                    touches.startY = touches.currentY;
                    data.currentTranslate = data.startTranslate;
                    touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
                    return;
                }
            } else {
                data.currentTranslate = data.startTranslate;
                return;
            }
            if (!params.followFinger || params.cssMode) return;
            if (params.freeMode && params.freeMode.enabled && swiper.freeMode || params.watchSlidesProgress) {
                swiper.updateActiveIndex();
                swiper.updateSlidesClasses();
            }
            if (params.freeMode && params.freeMode.enabled && swiper.freeMode) swiper.freeMode.onTouchMove();
            swiper.updateProgress(data.currentTranslate);
            swiper.setTranslate(data.currentTranslate);
        }
        function app_onTouchEnd(event) {
            const swiper = this;
            const data = swiper.touchEventsData;
            let e = event;
            if (e.originalEvent) e = e.originalEvent;
            let targetTouch;
            const isTouchEvent = e.type === "touchend" || e.type === "touchcancel";
            if (!isTouchEvent) {
                if (data.touchId !== null) return;
                if (e.pointerId !== data.pointerId) return;
                targetTouch = e;
            } else {
                targetTouch = [ ...e.changedTouches ].filter((t => t.identifier === data.touchId))[0];
                if (!targetTouch || targetTouch.identifier !== data.touchId) return;
            }
            if ([ "pointercancel", "pointerout", "pointerleave", "contextmenu" ].includes(e.type)) {
                const proceed = [ "pointercancel", "contextmenu" ].includes(e.type) && (swiper.browser.isSafari || swiper.browser.isWebView);
                if (!proceed) return;
            }
            data.pointerId = null;
            data.touchId = null;
            const {params, touches, rtlTranslate: rtl, slidesGrid, enabled} = swiper;
            if (!enabled) return;
            if (!params.simulateTouch && e.pointerType === "mouse") return;
            if (data.allowTouchCallbacks) swiper.emit("touchEnd", e);
            data.allowTouchCallbacks = false;
            if (!data.isTouched) {
                if (data.isMoved && params.grabCursor) swiper.setGrabCursor(false);
                data.isMoved = false;
                data.startMoving = false;
                return;
            }
            if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) swiper.setGrabCursor(false);
            const touchEndTime = app_now();
            const timeDiff = touchEndTime - data.touchStartTime;
            if (swiper.allowClick) {
                const pathTree = e.path || e.composedPath && e.composedPath();
                swiper.updateClickedSlide(pathTree && pathTree[0] || e.target, pathTree);
                swiper.emit("tap click", e);
                if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) swiper.emit("doubleTap doubleClick", e);
            }
            data.lastClickTime = app_now();
            app_utils_nextTick((() => {
                if (!swiper.destroyed) swiper.allowClick = true;
            }));
            if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 && !data.loopSwapReset || data.currentTranslate === data.startTranslate && !data.loopSwapReset) {
                data.isTouched = false;
                data.isMoved = false;
                data.startMoving = false;
                return;
            }
            data.isTouched = false;
            data.isMoved = false;
            data.startMoving = false;
            let currentPos;
            if (params.followFinger) currentPos = rtl ? swiper.translate : -swiper.translate; else currentPos = -data.currentTranslate;
            if (params.cssMode) return;
            if (params.freeMode && params.freeMode.enabled) {
                swiper.freeMode.onTouchEnd({
                    currentPos
                });
                return;
            }
            const swipeToLast = currentPos >= -swiper.maxTranslate() && !swiper.params.loop;
            let stopIndex = 0;
            let groupSize = swiper.slidesSizesGrid[0];
            for (let i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {
                const increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
                if (typeof slidesGrid[i + increment] !== "undefined") {
                    if (swipeToLast || currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment]) {
                        stopIndex = i;
                        groupSize = slidesGrid[i + increment] - slidesGrid[i];
                    }
                } else if (swipeToLast || currentPos >= slidesGrid[i]) {
                    stopIndex = i;
                    groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
                }
            }
            let rewindFirstIndex = null;
            let rewindLastIndex = null;
            if (params.rewind) if (swiper.isBeginning) rewindLastIndex = params.virtual && params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1; else if (swiper.isEnd) rewindFirstIndex = 0;
            const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
            const increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
            if (timeDiff > params.longSwipesMs) {
                if (!params.longSwipes) {
                    swiper.slideTo(swiper.activeIndex);
                    return;
                }
                if (swiper.swipeDirection === "next") if (ratio >= params.longSwipesRatio) swiper.slideTo(params.rewind && swiper.isEnd ? rewindFirstIndex : stopIndex + increment); else swiper.slideTo(stopIndex);
                if (swiper.swipeDirection === "prev") if (ratio > 1 - params.longSwipesRatio) swiper.slideTo(stopIndex + increment); else if (rewindLastIndex !== null && ratio < 0 && Math.abs(ratio) > params.longSwipesRatio) swiper.slideTo(rewindLastIndex); else swiper.slideTo(stopIndex);
            } else {
                if (!params.shortSwipes) {
                    swiper.slideTo(swiper.activeIndex);
                    return;
                }
                const isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);
                if (!isNavButtonTarget) {
                    if (swiper.swipeDirection === "next") swiper.slideTo(rewindFirstIndex !== null ? rewindFirstIndex : stopIndex + increment);
                    if (swiper.swipeDirection === "prev") swiper.slideTo(rewindLastIndex !== null ? rewindLastIndex : stopIndex);
                } else if (e.target === swiper.navigation.nextEl) swiper.slideTo(stopIndex + increment); else swiper.slideTo(stopIndex);
            }
        }
        function app_onResize() {
            const swiper = this;
            const {params, el} = swiper;
            if (el && el.offsetWidth === 0) return;
            if (params.breakpoints) swiper.setBreakpoint();
            const {allowSlideNext, allowSlidePrev, snapGrid} = swiper;
            const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
            swiper.allowSlideNext = true;
            swiper.allowSlidePrev = true;
            swiper.updateSize();
            swiper.updateSlides();
            swiper.updateSlidesClasses();
            const isVirtualLoop = isVirtual && params.loop;
            if ((params.slidesPerView === "auto" || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides && !isVirtualLoop) swiper.slideTo(swiper.slides.length - 1, 0, false, true); else if (swiper.params.loop && !isVirtual) swiper.slideToLoop(swiper.realIndex, 0, false, true); else swiper.slideTo(swiper.activeIndex, 0, false, true);
            if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
                clearTimeout(swiper.autoplay.resizeTimeout);
                swiper.autoplay.resizeTimeout = setTimeout((() => {
                    if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) swiper.autoplay.resume();
                }), 500);
            }
            swiper.allowSlidePrev = allowSlidePrev;
            swiper.allowSlideNext = allowSlideNext;
            if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) swiper.checkOverflow();
        }
        function app_onClick(e) {
            const swiper = this;
            if (!swiper.enabled) return;
            if (!swiper.allowClick) {
                if (swiper.params.preventClicks) e.preventDefault();
                if (swiper.params.preventClicksPropagation && swiper.animating) {
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                }
            }
        }
        function app_onScroll() {
            const swiper = this;
            const {wrapperEl, rtlTranslate, enabled} = swiper;
            if (!enabled) return;
            swiper.previousTranslate = swiper.translate;
            if (swiper.isHorizontal()) swiper.translate = -wrapperEl.scrollLeft; else swiper.translate = -wrapperEl.scrollTop;
            if (swiper.translate === 0) swiper.translate = 0;
            swiper.updateActiveIndex();
            swiper.updateSlidesClasses();
            let newProgress;
            const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
            if (translatesDiff === 0) newProgress = 0; else newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;
            if (newProgress !== swiper.progress) swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);
            swiper.emit("setTranslate", swiper.translate, false);
        }
        function app_onLoad(e) {
            const swiper = this;
            app_processLazyPreloader(swiper, e.target);
            if (swiper.params.cssMode || swiper.params.slidesPerView !== "auto" && !swiper.params.autoHeight) return;
            swiper.update();
        }
        function app_onDocumentTouchStart() {
            const swiper = this;
            if (swiper.documentTouchHandlerProceeded) return;
            swiper.documentTouchHandlerProceeded = true;
            if (swiper.params.touchReleaseOnEdges) swiper.el.style.touchAction = "auto";
        }
        const app_events = (swiper, method) => {
            const document = app_ssr_window_esm_getDocument();
            const {params, el, wrapperEl, device} = swiper;
            const capture = !!params.nested;
            const domMethod = method === "on" ? "addEventListener" : "removeEventListener";
            const swiperMethod = method;
            if (!el || typeof el === "string") return;
            document[domMethod]("touchstart", swiper.onDocumentTouchStart, {
                passive: false,
                capture
            });
            el[domMethod]("touchstart", swiper.onTouchStart, {
                passive: false
            });
            el[domMethod]("pointerdown", swiper.onTouchStart, {
                passive: false
            });
            document[domMethod]("touchmove", swiper.onTouchMove, {
                passive: false,
                capture
            });
            document[domMethod]("pointermove", swiper.onTouchMove, {
                passive: false,
                capture
            });
            document[domMethod]("touchend", swiper.onTouchEnd, {
                passive: true
            });
            document[domMethod]("pointerup", swiper.onTouchEnd, {
                passive: true
            });
            document[domMethod]("pointercancel", swiper.onTouchEnd, {
                passive: true
            });
            document[domMethod]("touchcancel", swiper.onTouchEnd, {
                passive: true
            });
            document[domMethod]("pointerout", swiper.onTouchEnd, {
                passive: true
            });
            document[domMethod]("pointerleave", swiper.onTouchEnd, {
                passive: true
            });
            document[domMethod]("contextmenu", swiper.onTouchEnd, {
                passive: true
            });
            if (params.preventClicks || params.preventClicksPropagation) el[domMethod]("click", swiper.onClick, true);
            if (params.cssMode) wrapperEl[domMethod]("scroll", swiper.onScroll);
            if (params.updateOnWindowResize) swiper[swiperMethod](device.ios || device.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", app_onResize, true); else swiper[swiperMethod]("observerUpdate", app_onResize, true);
            el[domMethod]("load", swiper.onLoad, {
                capture: true
            });
        };
        function app_attachEvents() {
            const swiper = this;
            const {params} = swiper;
            swiper.onTouchStart = app_onTouchStart.bind(swiper);
            swiper.onTouchMove = app_onTouchMove.bind(swiper);
            swiper.onTouchEnd = app_onTouchEnd.bind(swiper);
            swiper.onDocumentTouchStart = app_onDocumentTouchStart.bind(swiper);
            if (params.cssMode) swiper.onScroll = app_onScroll.bind(swiper);
            swiper.onClick = app_onClick.bind(swiper);
            swiper.onLoad = app_onLoad.bind(swiper);
            app_events(swiper, "on");
        }
        function app_detachEvents() {
            const swiper = this;
            app_events(swiper, "off");
        }
        var app_events$1 = {
            attachEvents: app_attachEvents,
            detachEvents: app_detachEvents
        };
        const app_isGridEnabled = (swiper, params) => swiper.grid && params.grid && params.grid.rows > 1;
        function app_setBreakpoint() {
            const swiper = this;
            const {realIndex, initialized, params, el} = swiper;
            const breakpoints = params.breakpoints;
            if (!breakpoints || breakpoints && Object.keys(breakpoints).length === 0) return;
            const breakpoint = swiper.getBreakpoint(breakpoints, swiper.params.breakpointsBase, swiper.el);
            if (!breakpoint || swiper.currentBreakpoint === breakpoint) return;
            const breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : void 0;
            const breakpointParams = breakpointOnlyParams || swiper.originalParams;
            const wasMultiRow = app_isGridEnabled(swiper, params);
            const isMultiRow = app_isGridEnabled(swiper, breakpointParams);
            const wasGrabCursor = swiper.params.grabCursor;
            const isGrabCursor = breakpointParams.grabCursor;
            const wasEnabled = params.enabled;
            if (wasMultiRow && !isMultiRow) {
                el.classList.remove(`${params.containerModifierClass}grid`, `${params.containerModifierClass}grid-column`);
                swiper.emitContainerClasses();
            } else if (!wasMultiRow && isMultiRow) {
                el.classList.add(`${params.containerModifierClass}grid`);
                if (breakpointParams.grid.fill && breakpointParams.grid.fill === "column" || !breakpointParams.grid.fill && params.grid.fill === "column") el.classList.add(`${params.containerModifierClass}grid-column`);
                swiper.emitContainerClasses();
            }
            if (wasGrabCursor && !isGrabCursor) swiper.unsetGrabCursor(); else if (!wasGrabCursor && isGrabCursor) swiper.setGrabCursor();
            [ "navigation", "pagination", "scrollbar" ].forEach((prop => {
                if (typeof breakpointParams[prop] === "undefined") return;
                const wasModuleEnabled = params[prop] && params[prop].enabled;
                const isModuleEnabled = breakpointParams[prop] && breakpointParams[prop].enabled;
                if (wasModuleEnabled && !isModuleEnabled) swiper[prop].disable();
                if (!wasModuleEnabled && isModuleEnabled) swiper[prop].enable();
            }));
            const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;
            const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);
            const wasLoop = params.loop;
            if (directionChanged && initialized) swiper.changeDirection();
            app_utils_extend(swiper.params, breakpointParams);
            const isEnabled = swiper.params.enabled;
            const hasLoop = swiper.params.loop;
            Object.assign(swiper, {
                allowTouchMove: swiper.params.allowTouchMove,
                allowSlideNext: swiper.params.allowSlideNext,
                allowSlidePrev: swiper.params.allowSlidePrev
            });
            if (wasEnabled && !isEnabled) swiper.disable(); else if (!wasEnabled && isEnabled) swiper.enable();
            swiper.currentBreakpoint = breakpoint;
            swiper.emit("_beforeBreakpoint", breakpointParams);
            if (initialized) if (needsReLoop) {
                swiper.loopDestroy();
                swiper.loopCreate(realIndex);
                swiper.updateSlides();
            } else if (!wasLoop && hasLoop) {
                swiper.loopCreate(realIndex);
                swiper.updateSlides();
            } else if (wasLoop && !hasLoop) swiper.loopDestroy();
            swiper.emit("breakpoint", breakpointParams);
        }
        function app_getBreakpoint(breakpoints, base, containerEl) {
            if (base === void 0) base = "window";
            if (!breakpoints || base === "container" && !containerEl) return;
            let breakpoint = false;
            const window = app_ssr_window_esm_getWindow();
            const currentHeight = base === "window" ? window.innerHeight : containerEl.clientHeight;
            const points = Object.keys(breakpoints).map((point => {
                if (typeof point === "string" && point.indexOf("@") === 0) {
                    const minRatio = parseFloat(point.substr(1));
                    const value = currentHeight * minRatio;
                    return {
                        value,
                        point
                    };
                }
                return {
                    value: point,
                    point
                };
            }));
            points.sort(((a, b) => parseInt(a.value, 10) - parseInt(b.value, 10)));
            for (let i = 0; i < points.length; i += 1) {
                const {point, value} = points[i];
                if (base === "window") {
                    if (window.matchMedia(`(min-width: ${value}px)`).matches) breakpoint = point;
                } else if (value <= containerEl.clientWidth) breakpoint = point;
            }
            return breakpoint || "max";
        }
        var app_breakpoints = {
            setBreakpoint: app_setBreakpoint,
            getBreakpoint: app_getBreakpoint
        };
        function app_prepareClasses(entries, prefix) {
            const resultClasses = [];
            entries.forEach((item => {
                if (typeof item === "object") Object.keys(item).forEach((classNames => {
                    if (item[classNames]) resultClasses.push(prefix + classNames);
                })); else if (typeof item === "string") resultClasses.push(prefix + item);
            }));
            return resultClasses;
        }
        function app_addClasses() {
            const swiper = this;
            const {classNames, params, rtl, el, device} = swiper;
            const suffixes = app_prepareClasses([ "initialized", params.direction, {
                "free-mode": swiper.params.freeMode && params.freeMode.enabled
            }, {
                autoheight: params.autoHeight
            }, {
                rtl
            }, {
                grid: params.grid && params.grid.rows > 1
            }, {
                "grid-column": params.grid && params.grid.rows > 1 && params.grid.fill === "column"
            }, {
                android: device.android
            }, {
                ios: device.ios
            }, {
                "css-mode": params.cssMode
            }, {
                centered: params.cssMode && params.centeredSlides
            }, {
                "watch-progress": params.watchSlidesProgress
            } ], params.containerModifierClass);
            classNames.push(...suffixes);
            el.classList.add(...classNames);
            swiper.emitContainerClasses();
        }
        function app_swiper_core_removeClasses() {
            const swiper = this;
            const {el, classNames} = swiper;
            if (!el || typeof el === "string") return;
            el.classList.remove(...classNames);
            swiper.emitContainerClasses();
        }
        var app_classes = {
            addClasses: app_addClasses,
            removeClasses: app_swiper_core_removeClasses
        };
        function app_checkOverflow() {
            const swiper = this;
            const {isLocked: wasLocked, params} = swiper;
            const {slidesOffsetBefore} = params;
            if (slidesOffsetBefore) {
                const lastSlideIndex = swiper.slides.length - 1;
                const lastSlideRightEdge = swiper.slidesGrid[lastSlideIndex] + swiper.slidesSizesGrid[lastSlideIndex] + slidesOffsetBefore * 2;
                swiper.isLocked = swiper.size > lastSlideRightEdge;
            } else swiper.isLocked = swiper.snapGrid.length === 1;
            if (params.allowSlideNext === true) swiper.allowSlideNext = !swiper.isLocked;
            if (params.allowSlidePrev === true) swiper.allowSlidePrev = !swiper.isLocked;
            if (wasLocked && wasLocked !== swiper.isLocked) swiper.isEnd = false;
            if (wasLocked !== swiper.isLocked) swiper.emit(swiper.isLocked ? "lock" : "unlock");
        }
        var app_checkOverflow$1 = {
            checkOverflow: app_checkOverflow
        };
        var app_defaults = {
            init: true,
            direction: "horizontal",
            oneWayMovement: false,
            swiperElementNodeName: "SWIPER-CONTAINER",
            touchEventsTarget: "wrapper",
            initialSlide: 0,
            speed: 300,
            cssMode: false,
            updateOnWindowResize: true,
            resizeObserver: true,
            nested: false,
            createElements: false,
            eventsPrefix: "swiper",
            enabled: true,
            focusableElements: "input, select, option, textarea, button, video, label",
            width: null,
            height: null,
            preventInteractionOnTransition: false,
            userAgent: null,
            url: null,
            edgeSwipeDetection: false,
            edgeSwipeThreshold: 20,
            autoHeight: false,
            setWrapperSize: false,
            virtualTranslate: false,
            effect: "slide",
            breakpoints: void 0,
            breakpointsBase: "window",
            spaceBetween: 0,
            slidesPerView: 1,
            slidesPerGroup: 1,
            slidesPerGroupSkip: 0,
            slidesPerGroupAuto: false,
            centeredSlides: false,
            centeredSlidesBounds: false,
            slidesOffsetBefore: 0,
            slidesOffsetAfter: 0,
            normalizeSlideIndex: true,
            centerInsufficientSlides: false,
            watchOverflow: true,
            roundLengths: false,
            touchRatio: 1,
            touchAngle: 45,
            simulateTouch: true,
            shortSwipes: true,
            longSwipes: true,
            longSwipesRatio: .5,
            longSwipesMs: 300,
            followFinger: true,
            allowTouchMove: true,
            threshold: 5,
            touchMoveStopPropagation: false,
            touchStartPreventDefault: true,
            touchStartForcePreventDefault: false,
            touchReleaseOnEdges: false,
            uniqueNavElements: true,
            resistance: true,
            resistanceRatio: .85,
            watchSlidesProgress: false,
            grabCursor: false,
            preventClicks: true,
            preventClicksPropagation: true,
            slideToClickedSlide: false,
            loop: false,
            loopAddBlankSlides: true,
            loopAdditionalSlides: 0,
            loopPreventsSliding: true,
            rewind: false,
            allowSlidePrev: true,
            allowSlideNext: true,
            swipeHandler: null,
            noSwiping: true,
            noSwipingClass: "swiper-no-swiping",
            noSwipingSelector: null,
            passiveListeners: true,
            maxBackfaceHiddenSlides: 10,
            containerModifierClass: "swiper-",
            slideClass: "swiper-slide",
            slideBlankClass: "swiper-slide-blank",
            slideActiveClass: "swiper-slide-active",
            slideVisibleClass: "swiper-slide-visible",
            slideFullyVisibleClass: "swiper-slide-fully-visible",
            slideNextClass: "swiper-slide-next",
            slidePrevClass: "swiper-slide-prev",
            wrapperClass: "swiper-wrapper",
            lazyPreloaderClass: "swiper-lazy-preloader",
            lazyPreloadPrevNext: 0,
            runCallbacksOnInit: true,
            _emitClasses: false
        };
        function app_moduleExtendParams(params, allModulesParams) {
            return function extendParams(obj) {
                if (obj === void 0) obj = {};
                const moduleParamName = Object.keys(obj)[0];
                const moduleParams = obj[moduleParamName];
                if (typeof moduleParams !== "object" || moduleParams === null) {
                    app_utils_extend(allModulesParams, obj);
                    return;
                }
                if (params[moduleParamName] === true) params[moduleParamName] = {
                    enabled: true
                };
                if (moduleParamName === "navigation" && params[moduleParamName] && params[moduleParamName].enabled && !params[moduleParamName].prevEl && !params[moduleParamName].nextEl) params[moduleParamName].auto = true;
                if ([ "pagination", "scrollbar" ].indexOf(moduleParamName) >= 0 && params[moduleParamName] && params[moduleParamName].enabled && !params[moduleParamName].el) params[moduleParamName].auto = true;
                if (!(moduleParamName in params && "enabled" in moduleParams)) {
                    app_utils_extend(allModulesParams, obj);
                    return;
                }
                if (typeof params[moduleParamName] === "object" && !("enabled" in params[moduleParamName])) params[moduleParamName].enabled = true;
                if (!params[moduleParamName]) params[moduleParamName] = {
                    enabled: false
                };
                app_utils_extend(allModulesParams, obj);
            };
        }
        const app_prototypes = {
            eventsEmitter: app_eventsEmitter,
            update: app_update,
            translate: app_translate,
            transition: app_transition,
            slide: app_slide,
            loop: app_loop,
            grabCursor: app_grabCursor,
            events: app_events$1,
            breakpoints: app_breakpoints,
            checkOverflow: app_checkOverflow$1,
            classes: app_classes
        };
        const app_extendedDefaults = {};
        class app_swiper_core_Swiper {
            constructor() {
                let el;
                let params;
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                if (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === "Object") params = args[0]; else [el, params] = args;
                if (!params) params = {};
                params = app_utils_extend({}, params);
                if (el && !params.el) params.el = el;
                const document = app_ssr_window_esm_getDocument();
                if (params.el && typeof params.el === "string" && document.querySelectorAll(params.el).length > 1) {
                    const swipers = [];
                    document.querySelectorAll(params.el).forEach((containerEl => {
                        const newParams = app_utils_extend({}, params, {
                            el: containerEl
                        });
                        swipers.push(new app_swiper_core_Swiper(newParams));
                    }));
                    return swipers;
                }
                const swiper = this;
                swiper.__swiper__ = true;
                swiper.support = app_getSupport();
                swiper.device = app_getDevice({
                    userAgent: params.userAgent
                });
                swiper.browser = app_getBrowser();
                swiper.eventsListeners = {};
                swiper.eventsAnyListeners = [];
                swiper.modules = [ ...swiper.__modules__ ];
                if (params.modules && Array.isArray(params.modules)) swiper.modules.push(...params.modules);
                const allModulesParams = {};
                swiper.modules.forEach((mod => {
                    mod({
                        params,
                        swiper,
                        extendParams: app_moduleExtendParams(params, allModulesParams),
                        on: swiper.on.bind(swiper),
                        once: swiper.once.bind(swiper),
                        off: swiper.off.bind(swiper),
                        emit: swiper.emit.bind(swiper)
                    });
                }));
                const swiperParams = app_utils_extend({}, app_defaults, allModulesParams);
                swiper.params = app_utils_extend({}, swiperParams, app_extendedDefaults, params);
                swiper.originalParams = app_utils_extend({}, swiper.params);
                swiper.passedParams = app_utils_extend({}, params);
                if (swiper.params && swiper.params.on) Object.keys(swiper.params.on).forEach((eventName => {
                    swiper.on(eventName, swiper.params.on[eventName]);
                }));
                if (swiper.params && swiper.params.onAny) swiper.onAny(swiper.params.onAny);
                Object.assign(swiper, {
                    enabled: swiper.params.enabled,
                    el,
                    classNames: [],
                    slides: [],
                    slidesGrid: [],
                    snapGrid: [],
                    slidesSizesGrid: [],
                    isHorizontal() {
                        return swiper.params.direction === "horizontal";
                    },
                    isVertical() {
                        return swiper.params.direction === "vertical";
                    },
                    activeIndex: 0,
                    realIndex: 0,
                    isBeginning: true,
                    isEnd: false,
                    translate: 0,
                    previousTranslate: 0,
                    progress: 0,
                    velocity: 0,
                    animating: false,
                    cssOverflowAdjustment() {
                        return Math.trunc(this.translate / 2 ** 23) * 2 ** 23;
                    },
                    allowSlideNext: swiper.params.allowSlideNext,
                    allowSlidePrev: swiper.params.allowSlidePrev,
                    touchEventsData: {
                        isTouched: void 0,
                        isMoved: void 0,
                        allowTouchCallbacks: void 0,
                        touchStartTime: void 0,
                        isScrolling: void 0,
                        currentTranslate: void 0,
                        startTranslate: void 0,
                        allowThresholdMove: void 0,
                        focusableElements: swiper.params.focusableElements,
                        lastClickTime: 0,
                        clickTimeout: void 0,
                        velocities: [],
                        allowMomentumBounce: void 0,
                        startMoving: void 0,
                        pointerId: null,
                        touchId: null
                    },
                    allowClick: true,
                    allowTouchMove: swiper.params.allowTouchMove,
                    touches: {
                        startX: 0,
                        startY: 0,
                        currentX: 0,
                        currentY: 0,
                        diff: 0
                    },
                    imagesToLoad: [],
                    imagesLoaded: 0
                });
                swiper.emit("_swiper");
                if (swiper.params.init) swiper.init();
                return swiper;
            }
            getDirectionLabel(property) {
                if (this.isHorizontal()) return property;
                return {
                    width: "height",
                    "margin-top": "margin-left",
                    "margin-bottom ": "margin-right",
                    "margin-left": "margin-top",
                    "margin-right": "margin-bottom",
                    "padding-left": "padding-top",
                    "padding-right": "padding-bottom",
                    marginRight: "marginBottom"
                }[property];
            }
            getSlideIndex(slideEl) {
                const {slidesEl, params} = this;
                const slides = app_utils_elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);
                const firstSlideIndex = app_utils_elementIndex(slides[0]);
                return app_utils_elementIndex(slideEl) - firstSlideIndex;
            }
            getSlideIndexByData(index) {
                return this.getSlideIndex(this.slides.filter((slideEl => slideEl.getAttribute("data-swiper-slide-index") * 1 === index))[0]);
            }
            recalcSlides() {
                const swiper = this;
                const {slidesEl, params} = swiper;
                swiper.slides = app_utils_elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);
            }
            enable() {
                const swiper = this;
                if (swiper.enabled) return;
                swiper.enabled = true;
                if (swiper.params.grabCursor) swiper.setGrabCursor();
                swiper.emit("enable");
            }
            disable() {
                const swiper = this;
                if (!swiper.enabled) return;
                swiper.enabled = false;
                if (swiper.params.grabCursor) swiper.unsetGrabCursor();
                swiper.emit("disable");
            }
            setProgress(progress, speed) {
                const swiper = this;
                progress = Math.min(Math.max(progress, 0), 1);
                const min = swiper.minTranslate();
                const max = swiper.maxTranslate();
                const current = (max - min) * progress + min;
                swiper.translateTo(current, typeof speed === "undefined" ? 0 : speed);
                swiper.updateActiveIndex();
                swiper.updateSlidesClasses();
            }
            emitContainerClasses() {
                const swiper = this;
                if (!swiper.params._emitClasses || !swiper.el) return;
                const cls = swiper.el.className.split(" ").filter((className => className.indexOf("swiper") === 0 || className.indexOf(swiper.params.containerModifierClass) === 0));
                swiper.emit("_containerClasses", cls.join(" "));
            }
            getSlideClasses(slideEl) {
                const swiper = this;
                if (swiper.destroyed) return "";
                return slideEl.className.split(" ").filter((className => className.indexOf("swiper-slide") === 0 || className.indexOf(swiper.params.slideClass) === 0)).join(" ");
            }
            emitSlidesClasses() {
                const swiper = this;
                if (!swiper.params._emitClasses || !swiper.el) return;
                const updates = [];
                swiper.slides.forEach((slideEl => {
                    const classNames = swiper.getSlideClasses(slideEl);
                    updates.push({
                        slideEl,
                        classNames
                    });
                    swiper.emit("_slideClass", slideEl, classNames);
                }));
                swiper.emit("_slideClasses", updates);
            }
            slidesPerViewDynamic(view, exact) {
                if (view === void 0) view = "current";
                if (exact === void 0) exact = false;
                const swiper = this;
                const {params, slides, slidesGrid, slidesSizesGrid, size: swiperSize, activeIndex} = swiper;
                let spv = 1;
                if (typeof params.slidesPerView === "number") return params.slidesPerView;
                if (params.centeredSlides) {
                    let slideSize = slides[activeIndex] ? Math.ceil(slides[activeIndex].swiperSlideSize) : 0;
                    let breakLoop;
                    for (let i = activeIndex + 1; i < slides.length; i += 1) if (slides[i] && !breakLoop) {
                        slideSize += Math.ceil(slides[i].swiperSlideSize);
                        spv += 1;
                        if (slideSize > swiperSize) breakLoop = true;
                    }
                    for (let i = activeIndex - 1; i >= 0; i -= 1) if (slides[i] && !breakLoop) {
                        slideSize += slides[i].swiperSlideSize;
                        spv += 1;
                        if (slideSize > swiperSize) breakLoop = true;
                    }
                } else if (view === "current") for (let i = activeIndex + 1; i < slides.length; i += 1) {
                    const slideInView = exact ? slidesGrid[i] + slidesSizesGrid[i] - slidesGrid[activeIndex] < swiperSize : slidesGrid[i] - slidesGrid[activeIndex] < swiperSize;
                    if (slideInView) spv += 1;
                } else for (let i = activeIndex - 1; i >= 0; i -= 1) {
                    const slideInView = slidesGrid[activeIndex] - slidesGrid[i] < swiperSize;
                    if (slideInView) spv += 1;
                }
                return spv;
            }
            update() {
                const swiper = this;
                if (!swiper || swiper.destroyed) return;
                const {snapGrid, params} = swiper;
                if (params.breakpoints) swiper.setBreakpoint();
                [ ...swiper.el.querySelectorAll('[loading="lazy"]') ].forEach((imageEl => {
                    if (imageEl.complete) app_processLazyPreloader(swiper, imageEl);
                }));
                swiper.updateSize();
                swiper.updateSlides();
                swiper.updateProgress();
                swiper.updateSlidesClasses();
                function setTranslate() {
                    const translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;
                    const newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
                    swiper.setTranslate(newTranslate);
                    swiper.updateActiveIndex();
                    swiper.updateSlidesClasses();
                }
                let translated;
                if (params.freeMode && params.freeMode.enabled && !params.cssMode) {
                    setTranslate();
                    if (params.autoHeight) swiper.updateAutoHeight();
                } else {
                    if ((params.slidesPerView === "auto" || params.slidesPerView > 1) && swiper.isEnd && !params.centeredSlides) {
                        const slides = swiper.virtual && params.virtual.enabled ? swiper.virtual.slides : swiper.slides;
                        translated = swiper.slideTo(slides.length - 1, 0, false, true);
                    } else translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
                    if (!translated) setTranslate();
                }
                if (params.watchOverflow && snapGrid !== swiper.snapGrid) swiper.checkOverflow();
                swiper.emit("update");
            }
            changeDirection(newDirection, needUpdate) {
                if (needUpdate === void 0) needUpdate = true;
                const swiper = this;
                const currentDirection = swiper.params.direction;
                if (!newDirection) newDirection = currentDirection === "horizontal" ? "vertical" : "horizontal";
                if (newDirection === currentDirection || newDirection !== "horizontal" && newDirection !== "vertical") return swiper;
                swiper.el.classList.remove(`${swiper.params.containerModifierClass}${currentDirection}`);
                swiper.el.classList.add(`${swiper.params.containerModifierClass}${newDirection}`);
                swiper.emitContainerClasses();
                swiper.params.direction = newDirection;
                swiper.slides.forEach((slideEl => {
                    if (newDirection === "vertical") slideEl.style.width = ""; else slideEl.style.height = "";
                }));
                swiper.emit("changeDirection");
                if (needUpdate) swiper.update();
                return swiper;
            }
            changeLanguageDirection(direction) {
                const swiper = this;
                if (swiper.rtl && direction === "rtl" || !swiper.rtl && direction === "ltr") return;
                swiper.rtl = direction === "rtl";
                swiper.rtlTranslate = swiper.params.direction === "horizontal" && swiper.rtl;
                if (swiper.rtl) {
                    swiper.el.classList.add(`${swiper.params.containerModifierClass}rtl`);
                    swiper.el.dir = "rtl";
                } else {
                    swiper.el.classList.remove(`${swiper.params.containerModifierClass}rtl`);
                    swiper.el.dir = "ltr";
                }
                swiper.update();
            }
            mount(element) {
                const swiper = this;
                if (swiper.mounted) return true;
                let el = element || swiper.params.el;
                if (typeof el === "string") el = document.querySelector(el);
                if (!el) return false;
                el.swiper = swiper;
                if (el.parentNode && el.parentNode.host && el.parentNode.host.nodeName === swiper.params.swiperElementNodeName.toUpperCase()) swiper.isElement = true;
                const getWrapperSelector = () => `.${(swiper.params.wrapperClass || "").trim().split(" ").join(".")}`;
                const getWrapper = () => {
                    if (el && el.shadowRoot && el.shadowRoot.querySelector) {
                        const res = el.shadowRoot.querySelector(getWrapperSelector());
                        return res;
                    }
                    return app_utils_elementChildren(el, getWrapperSelector())[0];
                };
                let wrapperEl = getWrapper();
                if (!wrapperEl && swiper.params.createElements) {
                    wrapperEl = app_utils_createElement("div", swiper.params.wrapperClass);
                    el.append(wrapperEl);
                    app_utils_elementChildren(el, `.${swiper.params.slideClass}`).forEach((slideEl => {
                        wrapperEl.append(slideEl);
                    }));
                }
                Object.assign(swiper, {
                    el,
                    wrapperEl,
                    slidesEl: swiper.isElement && !el.parentNode.host.slideSlots ? el.parentNode.host : wrapperEl,
                    hostEl: swiper.isElement ? el.parentNode.host : el,
                    mounted: true,
                    rtl: el.dir.toLowerCase() === "rtl" || app_elementStyle(el, "direction") === "rtl",
                    rtlTranslate: swiper.params.direction === "horizontal" && (el.dir.toLowerCase() === "rtl" || app_elementStyle(el, "direction") === "rtl"),
                    wrongRTL: app_elementStyle(wrapperEl, "display") === "-webkit-box"
                });
                return true;
            }
            init(el) {
                const swiper = this;
                if (swiper.initialized) return swiper;
                const mounted = swiper.mount(el);
                if (mounted === false) return swiper;
                swiper.emit("beforeInit");
                if (swiper.params.breakpoints) swiper.setBreakpoint();
                swiper.addClasses();
                swiper.updateSize();
                swiper.updateSlides();
                if (swiper.params.watchOverflow) swiper.checkOverflow();
                if (swiper.params.grabCursor && swiper.enabled) swiper.setGrabCursor();
                if (swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) swiper.slideTo(swiper.params.initialSlide + swiper.virtual.slidesBefore, 0, swiper.params.runCallbacksOnInit, false, true); else swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);
                if (swiper.params.loop) swiper.loopCreate();
                swiper.attachEvents();
                const lazyElements = [ ...swiper.el.querySelectorAll('[loading="lazy"]') ];
                if (swiper.isElement) lazyElements.push(...swiper.hostEl.querySelectorAll('[loading="lazy"]'));
                lazyElements.forEach((imageEl => {
                    if (imageEl.complete) app_processLazyPreloader(swiper, imageEl); else imageEl.addEventListener("load", (e => {
                        app_processLazyPreloader(swiper, e.target);
                    }));
                }));
                app_preload(swiper);
                swiper.initialized = true;
                app_preload(swiper);
                swiper.emit("init");
                swiper.emit("afterInit");
                return swiper;
            }
            destroy(deleteInstance, cleanStyles) {
                if (deleteInstance === void 0) deleteInstance = true;
                if (cleanStyles === void 0) cleanStyles = true;
                const swiper = this;
                const {params, el, wrapperEl, slides} = swiper;
                if (typeof swiper.params === "undefined" || swiper.destroyed) return null;
                swiper.emit("beforeDestroy");
                swiper.initialized = false;
                swiper.detachEvents();
                if (params.loop) swiper.loopDestroy();
                if (cleanStyles) {
                    swiper.removeClasses();
                    if (el && typeof el !== "string") el.removeAttribute("style");
                    if (wrapperEl) wrapperEl.removeAttribute("style");
                    if (slides && slides.length) slides.forEach((slideEl => {
                        slideEl.classList.remove(params.slideVisibleClass, params.slideFullyVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass);
                        slideEl.removeAttribute("style");
                        slideEl.removeAttribute("data-swiper-slide-index");
                    }));
                }
                swiper.emit("destroy");
                Object.keys(swiper.eventsListeners).forEach((eventName => {
                    swiper.off(eventName);
                }));
                if (deleteInstance !== false) {
                    if (swiper.el && typeof swiper.el !== "string") swiper.el.swiper = null;
                    app_deleteProps(swiper);
                }
                swiper.destroyed = true;
                return null;
            }
            static extendDefaults(newDefaults) {
                app_utils_extend(app_extendedDefaults, newDefaults);
            }
            static get extendedDefaults() {
                return app_extendedDefaults;
            }
            static get defaults() {
                return app_defaults;
            }
            static installModule(mod) {
                if (!app_swiper_core_Swiper.prototype.__modules__) app_swiper_core_Swiper.prototype.__modules__ = [];
                const modules = app_swiper_core_Swiper.prototype.__modules__;
                if (typeof mod === "function" && modules.indexOf(mod) < 0) modules.push(mod);
            }
            static use(module) {
                if (Array.isArray(module)) {
                    module.forEach((m => app_swiper_core_Swiper.installModule(m)));
                    return app_swiper_core_Swiper;
                }
                app_swiper_core_Swiper.installModule(module);
                return app_swiper_core_Swiper;
            }
        }
        Object.keys(app_prototypes).forEach((prototypeGroup => {
            Object.keys(app_prototypes[prototypeGroup]).forEach((protoMethod => {
                app_swiper_core_Swiper.prototype[protoMethod] = app_prototypes[prototypeGroup][protoMethod];
            }));
        }));
        app_swiper_core_Swiper.use([ app_Resize, app_Observer ]);
        function app_Mousewheel(_ref) {
            let {swiper, extendParams, on, emit} = _ref;
            const window = app_ssr_window_esm_getWindow();
            extendParams({
                mousewheel: {
                    enabled: false,
                    releaseOnEdges: false,
                    invert: false,
                    forceToAxis: false,
                    sensitivity: 1,
                    eventsTarget: "container",
                    thresholdDelta: null,
                    thresholdTime: null,
                    noMousewheelClass: "swiper-no-mousewheel"
                }
            });
            swiper.mousewheel = {
                enabled: false
            };
            let timeout;
            let lastScrollTime = app_now();
            let lastEventBeforeSnap;
            const recentWheelEvents = [];
            function normalize(e) {
                const PIXEL_STEP = 10;
                const LINE_HEIGHT = 40;
                const PAGE_HEIGHT = 800;
                let sX = 0;
                let sY = 0;
                let pX = 0;
                let pY = 0;
                if ("detail" in e) sY = e.detail;
                if ("wheelDelta" in e) sY = -e.wheelDelta / 120;
                if ("wheelDeltaY" in e) sY = -e.wheelDeltaY / 120;
                if ("wheelDeltaX" in e) sX = -e.wheelDeltaX / 120;
                if ("axis" in e && e.axis === e.HORIZONTAL_AXIS) {
                    sX = sY;
                    sY = 0;
                }
                pX = sX * PIXEL_STEP;
                pY = sY * PIXEL_STEP;
                if ("deltaY" in e) pY = e.deltaY;
                if ("deltaX" in e) pX = e.deltaX;
                if (e.shiftKey && !pX) {
                    pX = pY;
                    pY = 0;
                }
                if ((pX || pY) && e.deltaMode) if (e.deltaMode === 1) {
                    pX *= LINE_HEIGHT;
                    pY *= LINE_HEIGHT;
                } else {
                    pX *= PAGE_HEIGHT;
                    pY *= PAGE_HEIGHT;
                }
                if (pX && !sX) sX = pX < 1 ? -1 : 1;
                if (pY && !sY) sY = pY < 1 ? -1 : 1;
                return {
                    spinX: sX,
                    spinY: sY,
                    pixelX: pX,
                    pixelY: pY
                };
            }
            function handleMouseEnter() {
                if (!swiper.enabled) return;
                swiper.mouseEntered = true;
            }
            function handleMouseLeave() {
                if (!swiper.enabled) return;
                swiper.mouseEntered = false;
            }
            function animateSlider(newEvent) {
                if (swiper.params.mousewheel.thresholdDelta && newEvent.delta < swiper.params.mousewheel.thresholdDelta) return false;
                if (swiper.params.mousewheel.thresholdTime && app_now() - lastScrollTime < swiper.params.mousewheel.thresholdTime) return false;
                if (newEvent.delta >= 6 && app_now() - lastScrollTime < 60) return true;
                if (newEvent.direction < 0) {
                    if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {
                        swiper.slideNext();
                        emit("scroll", newEvent.raw);
                    }
                } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {
                    swiper.slidePrev();
                    emit("scroll", newEvent.raw);
                }
                lastScrollTime = (new window.Date).getTime();
                return false;
            }
            function releaseScroll(newEvent) {
                const params = swiper.params.mousewheel;
                if (newEvent.direction < 0) {
                    if (swiper.isEnd && !swiper.params.loop && params.releaseOnEdges) return true;
                } else if (swiper.isBeginning && !swiper.params.loop && params.releaseOnEdges) return true;
                return false;
            }
            function handle(event) {
                let e = event;
                let disableParentSwiper = true;
                if (!swiper.enabled) return;
                if (event.target.closest(`.${swiper.params.mousewheel.noMousewheelClass}`)) return;
                const params = swiper.params.mousewheel;
                if (swiper.params.cssMode) e.preventDefault();
                let targetEl = swiper.el;
                if (swiper.params.mousewheel.eventsTarget !== "container") targetEl = document.querySelector(swiper.params.mousewheel.eventsTarget);
                const targetElContainsTarget = targetEl && targetEl.contains(e.target);
                if (!swiper.mouseEntered && !targetElContainsTarget && !params.releaseOnEdges) return true;
                if (e.originalEvent) e = e.originalEvent;
                let delta = 0;
                const rtlFactor = swiper.rtlTranslate ? -1 : 1;
                const data = normalize(e);
                if (params.forceToAxis) if (swiper.isHorizontal()) if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) delta = -data.pixelX * rtlFactor; else return true; else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) delta = -data.pixelY; else return true; else delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;
                if (delta === 0) return true;
                if (params.invert) delta = -delta;
                let positions = swiper.getTranslate() + delta * params.sensitivity;
                if (positions >= swiper.minTranslate()) positions = swiper.minTranslate();
                if (positions <= swiper.maxTranslate()) positions = swiper.maxTranslate();
                disableParentSwiper = swiper.params.loop ? true : !(positions === swiper.minTranslate() || positions === swiper.maxTranslate());
                if (disableParentSwiper && swiper.params.nested) e.stopPropagation();
                if (!swiper.params.freeMode || !swiper.params.freeMode.enabled) {
                    const newEvent = {
                        time: app_now(),
                        delta: Math.abs(delta),
                        direction: Math.sign(delta),
                        raw: event
                    };
                    if (recentWheelEvents.length >= 2) recentWheelEvents.shift();
                    const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : void 0;
                    recentWheelEvents.push(newEvent);
                    if (prevEvent) {
                        if (newEvent.direction !== prevEvent.direction || newEvent.delta > prevEvent.delta || newEvent.time > prevEvent.time + 150) animateSlider(newEvent);
                    } else animateSlider(newEvent);
                    if (releaseScroll(newEvent)) return true;
                } else {
                    const newEvent = {
                        time: app_now(),
                        delta: Math.abs(delta),
                        direction: Math.sign(delta)
                    };
                    const ignoreWheelEvents = lastEventBeforeSnap && newEvent.time < lastEventBeforeSnap.time + 500 && newEvent.delta <= lastEventBeforeSnap.delta && newEvent.direction === lastEventBeforeSnap.direction;
                    if (!ignoreWheelEvents) {
                        lastEventBeforeSnap = void 0;
                        let position = swiper.getTranslate() + delta * params.sensitivity;
                        const wasBeginning = swiper.isBeginning;
                        const wasEnd = swiper.isEnd;
                        if (position >= swiper.minTranslate()) position = swiper.minTranslate();
                        if (position <= swiper.maxTranslate()) position = swiper.maxTranslate();
                        swiper.setTransition(0);
                        swiper.setTranslate(position);
                        swiper.updateProgress();
                        swiper.updateActiveIndex();
                        swiper.updateSlidesClasses();
                        if (!wasBeginning && swiper.isBeginning || !wasEnd && swiper.isEnd) swiper.updateSlidesClasses();
                        if (swiper.params.loop) swiper.loopFix({
                            direction: newEvent.direction < 0 ? "next" : "prev",
                            byMousewheel: true
                        });
                        if (swiper.params.freeMode.sticky) {
                            clearTimeout(timeout);
                            timeout = void 0;
                            if (recentWheelEvents.length >= 15) recentWheelEvents.shift();
                            const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : void 0;
                            const firstEvent = recentWheelEvents[0];
                            recentWheelEvents.push(newEvent);
                            if (prevEvent && (newEvent.delta > prevEvent.delta || newEvent.direction !== prevEvent.direction)) recentWheelEvents.splice(0); else if (recentWheelEvents.length >= 15 && newEvent.time - firstEvent.time < 500 && firstEvent.delta - newEvent.delta >= 1 && newEvent.delta <= 6) {
                                const snapToThreshold = delta > 0 ? .8 : .2;
                                lastEventBeforeSnap = newEvent;
                                recentWheelEvents.splice(0);
                                timeout = app_utils_nextTick((() => {
                                    if (swiper.destroyed || !swiper.params) return;
                                    swiper.slideToClosest(swiper.params.speed, true, void 0, snapToThreshold);
                                }), 0);
                            }
                            if (!timeout) timeout = app_utils_nextTick((() => {
                                if (swiper.destroyed || !swiper.params) return;
                                const snapToThreshold = .5;
                                lastEventBeforeSnap = newEvent;
                                recentWheelEvents.splice(0);
                                swiper.slideToClosest(swiper.params.speed, true, void 0, snapToThreshold);
                            }), 500);
                        }
                        if (!ignoreWheelEvents) emit("scroll", e);
                        if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction) swiper.autoplay.stop();
                        if (params.releaseOnEdges && (position === swiper.minTranslate() || position === swiper.maxTranslate())) return true;
                    }
                }
                if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
                return false;
            }
            function events(method) {
                let targetEl = swiper.el;
                if (swiper.params.mousewheel.eventsTarget !== "container") targetEl = document.querySelector(swiper.params.mousewheel.eventsTarget);
                targetEl[method]("mouseenter", handleMouseEnter);
                targetEl[method]("mouseleave", handleMouseLeave);
                targetEl[method]("wheel", handle);
            }
            function enable() {
                if (swiper.params.cssMode) {
                    swiper.wrapperEl.removeEventListener("wheel", handle);
                    return true;
                }
                if (swiper.mousewheel.enabled) return false;
                events("addEventListener");
                swiper.mousewheel.enabled = true;
                return true;
            }
            function disable() {
                if (swiper.params.cssMode) {
                    swiper.wrapperEl.addEventListener(event, handle);
                    return true;
                }
                if (!swiper.mousewheel.enabled) return false;
                events("removeEventListener");
                swiper.mousewheel.enabled = false;
                return true;
            }
            on("init", (() => {
                if (!swiper.params.mousewheel.enabled && swiper.params.cssMode) disable();
                if (swiper.params.mousewheel.enabled) enable();
            }));
            on("destroy", (() => {
                if (swiper.params.cssMode) enable();
                if (swiper.mousewheel.enabled) disable();
            }));
            Object.assign(swiper.mousewheel, {
                enable,
                disable
            });
        }
        function app_create_element_if_not_defined_createElementIfNotDefined(swiper, originalParams, params, checkProps) {
            if (swiper.params.createElements) Object.keys(checkProps).forEach((key => {
                if (!params[key] && params.auto === true) {
                    let element = app_utils_elementChildren(swiper.el, `.${checkProps[key]}`)[0];
                    if (!element) {
                        element = app_utils_createElement("div", checkProps[key]);
                        element.className = checkProps[key];
                        swiper.el.append(element);
                    }
                    params[key] = element;
                    originalParams[key] = element;
                }
            }));
            return params;
        }
        function app_Navigation(_ref) {
            let {swiper, extendParams, on, emit} = _ref;
            extendParams({
                navigation: {
                    nextEl: null,
                    prevEl: null,
                    hideOnClick: false,
                    disabledClass: "swiper-button-disabled",
                    hiddenClass: "swiper-button-hidden",
                    lockClass: "swiper-button-lock",
                    navigationDisabledClass: "swiper-navigation-disabled"
                }
            });
            swiper.navigation = {
                nextEl: null,
                prevEl: null
            };
            function getEl(el) {
                let res;
                if (el && typeof el === "string" && swiper.isElement) {
                    res = swiper.el.querySelector(el) || swiper.hostEl.querySelector(el);
                    if (res) return res;
                }
                if (el) {
                    if (typeof el === "string") res = [ ...document.querySelectorAll(el) ];
                    if (swiper.params.uniqueNavElements && typeof el === "string" && res && res.length > 1 && swiper.el.querySelectorAll(el).length === 1) res = swiper.el.querySelector(el); else if (res && res.length === 1) res = res[0];
                }
                if (el && !res) return el;
                return res;
            }
            function toggleEl(el, disabled) {
                const params = swiper.params.navigation;
                el = app_utils_makeElementsArray(el);
                el.forEach((subEl => {
                    if (subEl) {
                        subEl.classList[disabled ? "add" : "remove"](...params.disabledClass.split(" "));
                        if (subEl.tagName === "BUTTON") subEl.disabled = disabled;
                        if (swiper.params.watchOverflow && swiper.enabled) subEl.classList[swiper.isLocked ? "add" : "remove"](params.lockClass);
                    }
                }));
            }
            function update() {
                const {nextEl, prevEl} = swiper.navigation;
                if (swiper.params.loop) {
                    toggleEl(prevEl, false);
                    toggleEl(nextEl, false);
                    return;
                }
                toggleEl(prevEl, swiper.isBeginning && !swiper.params.rewind);
                toggleEl(nextEl, swiper.isEnd && !swiper.params.rewind);
            }
            function onPrevClick(e) {
                e.preventDefault();
                if (swiper.isBeginning && !swiper.params.loop && !swiper.params.rewind) return;
                swiper.slidePrev();
                emit("navigationPrev");
            }
            function onNextClick(e) {
                e.preventDefault();
                if (swiper.isEnd && !swiper.params.loop && !swiper.params.rewind) return;
                swiper.slideNext();
                emit("navigationNext");
            }
            function init() {
                const params = swiper.params.navigation;
                swiper.params.navigation = app_create_element_if_not_defined_createElementIfNotDefined(swiper, swiper.originalParams.navigation, swiper.params.navigation, {
                    nextEl: "swiper-button-next",
                    prevEl: "swiper-button-prev"
                });
                if (!(params.nextEl || params.prevEl)) return;
                let nextEl = getEl(params.nextEl);
                let prevEl = getEl(params.prevEl);
                Object.assign(swiper.navigation, {
                    nextEl,
                    prevEl
                });
                nextEl = app_utils_makeElementsArray(nextEl);
                prevEl = app_utils_makeElementsArray(prevEl);
                const initButton = (el, dir) => {
                    if (el) el.addEventListener("click", dir === "next" ? onNextClick : onPrevClick);
                    if (!swiper.enabled && el) el.classList.add(...params.lockClass.split(" "));
                };
                nextEl.forEach((el => initButton(el, "next")));
                prevEl.forEach((el => initButton(el, "prev")));
            }
            function destroy() {
                let {nextEl, prevEl} = swiper.navigation;
                nextEl = app_utils_makeElementsArray(nextEl);
                prevEl = app_utils_makeElementsArray(prevEl);
                const destroyButton = (el, dir) => {
                    el.removeEventListener("click", dir === "next" ? onNextClick : onPrevClick);
                    el.classList.remove(...swiper.params.navigation.disabledClass.split(" "));
                };
                nextEl.forEach((el => destroyButton(el, "next")));
                prevEl.forEach((el => destroyButton(el, "prev")));
            }
            on("init", (() => {
                if (swiper.params.navigation.enabled === false) disable(); else {
                    init();
                    update();
                }
            }));
            on("toEdge fromEdge lock unlock", (() => {
                update();
            }));
            on("destroy", (() => {
                destroy();
            }));
            on("enable disable", (() => {
                let {nextEl, prevEl} = swiper.navigation;
                nextEl = app_utils_makeElementsArray(nextEl);
                prevEl = app_utils_makeElementsArray(prevEl);
                if (swiper.enabled) {
                    update();
                    return;
                }
                [ ...nextEl, ...prevEl ].filter((el => !!el)).forEach((el => el.classList.add(swiper.params.navigation.lockClass)));
            }));
            on("click", ((_s, e) => {
                let {nextEl, prevEl} = swiper.navigation;
                nextEl = app_utils_makeElementsArray(nextEl);
                prevEl = app_utils_makeElementsArray(prevEl);
                const targetEl = e.target;
                let targetIsButton = prevEl.includes(targetEl) || nextEl.includes(targetEl);
                if (swiper.isElement && !targetIsButton) {
                    const path = e.path || e.composedPath && e.composedPath();
                    if (path) targetIsButton = path.find((pathEl => nextEl.includes(pathEl) || prevEl.includes(pathEl)));
                }
                if (swiper.params.navigation.hideOnClick && !targetIsButton) {
                    if (swiper.pagination && swiper.params.pagination && swiper.params.pagination.clickable && (swiper.pagination.el === targetEl || swiper.pagination.el.contains(targetEl))) return;
                    let isHidden;
                    if (nextEl.length) isHidden = nextEl[0].classList.contains(swiper.params.navigation.hiddenClass); else if (prevEl.length) isHidden = prevEl[0].classList.contains(swiper.params.navigation.hiddenClass);
                    if (isHidden === true) emit("navigationShow"); else emit("navigationHide");
                    [ ...nextEl, ...prevEl ].filter((el => !!el)).forEach((el => el.classList.toggle(swiper.params.navigation.hiddenClass)));
                }
            }));
            const enable = () => {
                swiper.el.classList.remove(...swiper.params.navigation.navigationDisabledClass.split(" "));
                init();
                update();
            };
            const disable = () => {
                swiper.el.classList.add(...swiper.params.navigation.navigationDisabledClass.split(" "));
                destroy();
            };
            Object.assign(swiper.navigation, {
                enable,
                disable,
                update,
                init,
                destroy
            });
        }
        function app_classes_to_selector_classesToSelector(classes) {
            if (classes === void 0) classes = "";
            return `.${classes.trim().replace(/([\.:!+\/])/g, "\\$1").replace(/ /g, ".")}`;
        }
        function app_Pagination(_ref) {
            let {swiper, extendParams, on, emit} = _ref;
            const pfx = "swiper-pagination";
            extendParams({
                pagination: {
                    el: null,
                    bulletElement: "span",
                    clickable: false,
                    hideOnClick: false,
                    renderBullet: null,
                    renderProgressbar: null,
                    renderFraction: null,
                    renderCustom: null,
                    progressbarOpposite: false,
                    type: "bullets",
                    dynamicBullets: false,
                    dynamicMainBullets: 1,
                    formatFractionCurrent: number => number,
                    formatFractionTotal: number => number,
                    bulletClass: `${pfx}-bullet`,
                    bulletActiveClass: `${pfx}-bullet-active`,
                    modifierClass: `${pfx}-`,
                    currentClass: `${pfx}-current`,
                    totalClass: `${pfx}-total`,
                    hiddenClass: `${pfx}-hidden`,
                    progressbarFillClass: `${pfx}-progressbar-fill`,
                    progressbarOppositeClass: `${pfx}-progressbar-opposite`,
                    clickableClass: `${pfx}-clickable`,
                    lockClass: `${pfx}-lock`,
                    horizontalClass: `${pfx}-horizontal`,
                    verticalClass: `${pfx}-vertical`,
                    paginationDisabledClass: `${pfx}-disabled`
                }
            });
            swiper.pagination = {
                el: null,
                bullets: []
            };
            let bulletSize;
            let dynamicBulletIndex = 0;
            function isPaginationDisabled() {
                return !swiper.params.pagination.el || !swiper.pagination.el || Array.isArray(swiper.pagination.el) && swiper.pagination.el.length === 0;
            }
            function setSideBullets(bulletEl, position) {
                const {bulletActiveClass} = swiper.params.pagination;
                if (!bulletEl) return;
                bulletEl = bulletEl[`${position === "prev" ? "previous" : "next"}ElementSibling`];
                if (bulletEl) {
                    bulletEl.classList.add(`${bulletActiveClass}-${position}`);
                    bulletEl = bulletEl[`${position === "prev" ? "previous" : "next"}ElementSibling`];
                    if (bulletEl) bulletEl.classList.add(`${bulletActiveClass}-${position}-${position}`);
                }
            }
            function getMoveDirection(prevIndex, nextIndex, length) {
                prevIndex %= length;
                nextIndex %= length;
                if (nextIndex === prevIndex + 1) return "next"; else if (nextIndex === prevIndex - 1) return "previous";
                return;
            }
            function onBulletClick(e) {
                const bulletEl = e.target.closest(app_classes_to_selector_classesToSelector(swiper.params.pagination.bulletClass));
                if (!bulletEl) return;
                e.preventDefault();
                const index = app_utils_elementIndex(bulletEl) * swiper.params.slidesPerGroup;
                if (swiper.params.loop) {
                    if (swiper.realIndex === index) return;
                    const moveDirection = getMoveDirection(swiper.realIndex, index, swiper.slides.length);
                    if (moveDirection === "next") swiper.slideNext(); else if (moveDirection === "previous") swiper.slidePrev(); else swiper.slideToLoop(index);
                } else swiper.slideTo(index);
            }
            function update() {
                const rtl = swiper.rtl;
                const params = swiper.params.pagination;
                if (isPaginationDisabled()) return;
                let el = swiper.pagination.el;
                el = app_utils_makeElementsArray(el);
                let current;
                let previousIndex;
                const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
                const total = swiper.params.loop ? Math.ceil(slidesLength / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
                if (swiper.params.loop) {
                    previousIndex = swiper.previousRealIndex || 0;
                    current = swiper.params.slidesPerGroup > 1 ? Math.floor(swiper.realIndex / swiper.params.slidesPerGroup) : swiper.realIndex;
                } else if (typeof swiper.snapIndex !== "undefined") {
                    current = swiper.snapIndex;
                    previousIndex = swiper.previousSnapIndex;
                } else {
                    previousIndex = swiper.previousIndex || 0;
                    current = swiper.activeIndex || 0;
                }
                if (params.type === "bullets" && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {
                    const bullets = swiper.pagination.bullets;
                    let firstIndex;
                    let lastIndex;
                    let midIndex;
                    if (params.dynamicBullets) {
                        bulletSize = app_elementOuterSize(bullets[0], swiper.isHorizontal() ? "width" : "height", true);
                        el.forEach((subEl => {
                            subEl.style[swiper.isHorizontal() ? "width" : "height"] = `${bulletSize * (params.dynamicMainBullets + 4)}px`;
                        }));
                        if (params.dynamicMainBullets > 1 && previousIndex !== void 0) {
                            dynamicBulletIndex += current - (previousIndex || 0);
                            if (dynamicBulletIndex > params.dynamicMainBullets - 1) dynamicBulletIndex = params.dynamicMainBullets - 1; else if (dynamicBulletIndex < 0) dynamicBulletIndex = 0;
                        }
                        firstIndex = Math.max(current - dynamicBulletIndex, 0);
                        lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);
                        midIndex = (lastIndex + firstIndex) / 2;
                    }
                    bullets.forEach((bulletEl => {
                        const classesToRemove = [ ...[ "", "-next", "-next-next", "-prev", "-prev-prev", "-main" ].map((suffix => `${params.bulletActiveClass}${suffix}`)) ].map((s => typeof s === "string" && s.includes(" ") ? s.split(" ") : s)).flat();
                        bulletEl.classList.remove(...classesToRemove);
                    }));
                    if (el.length > 1) bullets.forEach((bullet => {
                        const bulletIndex = app_utils_elementIndex(bullet);
                        if (bulletIndex === current) bullet.classList.add(...params.bulletActiveClass.split(" ")); else if (swiper.isElement) bullet.setAttribute("part", "bullet");
                        if (params.dynamicBullets) {
                            if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) bullet.classList.add(...`${params.bulletActiveClass}-main`.split(" "));
                            if (bulletIndex === firstIndex) setSideBullets(bullet, "prev");
                            if (bulletIndex === lastIndex) setSideBullets(bullet, "next");
                        }
                    })); else {
                        const bullet = bullets[current];
                        if (bullet) bullet.classList.add(...params.bulletActiveClass.split(" "));
                        if (swiper.isElement) bullets.forEach(((bulletEl, bulletIndex) => {
                            bulletEl.setAttribute("part", bulletIndex === current ? "bullet-active" : "bullet");
                        }));
                        if (params.dynamicBullets) {
                            const firstDisplayedBullet = bullets[firstIndex];
                            const lastDisplayedBullet = bullets[lastIndex];
                            for (let i = firstIndex; i <= lastIndex; i += 1) if (bullets[i]) bullets[i].classList.add(...`${params.bulletActiveClass}-main`.split(" "));
                            setSideBullets(firstDisplayedBullet, "prev");
                            setSideBullets(lastDisplayedBullet, "next");
                        }
                    }
                    if (params.dynamicBullets) {
                        const dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);
                        const bulletsOffset = (bulletSize * dynamicBulletsLength - bulletSize) / 2 - midIndex * bulletSize;
                        const offsetProp = rtl ? "right" : "left";
                        bullets.forEach((bullet => {
                            bullet.style[swiper.isHorizontal() ? offsetProp : "top"] = `${bulletsOffset}px`;
                        }));
                    }
                }
                el.forEach(((subEl, subElIndex) => {
                    if (params.type === "fraction") {
                        subEl.querySelectorAll(app_classes_to_selector_classesToSelector(params.currentClass)).forEach((fractionEl => {
                            fractionEl.textContent = params.formatFractionCurrent(current + 1);
                        }));
                        subEl.querySelectorAll(app_classes_to_selector_classesToSelector(params.totalClass)).forEach((totalEl => {
                            totalEl.textContent = params.formatFractionTotal(total);
                        }));
                    }
                    if (params.type === "progressbar") {
                        let progressbarDirection;
                        if (params.progressbarOpposite) progressbarDirection = swiper.isHorizontal() ? "vertical" : "horizontal"; else progressbarDirection = swiper.isHorizontal() ? "horizontal" : "vertical";
                        const scale = (current + 1) / total;
                        let scaleX = 1;
                        let scaleY = 1;
                        if (progressbarDirection === "horizontal") scaleX = scale; else scaleY = scale;
                        subEl.querySelectorAll(app_classes_to_selector_classesToSelector(params.progressbarFillClass)).forEach((progressEl => {
                            progressEl.style.transform = `translate3d(0,0,0) scaleX(${scaleX}) scaleY(${scaleY})`;
                            progressEl.style.transitionDuration = `${swiper.params.speed}ms`;
                        }));
                    }
                    if (params.type === "custom" && params.renderCustom) {
                        subEl.innerHTML = params.renderCustom(swiper, current + 1, total);
                        if (subElIndex === 0) emit("paginationRender", subEl);
                    } else {
                        if (subElIndex === 0) emit("paginationRender", subEl);
                        emit("paginationUpdate", subEl);
                    }
                    if (swiper.params.watchOverflow && swiper.enabled) subEl.classList[swiper.isLocked ? "add" : "remove"](params.lockClass);
                }));
            }
            function render() {
                const params = swiper.params.pagination;
                if (isPaginationDisabled()) return;
                const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.grid && swiper.params.grid.rows > 1 ? swiper.slides.length / Math.ceil(swiper.params.grid.rows) : swiper.slides.length;
                let el = swiper.pagination.el;
                el = app_utils_makeElementsArray(el);
                let paginationHTML = "";
                if (params.type === "bullets") {
                    let numberOfBullets = swiper.params.loop ? Math.ceil(slidesLength / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
                    if (swiper.params.freeMode && swiper.params.freeMode.enabled && numberOfBullets > slidesLength) numberOfBullets = slidesLength;
                    for (let i = 0; i < numberOfBullets; i += 1) if (params.renderBullet) paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass); else paginationHTML += `<${params.bulletElement} ${swiper.isElement ? 'part="bullet"' : ""} class="${params.bulletClass}"></${params.bulletElement}>`;
                }
                if (params.type === "fraction") if (params.renderFraction) paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass); else paginationHTML = `<span class="${params.currentClass}"></span>` + " / " + `<span class="${params.totalClass}"></span>`;
                if (params.type === "progressbar") if (params.renderProgressbar) paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass); else paginationHTML = `<span class="${params.progressbarFillClass}"></span>`;
                swiper.pagination.bullets = [];
                el.forEach((subEl => {
                    if (params.type !== "custom") subEl.innerHTML = paginationHTML || "";
                    if (params.type === "bullets") swiper.pagination.bullets.push(...subEl.querySelectorAll(app_classes_to_selector_classesToSelector(params.bulletClass)));
                }));
                if (params.type !== "custom") emit("paginationRender", el[0]);
            }
            function init() {
                swiper.params.pagination = app_create_element_if_not_defined_createElementIfNotDefined(swiper, swiper.originalParams.pagination, swiper.params.pagination, {
                    el: "swiper-pagination"
                });
                const params = swiper.params.pagination;
                if (!params.el) return;
                let el;
                if (typeof params.el === "string" && swiper.isElement) el = swiper.el.querySelector(params.el);
                if (!el && typeof params.el === "string") el = [ ...document.querySelectorAll(params.el) ];
                if (!el) el = params.el;
                if (!el || el.length === 0) return;
                if (swiper.params.uniqueNavElements && typeof params.el === "string" && Array.isArray(el) && el.length > 1) {
                    el = [ ...swiper.el.querySelectorAll(params.el) ];
                    if (el.length > 1) el = el.filter((subEl => {
                        if (app_utils_elementParents(subEl, ".swiper")[0] !== swiper.el) return false;
                        return true;
                    }))[0];
                }
                if (Array.isArray(el) && el.length === 1) el = el[0];
                Object.assign(swiper.pagination, {
                    el
                });
                el = app_utils_makeElementsArray(el);
                el.forEach((subEl => {
                    if (params.type === "bullets" && params.clickable) subEl.classList.add(...(params.clickableClass || "").split(" "));
                    subEl.classList.add(params.modifierClass + params.type);
                    subEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
                    if (params.type === "bullets" && params.dynamicBullets) {
                        subEl.classList.add(`${params.modifierClass}${params.type}-dynamic`);
                        dynamicBulletIndex = 0;
                        if (params.dynamicMainBullets < 1) params.dynamicMainBullets = 1;
                    }
                    if (params.type === "progressbar" && params.progressbarOpposite) subEl.classList.add(params.progressbarOppositeClass);
                    if (params.clickable) subEl.addEventListener("click", onBulletClick);
                    if (!swiper.enabled) subEl.classList.add(params.lockClass);
                }));
            }
            function destroy() {
                const params = swiper.params.pagination;
                if (isPaginationDisabled()) return;
                let el = swiper.pagination.el;
                if (el) {
                    el = app_utils_makeElementsArray(el);
                    el.forEach((subEl => {
                        subEl.classList.remove(params.hiddenClass);
                        subEl.classList.remove(params.modifierClass + params.type);
                        subEl.classList.remove(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
                        if (params.clickable) {
                            subEl.classList.remove(...(params.clickableClass || "").split(" "));
                            subEl.removeEventListener("click", onBulletClick);
                        }
                    }));
                }
                if (swiper.pagination.bullets) swiper.pagination.bullets.forEach((subEl => subEl.classList.remove(...params.bulletActiveClass.split(" "))));
            }
            on("changeDirection", (() => {
                if (!swiper.pagination || !swiper.pagination.el) return;
                const params = swiper.params.pagination;
                let {el} = swiper.pagination;
                el = app_utils_makeElementsArray(el);
                el.forEach((subEl => {
                    subEl.classList.remove(params.horizontalClass, params.verticalClass);
                    subEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
                }));
            }));
            on("init", (() => {
                if (swiper.params.pagination.enabled === false) disable(); else {
                    init();
                    render();
                    update();
                }
            }));
            on("activeIndexChange", (() => {
                if (typeof swiper.snapIndex === "undefined") update();
            }));
            on("snapIndexChange", (() => {
                update();
            }));
            on("snapGridLengthChange", (() => {
                render();
                update();
            }));
            on("destroy", (() => {
                destroy();
            }));
            on("enable disable", (() => {
                let {el} = swiper.pagination;
                if (el) {
                    el = app_utils_makeElementsArray(el);
                    el.forEach((subEl => subEl.classList[swiper.enabled ? "remove" : "add"](swiper.params.pagination.lockClass)));
                }
            }));
            on("lock unlock", (() => {
                update();
            }));
            on("click", ((_s, e) => {
                const targetEl = e.target;
                const el = app_utils_makeElementsArray(swiper.pagination.el);
                if (swiper.params.pagination.el && swiper.params.pagination.hideOnClick && el && el.length > 0 && !targetEl.classList.contains(swiper.params.pagination.bulletClass)) {
                    if (swiper.navigation && (swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl || swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl)) return;
                    const isHidden = el[0].classList.contains(swiper.params.pagination.hiddenClass);
                    if (isHidden === true) emit("paginationShow"); else emit("paginationHide");
                    el.forEach((subEl => subEl.classList.toggle(swiper.params.pagination.hiddenClass)));
                }
            }));
            const enable = () => {
                swiper.el.classList.remove(swiper.params.pagination.paginationDisabledClass);
                let {el} = swiper.pagination;
                if (el) {
                    el = app_utils_makeElementsArray(el);
                    el.forEach((subEl => subEl.classList.remove(swiper.params.pagination.paginationDisabledClass)));
                }
                init();
                render();
                update();
            };
            const disable = () => {
                swiper.el.classList.add(swiper.params.pagination.paginationDisabledClass);
                let {el} = swiper.pagination;
                if (el) {
                    el = app_utils_makeElementsArray(el);
                    el.forEach((subEl => subEl.classList.add(swiper.params.pagination.paginationDisabledClass)));
                }
                destroy();
            };
            Object.assign(swiper.pagination, {
                enable,
                disable,
                render,
                update,
                init,
                destroy
            });
        }
        function app_Thumb(_ref) {
            let {swiper, extendParams, on} = _ref;
            extendParams({
                thumbs: {
                    swiper: null,
                    multipleActiveThumbs: true,
                    autoScrollOffset: 0,
                    slideThumbActiveClass: "swiper-slide-thumb-active",
                    thumbsContainerClass: "swiper-thumbs"
                }
            });
            let initialized = false;
            let swiperCreated = false;
            swiper.thumbs = {
                swiper: null
            };
            function onThumbClick() {
                const thumbsSwiper = swiper.thumbs.swiper;
                if (!thumbsSwiper || thumbsSwiper.destroyed) return;
                const clickedIndex = thumbsSwiper.clickedIndex;
                const clickedSlide = thumbsSwiper.clickedSlide;
                if (clickedSlide && clickedSlide.classList.contains(swiper.params.thumbs.slideThumbActiveClass)) return;
                if (typeof clickedIndex === "undefined" || clickedIndex === null) return;
                let slideToIndex;
                if (thumbsSwiper.params.loop) slideToIndex = parseInt(thumbsSwiper.clickedSlide.getAttribute("data-swiper-slide-index"), 10); else slideToIndex = clickedIndex;
                if (swiper.params.loop) swiper.slideToLoop(slideToIndex); else swiper.slideTo(slideToIndex);
            }
            function init() {
                const {thumbs: thumbsParams} = swiper.params;
                if (initialized) return false;
                initialized = true;
                const SwiperClass = swiper.constructor;
                if (thumbsParams.swiper instanceof SwiperClass) {
                    swiper.thumbs.swiper = thumbsParams.swiper;
                    Object.assign(swiper.thumbs.swiper.originalParams, {
                        watchSlidesProgress: true,
                        slideToClickedSlide: false
                    });
                    Object.assign(swiper.thumbs.swiper.params, {
                        watchSlidesProgress: true,
                        slideToClickedSlide: false
                    });
                    swiper.thumbs.swiper.update();
                } else if (app_utils_isObject(thumbsParams.swiper)) {
                    const thumbsSwiperParams = Object.assign({}, thumbsParams.swiper);
                    Object.assign(thumbsSwiperParams, {
                        watchSlidesProgress: true,
                        slideToClickedSlide: false
                    });
                    swiper.thumbs.swiper = new SwiperClass(thumbsSwiperParams);
                    swiperCreated = true;
                }
                swiper.thumbs.swiper.el.classList.add(swiper.params.thumbs.thumbsContainerClass);
                swiper.thumbs.swiper.on("tap", onThumbClick);
                return true;
            }
            function update(initial) {
                const thumbsSwiper = swiper.thumbs.swiper;
                if (!thumbsSwiper || thumbsSwiper.destroyed) return;
                const slidesPerView = thumbsSwiper.params.slidesPerView === "auto" ? thumbsSwiper.slidesPerViewDynamic() : thumbsSwiper.params.slidesPerView;
                let thumbsToActivate = 1;
                const thumbActiveClass = swiper.params.thumbs.slideThumbActiveClass;
                if (swiper.params.slidesPerView > 1 && !swiper.params.centeredSlides) thumbsToActivate = swiper.params.slidesPerView;
                if (!swiper.params.thumbs.multipleActiveThumbs) thumbsToActivate = 1;
                thumbsToActivate = Math.floor(thumbsToActivate);
                thumbsSwiper.slides.forEach((slideEl => slideEl.classList.remove(thumbActiveClass)));
                if (thumbsSwiper.params.loop || thumbsSwiper.params.virtual && thumbsSwiper.params.virtual.enabled) for (let i = 0; i < thumbsToActivate; i += 1) app_utils_elementChildren(thumbsSwiper.slidesEl, `[data-swiper-slide-index="${swiper.realIndex + i}"]`).forEach((slideEl => {
                    slideEl.classList.add(thumbActiveClass);
                })); else for (let i = 0; i < thumbsToActivate; i += 1) if (thumbsSwiper.slides[swiper.realIndex + i]) thumbsSwiper.slides[swiper.realIndex + i].classList.add(thumbActiveClass);
                const autoScrollOffset = swiper.params.thumbs.autoScrollOffset;
                const useOffset = autoScrollOffset && !thumbsSwiper.params.loop;
                if (swiper.realIndex !== thumbsSwiper.realIndex || useOffset) {
                    const currentThumbsIndex = thumbsSwiper.activeIndex;
                    let newThumbsIndex;
                    let direction;
                    if (thumbsSwiper.params.loop) {
                        const newThumbsSlide = thumbsSwiper.slides.filter((slideEl => slideEl.getAttribute("data-swiper-slide-index") === `${swiper.realIndex}`))[0];
                        newThumbsIndex = thumbsSwiper.slides.indexOf(newThumbsSlide);
                        direction = swiper.activeIndex > swiper.previousIndex ? "next" : "prev";
                    } else {
                        newThumbsIndex = swiper.realIndex;
                        direction = newThumbsIndex > swiper.previousIndex ? "next" : "prev";
                    }
                    if (useOffset) newThumbsIndex += direction === "next" ? autoScrollOffset : -1 * autoScrollOffset;
                    if (thumbsSwiper.visibleSlidesIndexes && thumbsSwiper.visibleSlidesIndexes.indexOf(newThumbsIndex) < 0) {
                        if (thumbsSwiper.params.centeredSlides) if (newThumbsIndex > currentThumbsIndex) newThumbsIndex = newThumbsIndex - Math.floor(slidesPerView / 2) + 1; else newThumbsIndex = newThumbsIndex + Math.floor(slidesPerView / 2) - 1; else if (newThumbsIndex > currentThumbsIndex && thumbsSwiper.params.slidesPerGroup === 1) ;
                        thumbsSwiper.slideTo(newThumbsIndex, initial ? 0 : void 0);
                    }
                }
            }
            on("beforeInit", (() => {
                const {thumbs} = swiper.params;
                if (!thumbs || !thumbs.swiper) return;
                if (typeof thumbs.swiper === "string" || thumbs.swiper instanceof HTMLElement) {
                    const document = app_ssr_window_esm_getDocument();
                    const getThumbsElementAndInit = () => {
                        const thumbsElement = typeof thumbs.swiper === "string" ? document.querySelector(thumbs.swiper) : thumbs.swiper;
                        if (thumbsElement && thumbsElement.swiper) {
                            thumbs.swiper = thumbsElement.swiper;
                            init();
                            update(true);
                        } else if (thumbsElement) {
                            const eventName = `${swiper.params.eventsPrefix}init`;
                            const onThumbsSwiper = e => {
                                thumbs.swiper = e.detail[0];
                                thumbsElement.removeEventListener(eventName, onThumbsSwiper);
                                init();
                                update(true);
                                thumbs.swiper.update();
                                swiper.update();
                            };
                            thumbsElement.addEventListener(eventName, onThumbsSwiper);
                        }
                        return thumbsElement;
                    };
                    const watchForThumbsToAppear = () => {
                        if (swiper.destroyed) return;
                        const thumbsElement = getThumbsElementAndInit();
                        if (!thumbsElement) requestAnimationFrame(watchForThumbsToAppear);
                    };
                    requestAnimationFrame(watchForThumbsToAppear);
                } else {
                    init();
                    update(true);
                }
            }));
            on("slideChange update resize observerUpdate", (() => {
                update();
            }));
            on("setTransition", ((_s, duration) => {
                const thumbsSwiper = swiper.thumbs.swiper;
                if (!thumbsSwiper || thumbsSwiper.destroyed) return;
                thumbsSwiper.setTransition(duration);
            }));
            on("beforeDestroy", (() => {
                const thumbsSwiper = swiper.thumbs.swiper;
                if (!thumbsSwiper || thumbsSwiper.destroyed) return;
                if (swiperCreated) thumbsSwiper.destroy();
            }));
            Object.assign(swiper.thumbs, {
                init,
                update
            });
        }
        function app_freeMode(_ref) {
            let {swiper, extendParams, emit, once} = _ref;
            extendParams({
                freeMode: {
                    enabled: false,
                    momentum: true,
                    momentumRatio: 1,
                    momentumBounce: true,
                    momentumBounceRatio: 1,
                    momentumVelocityRatio: 1,
                    sticky: false,
                    minimumVelocity: .02
                }
            });
            function onTouchStart() {
                if (swiper.params.cssMode) return;
                const translate = swiper.getTranslate();
                swiper.setTranslate(translate);
                swiper.setTransition(0);
                swiper.touchEventsData.velocities.length = 0;
                swiper.freeMode.onTouchEnd({
                    currentPos: swiper.rtl ? swiper.translate : -swiper.translate
                });
            }
            function onTouchMove() {
                if (swiper.params.cssMode) return;
                const {touchEventsData: data, touches} = swiper;
                if (data.velocities.length === 0) data.velocities.push({
                    position: touches[swiper.isHorizontal() ? "startX" : "startY"],
                    time: data.touchStartTime
                });
                data.velocities.push({
                    position: touches[swiper.isHorizontal() ? "currentX" : "currentY"],
                    time: app_now()
                });
            }
            function onTouchEnd(_ref2) {
                let {currentPos} = _ref2;
                if (swiper.params.cssMode) return;
                const {params, wrapperEl, rtlTranslate: rtl, snapGrid, touchEventsData: data} = swiper;
                const touchEndTime = app_now();
                const timeDiff = touchEndTime - data.touchStartTime;
                if (currentPos < -swiper.minTranslate()) {
                    swiper.slideTo(swiper.activeIndex);
                    return;
                }
                if (currentPos > -swiper.maxTranslate()) {
                    if (swiper.slides.length < snapGrid.length) swiper.slideTo(snapGrid.length - 1); else swiper.slideTo(swiper.slides.length - 1);
                    return;
                }
                if (params.freeMode.momentum) {
                    if (data.velocities.length > 1) {
                        const lastMoveEvent = data.velocities.pop();
                        const velocityEvent = data.velocities.pop();
                        const distance = lastMoveEvent.position - velocityEvent.position;
                        const time = lastMoveEvent.time - velocityEvent.time;
                        swiper.velocity = distance / time;
                        swiper.velocity /= 2;
                        if (Math.abs(swiper.velocity) < params.freeMode.minimumVelocity) swiper.velocity = 0;
                        if (time > 150 || app_now() - lastMoveEvent.time > 300) swiper.velocity = 0;
                    } else swiper.velocity = 0;
                    swiper.velocity *= params.freeMode.momentumVelocityRatio;
                    data.velocities.length = 0;
                    let momentumDuration = 1e3 * params.freeMode.momentumRatio;
                    const momentumDistance = swiper.velocity * momentumDuration;
                    let newPosition = swiper.translate + momentumDistance;
                    if (rtl) newPosition = -newPosition;
                    let doBounce = false;
                    let afterBouncePosition;
                    const bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeMode.momentumBounceRatio;
                    let needsLoopFix;
                    if (newPosition < swiper.maxTranslate()) {
                        if (params.freeMode.momentumBounce) {
                            if (newPosition + swiper.maxTranslate() < -bounceAmount) newPosition = swiper.maxTranslate() - bounceAmount;
                            afterBouncePosition = swiper.maxTranslate();
                            doBounce = true;
                            data.allowMomentumBounce = true;
                        } else newPosition = swiper.maxTranslate();
                        if (params.loop && params.centeredSlides) needsLoopFix = true;
                    } else if (newPosition > swiper.minTranslate()) {
                        if (params.freeMode.momentumBounce) {
                            if (newPosition - swiper.minTranslate() > bounceAmount) newPosition = swiper.minTranslate() + bounceAmount;
                            afterBouncePosition = swiper.minTranslate();
                            doBounce = true;
                            data.allowMomentumBounce = true;
                        } else newPosition = swiper.minTranslate();
                        if (params.loop && params.centeredSlides) needsLoopFix = true;
                    } else if (params.freeMode.sticky) {
                        let nextSlide;
                        for (let j = 0; j < snapGrid.length; j += 1) if (snapGrid[j] > -newPosition) {
                            nextSlide = j;
                            break;
                        }
                        if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === "next") newPosition = snapGrid[nextSlide]; else newPosition = snapGrid[nextSlide - 1];
                        newPosition = -newPosition;
                    }
                    if (needsLoopFix) once("transitionEnd", (() => {
                        swiper.loopFix();
                    }));
                    if (swiper.velocity !== 0) {
                        if (rtl) momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity); else momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);
                        if (params.freeMode.sticky) {
                            const moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);
                            const currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];
                            if (moveDistance < currentSlideSize) momentumDuration = params.speed; else if (moveDistance < 2 * currentSlideSize) momentumDuration = params.speed * 1.5; else momentumDuration = params.speed * 2.5;
                        }
                    } else if (params.freeMode.sticky) {
                        swiper.slideToClosest();
                        return;
                    }
                    if (params.freeMode.momentumBounce && doBounce) {
                        swiper.updateProgress(afterBouncePosition);
                        swiper.setTransition(momentumDuration);
                        swiper.setTranslate(newPosition);
                        swiper.transitionStart(true, swiper.swipeDirection);
                        swiper.animating = true;
                        app_utils_elementTransitionEnd(wrapperEl, (() => {
                            if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;
                            emit("momentumBounce");
                            swiper.setTransition(params.speed);
                            setTimeout((() => {
                                swiper.setTranslate(afterBouncePosition);
                                app_utils_elementTransitionEnd(wrapperEl, (() => {
                                    if (!swiper || swiper.destroyed) return;
                                    swiper.transitionEnd();
                                }));
                            }), 0);
                        }));
                    } else if (swiper.velocity) {
                        emit("_freeModeNoMomentumRelease");
                        swiper.updateProgress(newPosition);
                        swiper.setTransition(momentumDuration);
                        swiper.setTranslate(newPosition);
                        swiper.transitionStart(true, swiper.swipeDirection);
                        if (!swiper.animating) {
                            swiper.animating = true;
                            app_utils_elementTransitionEnd(wrapperEl, (() => {
                                if (!swiper || swiper.destroyed) return;
                                swiper.transitionEnd();
                            }));
                        }
                    } else swiper.updateProgress(newPosition);
                    swiper.updateActiveIndex();
                    swiper.updateSlidesClasses();
                } else if (params.freeMode.sticky) {
                    swiper.slideToClosest();
                    return;
                } else if (params.freeMode) emit("_freeModeNoMomentumRelease");
                if (!params.freeMode.momentum || timeDiff >= params.longSwipesMs) {
                    emit("_freeModeStaticRelease");
                    swiper.updateProgress();
                    swiper.updateActiveIndex();
                    swiper.updateSlidesClasses();
                }
            }
            Object.assign(swiper, {
                freeMode: {
                    onTouchStart,
                    onTouchMove,
                    onTouchEnd
                }
            });
        }
        function app_effect_init_effectInit(params) {
            const {effect, swiper, on, setTranslate, setTransition, overwriteParams, perspective, recreateShadows, getEffectParams} = params;
            on("beforeInit", (() => {
                if (swiper.params.effect !== effect) return;
                swiper.classNames.push(`${swiper.params.containerModifierClass}${effect}`);
                if (perspective && perspective()) swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);
                const overwriteParamsResult = overwriteParams ? overwriteParams() : {};
                Object.assign(swiper.params, overwriteParamsResult);
                Object.assign(swiper.originalParams, overwriteParamsResult);
            }));
            on("setTranslate", (() => {
                if (swiper.params.effect !== effect) return;
                setTranslate();
            }));
            on("setTransition", ((_s, duration) => {
                if (swiper.params.effect !== effect) return;
                setTransition(duration);
            }));
            on("transitionEnd", (() => {
                if (swiper.params.effect !== effect) return;
                if (recreateShadows) {
                    if (!getEffectParams || !getEffectParams().slideShadows) return;
                    swiper.slides.forEach((slideEl => {
                        slideEl.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach((shadowEl => shadowEl.remove()));
                    }));
                    recreateShadows();
                }
            }));
            let requireUpdateOnVirtual;
            on("virtualUpdate", (() => {
                if (swiper.params.effect !== effect) return;
                if (!swiper.slides.length) requireUpdateOnVirtual = true;
                requestAnimationFrame((() => {
                    if (requireUpdateOnVirtual && swiper.slides && swiper.slides.length) {
                        setTranslate();
                        requireUpdateOnVirtual = false;
                    }
                }));
            }));
        }
        function app_effect_target_effectTarget(effectParams, slideEl) {
            const transformEl = app_utils_getSlideTransformEl(slideEl);
            if (transformEl !== slideEl) {
                transformEl.style.backfaceVisibility = "hidden";
                transformEl.style["-webkit-backface-visibility"] = "hidden";
            }
            return transformEl;
        }
        function app_effect_virtual_transition_end_effectVirtualTransitionEnd(_ref) {
            let {swiper, duration, transformElements, allSlides} = _ref;
            const {activeIndex} = swiper;
            const getSlide = el => {
                if (!el.parentElement) {
                    const slide = swiper.slides.filter((slideEl => slideEl.shadowRoot && slideEl.shadowRoot === el.parentNode))[0];
                    return slide;
                }
                return el.parentElement;
            };
            if (swiper.params.virtualTranslate && duration !== 0) {
                let eventTriggered = false;
                let transitionEndTarget;
                if (allSlides) transitionEndTarget = transformElements; else transitionEndTarget = transformElements.filter((transformEl => {
                    const el = transformEl.classList.contains("swiper-slide-transform") ? getSlide(transformEl) : transformEl;
                    return swiper.getSlideIndex(el) === activeIndex;
                }));
                transitionEndTarget.forEach((el => {
                    app_utils_elementTransitionEnd(el, (() => {
                        if (eventTriggered) return;
                        if (!swiper || swiper.destroyed) return;
                        eventTriggered = true;
                        swiper.animating = false;
                        const evt = new window.CustomEvent("transitionend", {
                            bubbles: true,
                            cancelable: true
                        });
                        swiper.wrapperEl.dispatchEvent(evt);
                    }));
                }));
            }
        }
        function app_EffectFade(_ref) {
            let {swiper, extendParams, on} = _ref;
            extendParams({
                fadeEffect: {
                    crossFade: false
                }
            });
            const setTranslate = () => {
                const {slides} = swiper;
                const params = swiper.params.fadeEffect;
                for (let i = 0; i < slides.length; i += 1) {
                    const slideEl = swiper.slides[i];
                    const offset = slideEl.swiperSlideOffset;
                    let tx = -offset;
                    if (!swiper.params.virtualTranslate) tx -= swiper.translate;
                    let ty = 0;
                    if (!swiper.isHorizontal()) {
                        ty = tx;
                        tx = 0;
                    }
                    const slideOpacity = swiper.params.fadeEffect.crossFade ? Math.max(1 - Math.abs(slideEl.progress), 0) : 1 + Math.min(Math.max(slideEl.progress, -1), 0);
                    const targetEl = app_effect_target_effectTarget(params, slideEl);
                    targetEl.style.opacity = slideOpacity;
                    targetEl.style.transform = `translate3d(${tx}px, ${ty}px, 0px)`;
                }
            };
            const setTransition = duration => {
                const transformElements = swiper.slides.map((slideEl => app_utils_getSlideTransformEl(slideEl)));
                transformElements.forEach((el => {
                    el.style.transitionDuration = `${duration}ms`;
                }));
                app_effect_virtual_transition_end_effectVirtualTransitionEnd({
                    swiper,
                    duration,
                    transformElements,
                    allSlides: true
                });
            };
            app_effect_init_effectInit({
                effect: "fade",
                swiper,
                on,
                setTranslate,
                setTransition,
                overwriteParams: () => ({
                    slidesPerView: 1,
                    slidesPerGroup: 1,
                    watchSlidesProgress: true,
                    spaceBetween: 0,
                    virtualTranslate: !swiper.params.cssMode
                })
            });
        }
        function app_createSlider(selector, config) {
            if (document.querySelector(selector)) return new app_swiper_core_Swiper(selector, config);
        }
        const app_baseConfig = {
            observer: true,
            observeParents: true,
            speed: 400,
            slidesPerView: 1,
            spaceBetween: 15
        };
        function app_initSliders() {
            app_createSlider(".slide-1", {
                ...app_baseConfig,
                modules: [ app_Navigation, app_Pagination ],
                pagination: {
                    el: ".slide-1 .swiper-pagination",
                    clickable: true
                },
                navigation: {
                    nextEl: ".slide-1 .swiper-button-next",
                    prevEl: ".slide-1 .swiper-button-prev"
                },
                breakpoints: {
                    768: {
                        speed: 800
                    }
                }
            });
            app_createSlider(".unique__slider", {
                ...app_baseConfig,
                modules: [ app_Pagination ],
                pagination: {
                    el: ".unique__slider .swiper-pagination",
                    clickable: true
                },
                breakpoints: {
                    320: {
                        slidesPerView: 1,
                        spaceBetween: 10
                    },
                    389: {
                        slidesPerView: 1,
                        spaceBetween: 15
                    },
                    640: {
                        slidesPerView: 1,
                        spaceBetween: 15
                    },
                    768: {
                        slidesPerView: 2,
                        spaceBetween: 15,
                        speed: 800
                    },
                    992: {
                        slidesPerView: 1.2,
                        spaceBetween: 15,
                        speed: 800
                    },
                    1268: {
                        slidesPerView: 1.671,
                        spaceBetween: 24,
                        speed: 800
                    }
                }
            });
            app_createSlider(".pros__slider", {
                ...app_baseConfig,
                modules: [ app_Pagination ],
                pagination: {
                    el: ".pros__slider .swiper-pagination",
                    clickable: true
                },
                breakpoints: {
                    320: {
                        slidesPerView: 1,
                        spaceBetween: 10
                    },
                    389: {
                        slidesPerView: 1,
                        spaceBetween: 15
                    },
                    768: {
                        slidesPerView: 1.8,
                        spaceBetween: 15,
                        speed: 800
                    },
                    992: {
                        slidesPerView: 2.4,
                        spaceBetween: 15,
                        speed: 800
                    },
                    1268: {
                        slidesPerView: 2.4,
                        spaceBetween: 24,
                        speed: 800
                    }
                }
            });
            app_createSlider(".pros__slider-reverse", {
                ...app_baseConfig,
                modules: [ app_Pagination ],
                pagination: {
                    el: ".pros__slider-reverse .swiper-pagination",
                    clickable: true
                },
                initialSlide: document.querySelectorAll(".pros__slider-reverse .swiper-slide").length - 1,
                breakpoints: {
                    320: {
                        slidesPerView: 1,
                        spaceBetween: 10
                    },
                    389: {
                        slidesPerView: 1,
                        spaceBetween: 15
                    },
                    768: {
                        slidesPerView: 1.8,
                        spaceBetween: 15,
                        speed: 800
                    },
                    992: {
                        slidesPerView: 2.4,
                        spaceBetween: 15,
                        speed: 800
                    },
                    1268: {
                        slidesPerView: 2.4,
                        spaceBetween: 24,
                        speed: 800
                    }
                }
            });
            app_createSlider(".history__slider", {
                ...app_baseConfig,
                modules: [ app_Navigation, app_Pagination ],
                pagination: {
                    el: ".history__slider .swiper-pagination",
                    clickable: true
                },
                breakpoints: {
                    320: {
                        slidesPerView: 1,
                        spaceBetween: 10
                    },
                    389: {
                        slidesPerView: 1,
                        spaceBetween: 15
                    },
                    640: {
                        slidesPerView: 1.3,
                        spaceBetween: 15
                    },
                    768: {
                        slidesPerView: 2.2,
                        spaceBetween: 15,
                        speed: 800
                    },
                    992: {
                        slidesPerView: 3,
                        spaceBetween: 15,
                        speed: 800
                    },
                    1268: {
                        slidesPerView: 3,
                        spaceBetween: 24,
                        speed: 800
                    }
                },
                on: {
                    init: () => app_handleHoverEffects(".history__slide")
                }
            });
            app_createSlider(".reviews__slider", {
                ...app_baseConfig,
                modules: [ app_Navigation, app_Pagination ],
                pagination: {
                    el: ".reviews__slider .swiper-pagination",
                    clickable: true
                },
                navigation: {
                    nextEl: ".reviews__slider .swiper-button-next",
                    prevEl: ".reviews__slider .swiper-button-prev"
                },
                breakpoints: {
                    320: {
                        slidesPerView: 1,
                        spaceBetween: 10
                    },
                    389: {
                        slidesPerView: 1,
                        spaceBetween: 15
                    },
                    640: {
                        slidesPerView: 1.3,
                        spaceBetween: 15
                    },
                    768: {
                        slidesPerView: 2,
                        spaceBetween: 15,
                        speed: 800
                    },
                    992: {
                        slidesPerView: 2,
                        spaceBetween: 15,
                        speed: 800
                    },
                    1268: {
                        slidesPerView: 3,
                        spaceBetween: 24,
                        speed: 800
                    },
                    1632: {
                        slidesPerView: 4,
                        spaceBetween: 24,
                        speed: 800
                    }
                }
            });
            app_createSlider(".you-get__slider", {
                ...app_baseConfig,
                modules: [ app_Navigation, app_Pagination ],
                pagination: {
                    el: ".you-get__slider .swiper-pagination",
                    clickable: true
                },
                navigation: {
                    nextEl: ".you-get__slider .swiper-button-next",
                    prevEl: ".you-get__slider .swiper-button-prev"
                },
                breakpoints: {
                    320: {
                        slidesPerView: 1,
                        spaceBetween: 10
                    },
                    389: {
                        slidesPerView: 1,
                        spaceBetween: 15
                    },
                    640: {
                        slidesPerView: 1.3,
                        spaceBetween: 15
                    },
                    768: {
                        slidesPerView: 2,
                        spaceBetween: 15,
                        speed: 800
                    },
                    992: {
                        slidesPerView: 2,
                        spaceBetween: 15,
                        speed: 800
                    },
                    1268: {
                        slidesPerView: 2,
                        spaceBetween: 24,
                        speed: 800
                    }
                }
            });
            app_createSlider(".courses__slider", {
                ...app_baseConfig,
                modules: [ app_Pagination ],
                pagination: {
                    el: ".courses__slider .swiper-pagination",
                    clickable: true
                },
                navigation: {
                    nextEl: ".courses__slider .swiper-button-next",
                    prevEl: ".courses__slider .swiper-button-prev"
                },
                breakpoints: {
                    320: {
                        slidesPerView: 1,
                        spaceBetween: 10
                    },
                    389: {
                        slidesPerView: 1,
                        spaceBetween: 15
                    },
                    640: {
                        slidesPerView: 1.3,
                        spaceBetween: 15
                    },
                    768: {
                        slidesPerView: 2,
                        spaceBetween: 15,
                        speed: 800
                    },
                    992: {
                        slidesPerView: 2,
                        spaceBetween: 15,
                        speed: 800
                    },
                    1168: {
                        slidesPerView: 3,
                        spaceBetween: 24,
                        speed: 800
                    },
                    1532: {
                        slidesPerView: 4,
                        spaceBetween: 24,
                        speed: 800
                    }
                }
            });
            if (document.querySelector(".our-history__slider") && document.querySelector(".our-history__nav")) {
                let isScrolling = false;
                const navItems = document.querySelectorAll(".our-history__nav-item");
                const ourHistorySwiper = new app_swiper_core_Swiper(".our-history__slider", {
                    modules: [ app_Navigation, app_Pagination, app_freeMode, app_Mousewheel ],
                    observer: true,
                    observeParents: true,
                    slidesPerView: 1,
                    spaceBetween: 15,
                    speed: 400,
                    mousewheel: {
                        enabled: true,
                        releaseOnEdges: true
                    },
                    pagination: {
                        el: ".our-history__slider .swiper-pagination",
                        clickable: true
                    },
                    navigation: {
                        prevEl: ".our-history__slider .swiper-button-prev",
                        nextEl: ".our-history__slider .swiper-button-next"
                    },
                    breakpoints: {
                        768: {
                            speed: 800
                        }
                    },
                    on: {
                        slideChangeTransitionStart: function() {
                            isScrolling = true;
                        },
                        slideChangeTransitionEnd: function() {
                            isScrolling = false;
                        },
                        slideChange: function() {
                            navItems.forEach((item => item.classList.remove("active")));
                            navItems[this.activeIndex].classList.add("active");
                        }
                    }
                });
                window.addEventListener("wheel", (e => {
                    if (isScrolling) e.preventDefault();
                }), {
                    passive: false
                });
                navItems.forEach(((item, index) => {
                    item.addEventListener("click", (() => {
                        ourHistorySwiper.slideTo(index);
                    }));
                }));
            }
            app_createSlider(".teachers-block__slider", {
                ...app_baseConfig,
                modules: [ app_Pagination, app_Navigation ],
                pagination: {
                    el: ".teachers-block__slider .swiper-pagination",
                    clickable: true
                },
                navigation: {
                    nextEl: ".teachers-block__slider .swiper-button-next",
                    prevEl: ".teachers-block__slider .swiper-button-prev"
                },
                breakpoints: {
                    320: {
                        slidesPerView: 1,
                        spaceBetween: 10
                    },
                    389: {
                        slidesPerView: 1,
                        spaceBetween: 15
                    },
                    640: {
                        slidesPerView: 1.3,
                        spaceBetween: 15
                    },
                    992: {
                        slidesPerView: 1,
                        spaceBetween: 15,
                        speed: 800
                    },
                    1168: {
                        slidesPerView: 1,
                        spaceBetween: 24,
                        speed: 800
                    },
                    1532: {
                        slidesPerView: 2,
                        spaceBetween: 24,
                        speed: 800
                    }
                }
            });
            const teachersImgs = app_createSlider(".teachers__imgs", {
                ...app_baseConfig,
                slidesPerView: 1.05,
                slideToClickedSlide: true,
                breakpoints: {
                    479.98: {
                        slidesPerView: 2
                    },
                    767.98: {
                        slidesPerView: 3
                    },
                    991.98: {
                        slidesPerView: 4
                    }
                }
            });
            const teachersSlider = app_createSlider(".teachers__slider", {
                ...app_baseConfig,
                modules: [ app_Thumb, app_Pagination, app_Navigation ],
                thumbs: {
                    swiper: teachersImgs
                },
                pagination: {
                    el: ".teachers__slider .swiper-pagination",
                    clickable: true
                },
                navigation: {
                    nextEl: ".teachers__slider .swiper-button-next",
                    prevEl: ".teachers__slider .swiper-button-prev"
                },
                on: {
                    slideChange: function() {
                        teachersImgs.slideTo(this.activeIndex);
                    }
                }
            });
            if (teachersImgs) teachersImgs.on("slideChange", (function() {
                teachersSlider.slideTo(this.activeIndex);
            }));
            const videoThumbsSlider = app_createSlider(".video__thumbs-slider", {
                ...app_baseConfig,
                slidesPerView: 2,
                direction: "horizontal",
                breakpoints: {
                    320: {
                        slidesPerView: 3,
                        spaceBetween: 10,
                        direction: "horizontal"
                    },
                    640: {
                        slidesPerView: 3,
                        spaceBetween: 12,
                        direction: "horizontal"
                    },
                    992: {
                        slidesPerView: 3,
                        spaceBetween: 15,
                        speed: 800,
                        direction: "vertical"
                    },
                    1532: {
                        slidesPerView: 3,
                        spaceBetween: 24,
                        speed: 800,
                        direction: "vertical"
                    }
                }
            });
            app_createSlider(".video__slider", {
                ...app_baseConfig,
                modules: [ app_Thumb, app_Navigation, app_EffectFade ],
                effect: "fade",
                speed: 800,
                fadeEffect: {
                    crossFade: true
                },
                thumbs: {
                    swiper: videoThumbsSlider,
                    autoScrollOffset: 2
                },
                navigation: {
                    nextEl: ".video__slider .swiper-button-next",
                    prevEl: ".video__slider .swiper-button-prev"
                }
            });
        }
        function app_handleHoverEffects(slideSelector) {
            const slides = document.querySelectorAll(slideSelector);
            slides.forEach((slide => {
                slide.addEventListener("mouseenter", (() => activateSlide(slide, slides)));
                slide.addEventListener("click", (event => {
                    event.stopPropagation();
                    activateSlide(slide, slides);
                }));
            }));
            function activateSlide(activeSlide, allSlides) {
                allSlides.forEach((s => s.classList.remove("swiper-slide-active")));
                activeSlide.classList.add("swiper-slide-active");
            }
        }
        document.addEventListener("DOMContentLoaded", app_initSliders);
        class app_ScrollWatcher {
            constructor(props) {
                let defaultConfig = {
                    logging: true
                };
                this.config = Object.assign(defaultConfig, props);
                this.observer;
                !document.documentElement.classList.contains("watcher") ? this.scrollWatcherRun() : null;
            }
            scrollWatcherUpdate() {
                this.scrollWatcherRun();
            }
            scrollWatcherRun() {
                document.documentElement.classList.add("watcher");
                this.scrollWatcherConstructor(document.querySelectorAll("[data-watch]"));
            }
            scrollWatcherConstructor(items) {
                if (items.length) {
                    this.scrollWatcherLogging(`–ü—Ä–æ–∫–∏–Ω—É–≤—Å—è, —Å—Ç–µ–∂—É –∑–∞ –æ–±'—î–∫—Ç–∞–º–∏ (${items.length})...`);
                    let uniqParams = app_uniqArray(Array.from(items).map((function(item) {
                        if (item.dataset.watch === "navigator" && !item.dataset.watchThreshold) {
                            let valueOfThreshold;
                            if (item.clientHeight > 2) {
                                valueOfThreshold = window.innerHeight / 2 / (item.clientHeight - 1);
                                if (valueOfThreshold > 1) valueOfThreshold = 1;
                            } else valueOfThreshold = 1;
                            item.setAttribute("data-watch-threshold", valueOfThreshold.toFixed(2));
                        }
                        return `${item.dataset.watchRoot ? item.dataset.watchRoot : null}|${item.dataset.watchMargin ? item.dataset.watchMargin : "0px"}|${item.dataset.watchThreshold ? item.dataset.watchThreshold : 0}`;
                    })));
                    uniqParams.forEach((uniqParam => {
                        let uniqParamArray = uniqParam.split("|");
                        let paramsWatch = {
                            root: uniqParamArray[0],
                            margin: uniqParamArray[1],
                            threshold: uniqParamArray[2]
                        };
                        let groupItems = Array.from(items).filter((function(item) {
                            let watchRoot = item.dataset.watchRoot ? item.dataset.watchRoot : null;
                            let watchMargin = item.dataset.watchMargin ? item.dataset.watchMargin : "0px";
                            let watchThreshold = item.dataset.watchThreshold ? item.dataset.watchThreshold : 0;
                            if (String(watchRoot) === paramsWatch.root && String(watchMargin) === paramsWatch.margin && String(watchThreshold) === paramsWatch.threshold) return item;
                        }));
                        let configWatcher = this.getScrollWatcherConfig(paramsWatch);
                        this.scrollWatcherInit(groupItems, configWatcher);
                    }));
                } else this.scrollWatcherLogging("–°–ø–ª—é, –Ω–µ–º–∞—î –æ–±'—î–∫—Ç—ñ–≤ –¥–ª—è —Å—Ç–µ–∂–µ–Ω–Ω—è. ZzzZZzz");
            }
            getScrollWatcherConfig(paramsWatch) {
                let configWatcher = {};
                if (document.querySelector(paramsWatch.root)) configWatcher.root = document.querySelector(paramsWatch.root); else if (paramsWatch.root !== "null") this.scrollWatcherLogging(`–≠–º–º... –±–∞—Ç—å–∫—ñ–≤—Å—å–∫–æ–≥–æ –æ–±'—î–∫—Ç–∞ ${paramsWatch.root} –Ω–µ–º–∞—î –Ω–∞ —Å—Ç–æ—Ä—ñ–Ω—Ü—ñ`);
                configWatcher.rootMargin = paramsWatch.margin;
                if (paramsWatch.margin.indexOf("px") < 0 && paramsWatch.margin.indexOf("%") < 0) {
                    this.scrollWatcherLogging(`–π–æ–π, –Ω–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è data-watch-margin –ø–æ—Ç—Ä—ñ–±–Ω–æ –∑–∞–¥–∞–≤–∞—Ç–∏ –≤ PX –∞–±–æ %`);
                    return;
                }
                if (paramsWatch.threshold === "prx") {
                    paramsWatch.threshold = [];
                    for (let i = 0; i <= 1; i += .005) paramsWatch.threshold.push(i);
                } else paramsWatch.threshold = paramsWatch.threshold.split(",");
                configWatcher.threshold = paramsWatch.threshold;
                return configWatcher;
            }
            scrollWatcherCreate(configWatcher) {
                console.log(configWatcher);
                this.observer = new IntersectionObserver(((entries, observer) => {
                    entries.forEach((entry => {
                        this.scrollWatcherCallback(entry, observer);
                    }));
                }), configWatcher);
            }
            scrollWatcherInit(items, configWatcher) {
                this.scrollWatcherCreate(configWatcher);
                items.forEach((item => this.observer.observe(item)));
            }
            scrollWatcherIntersecting(entry, targetElement) {
                if (entry.isIntersecting) {
                    !targetElement.classList.contains("_watcher-view") ? targetElement.classList.add("_watcher-view") : null;
                    this.scrollWatcherLogging(`–Ø –±–∞—á—É ${targetElement.classList}, –¥–æ–¥–∞–≤ –∫–ª–∞—Å _watcher-view`);
                } else {
                    targetElement.classList.contains("_watcher-view") ? targetElement.classList.remove("_watcher-view") : null;
                    this.scrollWatcherLogging(`–Ø –Ω–µ –±–∞—á—É ${targetElement.classList}, –ø—Ä–∏–±—Ä–∞–≤ –∫–ª–∞—Å _watcher-view`);
                }
            }
            scrollWatcherOff(targetElement, observer) {
                observer.unobserve(targetElement);
                this.scrollWatcherLogging(`–Ø –ø–µ—Ä–µ—Å—Ç–∞–≤ —Å—Ç–µ–∂–∏—Ç–∏ –∑–∞ ${targetElement.classList}`);
            }
            scrollWatcherLogging(message) {
                this.config.logging ? app_functions_FLS(`[–°–ø–æ—Å—Ç–µ—Ä—ñ–≥–∞—á]: ${message}`) : null;
            }
            scrollWatcherCallback(entry, observer) {
                const targetElement = entry.target;
                this.scrollWatcherIntersecting(entry, targetElement);
                targetElement.hasAttribute("data-watch-once") && entry.isIntersecting ? this.scrollWatcherOff(targetElement, observer) : null;
                document.dispatchEvent(new CustomEvent("watcherCallback", {
                    detail: {
                        entry
                    }
                }));
            }
        }
        app_modules_flsModules.watcher = new app_ScrollWatcher({});
        let app_addWindowScrollEvent = false;
        function app_pageNavigation() {
            document.addEventListener("click", pageNavigationAction);
            document.addEventListener("watcherCallback", pageNavigationAction);
            function pageNavigationAction(e) {
                if (e.type === "click") {
                    const targetElement = e.target;
                    if (targetElement.closest("[data-goto]")) {
                        const gotoLink = targetElement.closest("[data-goto]");
                        const gotoLinkSelector = gotoLink.dataset.goto ? gotoLink.dataset.goto : "";
                        const noHeader = gotoLink.hasAttribute("data-goto-header") ? true : false;
                        const gotoSpeed = gotoLink.dataset.gotoSpeed ? gotoLink.dataset.gotoSpeed : 500;
                        const offsetTop = gotoLink.dataset.gotoTop ? parseInt(gotoLink.dataset.gotoTop) : 0;
                        if (app_modules_flsModules.fullpage) {
                            const fullpageSection = document.querySelector(`${gotoLinkSelector}`).closest("[data-fp-section]");
                            const fullpageSectionId = fullpageSection ? +fullpageSection.dataset.fpId : null;
                            if (fullpageSectionId !== null) {
                                app_modules_flsModules.fullpage.switchingSection(fullpageSectionId);
                                document.documentElement.classList.contains("menu-open") ? app_menuClose() : null;
                            }
                        } else app_gotoblock_gotoBlock(gotoLinkSelector, noHeader, gotoSpeed, offsetTop);
                        e.preventDefault();
                    }
                } else if (e.type === "watcherCallback" && e.detail) {
                    const entry = e.detail.entry;
                    const targetElement = entry.target;
                    if (targetElement.dataset.watch === "navigator") {
                        document.querySelector(`[data-goto]._navigator-active`);
                        let navigatorCurrentItem;
                        if (targetElement.id && document.querySelector(`[data-goto="#${targetElement.id}"]`)) navigatorCurrentItem = document.querySelector(`[data-goto="#${targetElement.id}"]`); else if (targetElement.classList.length) for (let index = 0; index < targetElement.classList.length; index++) {
                            const element = targetElement.classList[index];
                            if (document.querySelector(`[data-goto=".${element}"]`)) {
                                navigatorCurrentItem = document.querySelector(`[data-goto=".${element}"]`);
                                break;
                            }
                        }
                        if (entry.isIntersecting) navigatorCurrentItem ? navigatorCurrentItem.classList.add("_navigator-active") : null; else navigatorCurrentItem ? navigatorCurrentItem.classList.remove("_navigator-active") : null;
                    }
                }
            }
            if (app_getHash()) {
                let goToHash;
                if (document.querySelector(`#${app_getHash()}`)) goToHash = `#${app_getHash()}`; else if (document.querySelector(`.${app_getHash()}`)) goToHash = `.${app_getHash()}`;
                goToHash ? app_gotoblock_gotoBlock(goToHash, true, 500, 20) : null;
            }
        }
        function app_headerScroll() {
            app_addWindowScrollEvent = true;
            const header = document.querySelector("header.header");
            const headerShow = header.hasAttribute("data-scroll-show");
            const headerShowTimer = header.dataset.scrollShow ? header.dataset.scrollShow : 500;
            const startPoint = header.dataset.scroll ? header.dataset.scroll : 1;
            let scrollDirection = 0;
            let timer;
            document.addEventListener("windowScroll", (function(e) {
                const scrollTop = window.scrollY;
                clearTimeout(timer);
                if (scrollTop >= startPoint) {
                    if (scrollTop > scrollDirection) header.classList.add("_header-hide") & header.classList.remove("_header-scroll"); else header.classList.remove("_header-hide") & header.classList.add("_header-scroll");
                    if (headerShow) {
                        if (scrollTop > scrollDirection) header.classList.contains("_header-show") ? header.classList.remove("_header-show") : null; else !header.classList.contains("_header-show") ? header.classList.add("_header-show") : null;
                        timer = setTimeout((() => {
                            !header.classList.contains("_header-show") ? header.classList.add("_header-show") : null;
                        }), headerShowTimer);
                    }
                } else {
                    header.classList.contains("_header-scroll") ? header.classList.remove("_header-scroll") : null;
                    if (headerShow) header.classList.contains("_header-show") ? header.classList.remove("_header-show") : null;
                }
                scrollDirection = scrollTop <= 0 ? 0 : scrollTop;
            }));
        }
        setTimeout((() => {
            if (app_addWindowScrollEvent) {
                let windowScroll = new Event("windowScroll");
                window.addEventListener("scroll", (function(e) {
                    document.dispatchEvent(windowScroll);
                }));
            }
        }), 0);
        var app_global_window = __webpack_require__(840);
        var app_window_default = __webpack_require__.n(app_global_window);
        var app_global_document = __webpack_require__(697);
        var app_document_default = __webpack_require__.n(app_global_document);
        var app_lib = __webpack_require__(36);
        var app_lib_default = __webpack_require__.n(app_lib);
        var app_browser_index = __webpack_require__(784);
        var app_browser_index_default = __webpack_require__.n(app_browser_index);
        function app_extends() {
            return app_extends = Object.assign ? Object.assign.bind() : function(n) {
                for (var e = 1; e < arguments.length; e++) {
                    var t = arguments[e];
                    for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
                }
                return n;
            }, app_extends.apply(null, arguments);
        }
        var app_DEFAULT_LOCATION = "https://example.com";
        var app_resolveUrl = function resolveUrl(baseUrl, relativeUrl) {
            if (/^[a-z]+:/i.test(relativeUrl)) return relativeUrl;
            if (/^data:/.test(baseUrl)) baseUrl = app_window_default().location && app_window_default().location.href || "";
            var protocolLess = /^\/\//.test(baseUrl);
            var removeLocation = !app_window_default().location && !/\/\//i.test(baseUrl);
            baseUrl = new (app_window_default().URL)(baseUrl, app_window_default().location || app_DEFAULT_LOCATION);
            var newUrl = new URL(relativeUrl, baseUrl);
            if (removeLocation) return newUrl.href.slice(app_DEFAULT_LOCATION.length); else if (protocolLess) return newUrl.href.slice(newUrl.protocol.length);
            return newUrl.href;
        };
        const app_resolve_url = app_resolveUrl;
        var app_Stream = function() {
            function Stream() {
                this.listeners = {};
            }
            var _proto = Stream.prototype;
            _proto.on = function on(type, listener) {
                if (!this.listeners[type]) this.listeners[type] = [];
                this.listeners[type].push(listener);
            };
            _proto.off = function off(type, listener) {
                if (!this.listeners[type]) return false;
                var index = this.listeners[type].indexOf(listener);
                this.listeners[type] = this.listeners[type].slice(0);
                this.listeners[type].splice(index, 1);
                return index > -1;
            };
            _proto.trigger = function trigger(type) {
                var callbacks = this.listeners[type];
                if (!callbacks) return;
                if (arguments.length === 2) {
                    var length = callbacks.length;
                    for (var i = 0; i < length; ++i) callbacks[i].call(this, arguments[1]);
                } else {
                    var args = Array.prototype.slice.call(arguments, 1);
                    var _length = callbacks.length;
                    for (var _i = 0; _i < _length; ++_i) callbacks[_i].apply(this, args);
                }
            };
            _proto.dispose = function dispose() {
                this.listeners = {};
            };
            _proto.pipe = function pipe(destination) {
                this.on("data", (function(data) {
                    destination.push(data);
                }));
            };
            return Stream;
        }();
        var app_atob = function atob(s) {
            return app_window_default().atob ? app_window_default().atob(s) : Buffer.from(s, "base64").toString("binary");
        };
        function app_decodeB64ToUint8Array(b64Text) {
            var decodedString = app_atob(b64Text);
            var array = new Uint8Array(decodedString.length);
            for (var i = 0; i < decodedString.length; i++) array[i] = decodedString.charCodeAt(i);
            return array;
        }
        /*! @name m3u8-parser @version 7.2.0 @license Apache-2.0 */
        class app_LineStream extends app_Stream {
            constructor() {
                super();
                this.buffer = "";
            }
            push(data) {
                let nextNewline;
                this.buffer += data;
                nextNewline = this.buffer.indexOf("\n");
                for (;nextNewline > -1; nextNewline = this.buffer.indexOf("\n")) {
                    this.trigger("data", this.buffer.substring(0, nextNewline));
                    this.buffer = this.buffer.substring(nextNewline + 1);
                }
            }
        }
        const app_TAB = String.fromCharCode(9);
        const app_parseByterange = function(byterangeString) {
            const match = /([0-9.]*)?@?([0-9.]*)?/.exec(byterangeString || "");
            const result = {};
            if (match[1]) result.length = parseInt(match[1], 10);
            if (match[2]) result.offset = parseInt(match[2], 10);
            return result;
        };
        const app_attributeSeparator = function() {
            const key = "[^=]*";
            const value = '"[^"]*"|[^,]*';
            const keyvalue = "(?:" + key + ")=(?:" + value + ")";
            return new RegExp("(?:^|,)(" + keyvalue + ")");
        };
        const app_parseAttributes = function(attributes) {
            const result = {};
            if (!attributes) return result;
            const attrs = attributes.split(app_attributeSeparator());
            let i = attrs.length;
            let attr;
            while (i--) {
                if (attrs[i] === "") continue;
                attr = /([^=]*)=(.*)/.exec(attrs[i]).slice(1);
                attr[0] = attr[0].replace(/^\s+|\s+$/g, "");
                attr[1] = attr[1].replace(/^\s+|\s+$/g, "");
                attr[1] = attr[1].replace(/^['"](.*)['"]$/g, "$1");
                result[attr[0]] = attr[1];
            }
            return result;
        };
        const app_parseResolution = resolution => {
            const split = resolution.split("x");
            const result = {};
            if (split[0]) result.width = parseInt(split[0], 10);
            if (split[1]) result.height = parseInt(split[1], 10);
            return result;
        };
        class app_ParseStream extends app_Stream {
            constructor() {
                super();
                this.customParsers = [];
                this.tagMappers = [];
            }
            push(line) {
                let match;
                let event;
                line = line.trim();
                if (line.length === 0) return;
                if (line[0] !== "#") {
                    this.trigger("data", {
                        type: "uri",
                        uri: line
                    });
                    return;
                }
                const newLines = this.tagMappers.reduce(((acc, mapper) => {
                    const mappedLine = mapper(line);
                    if (mappedLine === line) return acc;
                    return acc.concat([ mappedLine ]);
                }), [ line ]);
                newLines.forEach((newLine => {
                    for (let i = 0; i < this.customParsers.length; i++) if (this.customParsers[i].call(this, newLine)) return;
                    if (newLine.indexOf("#EXT") !== 0) {
                        this.trigger("data", {
                            type: "comment",
                            text: newLine.slice(1)
                        });
                        return;
                    }
                    newLine = newLine.replace("\r", "");
                    match = /^#EXTM3U/.exec(newLine);
                    if (match) {
                        this.trigger("data", {
                            type: "tag",
                            tagType: "m3u"
                        });
                        return;
                    }
                    match = /^#EXTINF:([0-9\.]*)?,?(.*)?$/.exec(newLine);
                    if (match) {
                        event = {
                            type: "tag",
                            tagType: "inf"
                        };
                        if (match[1]) event.duration = parseFloat(match[1]);
                        if (match[2]) event.title = match[2];
                        this.trigger("data", event);
                        return;
                    }
                    match = /^#EXT-X-TARGETDURATION:([0-9.]*)?/.exec(newLine);
                    if (match) {
                        event = {
                            type: "tag",
                            tagType: "targetduration"
                        };
                        if (match[1]) event.duration = parseInt(match[1], 10);
                        this.trigger("data", event);
                        return;
                    }
                    match = /^#EXT-X-VERSION:([0-9.]*)?/.exec(newLine);
                    if (match) {
                        event = {
                            type: "tag",
                            tagType: "version"
                        };
                        if (match[1]) event.version = parseInt(match[1], 10);
                        this.trigger("data", event);
                        return;
                    }
                    match = /^#EXT-X-MEDIA-SEQUENCE:(\-?[0-9.]*)?/.exec(newLine);
                    if (match) {
                        event = {
                            type: "tag",
                            tagType: "media-sequence"
                        };
                        if (match[1]) event.number = parseInt(match[1], 10);
                        this.trigger("data", event);
                        return;
                    }
                    match = /^#EXT-X-DISCONTINUITY-SEQUENCE:(\-?[0-9.]*)?/.exec(newLine);
                    if (match) {
                        event = {
                            type: "tag",
                            tagType: "discontinuity-sequence"
                        };
                        if (match[1]) event.number = parseInt(match[1], 10);
                        this.trigger("data", event);
                        return;
                    }
                    match = /^#EXT-X-PLAYLIST-TYPE:(.*)?$/.exec(newLine);
                    if (match) {
                        event = {
                            type: "tag",
                            tagType: "playlist-type"
                        };
                        if (match[1]) event.playlistType = match[1];
                        this.trigger("data", event);
                        return;
                    }
                    match = /^#EXT-X-BYTERANGE:(.*)?$/.exec(newLine);
                    if (match) {
                        event = app_extends(app_parseByterange(match[1]), {
                            type: "tag",
                            tagType: "byterange"
                        });
                        this.trigger("data", event);
                        return;
                    }
                    match = /^#EXT-X-ALLOW-CACHE:(YES|NO)?/.exec(newLine);
                    if (match) {
                        event = {
                            type: "tag",
                            tagType: "allow-cache"
                        };
                        if (match[1]) event.allowed = !/NO/.test(match[1]);
                        this.trigger("data", event);
                        return;
                    }
                    match = /^#EXT-X-MAP:(.*)$/.exec(newLine);
                    if (match) {
                        event = {
                            type: "tag",
                            tagType: "map"
                        };
                        if (match[1]) {
                            const attributes = app_parseAttributes(match[1]);
                            if (attributes.URI) event.uri = attributes.URI;
                            if (attributes.BYTERANGE) event.byterange = app_parseByterange(attributes.BYTERANGE);
                        }
                        this.trigger("data", event);
                        return;
                    }
                    match = /^#EXT-X-STREAM-INF:(.*)$/.exec(newLine);
                    if (match) {
                        event = {
                            type: "tag",
                            tagType: "stream-inf"
                        };
                        if (match[1]) {
                            event.attributes = app_parseAttributes(match[1]);
                            if (event.attributes.RESOLUTION) event.attributes.RESOLUTION = app_parseResolution(event.attributes.RESOLUTION);
                            if (event.attributes.BANDWIDTH) event.attributes.BANDWIDTH = parseInt(event.attributes.BANDWIDTH, 10);
                            if (event.attributes["FRAME-RATE"]) event.attributes["FRAME-RATE"] = parseFloat(event.attributes["FRAME-RATE"]);
                            if (event.attributes["PROGRAM-ID"]) event.attributes["PROGRAM-ID"] = parseInt(event.attributes["PROGRAM-ID"], 10);
                        }
                        this.trigger("data", event);
                        return;
                    }
                    match = /^#EXT-X-MEDIA:(.*)$/.exec(newLine);
                    if (match) {
                        event = {
                            type: "tag",
                            tagType: "media"
                        };
                        if (match[1]) event.attributes = app_parseAttributes(match[1]);
                        this.trigger("data", event);
                        return;
                    }
                    match = /^#EXT-X-ENDLIST/.exec(newLine);
                    if (match) {
                        this.trigger("data", {
                            type: "tag",
                            tagType: "endlist"
                        });
                        return;
                    }
                    match = /^#EXT-X-DISCONTINUITY/.exec(newLine);
                    if (match) {
                        this.trigger("data", {
                            type: "tag",
                            tagType: "discontinuity"
                        });
                        return;
                    }
                    match = /^#EXT-X-PROGRAM-DATE-TIME:(.*)$/.exec(newLine);
                    if (match) {
                        event = {
                            type: "tag",
                            tagType: "program-date-time"
                        };
                        if (match[1]) {
                            event.dateTimeString = match[1];
                            event.dateTimeObject = new Date(match[1]);
                        }
                        this.trigger("data", event);
                        return;
                    }
                    match = /^#EXT-X-KEY:(.*)$/.exec(newLine);
                    if (match) {
                        event = {
                            type: "tag",
                            tagType: "key"
                        };
                        if (match[1]) {
                            event.attributes = app_parseAttributes(match[1]);
                            if (event.attributes.IV) {
                                if (event.attributes.IV.substring(0, 2).toLowerCase() === "0x") event.attributes.IV = event.attributes.IV.substring(2);
                                event.attributes.IV = event.attributes.IV.match(/.{8}/g);
                                event.attributes.IV[0] = parseInt(event.attributes.IV[0], 16);
                                event.attributes.IV[1] = parseInt(event.attributes.IV[1], 16);
                                event.attributes.IV[2] = parseInt(event.attributes.IV[2], 16);
                                event.attributes.IV[3] = parseInt(event.attributes.IV[3], 16);
                                event.attributes.IV = new Uint32Array(event.attributes.IV);
                            }
                        }
                        this.trigger("data", event);
                        return;
                    }
                    match = /^#EXT-X-START:(.*)$/.exec(newLine);
                    if (match) {
                        event = {
                            type: "tag",
                            tagType: "start"
                        };
                        if (match[1]) {
                            event.attributes = app_parseAttributes(match[1]);
                            event.attributes["TIME-OFFSET"] = parseFloat(event.attributes["TIME-OFFSET"]);
                            event.attributes.PRECISE = /YES/.test(event.attributes.PRECISE);
                        }
                        this.trigger("data", event);
                        return;
                    }
                    match = /^#EXT-X-CUE-OUT-CONT:(.*)?$/.exec(newLine);
                    if (match) {
                        event = {
                            type: "tag",
                            tagType: "cue-out-cont"
                        };
                        if (match[1]) event.data = match[1]; else event.data = "";
                        this.trigger("data", event);
                        return;
                    }
                    match = /^#EXT-X-CUE-OUT:(.*)?$/.exec(newLine);
                    if (match) {
                        event = {
                            type: "tag",
                            tagType: "cue-out"
                        };
                        if (match[1]) event.data = match[1]; else event.data = "";
                        this.trigger("data", event);
                        return;
                    }
                    match = /^#EXT-X-CUE-IN:?(.*)?$/.exec(newLine);
                    if (match) {
                        event = {
                            type: "tag",
                            tagType: "cue-in"
                        };
                        if (match[1]) event.data = match[1]; else event.data = "";
                        this.trigger("data", event);
                        return;
                    }
                    match = /^#EXT-X-SKIP:(.*)$/.exec(newLine);
                    if (match && match[1]) {
                        event = {
                            type: "tag",
                            tagType: "skip"
                        };
                        event.attributes = app_parseAttributes(match[1]);
                        if (event.attributes.hasOwnProperty("SKIPPED-SEGMENTS")) event.attributes["SKIPPED-SEGMENTS"] = parseInt(event.attributes["SKIPPED-SEGMENTS"], 10);
                        if (event.attributes.hasOwnProperty("RECENTLY-REMOVED-DATERANGES")) event.attributes["RECENTLY-REMOVED-DATERANGES"] = event.attributes["RECENTLY-REMOVED-DATERANGES"].split(app_TAB);
                        this.trigger("data", event);
                        return;
                    }
                    match = /^#EXT-X-PART:(.*)$/.exec(newLine);
                    if (match && match[1]) {
                        event = {
                            type: "tag",
                            tagType: "part"
                        };
                        event.attributes = app_parseAttributes(match[1]);
                        [ "DURATION" ].forEach((function(key) {
                            if (event.attributes.hasOwnProperty(key)) event.attributes[key] = parseFloat(event.attributes[key]);
                        }));
                        [ "INDEPENDENT", "GAP" ].forEach((function(key) {
                            if (event.attributes.hasOwnProperty(key)) event.attributes[key] = /YES/.test(event.attributes[key]);
                        }));
                        if (event.attributes.hasOwnProperty("BYTERANGE")) event.attributes.byterange = app_parseByterange(event.attributes.BYTERANGE);
                        this.trigger("data", event);
                        return;
                    }
                    match = /^#EXT-X-SERVER-CONTROL:(.*)$/.exec(newLine);
                    if (match && match[1]) {
                        event = {
                            type: "tag",
                            tagType: "server-control"
                        };
                        event.attributes = app_parseAttributes(match[1]);
                        [ "CAN-SKIP-UNTIL", "PART-HOLD-BACK", "HOLD-BACK" ].forEach((function(key) {
                            if (event.attributes.hasOwnProperty(key)) event.attributes[key] = parseFloat(event.attributes[key]);
                        }));
                        [ "CAN-SKIP-DATERANGES", "CAN-BLOCK-RELOAD" ].forEach((function(key) {
                            if (event.attributes.hasOwnProperty(key)) event.attributes[key] = /YES/.test(event.attributes[key]);
                        }));
                        this.trigger("data", event);
                        return;
                    }
                    match = /^#EXT-X-PART-INF:(.*)$/.exec(newLine);
                    if (match && match[1]) {
                        event = {
                            type: "tag",
                            tagType: "part-inf"
                        };
                        event.attributes = app_parseAttributes(match[1]);
                        [ "PART-TARGET" ].forEach((function(key) {
                            if (event.attributes.hasOwnProperty(key)) event.attributes[key] = parseFloat(event.attributes[key]);
                        }));
                        this.trigger("data", event);
                        return;
                    }
                    match = /^#EXT-X-PRELOAD-HINT:(.*)$/.exec(newLine);
                    if (match && match[1]) {
                        event = {
                            type: "tag",
                            tagType: "preload-hint"
                        };
                        event.attributes = app_parseAttributes(match[1]);
                        [ "BYTERANGE-START", "BYTERANGE-LENGTH" ].forEach((function(key) {
                            if (event.attributes.hasOwnProperty(key)) {
                                event.attributes[key] = parseInt(event.attributes[key], 10);
                                const subkey = key === "BYTERANGE-LENGTH" ? "length" : "offset";
                                event.attributes.byterange = event.attributes.byterange || {};
                                event.attributes.byterange[subkey] = event.attributes[key];
                                delete event.attributes[key];
                            }
                        }));
                        this.trigger("data", event);
                        return;
                    }
                    match = /^#EXT-X-RENDITION-REPORT:(.*)$/.exec(newLine);
                    if (match && match[1]) {
                        event = {
                            type: "tag",
                            tagType: "rendition-report"
                        };
                        event.attributes = app_parseAttributes(match[1]);
                        [ "LAST-MSN", "LAST-PART" ].forEach((function(key) {
                            if (event.attributes.hasOwnProperty(key)) event.attributes[key] = parseInt(event.attributes[key], 10);
                        }));
                        this.trigger("data", event);
                        return;
                    }
                    match = /^#EXT-X-DATERANGE:(.*)$/.exec(newLine);
                    if (match && match[1]) {
                        event = {
                            type: "tag",
                            tagType: "daterange"
                        };
                        event.attributes = app_parseAttributes(match[1]);
                        [ "ID", "CLASS" ].forEach((function(key) {
                            if (event.attributes.hasOwnProperty(key)) event.attributes[key] = String(event.attributes[key]);
                        }));
                        [ "START-DATE", "END-DATE" ].forEach((function(key) {
                            if (event.attributes.hasOwnProperty(key)) event.attributes[key] = new Date(event.attributes[key]);
                        }));
                        [ "DURATION", "PLANNED-DURATION" ].forEach((function(key) {
                            if (event.attributes.hasOwnProperty(key)) event.attributes[key] = parseFloat(event.attributes[key]);
                        }));
                        [ "END-ON-NEXT" ].forEach((function(key) {
                            if (event.attributes.hasOwnProperty(key)) event.attributes[key] = /YES/i.test(event.attributes[key]);
                        }));
                        [ "SCTE35-CMD", " SCTE35-OUT", "SCTE35-IN" ].forEach((function(key) {
                            if (event.attributes.hasOwnProperty(key)) event.attributes[key] = event.attributes[key].toString(16);
                        }));
                        const clientAttributePattern = /^X-([A-Z]+-)+[A-Z]+$/;
                        for (const key in event.attributes) {
                            if (!clientAttributePattern.test(key)) continue;
                            const isHexaDecimal = /[0-9A-Fa-f]{6}/g.test(event.attributes[key]);
                            const isDecimalFloating = /^\d+(\.\d+)?$/.test(event.attributes[key]);
                            event.attributes[key] = isHexaDecimal ? event.attributes[key].toString(16) : isDecimalFloating ? parseFloat(event.attributes[key]) : String(event.attributes[key]);
                        }
                        this.trigger("data", event);
                        return;
                    }
                    match = /^#EXT-X-INDEPENDENT-SEGMENTS/.exec(newLine);
                    if (match) {
                        this.trigger("data", {
                            type: "tag",
                            tagType: "independent-segments"
                        });
                        return;
                    }
                    match = /^#EXT-X-I-FRAMES-ONLY/.exec(newLine);
                    if (match) {
                        this.trigger("data", {
                            type: "tag",
                            tagType: "i-frames-only"
                        });
                        return;
                    }
                    match = /^#EXT-X-CONTENT-STEERING:(.*)$/.exec(newLine);
                    if (match) {
                        event = {
                            type: "tag",
                            tagType: "content-steering"
                        };
                        event.attributes = app_parseAttributes(match[1]);
                        this.trigger("data", event);
                        return;
                    }
                    match = /^#EXT-X-I-FRAME-STREAM-INF:(.*)$/.exec(newLine);
                    if (match) {
                        event = {
                            type: "tag",
                            tagType: "i-frame-playlist"
                        };
                        event.attributes = app_parseAttributes(match[1]);
                        if (event.attributes.URI) event.uri = event.attributes.URI;
                        if (event.attributes.BANDWIDTH) event.attributes.BANDWIDTH = parseInt(event.attributes.BANDWIDTH, 10);
                        if (event.attributes.RESOLUTION) event.attributes.RESOLUTION = app_parseResolution(event.attributes.RESOLUTION);
                        if (event.attributes["AVERAGE-BANDWIDTH"]) event.attributes["AVERAGE-BANDWIDTH"] = parseInt(event.attributes["AVERAGE-BANDWIDTH"], 10);
                        if (event.attributes["FRAME-RATE"]) event.attributes["FRAME-RATE"] = parseFloat(event.attributes["FRAME-RATE"]);
                        this.trigger("data", event);
                        return;
                    }
                    match = /^#EXT-X-DEFINE:(.*)$/.exec(newLine);
                    if (match) {
                        event = {
                            type: "tag",
                            tagType: "define"
                        };
                        event.attributes = app_parseAttributes(match[1]);
                        this.trigger("data", event);
                        return;
                    }
                    this.trigger("data", {
                        type: "tag",
                        data: newLine.slice(4)
                    });
                }));
            }
            addParser({expression, customType, dataParser, segment}) {
                if (typeof dataParser !== "function") dataParser = line => line;
                this.customParsers.push((line => {
                    const match = expression.exec(line);
                    if (match) {
                        this.trigger("data", {
                            type: "custom",
                            data: dataParser(line),
                            customType,
                            segment
                        });
                        return true;
                    }
                }));
            }
            addTagMapper({expression, map}) {
                const mapFn = line => {
                    if (expression.test(line)) return map(line);
                    return line;
                };
                this.tagMappers.push(mapFn);
            }
        }
        const app_camelCase = str => str.toLowerCase().replace(/-(\w)/g, (a => a[1].toUpperCase()));
        const app_camelCaseKeys = function(attributes) {
            const result = {};
            Object.keys(attributes).forEach((function(key) {
                result[app_camelCase(key)] = attributes[key];
            }));
            return result;
        };
        const app_setHoldBack = function(manifest) {
            const {serverControl, targetDuration, partTargetDuration} = manifest;
            if (!serverControl) return;
            const tag = "#EXT-X-SERVER-CONTROL";
            const hb = "holdBack";
            const phb = "partHoldBack";
            const minTargetDuration = targetDuration && targetDuration * 3;
            const minPartDuration = partTargetDuration && partTargetDuration * 2;
            if (targetDuration && !serverControl.hasOwnProperty(hb)) {
                serverControl[hb] = minTargetDuration;
                this.trigger("info", {
                    message: `${tag} defaulting HOLD-BACK to targetDuration * 3 (${minTargetDuration}).`
                });
            }
            if (minTargetDuration && serverControl[hb] < minTargetDuration) {
                this.trigger("warn", {
                    message: `${tag} clamping HOLD-BACK (${serverControl[hb]}) to targetDuration * 3 (${minTargetDuration})`
                });
                serverControl[hb] = minTargetDuration;
            }
            if (partTargetDuration && !serverControl.hasOwnProperty(phb)) {
                serverControl[phb] = partTargetDuration * 3;
                this.trigger("info", {
                    message: `${tag} defaulting PART-HOLD-BACK to partTargetDuration * 3 (${serverControl[phb]}).`
                });
            }
            if (partTargetDuration && serverControl[phb] < minPartDuration) {
                this.trigger("warn", {
                    message: `${tag} clamping PART-HOLD-BACK (${serverControl[phb]}) to partTargetDuration * 2 (${minPartDuration}).`
                });
                serverControl[phb] = minPartDuration;
            }
        };
        class app_Parser extends app_Stream {
            constructor(opts = {}) {
                super();
                this.lineStream = new app_LineStream;
                this.parseStream = new app_ParseStream;
                this.lineStream.pipe(this.parseStream);
                this.mainDefinitions = opts.mainDefinitions || {};
                this.params = new URL(opts.uri, "https://a.com").searchParams;
                this.lastProgramDateTime = null;
                const self = this;
                const uris = [];
                let currentUri = {};
                let currentMap;
                let key;
                let hasParts = false;
                const noop = function() {};
                const defaultMediaGroups = {
                    AUDIO: {},
                    VIDEO: {},
                    "CLOSED-CAPTIONS": {},
                    SUBTITLES: {}
                };
                const widevineUuid = "urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed";
                let currentTimeline = 0;
                this.manifest = {
                    allowCache: true,
                    discontinuityStarts: [],
                    dateRanges: [],
                    iFramePlaylists: [],
                    segments: []
                };
                let lastByterangeEnd = 0;
                let lastPartByterangeEnd = 0;
                const dateRangeTags = {};
                this.on("end", (() => {
                    if (currentUri.uri || !currentUri.parts && !currentUri.preloadHints) return;
                    if (!currentUri.map && currentMap) currentUri.map = currentMap;
                    if (!currentUri.key && key) currentUri.key = key;
                    if (!currentUri.timeline && typeof currentTimeline === "number") currentUri.timeline = currentTimeline;
                    this.manifest.preloadSegment = currentUri;
                }));
                this.parseStream.on("data", (function(entry) {
                    let mediaGroup;
                    let rendition;
                    if (self.manifest.definitions) for (const def in self.manifest.definitions) {
                        if (entry.uri) entry.uri = entry.uri.replace(`{$${def}}`, self.manifest.definitions[def]);
                        if (entry.attributes) for (const attr in entry.attributes) if (typeof entry.attributes[attr] === "string") entry.attributes[attr] = entry.attributes[attr].replace(`{$${def}}`, self.manifest.definitions[def]);
                    }
                    ({
                        tag() {
                            ({
                                version() {
                                    if (entry.version) this.manifest.version = entry.version;
                                },
                                "allow-cache"() {
                                    this.manifest.allowCache = entry.allowed;
                                    if (!("allowed" in entry)) {
                                        this.trigger("info", {
                                            message: "defaulting allowCache to YES"
                                        });
                                        this.manifest.allowCache = true;
                                    }
                                },
                                byterange() {
                                    const byterange = {};
                                    if ("length" in entry) {
                                        currentUri.byterange = byterange;
                                        byterange.length = entry.length;
                                        if (!("offset" in entry)) entry.offset = lastByterangeEnd;
                                    }
                                    if ("offset" in entry) {
                                        currentUri.byterange = byterange;
                                        byterange.offset = entry.offset;
                                    }
                                    lastByterangeEnd = byterange.offset + byterange.length;
                                },
                                endlist() {
                                    this.manifest.endList = true;
                                },
                                inf() {
                                    if (!("mediaSequence" in this.manifest)) {
                                        this.manifest.mediaSequence = 0;
                                        this.trigger("info", {
                                            message: "defaulting media sequence to zero"
                                        });
                                    }
                                    if (!("discontinuitySequence" in this.manifest)) {
                                        this.manifest.discontinuitySequence = 0;
                                        this.trigger("info", {
                                            message: "defaulting discontinuity sequence to zero"
                                        });
                                    }
                                    if (entry.title) currentUri.title = entry.title;
                                    if (entry.duration > 0) currentUri.duration = entry.duration;
                                    if (entry.duration === 0) {
                                        currentUri.duration = .01;
                                        this.trigger("info", {
                                            message: "updating zero segment duration to a small value"
                                        });
                                    }
                                    this.manifest.segments = uris;
                                },
                                key() {
                                    if (!entry.attributes) {
                                        this.trigger("warn", {
                                            message: "ignoring key declaration without attribute list"
                                        });
                                        return;
                                    }
                                    if (entry.attributes.METHOD === "NONE") {
                                        key = null;
                                        return;
                                    }
                                    if (!entry.attributes.URI) {
                                        this.trigger("warn", {
                                            message: "ignoring key declaration without URI"
                                        });
                                        return;
                                    }
                                    if (entry.attributes.KEYFORMAT === "com.apple.streamingkeydelivery") {
                                        this.manifest.contentProtection = this.manifest.contentProtection || {};
                                        this.manifest.contentProtection["com.apple.fps.1_0"] = {
                                            attributes: entry.attributes
                                        };
                                        return;
                                    }
                                    if (entry.attributes.KEYFORMAT === "com.microsoft.playready") {
                                        this.manifest.contentProtection = this.manifest.contentProtection || {};
                                        this.manifest.contentProtection["com.microsoft.playready"] = {
                                            uri: entry.attributes.URI
                                        };
                                        return;
                                    }
                                    if (entry.attributes.KEYFORMAT === widevineUuid) {
                                        const VALID_METHODS = [ "SAMPLE-AES", "SAMPLE-AES-CTR", "SAMPLE-AES-CENC" ];
                                        if (VALID_METHODS.indexOf(entry.attributes.METHOD) === -1) {
                                            this.trigger("warn", {
                                                message: "invalid key method provided for Widevine"
                                            });
                                            return;
                                        }
                                        if (entry.attributes.METHOD === "SAMPLE-AES-CENC") this.trigger("warn", {
                                            message: "SAMPLE-AES-CENC is deprecated, please use SAMPLE-AES-CTR instead"
                                        });
                                        if (entry.attributes.URI.substring(0, 23) !== "data:text/plain;base64,") {
                                            this.trigger("warn", {
                                                message: "invalid key URI provided for Widevine"
                                            });
                                            return;
                                        }
                                        if (!(entry.attributes.KEYID && entry.attributes.KEYID.substring(0, 2) === "0x")) {
                                            this.trigger("warn", {
                                                message: "invalid key ID provided for Widevine"
                                            });
                                            return;
                                        }
                                        this.manifest.contentProtection = this.manifest.contentProtection || {};
                                        this.manifest.contentProtection["com.widevine.alpha"] = {
                                            attributes: {
                                                schemeIdUri: entry.attributes.KEYFORMAT,
                                                keyId: entry.attributes.KEYID.substring(2)
                                            },
                                            pssh: app_decodeB64ToUint8Array(entry.attributes.URI.split(",")[1])
                                        };
                                        return;
                                    }
                                    if (!entry.attributes.METHOD) this.trigger("warn", {
                                        message: "defaulting key method to AES-128"
                                    });
                                    key = {
                                        method: entry.attributes.METHOD || "AES-128",
                                        uri: entry.attributes.URI
                                    };
                                    if (typeof entry.attributes.IV !== "undefined") key.iv = entry.attributes.IV;
                                },
                                "media-sequence"() {
                                    if (!isFinite(entry.number)) {
                                        this.trigger("warn", {
                                            message: "ignoring invalid media sequence: " + entry.number
                                        });
                                        return;
                                    }
                                    this.manifest.mediaSequence = entry.number;
                                },
                                "discontinuity-sequence"() {
                                    if (!isFinite(entry.number)) {
                                        this.trigger("warn", {
                                            message: "ignoring invalid discontinuity sequence: " + entry.number
                                        });
                                        return;
                                    }
                                    this.manifest.discontinuitySequence = entry.number;
                                    currentTimeline = entry.number;
                                },
                                "playlist-type"() {
                                    if (!/VOD|EVENT/.test(entry.playlistType)) {
                                        this.trigger("warn", {
                                            message: "ignoring unknown playlist type: " + entry.playlist
                                        });
                                        return;
                                    }
                                    this.manifest.playlistType = entry.playlistType;
                                },
                                map() {
                                    currentMap = {};
                                    if (entry.uri) currentMap.uri = entry.uri;
                                    if (entry.byterange) currentMap.byterange = entry.byterange;
                                    if (key) currentMap.key = key;
                                },
                                "stream-inf"() {
                                    this.manifest.playlists = uris;
                                    this.manifest.mediaGroups = this.manifest.mediaGroups || defaultMediaGroups;
                                    if (!entry.attributes) {
                                        this.trigger("warn", {
                                            message: "ignoring empty stream-inf attributes"
                                        });
                                        return;
                                    }
                                    if (!currentUri.attributes) currentUri.attributes = {};
                                    app_extends(currentUri.attributes, entry.attributes);
                                },
                                media() {
                                    this.manifest.mediaGroups = this.manifest.mediaGroups || defaultMediaGroups;
                                    if (!(entry.attributes && entry.attributes.TYPE && entry.attributes["GROUP-ID"] && entry.attributes.NAME)) {
                                        this.trigger("warn", {
                                            message: "ignoring incomplete or missing media group"
                                        });
                                        return;
                                    }
                                    const mediaGroupType = this.manifest.mediaGroups[entry.attributes.TYPE];
                                    mediaGroupType[entry.attributes["GROUP-ID"]] = mediaGroupType[entry.attributes["GROUP-ID"]] || {};
                                    mediaGroup = mediaGroupType[entry.attributes["GROUP-ID"]];
                                    rendition = {
                                        default: /yes/i.test(entry.attributes.DEFAULT)
                                    };
                                    if (rendition.default) rendition.autoselect = true; else rendition.autoselect = /yes/i.test(entry.attributes.AUTOSELECT);
                                    if (entry.attributes.LANGUAGE) rendition.language = entry.attributes.LANGUAGE;
                                    if (entry.attributes.URI) rendition.uri = entry.attributes.URI;
                                    if (entry.attributes["INSTREAM-ID"]) rendition.instreamId = entry.attributes["INSTREAM-ID"];
                                    if (entry.attributes.CHARACTERISTICS) rendition.characteristics = entry.attributes.CHARACTERISTICS;
                                    if (entry.attributes.FORCED) rendition.forced = /yes/i.test(entry.attributes.FORCED);
                                    mediaGroup[entry.attributes.NAME] = rendition;
                                },
                                discontinuity() {
                                    currentTimeline += 1;
                                    currentUri.discontinuity = true;
                                    this.manifest.discontinuityStarts.push(uris.length);
                                },
                                "program-date-time"() {
                                    if (typeof this.manifest.dateTimeString === "undefined") {
                                        this.manifest.dateTimeString = entry.dateTimeString;
                                        this.manifest.dateTimeObject = entry.dateTimeObject;
                                    }
                                    currentUri.dateTimeString = entry.dateTimeString;
                                    currentUri.dateTimeObject = entry.dateTimeObject;
                                    const {lastProgramDateTime} = this;
                                    this.lastProgramDateTime = new Date(entry.dateTimeString).getTime();
                                    if (lastProgramDateTime === null) this.manifest.segments.reduceRight(((programDateTime, segment) => {
                                        segment.programDateTime = programDateTime - segment.duration * 1e3;
                                        return segment.programDateTime;
                                    }), this.lastProgramDateTime);
                                },
                                targetduration() {
                                    if (!isFinite(entry.duration) || entry.duration < 0) {
                                        this.trigger("warn", {
                                            message: "ignoring invalid target duration: " + entry.duration
                                        });
                                        return;
                                    }
                                    this.manifest.targetDuration = entry.duration;
                                    app_setHoldBack.call(this, this.manifest);
                                },
                                start() {
                                    if (!entry.attributes || isNaN(entry.attributes["TIME-OFFSET"])) {
                                        this.trigger("warn", {
                                            message: "ignoring start declaration without appropriate attribute list"
                                        });
                                        return;
                                    }
                                    this.manifest.start = {
                                        timeOffset: entry.attributes["TIME-OFFSET"],
                                        precise: entry.attributes.PRECISE
                                    };
                                },
                                "cue-out"() {
                                    currentUri.cueOut = entry.data;
                                },
                                "cue-out-cont"() {
                                    currentUri.cueOutCont = entry.data;
                                },
                                "cue-in"() {
                                    currentUri.cueIn = entry.data;
                                },
                                skip() {
                                    this.manifest.skip = app_camelCaseKeys(entry.attributes);
                                    this.warnOnMissingAttributes_("#EXT-X-SKIP", entry.attributes, [ "SKIPPED-SEGMENTS" ]);
                                },
                                part() {
                                    hasParts = true;
                                    const segmentIndex = this.manifest.segments.length;
                                    const part = app_camelCaseKeys(entry.attributes);
                                    currentUri.parts = currentUri.parts || [];
                                    currentUri.parts.push(part);
                                    if (part.byterange) {
                                        if (!part.byterange.hasOwnProperty("offset")) part.byterange.offset = lastPartByterangeEnd;
                                        lastPartByterangeEnd = part.byterange.offset + part.byterange.length;
                                    }
                                    const partIndex = currentUri.parts.length - 1;
                                    this.warnOnMissingAttributes_(`#EXT-X-PART #${partIndex} for segment #${segmentIndex}`, entry.attributes, [ "URI", "DURATION" ]);
                                    if (this.manifest.renditionReports) this.manifest.renditionReports.forEach(((r, i) => {
                                        if (!r.hasOwnProperty("lastPart")) this.trigger("warn", {
                                            message: `#EXT-X-RENDITION-REPORT #${i} lacks required attribute(s): LAST-PART`
                                        });
                                    }));
                                },
                                "server-control"() {
                                    const attrs = this.manifest.serverControl = app_camelCaseKeys(entry.attributes);
                                    if (!attrs.hasOwnProperty("canBlockReload")) {
                                        attrs.canBlockReload = false;
                                        this.trigger("info", {
                                            message: "#EXT-X-SERVER-CONTROL defaulting CAN-BLOCK-RELOAD to false"
                                        });
                                    }
                                    app_setHoldBack.call(this, this.manifest);
                                    if (attrs.canSkipDateranges && !attrs.hasOwnProperty("canSkipUntil")) this.trigger("warn", {
                                        message: "#EXT-X-SERVER-CONTROL lacks required attribute CAN-SKIP-UNTIL which is required when CAN-SKIP-DATERANGES is set"
                                    });
                                },
                                "preload-hint"() {
                                    const segmentIndex = this.manifest.segments.length;
                                    const hint = app_camelCaseKeys(entry.attributes);
                                    const isPart = hint.type && hint.type === "PART";
                                    currentUri.preloadHints = currentUri.preloadHints || [];
                                    currentUri.preloadHints.push(hint);
                                    if (hint.byterange) if (!hint.byterange.hasOwnProperty("offset")) {
                                        hint.byterange.offset = isPart ? lastPartByterangeEnd : 0;
                                        if (isPart) lastPartByterangeEnd = hint.byterange.offset + hint.byterange.length;
                                    }
                                    const index = currentUri.preloadHints.length - 1;
                                    this.warnOnMissingAttributes_(`#EXT-X-PRELOAD-HINT #${index} for segment #${segmentIndex}`, entry.attributes, [ "TYPE", "URI" ]);
                                    if (!hint.type) return;
                                    for (let i = 0; i < currentUri.preloadHints.length - 1; i++) {
                                        const otherHint = currentUri.preloadHints[i];
                                        if (!otherHint.type) continue;
                                        if (otherHint.type === hint.type) this.trigger("warn", {
                                            message: `#EXT-X-PRELOAD-HINT #${index} for segment #${segmentIndex} has the same TYPE ${hint.type} as preload hint #${i}`
                                        });
                                    }
                                },
                                "rendition-report"() {
                                    const report = app_camelCaseKeys(entry.attributes);
                                    this.manifest.renditionReports = this.manifest.renditionReports || [];
                                    this.manifest.renditionReports.push(report);
                                    const index = this.manifest.renditionReports.length - 1;
                                    const required = [ "LAST-MSN", "URI" ];
                                    if (hasParts) required.push("LAST-PART");
                                    this.warnOnMissingAttributes_(`#EXT-X-RENDITION-REPORT #${index}`, entry.attributes, required);
                                },
                                "part-inf"() {
                                    this.manifest.partInf = app_camelCaseKeys(entry.attributes);
                                    this.warnOnMissingAttributes_("#EXT-X-PART-INF", entry.attributes, [ "PART-TARGET" ]);
                                    if (this.manifest.partInf.partTarget) this.manifest.partTargetDuration = this.manifest.partInf.partTarget;
                                    app_setHoldBack.call(this, this.manifest);
                                },
                                daterange() {
                                    this.manifest.dateRanges.push(app_camelCaseKeys(entry.attributes));
                                    const index = this.manifest.dateRanges.length - 1;
                                    this.warnOnMissingAttributes_(`#EXT-X-DATERANGE #${index}`, entry.attributes, [ "ID", "START-DATE" ]);
                                    const dateRange = this.manifest.dateRanges[index];
                                    if (dateRange.endDate && dateRange.startDate && new Date(dateRange.endDate) < new Date(dateRange.startDate)) this.trigger("warn", {
                                        message: "EXT-X-DATERANGE END-DATE must be equal to or later than the value of the START-DATE"
                                    });
                                    if (dateRange.duration && dateRange.duration < 0) this.trigger("warn", {
                                        message: "EXT-X-DATERANGE DURATION must not be negative"
                                    });
                                    if (dateRange.plannedDuration && dateRange.plannedDuration < 0) this.trigger("warn", {
                                        message: "EXT-X-DATERANGE PLANNED-DURATION must not be negative"
                                    });
                                    const endOnNextYes = !!dateRange.endOnNext;
                                    if (endOnNextYes && !dateRange.class) this.trigger("warn", {
                                        message: "EXT-X-DATERANGE with an END-ON-NEXT=YES attribute must have a CLASS attribute"
                                    });
                                    if (endOnNextYes && (dateRange.duration || dateRange.endDate)) this.trigger("warn", {
                                        message: "EXT-X-DATERANGE with an END-ON-NEXT=YES attribute must not contain DURATION or END-DATE attributes"
                                    });
                                    if (dateRange.duration && dateRange.endDate) {
                                        const startDate = dateRange.startDate;
                                        const newDateInSeconds = startDate.getTime() + dateRange.duration * 1e3;
                                        this.manifest.dateRanges[index].endDate = new Date(newDateInSeconds);
                                    }
                                    if (!dateRangeTags[dateRange.id]) dateRangeTags[dateRange.id] = dateRange; else {
                                        for (const attribute in dateRangeTags[dateRange.id]) if (!!dateRange[attribute] && JSON.stringify(dateRangeTags[dateRange.id][attribute]) !== JSON.stringify(dateRange[attribute])) {
                                            this.trigger("warn", {
                                                message: "EXT-X-DATERANGE tags with the same ID in a playlist must have the same attributes values"
                                            });
                                            break;
                                        }
                                        const dateRangeWithSameId = this.manifest.dateRanges.findIndex((dateRangeToFind => dateRangeToFind.id === dateRange.id));
                                        this.manifest.dateRanges[dateRangeWithSameId] = app_extends(this.manifest.dateRanges[dateRangeWithSameId], dateRange);
                                        dateRangeTags[dateRange.id] = app_extends(dateRangeTags[dateRange.id], dateRange);
                                        this.manifest.dateRanges.pop();
                                    }
                                },
                                "independent-segments"() {
                                    this.manifest.independentSegments = true;
                                },
                                "i-frames-only"() {
                                    this.manifest.iFramesOnly = true;
                                    this.requiredCompatibilityversion(this.manifest.version, 4);
                                },
                                "content-steering"() {
                                    this.manifest.contentSteering = app_camelCaseKeys(entry.attributes);
                                    this.warnOnMissingAttributes_("#EXT-X-CONTENT-STEERING", entry.attributes, [ "SERVER-URI" ]);
                                },
                                define() {
                                    this.manifest.definitions = this.manifest.definitions || {};
                                    const addDef = (n, v) => {
                                        if (n in this.manifest.definitions) {
                                            this.trigger("error", {
                                                message: `EXT-X-DEFINE: Duplicate name ${n}`
                                            });
                                            return;
                                        }
                                        this.manifest.definitions[n] = v;
                                    };
                                    if ("QUERYPARAM" in entry.attributes) {
                                        if ("NAME" in entry.attributes || "IMPORT" in entry.attributes) {
                                            this.trigger("error", {
                                                message: "EXT-X-DEFINE: Invalid attributes"
                                            });
                                            return;
                                        }
                                        const val = this.params.get(entry.attributes.QUERYPARAM);
                                        if (!val) {
                                            this.trigger("error", {
                                                message: `EXT-X-DEFINE: No query param ${entry.attributes.QUERYPARAM}`
                                            });
                                            return;
                                        }
                                        addDef(entry.attributes.QUERYPARAM, decodeURIComponent(val));
                                        return;
                                    }
                                    if ("NAME" in entry.attributes) {
                                        if ("IMPORT" in entry.attributes) {
                                            this.trigger("error", {
                                                message: "EXT-X-DEFINE: Invalid attributes"
                                            });
                                            return;
                                        }
                                        if (!("VALUE" in entry.attributes) || typeof entry.attributes.VALUE !== "string") {
                                            this.trigger("error", {
                                                message: `EXT-X-DEFINE: No value for ${entry.attributes.NAME}`
                                            });
                                            return;
                                        }
                                        addDef(entry.attributes.NAME, entry.attributes.VALUE);
                                        return;
                                    }
                                    if ("IMPORT" in entry.attributes) {
                                        if (!this.mainDefinitions[entry.attributes.IMPORT]) {
                                            this.trigger("error", {
                                                message: `EXT-X-DEFINE: No value ${entry.attributes.IMPORT} to import, or IMPORT used on main playlist`
                                            });
                                            return;
                                        }
                                        addDef(entry.attributes.IMPORT, this.mainDefinitions[entry.attributes.IMPORT]);
                                        return;
                                    }
                                    this.trigger("error", {
                                        message: "EXT-X-DEFINE: No attribute"
                                    });
                                },
                                "i-frame-playlist"() {
                                    this.manifest.iFramePlaylists.push({
                                        attributes: entry.attributes,
                                        uri: entry.uri,
                                        timeline: currentTimeline
                                    });
                                    this.warnOnMissingAttributes_("#EXT-X-I-FRAME-STREAM-INF", entry.attributes, [ "BANDWIDTH", "URI" ]);
                                }
                            }[entry.tagType] || noop).call(self);
                        },
                        uri() {
                            currentUri.uri = entry.uri;
                            uris.push(currentUri);
                            if (this.manifest.targetDuration && !("duration" in currentUri)) {
                                this.trigger("warn", {
                                    message: "defaulting segment duration to the target duration"
                                });
                                currentUri.duration = this.manifest.targetDuration;
                            }
                            if (key) currentUri.key = key;
                            currentUri.timeline = currentTimeline;
                            if (currentMap) currentUri.map = currentMap;
                            lastPartByterangeEnd = 0;
                            if (this.lastProgramDateTime !== null) {
                                currentUri.programDateTime = this.lastProgramDateTime;
                                this.lastProgramDateTime += currentUri.duration * 1e3;
                            }
                            currentUri = {};
                        },
                        comment() {},
                        custom() {
                            if (entry.segment) {
                                currentUri.custom = currentUri.custom || {};
                                currentUri.custom[entry.customType] = entry.data;
                            } else {
                                this.manifest.custom = this.manifest.custom || {};
                                this.manifest.custom[entry.customType] = entry.data;
                            }
                        }
                    })[entry.type].call(self);
                }));
            }
            requiredCompatibilityversion(currentVersion, targetVersion) {
                if (currentVersion < targetVersion || !currentVersion) this.trigger("warn", {
                    message: `manifest must be at least version ${targetVersion}`
                });
            }
            warnOnMissingAttributes_(identifier, attributes, required) {
                const missing = [];
                required.forEach((function(key) {
                    if (!attributes.hasOwnProperty(key)) missing.push(key);
                }));
                if (missing.length) this.trigger("warn", {
                    message: `${identifier} lacks required attribute(s): ${missing.join(", ")}`
                });
            }
            push(chunk) {
                this.lineStream.push(chunk);
            }
            end() {
                this.lineStream.push("\n");
                if (this.manifest.dateRanges.length && this.lastProgramDateTime === null) this.trigger("warn", {
                    message: "A playlist with EXT-X-DATERANGE tag must contain atleast one EXT-X-PROGRAM-DATE-TIME tag"
                });
                this.lastProgramDateTime = null;
                this.trigger("end");
            }
            addParser(options) {
                this.parseStream.addParser(options);
            }
            addTagMapper(options) {
                this.parseStream.addTagMapper(options);
            }
        }
        var app_regexs = {
            mp4: /^(av0?1|avc0?[1234]|vp0?9|flac|opus|mp3|mp4a|mp4v|stpp.ttml.im1t)/,
            webm: /^(vp0?[89]|av0?1|opus|vorbis)/,
            ogg: /^(vp0?[89]|theora|flac|opus|vorbis)/,
            video: /^(av0?1|avc0?[1234]|vp0?[89]|hvc1|hev1|theora|mp4v)/,
            audio: /^(mp4a|flac|vorbis|opus|ac-[34]|ec-3|alac|mp3|speex|aac)/,
            text: /^(stpp.ttml.im1t)/,
            muxerVideo: /^(avc0?1)/,
            muxerAudio: /^(mp4a)/,
            muxerText: /a^/
        };
        var app_mediaTypes = [ "video", "audio", "text" ];
        var app_upperMediaTypes = [ "Video", "Audio", "Text" ];
        var app_translateLegacyCodec = function translateLegacyCodec(codec) {
            if (!codec) return codec;
            return codec.replace(/avc1\.(\d+)\.(\d+)/i, (function(orig, profile, avcLevel) {
                var profileHex = ("00" + Number(profile).toString(16)).slice(-2);
                var avcLevelHex = ("00" + Number(avcLevel).toString(16)).slice(-2);
                return "avc1." + profileHex + "00" + avcLevelHex;
            }));
        };
        var app_parseCodecs = function parseCodecs(codecString) {
            if (codecString === void 0) codecString = "";
            var codecs = codecString.split(",");
            var result = [];
            codecs.forEach((function(codec) {
                codec = codec.trim();
                var codecType;
                app_mediaTypes.forEach((function(name) {
                    var match = app_regexs[name].exec(codec.toLowerCase());
                    if (!match || match.length <= 1) return;
                    codecType = name;
                    var type = codec.substring(0, match[1].length);
                    var details = codec.replace(type, "");
                    result.push({
                        type,
                        details,
                        mediaType: name
                    });
                }));
                if (!codecType) result.push({
                    type: codec,
                    details: "",
                    mediaType: "unknown"
                });
            }));
            return result;
        };
        var app_codecsFromDefault = function codecsFromDefault(master, audioGroupId) {
            if (!master.mediaGroups.AUDIO || !audioGroupId) return null;
            var audioGroup = master.mediaGroups.AUDIO[audioGroupId];
            if (!audioGroup) return null;
            for (var name in audioGroup) {
                var audioType = audioGroup[name];
                if (audioType.default && audioType.playlists) return app_parseCodecs(audioType.playlists[0].attributes.CODECS);
            }
            return null;
        };
        var app_isAudioCodec = function isAudioCodec(codec) {
            if (codec === void 0) codec = "";
            return app_regexs.audio.test(codec.trim().toLowerCase());
        };
        var app_isTextCodec = function isTextCodec(codec) {
            if (codec === void 0) codec = "";
            return app_regexs.text.test(codec.trim().toLowerCase());
        };
        var app_getMimeForCodec = function getMimeForCodec(codecString) {
            if (!codecString || typeof codecString !== "string") return;
            var codecs = codecString.toLowerCase().split(",").map((function(c) {
                return app_translateLegacyCodec(c.trim());
            }));
            var type = "video";
            if (codecs.length === 1 && app_isAudioCodec(codecs[0])) type = "audio"; else if (codecs.length === 1 && app_isTextCodec(codecs[0])) type = "application";
            var container = "mp4";
            if (codecs.every((function(c) {
                return app_regexs.mp4.test(c);
            }))) container = "mp4"; else if (codecs.every((function(c) {
                return app_regexs.webm.test(c);
            }))) container = "webm"; else if (codecs.every((function(c) {
                return app_regexs.ogg.test(c);
            }))) container = "ogg";
            return type + "/" + container + ';codecs="' + codecString + '"';
        };
        var app_browserSupportsCodec = function browserSupportsCodec(codecString, withMMS) {
            if (codecString === void 0) codecString = "";
            if (withMMS === void 0) withMMS = false;
            return app_window_default().MediaSource && app_window_default().MediaSource.isTypeSupported && app_window_default().MediaSource.isTypeSupported(app_getMimeForCodec(codecString)) || withMMS && app_window_default().ManagedMediaSource && app_window_default().ManagedMediaSource.isTypeSupported && app_window_default().ManagedMediaSource.isTypeSupported(app_getMimeForCodec(codecString)) || false;
        };
        var app_muxerSupportsCodec = function muxerSupportsCodec(codecString) {
            if (codecString === void 0) codecString = "";
            return codecString.toLowerCase().split(",").every((function(codec) {
                codec = codec.trim();
                for (var i = 0; i < app_upperMediaTypes.length; i++) {
                    var type = app_upperMediaTypes[i];
                    if (app_regexs["muxer" + type].test(codec)) return true;
                }
                return false;
            }));
        };
        var app_DEFAULT_AUDIO_CODEC = "mp4a.40.2";
        var app_DEFAULT_VIDEO_CODEC = "avc1.4d400d";
        var app_MPEGURL_REGEX = /^(audio|video|application)\/(x-|vnd\.apple\.)?mpegurl/i;
        var app_DASH_REGEX = /^application\/dash\+xml/i;
        var app_simpleTypeFromSourceType = function simpleTypeFromSourceType(type) {
            if (app_MPEGURL_REGEX.test(type)) return "hls";
            if (app_DASH_REGEX.test(type)) return "dash";
            if (type === "application/vnd.videojs.vhs+json") return "vhs-json";
            return null;
        };
        var app_countBits = function countBits(x) {
            return x.toString(2).length;
        };
        var app_countBytes = function countBytes(x) {
            return Math.ceil(app_countBits(x) / 8);
        };
        var app_isArrayBufferView = function isArrayBufferView(obj) {
            if (ArrayBuffer.isView === "function") return ArrayBuffer.isView(obj);
            return obj && obj.buffer instanceof ArrayBuffer;
        };
        var app_isTypedArray = function isTypedArray(obj) {
            return app_isArrayBufferView(obj);
        };
        var app_byte_helpers_toUint8 = function toUint8(bytes) {
            if (bytes instanceof Uint8Array) return bytes;
            if (!Array.isArray(bytes) && !app_isTypedArray(bytes) && !(bytes instanceof ArrayBuffer)) if (typeof bytes !== "number" || typeof bytes === "number" && bytes !== bytes) bytes = 0; else bytes = [ bytes ];
            return new Uint8Array(bytes && bytes.buffer || bytes, bytes && bytes.byteOffset || 0, bytes && bytes.byteLength || 0);
        };
        var app_BigInt = app_window_default().BigInt || Number;
        var app_BYTE_TABLE = [ app_BigInt("0x1"), app_BigInt("0x100"), app_BigInt("0x10000"), app_BigInt("0x1000000"), app_BigInt("0x100000000"), app_BigInt("0x10000000000"), app_BigInt("0x1000000000000"), app_BigInt("0x100000000000000"), app_BigInt("0x10000000000000000") ];
        (function() {
            var a = new Uint16Array([ 65484 ]);
            var b = new Uint8Array(a.buffer, a.byteOffset, a.byteLength);
            if (b[0] === 255) return "big";
            if (b[0] === 204) return "little";
        })();
        var app_byte_helpers_bytesToNumber = function bytesToNumber(bytes, _temp) {
            var _ref = _temp === void 0 ? {} : _temp, _ref$signed = _ref.signed, signed = _ref$signed === void 0 ? false : _ref$signed, _ref$le = _ref.le, le = _ref$le === void 0 ? false : _ref$le;
            bytes = app_byte_helpers_toUint8(bytes);
            var fn = le ? "reduce" : "reduceRight";
            var obj = bytes[fn] ? bytes[fn] : Array.prototype[fn];
            var number = obj.call(bytes, (function(total, byte, i) {
                var exponent = le ? i : Math.abs(i + 1 - bytes.length);
                return total + app_BigInt(byte) * app_BYTE_TABLE[exponent];
            }), app_BigInt(0));
            if (signed) {
                var max = app_BYTE_TABLE[bytes.length] / app_BigInt(2) - app_BigInt(1);
                number = app_BigInt(number);
                if (number > max) {
                    number -= max;
                    number -= max;
                    number -= app_BigInt(2);
                }
            }
            return Number(number);
        };
        var app_numberToBytes = function numberToBytes(number, _temp2) {
            var _ref2 = _temp2 === void 0 ? {} : _temp2, _ref2$le = _ref2.le, le = _ref2$le === void 0 ? false : _ref2$le;
            if (typeof number !== "bigint" && typeof number !== "number" || typeof number === "number" && number !== number) number = 0;
            number = app_BigInt(number);
            var byteCount = app_countBytes(number);
            var bytes = new Uint8Array(new ArrayBuffer(byteCount));
            for (var i = 0; i < byteCount; i++) {
                var byteIndex = le ? i : Math.abs(i + 1 - bytes.length);
                bytes[byteIndex] = Number(number / app_BYTE_TABLE[i] & app_BigInt(255));
                if (number < 0) {
                    bytes[byteIndex] = Math.abs(~bytes[byteIndex]);
                    bytes[byteIndex] -= i === 0 ? 1 : 2;
                }
            }
            return bytes;
        };
        var app_byte_helpers_bytesToString = function bytesToString(bytes) {
            if (!bytes) return "";
            bytes = Array.prototype.slice.call(bytes);
            var string = String.fromCharCode.apply(null, app_byte_helpers_toUint8(bytes));
            try {
                return decodeURIComponent(escape(string));
            } catch (e) {}
            return string;
        };
        var app_stringToBytes = function stringToBytes(string, stringIsBytes) {
            if (typeof string !== "string" && string && typeof string.toString === "function") string = string.toString();
            if (typeof string !== "string") return new Uint8Array;
            if (!stringIsBytes) string = unescape(encodeURIComponent(string));
            var view = new Uint8Array(string.length);
            for (var i = 0; i < string.length; i++) view[i] = string.charCodeAt(i);
            return view;
        };
        var app_concatTypedArrays = function concatTypedArrays() {
            for (var _len = arguments.length, buffers = new Array(_len), _key = 0; _key < _len; _key++) buffers[_key] = arguments[_key];
            buffers = buffers.filter((function(b) {
                return b && (b.byteLength || b.length) && typeof b !== "string";
            }));
            if (buffers.length <= 1) return app_byte_helpers_toUint8(buffers[0]);
            var totalLen = buffers.reduce((function(total, buf, i) {
                return total + (buf.byteLength || buf.length);
            }), 0);
            var tempBuffer = new Uint8Array(totalLen);
            var offset = 0;
            buffers.forEach((function(buf) {
                buf = app_byte_helpers_toUint8(buf);
                tempBuffer.set(buf, offset);
                offset += buf.byteLength;
            }));
            return tempBuffer;
        };
        var app_byte_helpers_bytesMatch = function bytesMatch(a, b, _temp3) {
            var _ref3 = _temp3 === void 0 ? {} : _temp3, _ref3$offset = _ref3.offset, offset = _ref3$offset === void 0 ? 0 : _ref3$offset, _ref3$mask = _ref3.mask, mask = _ref3$mask === void 0 ? [] : _ref3$mask;
            a = app_byte_helpers_toUint8(a);
            b = app_byte_helpers_toUint8(b);
            var fn = b.every ? b.every : Array.prototype.every;
            return b.length && a.length - offset >= b.length && fn.call(b, (function(bByte, i) {
                var aByte = mask[i] ? mask[i] & a[offset + i] : a[offset + i];
                return bByte === aByte;
            }));
        };
        var app_forEachMediaGroup = function forEachMediaGroup(master, groups, callback) {
            groups.forEach((function(mediaType) {
                for (var groupKey in master.mediaGroups[mediaType]) for (var labelKey in master.mediaGroups[mediaType][groupKey]) {
                    var mediaProperties = master.mediaGroups[mediaType][groupKey][labelKey];
                    callback(mediaProperties, mediaType, groupKey, labelKey);
                }
            }));
        };
        var app_xmldom_lib = __webpack_require__(978);
        const app_mpd_parser_es_isObject = obj => !!obj && typeof obj === "object";
        const app_merge = (...objects) => objects.reduce(((result, source) => {
            if (typeof source !== "object") return result;
            Object.keys(source).forEach((key => {
                if (Array.isArray(result[key]) && Array.isArray(source[key])) result[key] = result[key].concat(source[key]); else if (app_mpd_parser_es_isObject(result[key]) && app_mpd_parser_es_isObject(source[key])) result[key] = app_merge(result[key], source[key]); else result[key] = source[key];
            }));
            return result;
        }), {});
        const app_values = o => Object.keys(o).map((k => o[k]));
        const app_range = (start, end) => {
            const result = [];
            for (let i = start; i < end; i++) result.push(i);
            return result;
        };
        const app_flatten = lists => lists.reduce(((x, y) => x.concat(y)), []);
        const app_from = list => {
            if (!list.length) return [];
            const result = [];
            for (let i = 0; i < list.length; i++) result.push(list[i]);
            return result;
        };
        const app_findIndexes = (l, key) => l.reduce(((a, e, i) => {
            if (e[key]) a.push(i);
            return a;
        }), []);
        const app_union = (lists, keyFunction) => app_values(lists.reduce(((acc, list) => {
            list.forEach((el => {
                acc[keyFunction(el)] = el;
            }));
            return acc;
        }), {}));
        var app_errors = {
            INVALID_NUMBER_OF_PERIOD: "INVALID_NUMBER_OF_PERIOD",
            INVALID_NUMBER_OF_CONTENT_STEERING: "INVALID_NUMBER_OF_CONTENT_STEERING",
            DASH_EMPTY_MANIFEST: "DASH_EMPTY_MANIFEST",
            DASH_INVALID_XML: "DASH_INVALID_XML",
            NO_BASE_URL: "NO_BASE_URL",
            MISSING_SEGMENT_INFORMATION: "MISSING_SEGMENT_INFORMATION",
            SEGMENT_TIME_UNSPECIFIED: "SEGMENT_TIME_UNSPECIFIED",
            UNSUPPORTED_UTC_TIMING_SCHEME: "UNSUPPORTED_UTC_TIMING_SCHEME"
        };
        const app_urlTypeToSegment = ({baseUrl = "", source = "", range = "", indexRange = ""}) => {
            const segment = {
                uri: source,
                resolvedUri: app_resolve_url(baseUrl || "", source)
            };
            if (range || indexRange) {
                const rangeStr = range ? range : indexRange;
                const ranges = rangeStr.split("-");
                let startRange = app_window_default().BigInt ? app_window_default().BigInt(ranges[0]) : parseInt(ranges[0], 10);
                let endRange = app_window_default().BigInt ? app_window_default().BigInt(ranges[1]) : parseInt(ranges[1], 10);
                if (startRange < Number.MAX_SAFE_INTEGER && typeof startRange === "bigint") startRange = Number(startRange);
                if (endRange < Number.MAX_SAFE_INTEGER && typeof endRange === "bigint") endRange = Number(endRange);
                let length;
                if (typeof endRange === "bigint" || typeof startRange === "bigint") length = app_window_default().BigInt(endRange) - app_window_default().BigInt(startRange) + app_window_default().BigInt(1); else length = endRange - startRange + 1;
                if (typeof length === "bigint" && length < Number.MAX_SAFE_INTEGER) length = Number(length);
                segment.byterange = {
                    length,
                    offset: startRange
                };
            }
            return segment;
        };
        const app_byteRangeToString = byterange => {
            let endRange;
            if (typeof byterange.offset === "bigint" || typeof byterange.length === "bigint") endRange = app_window_default().BigInt(byterange.offset) + app_window_default().BigInt(byterange.length) - app_window_default().BigInt(1); else endRange = byterange.offset + byterange.length - 1;
            return `${byterange.offset}-${endRange}`;
        };
        const app_parseEndNumber = endNumber => {
            if (endNumber && typeof endNumber !== "number") endNumber = parseInt(endNumber, 10);
            if (isNaN(endNumber)) return null;
            return endNumber;
        };
        const app_segmentRange = {
            static(attributes) {
                const {duration, timescale = 1, sourceDuration, periodDuration} = attributes;
                const endNumber = app_parseEndNumber(attributes.endNumber);
                const segmentDuration = duration / timescale;
                if (typeof endNumber === "number") return {
                    start: 0,
                    end: endNumber
                };
                if (typeof periodDuration === "number") return {
                    start: 0,
                    end: periodDuration / segmentDuration
                };
                return {
                    start: 0,
                    end: sourceDuration / segmentDuration
                };
            },
            dynamic(attributes) {
                const {NOW, clientOffset, availabilityStartTime, timescale = 1, duration, periodStart = 0, minimumUpdatePeriod = 0, timeShiftBufferDepth = 1 / 0} = attributes;
                const endNumber = app_parseEndNumber(attributes.endNumber);
                const now = (NOW + clientOffset) / 1e3;
                const periodStartWC = availabilityStartTime + periodStart;
                const periodEndWC = now + minimumUpdatePeriod;
                const periodDuration = periodEndWC - periodStartWC;
                const segmentCount = Math.ceil(periodDuration * timescale / duration);
                const availableStart = Math.floor((now - periodStartWC - timeShiftBufferDepth) * timescale / duration);
                const availableEnd = Math.floor((now - periodStartWC) * timescale / duration);
                return {
                    start: Math.max(0, availableStart),
                    end: typeof endNumber === "number" ? endNumber : Math.min(segmentCount, availableEnd)
                };
            }
        };
        const app_toSegments = attributes => number => {
            const {duration, timescale = 1, periodStart, startNumber = 1} = attributes;
            return {
                number: startNumber + number,
                duration: duration / timescale,
                timeline: periodStart,
                time: number * duration
            };
        };
        const app_parseByDuration = attributes => {
            const {type, duration, timescale = 1, periodDuration, sourceDuration} = attributes;
            const {start, end} = app_segmentRange[type](attributes);
            const segments = app_range(start, end).map(app_toSegments(attributes));
            if (type === "static") {
                const index = segments.length - 1;
                const sectionDuration = typeof periodDuration === "number" ? periodDuration : sourceDuration;
                segments[index].duration = sectionDuration - duration / timescale * index;
            }
            return segments;
        };
        const app_segmentsFromBase = attributes => {
            const {baseUrl, initialization = {}, sourceDuration, indexRange = "", periodStart, presentationTime, number = 0, duration} = attributes;
            if (!baseUrl) throw new Error(app_errors.NO_BASE_URL);
            const initSegment = app_urlTypeToSegment({
                baseUrl,
                source: initialization.sourceURL,
                range: initialization.range
            });
            const segment = app_urlTypeToSegment({
                baseUrl,
                source: baseUrl,
                indexRange
            });
            segment.map = initSegment;
            if (duration) {
                const segmentTimeInfo = app_parseByDuration(attributes);
                if (segmentTimeInfo.length) {
                    segment.duration = segmentTimeInfo[0].duration;
                    segment.timeline = segmentTimeInfo[0].timeline;
                }
            } else if (sourceDuration) {
                segment.duration = sourceDuration;
                segment.timeline = periodStart;
            }
            segment.presentationTime = presentationTime || periodStart;
            segment.number = number;
            return [ segment ];
        };
        const app_addSidxSegmentsToPlaylist$1 = (playlist, sidx, baseUrl) => {
            const initSegment = playlist.sidx.map ? playlist.sidx.map : null;
            const sourceDuration = playlist.sidx.duration;
            const timeline = playlist.timeline || 0;
            const sidxByteRange = playlist.sidx.byterange;
            const sidxEnd = sidxByteRange.offset + sidxByteRange.length;
            const timescale = sidx.timescale;
            const mediaReferences = sidx.references.filter((r => r.referenceType !== 1));
            const segments = [];
            const type = playlist.endList ? "static" : "dynamic";
            const periodStart = playlist.sidx.timeline;
            let presentationTime = periodStart;
            let number = playlist.mediaSequence || 0;
            let startIndex;
            if (typeof sidx.firstOffset === "bigint") startIndex = app_window_default().BigInt(sidxEnd) + sidx.firstOffset; else startIndex = sidxEnd + sidx.firstOffset;
            for (let i = 0; i < mediaReferences.length; i++) {
                const reference = sidx.references[i];
                const size = reference.referencedSize;
                const duration = reference.subsegmentDuration;
                let endIndex;
                if (typeof startIndex === "bigint") endIndex = startIndex + app_window_default().BigInt(size) - app_window_default().BigInt(1); else endIndex = startIndex + size - 1;
                const indexRange = `${startIndex}-${endIndex}`;
                const attributes = {
                    baseUrl,
                    timescale,
                    timeline,
                    periodStart,
                    presentationTime,
                    number,
                    duration,
                    sourceDuration,
                    indexRange,
                    type
                };
                const segment = app_segmentsFromBase(attributes)[0];
                if (initSegment) segment.map = initSegment;
                segments.push(segment);
                if (typeof startIndex === "bigint") startIndex += app_window_default().BigInt(size); else startIndex += size;
                presentationTime += duration / timescale;
                number++;
            }
            playlist.segments = segments;
            return playlist;
        };
        const app_SUPPORTED_MEDIA_TYPES = [ "AUDIO", "SUBTITLES" ];
        const app_TIME_FUDGE = 1 / 60;
        const app_getUniqueTimelineStarts = timelineStarts => app_union(timelineStarts, (({timeline}) => timeline)).sort(((a, b) => a.timeline > b.timeline ? 1 : -1));
        const app_findPlaylistWithName = (playlists, name) => {
            for (let i = 0; i < playlists.length; i++) if (playlists[i].attributes.NAME === name) return playlists[i];
            return null;
        };
        const app_getMediaGroupPlaylists = manifest => {
            let mediaGroupPlaylists = [];
            app_forEachMediaGroup(manifest, app_SUPPORTED_MEDIA_TYPES, ((properties, type, group, label) => {
                mediaGroupPlaylists = mediaGroupPlaylists.concat(properties.playlists || []);
            }));
            return mediaGroupPlaylists;
        };
        const app_updateMediaSequenceForPlaylist = ({playlist, mediaSequence}) => {
            playlist.mediaSequence = mediaSequence;
            playlist.segments.forEach(((segment, index) => {
                segment.number = playlist.mediaSequence + index;
            }));
        };
        const app_updateSequenceNumbers = ({oldPlaylists, newPlaylists, timelineStarts}) => {
            newPlaylists.forEach((playlist => {
                playlist.discontinuitySequence = timelineStarts.findIndex((function({timeline}) {
                    return timeline === playlist.timeline;
                }));
                const oldPlaylist = app_findPlaylistWithName(oldPlaylists, playlist.attributes.NAME);
                if (!oldPlaylist) return;
                if (playlist.sidx) return;
                const firstNewSegment = playlist.segments[0];
                const oldMatchingSegmentIndex = oldPlaylist.segments.findIndex((function(oldSegment) {
                    return Math.abs(oldSegment.presentationTime - firstNewSegment.presentationTime) < app_TIME_FUDGE;
                }));
                if (oldMatchingSegmentIndex === -1) {
                    app_updateMediaSequenceForPlaylist({
                        playlist,
                        mediaSequence: oldPlaylist.mediaSequence + oldPlaylist.segments.length
                    });
                    playlist.segments[0].discontinuity = true;
                    playlist.discontinuityStarts.unshift(0);
                    if (!oldPlaylist.segments.length && playlist.timeline > oldPlaylist.timeline || oldPlaylist.segments.length && playlist.timeline > oldPlaylist.segments[oldPlaylist.segments.length - 1].timeline) playlist.discontinuitySequence--;
                    return;
                }
                const oldMatchingSegment = oldPlaylist.segments[oldMatchingSegmentIndex];
                if (oldMatchingSegment.discontinuity && !firstNewSegment.discontinuity) {
                    firstNewSegment.discontinuity = true;
                    playlist.discontinuityStarts.unshift(0);
                    playlist.discontinuitySequence--;
                }
                app_updateMediaSequenceForPlaylist({
                    playlist,
                    mediaSequence: oldPlaylist.segments[oldMatchingSegmentIndex].number
                });
            }));
        };
        const app_positionManifestOnTimeline = ({oldManifest, newManifest}) => {
            const oldPlaylists = oldManifest.playlists.concat(app_getMediaGroupPlaylists(oldManifest));
            const newPlaylists = newManifest.playlists.concat(app_getMediaGroupPlaylists(newManifest));
            newManifest.timelineStarts = app_getUniqueTimelineStarts([ oldManifest.timelineStarts, newManifest.timelineStarts ]);
            app_updateSequenceNumbers({
                oldPlaylists,
                newPlaylists,
                timelineStarts: newManifest.timelineStarts
            });
            return newManifest;
        };
        const app_generateSidxKey = sidx => sidx && sidx.uri + "-" + app_byteRangeToString(sidx.byterange);
        const app_mergeDiscontiguousPlaylists = playlists => {
            const playlistsByBaseUrl = playlists.reduce((function(acc, cur) {
                if (!acc[cur.attributes.baseUrl]) acc[cur.attributes.baseUrl] = [];
                acc[cur.attributes.baseUrl].push(cur);
                return acc;
            }), {});
            let allPlaylists = [];
            Object.values(playlistsByBaseUrl).forEach((playlistGroup => {
                const mergedPlaylists = app_values(playlistGroup.reduce(((acc, playlist) => {
                    const name = playlist.attributes.id + (playlist.attributes.lang || "");
                    if (!acc[name]) {
                        acc[name] = playlist;
                        acc[name].attributes.timelineStarts = [];
                    } else {
                        if (playlist.segments) {
                            if (playlist.segments[0]) playlist.segments[0].discontinuity = true;
                            acc[name].segments.push(...playlist.segments);
                        }
                        if (playlist.attributes.contentProtection) acc[name].attributes.contentProtection = playlist.attributes.contentProtection;
                    }
                    acc[name].attributes.timelineStarts.push({
                        start: playlist.attributes.periodStart,
                        timeline: playlist.attributes.periodStart
                    });
                    return acc;
                }), {}));
                allPlaylists = allPlaylists.concat(mergedPlaylists);
            }));
            return allPlaylists.map((playlist => {
                playlist.discontinuityStarts = app_findIndexes(playlist.segments || [], "discontinuity");
                return playlist;
            }));
        };
        const app_addSidxSegmentsToPlaylist = (playlist, sidxMapping) => {
            const sidxKey = app_generateSidxKey(playlist.sidx);
            const sidxMatch = sidxKey && sidxMapping[sidxKey] && sidxMapping[sidxKey].sidx;
            if (sidxMatch) app_addSidxSegmentsToPlaylist$1(playlist, sidxMatch, playlist.sidx.resolvedUri);
            return playlist;
        };
        const app_addSidxSegmentsToPlaylists = (playlists, sidxMapping = {}) => {
            if (!Object.keys(sidxMapping).length) return playlists;
            for (const i in playlists) playlists[i] = app_addSidxSegmentsToPlaylist(playlists[i], sidxMapping);
            return playlists;
        };
        const app_formatAudioPlaylist = ({attributes, segments, sidx, mediaSequence, discontinuitySequence, discontinuityStarts}, isAudioOnly) => {
            const playlist = {
                attributes: {
                    NAME: attributes.id,
                    BANDWIDTH: attributes.bandwidth,
                    CODECS: attributes.codecs,
                    ["PROGRAM-ID"]: 1
                },
                uri: "",
                endList: attributes.type === "static",
                timeline: attributes.periodStart,
                resolvedUri: attributes.baseUrl || "",
                targetDuration: attributes.duration,
                discontinuitySequence,
                discontinuityStarts,
                timelineStarts: attributes.timelineStarts,
                mediaSequence,
                segments
            };
            if (attributes.contentProtection) playlist.contentProtection = attributes.contentProtection;
            if (attributes.serviceLocation) playlist.attributes.serviceLocation = attributes.serviceLocation;
            if (sidx) playlist.sidx = sidx;
            if (isAudioOnly) {
                playlist.attributes.AUDIO = "audio";
                playlist.attributes.SUBTITLES = "subs";
            }
            return playlist;
        };
        const app_formatVttPlaylist = ({attributes, segments, mediaSequence, discontinuityStarts, discontinuitySequence}) => {
            if (typeof segments === "undefined") {
                segments = [ {
                    uri: attributes.baseUrl,
                    timeline: attributes.periodStart,
                    resolvedUri: attributes.baseUrl || "",
                    duration: attributes.sourceDuration,
                    number: 0
                } ];
                attributes.duration = attributes.sourceDuration;
            }
            const m3u8Attributes = {
                NAME: attributes.id,
                BANDWIDTH: attributes.bandwidth,
                ["PROGRAM-ID"]: 1
            };
            if (attributes.codecs) m3u8Attributes.CODECS = attributes.codecs;
            const vttPlaylist = {
                attributes: m3u8Attributes,
                uri: "",
                endList: attributes.type === "static",
                timeline: attributes.periodStart,
                resolvedUri: attributes.baseUrl || "",
                targetDuration: attributes.duration,
                timelineStarts: attributes.timelineStarts,
                discontinuityStarts,
                discontinuitySequence,
                mediaSequence,
                segments
            };
            if (attributes.serviceLocation) vttPlaylist.attributes.serviceLocation = attributes.serviceLocation;
            return vttPlaylist;
        };
        const app_organizeAudioPlaylists = (playlists, sidxMapping = {}, isAudioOnly = false) => {
            let mainPlaylist;
            const formattedPlaylists = playlists.reduce(((a, playlist) => {
                const role = playlist.attributes.role && playlist.attributes.role.value || "";
                const language = playlist.attributes.lang || "";
                let label = playlist.attributes.label || "main";
                if (language && !playlist.attributes.label) {
                    const roleLabel = role ? ` (${role})` : "";
                    label = `${playlist.attributes.lang}${roleLabel}`;
                }
                if (!a[label]) a[label] = {
                    language,
                    autoselect: true,
                    default: role === "main",
                    playlists: [],
                    uri: ""
                };
                const formatted = app_addSidxSegmentsToPlaylist(app_formatAudioPlaylist(playlist, isAudioOnly), sidxMapping);
                a[label].playlists.push(formatted);
                if (typeof mainPlaylist === "undefined" && role === "main") {
                    mainPlaylist = playlist;
                    mainPlaylist.default = true;
                }
                return a;
            }), {});
            if (!mainPlaylist) {
                const firstLabel = Object.keys(formattedPlaylists)[0];
                formattedPlaylists[firstLabel].default = true;
            }
            return formattedPlaylists;
        };
        const app_organizeVttPlaylists = (playlists, sidxMapping = {}) => playlists.reduce(((a, playlist) => {
            const label = playlist.attributes.label || playlist.attributes.lang || "text";
            const language = playlist.attributes.lang || "und";
            if (!a[label]) a[label] = {
                language,
                default: false,
                autoselect: false,
                playlists: [],
                uri: ""
            };
            a[label].playlists.push(app_addSidxSegmentsToPlaylist(app_formatVttPlaylist(playlist), sidxMapping));
            return a;
        }), {});
        const app_organizeCaptionServices = captionServices => captionServices.reduce(((svcObj, svc) => {
            if (!svc) return svcObj;
            svc.forEach((service => {
                const {channel, language} = service;
                svcObj[language] = {
                    autoselect: false,
                    default: false,
                    instreamId: channel,
                    language
                };
                if (service.hasOwnProperty("aspectRatio")) svcObj[language].aspectRatio = service.aspectRatio;
                if (service.hasOwnProperty("easyReader")) svcObj[language].easyReader = service.easyReader;
                if (service.hasOwnProperty("3D")) svcObj[language]["3D"] = service["3D"];
            }));
            return svcObj;
        }), {});
        const app_formatVideoPlaylist = ({attributes, segments, sidx, discontinuityStarts}) => {
            const playlist = {
                attributes: {
                    NAME: attributes.id,
                    AUDIO: "audio",
                    SUBTITLES: "subs",
                    RESOLUTION: {
                        width: attributes.width,
                        height: attributes.height
                    },
                    CODECS: attributes.codecs,
                    BANDWIDTH: attributes.bandwidth,
                    ["PROGRAM-ID"]: 1
                },
                uri: "",
                endList: attributes.type === "static",
                timeline: attributes.periodStart,
                resolvedUri: attributes.baseUrl || "",
                targetDuration: attributes.duration,
                discontinuityStarts,
                timelineStarts: attributes.timelineStarts,
                segments
            };
            if (attributes.frameRate) playlist.attributes["FRAME-RATE"] = attributes.frameRate;
            if (attributes.contentProtection) playlist.contentProtection = attributes.contentProtection;
            if (attributes.serviceLocation) playlist.attributes.serviceLocation = attributes.serviceLocation;
            if (sidx) playlist.sidx = sidx;
            return playlist;
        };
        const app_videoOnly = ({attributes}) => attributes.mimeType === "video/mp4" || attributes.mimeType === "video/webm" || attributes.contentType === "video";
        const app_audioOnly = ({attributes}) => attributes.mimeType === "audio/mp4" || attributes.mimeType === "audio/webm" || attributes.contentType === "audio";
        const app_vttOnly = ({attributes}) => attributes.mimeType === "text/vtt" || attributes.contentType === "text";
        const app_addMediaSequenceValues = (playlists, timelineStarts) => {
            playlists.forEach((playlist => {
                playlist.mediaSequence = 0;
                playlist.discontinuitySequence = timelineStarts.findIndex((function({timeline}) {
                    return timeline === playlist.timeline;
                }));
                if (!playlist.segments) return;
                playlist.segments.forEach(((segment, index) => {
                    segment.number = index;
                }));
            }));
        };
        const app_flattenMediaGroupPlaylists = mediaGroupObject => {
            if (!mediaGroupObject) return [];
            return Object.keys(mediaGroupObject).reduce(((acc, label) => {
                const labelContents = mediaGroupObject[label];
                return acc.concat(labelContents.playlists);
            }), []);
        };
        const app_toM3u8 = ({dashPlaylists, locations, contentSteering, sidxMapping = {}, previousManifest, eventStream}) => {
            if (!dashPlaylists.length) return {};
            const {sourceDuration: duration, type, suggestedPresentationDelay, minimumUpdatePeriod} = dashPlaylists[0].attributes;
            const videoPlaylists = app_mergeDiscontiguousPlaylists(dashPlaylists.filter(app_videoOnly)).map(app_formatVideoPlaylist);
            const audioPlaylists = app_mergeDiscontiguousPlaylists(dashPlaylists.filter(app_audioOnly));
            const vttPlaylists = app_mergeDiscontiguousPlaylists(dashPlaylists.filter(app_vttOnly));
            const captions = dashPlaylists.map((playlist => playlist.attributes.captionServices)).filter(Boolean);
            const manifest = {
                allowCache: true,
                discontinuityStarts: [],
                segments: [],
                endList: true,
                mediaGroups: {
                    AUDIO: {},
                    VIDEO: {},
                    ["CLOSED-CAPTIONS"]: {},
                    SUBTITLES: {}
                },
                uri: "",
                duration,
                playlists: app_addSidxSegmentsToPlaylists(videoPlaylists, sidxMapping)
            };
            if (minimumUpdatePeriod >= 0) manifest.minimumUpdatePeriod = minimumUpdatePeriod * 1e3;
            if (locations) manifest.locations = locations;
            if (contentSteering) manifest.contentSteering = contentSteering;
            if (type === "dynamic") manifest.suggestedPresentationDelay = suggestedPresentationDelay;
            if (eventStream && eventStream.length > 0) manifest.eventStream = eventStream;
            const isAudioOnly = manifest.playlists.length === 0;
            const organizedAudioGroup = audioPlaylists.length ? app_organizeAudioPlaylists(audioPlaylists, sidxMapping, isAudioOnly) : null;
            const organizedVttGroup = vttPlaylists.length ? app_organizeVttPlaylists(vttPlaylists, sidxMapping) : null;
            const formattedPlaylists = videoPlaylists.concat(app_flattenMediaGroupPlaylists(organizedAudioGroup), app_flattenMediaGroupPlaylists(organizedVttGroup));
            const playlistTimelineStarts = formattedPlaylists.map((({timelineStarts}) => timelineStarts));
            manifest.timelineStarts = app_getUniqueTimelineStarts(playlistTimelineStarts);
            app_addMediaSequenceValues(formattedPlaylists, manifest.timelineStarts);
            if (organizedAudioGroup) manifest.mediaGroups.AUDIO.audio = organizedAudioGroup;
            if (organizedVttGroup) manifest.mediaGroups.SUBTITLES.subs = organizedVttGroup;
            if (captions.length) manifest.mediaGroups["CLOSED-CAPTIONS"].cc = app_organizeCaptionServices(captions);
            if (previousManifest) return app_positionManifestOnTimeline({
                oldManifest: previousManifest,
                newManifest: manifest
            });
            return manifest;
        };
        const app_getLiveRValue = (attributes, time, duration) => {
            const {NOW, clientOffset, availabilityStartTime, timescale = 1, periodStart = 0, minimumUpdatePeriod = 0} = attributes;
            const now = (NOW + clientOffset) / 1e3;
            const periodStartWC = availabilityStartTime + periodStart;
            const periodEndWC = now + minimumUpdatePeriod;
            const periodDuration = periodEndWC - periodStartWC;
            return Math.ceil((periodDuration * timescale - time) / duration);
        };
        const app_parseByTimeline = (attributes, segmentTimeline) => {
            const {type, minimumUpdatePeriod = 0, media = "", sourceDuration, timescale = 1, startNumber = 1, periodStart: timeline} = attributes;
            const segments = [];
            let time = -1;
            for (let sIndex = 0; sIndex < segmentTimeline.length; sIndex++) {
                const S = segmentTimeline[sIndex];
                const duration = S.d;
                const repeat = S.r || 0;
                const segmentTime = S.t || 0;
                if (time < 0) time = segmentTime;
                if (segmentTime && segmentTime > time) time = segmentTime;
                let count;
                if (repeat < 0) {
                    const nextS = sIndex + 1;
                    if (nextS === segmentTimeline.length) if (type === "dynamic" && minimumUpdatePeriod > 0 && media.indexOf("$Number$") > 0) count = app_getLiveRValue(attributes, time, duration); else count = (sourceDuration * timescale - time) / duration; else count = (segmentTimeline[nextS].t - time) / duration;
                } else count = repeat + 1;
                const end = startNumber + segments.length + count;
                let number = startNumber + segments.length;
                while (number < end) {
                    segments.push({
                        number,
                        duration: duration / timescale,
                        time,
                        timeline
                    });
                    time += duration;
                    number++;
                }
            }
            return segments;
        };
        const app_identifierPattern = /\$([A-z]*)(?:(%0)([0-9]+)d)?\$/g;
        const app_identifierReplacement = values => (match, identifier, format, width) => {
            if (match === "$$") return "$";
            if (typeof values[identifier] === "undefined") return match;
            const value = "" + values[identifier];
            if (identifier === "RepresentationID") return value;
            if (!format) width = 1; else width = parseInt(width, 10);
            if (value.length >= width) return value;
            return `${new Array(width - value.length + 1).join("0")}${value}`;
        };
        const app_constructTemplateUrl = (url, values) => url.replace(app_identifierPattern, app_identifierReplacement(values));
        const app_parseTemplateInfo = (attributes, segmentTimeline) => {
            if (!attributes.duration && !segmentTimeline) return [ {
                number: attributes.startNumber || 1,
                duration: attributes.sourceDuration,
                time: 0,
                timeline: attributes.periodStart
            } ];
            if (attributes.duration) return app_parseByDuration(attributes);
            return app_parseByTimeline(attributes, segmentTimeline);
        };
        const app_segmentsFromTemplate = (attributes, segmentTimeline) => {
            const templateValues = {
                RepresentationID: attributes.id,
                Bandwidth: attributes.bandwidth || 0
            };
            const {initialization = {
                sourceURL: "",
                range: ""
            }} = attributes;
            const mapSegment = app_urlTypeToSegment({
                baseUrl: attributes.baseUrl,
                source: app_constructTemplateUrl(initialization.sourceURL, templateValues),
                range: initialization.range
            });
            const segments = app_parseTemplateInfo(attributes, segmentTimeline);
            return segments.map((segment => {
                templateValues.Number = segment.number;
                templateValues.Time = segment.time;
                const uri = app_constructTemplateUrl(attributes.media || "", templateValues);
                const timescale = attributes.timescale || 1;
                const presentationTimeOffset = attributes.presentationTimeOffset || 0;
                const presentationTime = attributes.periodStart + (segment.time - presentationTimeOffset) / timescale;
                const map = {
                    uri,
                    timeline: segment.timeline,
                    duration: segment.duration,
                    resolvedUri: app_resolve_url(attributes.baseUrl || "", uri),
                    map: mapSegment,
                    number: segment.number,
                    presentationTime
                };
                return map;
            }));
        };
        const app_SegmentURLToSegmentObject = (attributes, segmentUrl) => {
            const {baseUrl, initialization = {}} = attributes;
            const initSegment = app_urlTypeToSegment({
                baseUrl,
                source: initialization.sourceURL,
                range: initialization.range
            });
            const segment = app_urlTypeToSegment({
                baseUrl,
                source: segmentUrl.media,
                range: segmentUrl.mediaRange
            });
            segment.map = initSegment;
            return segment;
        };
        const app_segmentsFromList = (attributes, segmentTimeline) => {
            const {duration, segmentUrls = [], periodStart} = attributes;
            if (!duration && !segmentTimeline || duration && segmentTimeline) throw new Error(app_errors.SEGMENT_TIME_UNSPECIFIED);
            const segmentUrlMap = segmentUrls.map((segmentUrlObject => app_SegmentURLToSegmentObject(attributes, segmentUrlObject)));
            let segmentTimeInfo;
            if (duration) segmentTimeInfo = app_parseByDuration(attributes);
            if (segmentTimeline) segmentTimeInfo = app_parseByTimeline(attributes, segmentTimeline);
            const segments = segmentTimeInfo.map(((segmentTime, index) => {
                if (segmentUrlMap[index]) {
                    const segment = segmentUrlMap[index];
                    const timescale = attributes.timescale || 1;
                    const presentationTimeOffset = attributes.presentationTimeOffset || 0;
                    segment.timeline = segmentTime.timeline;
                    segment.duration = segmentTime.duration;
                    segment.number = segmentTime.number;
                    segment.presentationTime = periodStart + (segmentTime.time - presentationTimeOffset) / timescale;
                    return segment;
                }
            })).filter((segment => segment));
            return segments;
        };
        const app_generateSegments = ({attributes, segmentInfo}) => {
            let segmentAttributes;
            let segmentsFn;
            if (segmentInfo.template) {
                segmentsFn = app_segmentsFromTemplate;
                segmentAttributes = app_merge(attributes, segmentInfo.template);
            } else if (segmentInfo.base) {
                segmentsFn = app_segmentsFromBase;
                segmentAttributes = app_merge(attributes, segmentInfo.base);
            } else if (segmentInfo.list) {
                segmentsFn = app_segmentsFromList;
                segmentAttributes = app_merge(attributes, segmentInfo.list);
            }
            const segmentsInfo = {
                attributes
            };
            if (!segmentsFn) return segmentsInfo;
            const segments = segmentsFn(segmentAttributes, segmentInfo.segmentTimeline);
            if (segmentAttributes.duration) {
                const {duration, timescale = 1} = segmentAttributes;
                segmentAttributes.duration = duration / timescale;
            } else if (segments.length) segmentAttributes.duration = segments.reduce(((max, segment) => Math.max(max, Math.ceil(segment.duration))), 0); else segmentAttributes.duration = 0;
            segmentsInfo.attributes = segmentAttributes;
            segmentsInfo.segments = segments;
            if (segmentInfo.base && segmentAttributes.indexRange) {
                segmentsInfo.sidx = segments[0];
                segmentsInfo.segments = [];
            }
            return segmentsInfo;
        };
        const app_toPlaylists = representations => representations.map(app_generateSegments);
        const app_findChildren = (element, name) => app_from(element.childNodes).filter((({tagName}) => tagName === name));
        const app_getContent = element => element.textContent.trim();
        const app_parseDivisionValue = value => parseFloat(value.split("/").reduce(((prev, current) => prev / current)));
        const app_parseDuration = str => {
            const SECONDS_IN_YEAR = 365 * 24 * 60 * 60;
            const SECONDS_IN_MONTH = 30 * 24 * 60 * 60;
            const SECONDS_IN_DAY = 24 * 60 * 60;
            const SECONDS_IN_HOUR = 60 * 60;
            const SECONDS_IN_MIN = 60;
            const durationRegex = /P(?:(\d*)Y)?(?:(\d*)M)?(?:(\d*)D)?(?:T(?:(\d*)H)?(?:(\d*)M)?(?:([\d.]*)S)?)?/;
            const match = durationRegex.exec(str);
            if (!match) return 0;
            const [year, month, day, hour, minute, second] = match.slice(1);
            return parseFloat(year || 0) * SECONDS_IN_YEAR + parseFloat(month || 0) * SECONDS_IN_MONTH + parseFloat(day || 0) * SECONDS_IN_DAY + parseFloat(hour || 0) * SECONDS_IN_HOUR + parseFloat(minute || 0) * SECONDS_IN_MIN + parseFloat(second || 0);
        };
        const app_parseDate = str => {
            const dateRegex = /^\d+-\d+-\d+T\d+:\d+:\d+(\.\d+)?$/;
            if (dateRegex.test(str)) str += "Z";
            return Date.parse(str);
        };
        const app_parsers = {
            mediaPresentationDuration(value) {
                return app_parseDuration(value);
            },
            availabilityStartTime(value) {
                return app_parseDate(value) / 1e3;
            },
            minimumUpdatePeriod(value) {
                return app_parseDuration(value);
            },
            suggestedPresentationDelay(value) {
                return app_parseDuration(value);
            },
            type(value) {
                return value;
            },
            timeShiftBufferDepth(value) {
                return app_parseDuration(value);
            },
            start(value) {
                return app_parseDuration(value);
            },
            width(value) {
                return parseInt(value, 10);
            },
            height(value) {
                return parseInt(value, 10);
            },
            bandwidth(value) {
                return parseInt(value, 10);
            },
            frameRate(value) {
                return app_parseDivisionValue(value);
            },
            startNumber(value) {
                return parseInt(value, 10);
            },
            timescale(value) {
                return parseInt(value, 10);
            },
            presentationTimeOffset(value) {
                return parseInt(value, 10);
            },
            duration(value) {
                const parsedValue = parseInt(value, 10);
                if (isNaN(parsedValue)) return app_parseDuration(value);
                return parsedValue;
            },
            d(value) {
                return parseInt(value, 10);
            },
            t(value) {
                return parseInt(value, 10);
            },
            r(value) {
                return parseInt(value, 10);
            },
            presentationTime(value) {
                return parseInt(value, 10);
            },
            DEFAULT(value) {
                return value;
            }
        };
        const app_mpd_parser_es_parseAttributes = el => {
            if (!(el && el.attributes)) return {};
            return app_from(el.attributes).reduce(((a, e) => {
                const parseFn = app_parsers[e.name] || app_parsers.DEFAULT;
                a[e.name] = parseFn(e.value);
                return a;
            }), {});
        };
        const app_keySystemsMap = {
            "urn:uuid:1077efec-c0b2-4d02-ace3-3c1e52e2fb4b": "org.w3.clearkey",
            "urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed": "com.widevine.alpha",
            "urn:uuid:9a04f079-9840-4286-ab92-e65be0885f95": "com.microsoft.playready",
            "urn:uuid:f239e769-efa3-4850-9c16-a903c6932efb": "com.adobe.primetime",
            "urn:mpeg:dash:mp4protection:2011": "mp4protection"
        };
        const app_buildBaseUrls = (references, baseUrlElements) => {
            if (!baseUrlElements.length) return references;
            return app_flatten(references.map((function(reference) {
                return baseUrlElements.map((function(baseUrlElement) {
                    const initialBaseUrl = app_getContent(baseUrlElement);
                    const resolvedBaseUrl = app_resolve_url(reference.baseUrl, initialBaseUrl);
                    const finalBaseUrl = app_merge(app_mpd_parser_es_parseAttributes(baseUrlElement), {
                        baseUrl: resolvedBaseUrl
                    });
                    if (resolvedBaseUrl !== initialBaseUrl && !finalBaseUrl.serviceLocation && reference.serviceLocation) finalBaseUrl.serviceLocation = reference.serviceLocation;
                    return finalBaseUrl;
                }));
            })));
        };
        const app_getSegmentInformation = adaptationSet => {
            const segmentTemplate = app_findChildren(adaptationSet, "SegmentTemplate")[0];
            const segmentList = app_findChildren(adaptationSet, "SegmentList")[0];
            const segmentUrls = segmentList && app_findChildren(segmentList, "SegmentURL").map((s => app_merge({
                tag: "SegmentURL"
            }, app_mpd_parser_es_parseAttributes(s))));
            const segmentBase = app_findChildren(adaptationSet, "SegmentBase")[0];
            const segmentTimelineParentNode = segmentList || segmentTemplate;
            const segmentTimeline = segmentTimelineParentNode && app_findChildren(segmentTimelineParentNode, "SegmentTimeline")[0];
            const segmentInitializationParentNode = segmentList || segmentBase || segmentTemplate;
            const segmentInitialization = segmentInitializationParentNode && app_findChildren(segmentInitializationParentNode, "Initialization")[0];
            const template = segmentTemplate && app_mpd_parser_es_parseAttributes(segmentTemplate);
            if (template && segmentInitialization) template.initialization = segmentInitialization && app_mpd_parser_es_parseAttributes(segmentInitialization); else if (template && template.initialization) template.initialization = {
                sourceURL: template.initialization
            };
            const segmentInfo = {
                template,
                segmentTimeline: segmentTimeline && app_findChildren(segmentTimeline, "S").map((s => app_mpd_parser_es_parseAttributes(s))),
                list: segmentList && app_merge(app_mpd_parser_es_parseAttributes(segmentList), {
                    segmentUrls,
                    initialization: app_mpd_parser_es_parseAttributes(segmentInitialization)
                }),
                base: segmentBase && app_merge(app_mpd_parser_es_parseAttributes(segmentBase), {
                    initialization: app_mpd_parser_es_parseAttributes(segmentInitialization)
                })
            };
            Object.keys(segmentInfo).forEach((key => {
                if (!segmentInfo[key]) delete segmentInfo[key];
            }));
            return segmentInfo;
        };
        const app_inheritBaseUrls = (adaptationSetAttributes, adaptationSetBaseUrls, adaptationSetSegmentInfo) => representation => {
            const repBaseUrlElements = app_findChildren(representation, "BaseURL");
            const repBaseUrls = app_buildBaseUrls(adaptationSetBaseUrls, repBaseUrlElements);
            const attributes = app_merge(adaptationSetAttributes, app_mpd_parser_es_parseAttributes(representation));
            const representationSegmentInfo = app_getSegmentInformation(representation);
            return repBaseUrls.map((baseUrl => ({
                segmentInfo: app_merge(adaptationSetSegmentInfo, representationSegmentInfo),
                attributes: app_merge(attributes, baseUrl)
            })));
        };
        const app_generateKeySystemInformation = contentProtectionNodes => contentProtectionNodes.reduce(((acc, node) => {
            const attributes = app_mpd_parser_es_parseAttributes(node);
            if (attributes.schemeIdUri) attributes.schemeIdUri = attributes.schemeIdUri.toLowerCase();
            const keySystem = app_keySystemsMap[attributes.schemeIdUri];
            if (keySystem) {
                acc[keySystem] = {
                    attributes
                };
                const psshNode = app_findChildren(node, "cenc:pssh")[0];
                if (psshNode) {
                    const pssh = app_getContent(psshNode);
                    acc[keySystem].pssh = pssh && app_decodeB64ToUint8Array(pssh);
                }
            }
            return acc;
        }), {});
        const app_parseCaptionServiceMetadata = service => {
            if (service.schemeIdUri === "urn:scte:dash:cc:cea-608:2015") {
                const values = typeof service.value !== "string" ? [] : service.value.split(";");
                return values.map((value => {
                    let channel;
                    let language;
                    language = value;
                    if (/^CC\d=/.test(value)) [channel, language] = value.split("="); else if (/^CC\d$/.test(value)) channel = value;
                    return {
                        channel,
                        language
                    };
                }));
            } else if (service.schemeIdUri === "urn:scte:dash:cc:cea-708:2015") {
                const values = typeof service.value !== "string" ? [] : service.value.split(";");
                return values.map((value => {
                    const flags = {
                        channel: void 0,
                        language: void 0,
                        aspectRatio: 1,
                        easyReader: 0,
                        "3D": 0
                    };
                    if (/=/.test(value)) {
                        const [channel, opts = ""] = value.split("=");
                        flags.channel = channel;
                        flags.language = value;
                        opts.split(",").forEach((opt => {
                            const [name, val] = opt.split(":");
                            if (name === "lang") flags.language = val; else if (name === "er") flags.easyReader = Number(val); else if (name === "war") flags.aspectRatio = Number(val); else if (name === "3D") flags["3D"] = Number(val);
                        }));
                    } else flags.language = value;
                    if (flags.channel) flags.channel = "SERVICE" + flags.channel;
                    return flags;
                }));
            }
        };
        const app_toEventStream = period => app_flatten(app_findChildren(period.node, "EventStream").map((eventStream => {
            const eventStreamAttributes = app_mpd_parser_es_parseAttributes(eventStream);
            const schemeIdUri = eventStreamAttributes.schemeIdUri;
            return app_findChildren(eventStream, "Event").map((event => {
                const eventAttributes = app_mpd_parser_es_parseAttributes(event);
                const presentationTime = eventAttributes.presentationTime || 0;
                const timescale = eventStreamAttributes.timescale || 1;
                const duration = eventAttributes.duration || 0;
                const start = presentationTime / timescale + period.attributes.start;
                return {
                    schemeIdUri,
                    value: eventStreamAttributes.value,
                    id: eventAttributes.id,
                    start,
                    end: start + duration / timescale,
                    messageData: app_getContent(event) || eventAttributes.messageData,
                    contentEncoding: eventStreamAttributes.contentEncoding,
                    presentationTimeOffset: eventStreamAttributes.presentationTimeOffset || 0
                };
            }));
        })));
        const app_toRepresentations = (periodAttributes, periodBaseUrls, periodSegmentInfo) => adaptationSet => {
            const adaptationSetAttributes = app_mpd_parser_es_parseAttributes(adaptationSet);
            const adaptationSetBaseUrls = app_buildBaseUrls(periodBaseUrls, app_findChildren(adaptationSet, "BaseURL"));
            const role = app_findChildren(adaptationSet, "Role")[0];
            const roleAttributes = {
                role: app_mpd_parser_es_parseAttributes(role)
            };
            let attrs = app_merge(periodAttributes, adaptationSetAttributes, roleAttributes);
            const accessibility = app_findChildren(adaptationSet, "Accessibility")[0];
            const captionServices = app_parseCaptionServiceMetadata(app_mpd_parser_es_parseAttributes(accessibility));
            if (captionServices) attrs = app_merge(attrs, {
                captionServices
            });
            const label = app_findChildren(adaptationSet, "Label")[0];
            if (label && label.childNodes.length) {
                const labelVal = label.childNodes[0].nodeValue.trim();
                attrs = app_merge(attrs, {
                    label: labelVal
                });
            }
            const contentProtection = app_generateKeySystemInformation(app_findChildren(adaptationSet, "ContentProtection"));
            if (Object.keys(contentProtection).length) attrs = app_merge(attrs, {
                contentProtection
            });
            const segmentInfo = app_getSegmentInformation(adaptationSet);
            const representations = app_findChildren(adaptationSet, "Representation");
            const adaptationSetSegmentInfo = app_merge(periodSegmentInfo, segmentInfo);
            return app_flatten(representations.map(app_inheritBaseUrls(attrs, adaptationSetBaseUrls, adaptationSetSegmentInfo)));
        };
        const app_toAdaptationSets = (mpdAttributes, mpdBaseUrls) => (period, index) => {
            const periodBaseUrls = app_buildBaseUrls(mpdBaseUrls, app_findChildren(period.node, "BaseURL"));
            const periodAttributes = app_merge(mpdAttributes, {
                periodStart: period.attributes.start
            });
            if (typeof period.attributes.duration === "number") periodAttributes.periodDuration = period.attributes.duration;
            const adaptationSets = app_findChildren(period.node, "AdaptationSet");
            const periodSegmentInfo = app_getSegmentInformation(period.node);
            return app_flatten(adaptationSets.map(app_toRepresentations(periodAttributes, periodBaseUrls, periodSegmentInfo)));
        };
        const app_generateContentSteeringInformation = (contentSteeringNodes, eventHandler) => {
            if (contentSteeringNodes.length > 1) eventHandler({
                type: "warn",
                message: "The MPD manifest should contain no more than one ContentSteering tag"
            });
            if (!contentSteeringNodes.length) return null;
            const infoFromContentSteeringTag = app_merge({
                serverURL: app_getContent(contentSteeringNodes[0])
            }, app_mpd_parser_es_parseAttributes(contentSteeringNodes[0]));
            infoFromContentSteeringTag.queryBeforeStart = infoFromContentSteeringTag.queryBeforeStart === "true";
            return infoFromContentSteeringTag;
        };
        const app_getPeriodStart = ({attributes, priorPeriodAttributes, mpdType}) => {
            if (typeof attributes.start === "number") return attributes.start;
            if (priorPeriodAttributes && typeof priorPeriodAttributes.start === "number" && typeof priorPeriodAttributes.duration === "number") return priorPeriodAttributes.start + priorPeriodAttributes.duration;
            if (!priorPeriodAttributes && mpdType === "static") return 0;
            return null;
        };
        const app_inheritAttributes = (mpd, options = {}) => {
            const {manifestUri = "", NOW = Date.now(), clientOffset = 0, eventHandler = function() {}} = options;
            const periodNodes = app_findChildren(mpd, "Period");
            if (!periodNodes.length) throw new Error(app_errors.INVALID_NUMBER_OF_PERIOD);
            const locations = app_findChildren(mpd, "Location");
            const mpdAttributes = app_mpd_parser_es_parseAttributes(mpd);
            const mpdBaseUrls = app_buildBaseUrls([ {
                baseUrl: manifestUri
            } ], app_findChildren(mpd, "BaseURL"));
            const contentSteeringNodes = app_findChildren(mpd, "ContentSteering");
            mpdAttributes.type = mpdAttributes.type || "static";
            mpdAttributes.sourceDuration = mpdAttributes.mediaPresentationDuration || 0;
            mpdAttributes.NOW = NOW;
            mpdAttributes.clientOffset = clientOffset;
            if (locations.length) mpdAttributes.locations = locations.map(app_getContent);
            const periods = [];
            periodNodes.forEach(((node, index) => {
                const attributes = app_mpd_parser_es_parseAttributes(node);
                const priorPeriod = periods[index - 1];
                attributes.start = app_getPeriodStart({
                    attributes,
                    priorPeriodAttributes: priorPeriod ? priorPeriod.attributes : null,
                    mpdType: mpdAttributes.type
                });
                periods.push({
                    node,
                    attributes
                });
            }));
            return {
                locations: mpdAttributes.locations,
                contentSteeringInfo: app_generateContentSteeringInformation(contentSteeringNodes, eventHandler),
                representationInfo: app_flatten(periods.map(app_toAdaptationSets(mpdAttributes, mpdBaseUrls))),
                eventStream: app_flatten(periods.map(app_toEventStream))
            };
        };
        const app_stringToMpdXml = manifestString => {
            if (manifestString === "") throw new Error(app_errors.DASH_EMPTY_MANIFEST);
            const parser = new app_xmldom_lib.DOMParser;
            let xml;
            let mpd;
            try {
                xml = parser.parseFromString(manifestString, "application/xml");
                mpd = xml && xml.documentElement.tagName === "MPD" ? xml.documentElement : null;
            } catch (e) {}
            if (!mpd || mpd && mpd.getElementsByTagName("parsererror").length > 0) throw new Error(app_errors.DASH_INVALID_XML);
            return mpd;
        };
        const app_parseUTCTimingScheme = mpd => {
            const UTCTimingNode = app_findChildren(mpd, "UTCTiming")[0];
            if (!UTCTimingNode) return null;
            const attributes = app_mpd_parser_es_parseAttributes(UTCTimingNode);
            switch (attributes.schemeIdUri) {
              case "urn:mpeg:dash:utc:http-head:2014":
              case "urn:mpeg:dash:utc:http-head:2012":
                attributes.method = "HEAD";
                break;

              case "urn:mpeg:dash:utc:http-xsdate:2014":
              case "urn:mpeg:dash:utc:http-iso:2014":
              case "urn:mpeg:dash:utc:http-xsdate:2012":
              case "urn:mpeg:dash:utc:http-iso:2012":
                attributes.method = "GET";
                break;

              case "urn:mpeg:dash:utc:direct:2014":
              case "urn:mpeg:dash:utc:direct:2012":
                attributes.method = "DIRECT";
                attributes.value = Date.parse(attributes.value);
                break;

              case "urn:mpeg:dash:utc:http-ntp:2014":
              case "urn:mpeg:dash:utc:ntp:2014":
              case "urn:mpeg:dash:utc:sntp:2014":
              default:
                throw new Error(app_errors.UNSUPPORTED_UTC_TIMING_SCHEME);
            }
            return attributes;
        };
        const app_parse = (manifestString, options = {}) => {
            const parsedManifestInfo = app_inheritAttributes(app_stringToMpdXml(manifestString), options);
            const playlists = app_toPlaylists(parsedManifestInfo.representationInfo);
            return app_toM3u8({
                dashPlaylists: playlists,
                locations: parsedManifestInfo.locations,
                contentSteering: parsedManifestInfo.contentSteeringInfo,
                sidxMapping: options.sidxMapping,
                previousManifest: options.previousManifest,
                eventStream: parsedManifestInfo.eventStream
            });
        };
        const app_parseUTCTiming = manifestString => app_parseUTCTimingScheme(app_stringToMpdXml(manifestString));
        var app_parse_sidx = __webpack_require__(962);
        var app_parse_sidx_default = __webpack_require__.n(app_parse_sidx);
        var app_ID3 = app_byte_helpers_toUint8([ 73, 68, 51 ]);
        var app_getId3Size = function getId3Size(bytes, offset) {
            if (offset === void 0) offset = 0;
            bytes = app_byte_helpers_toUint8(bytes);
            var flags = bytes[offset + 5];
            var returnSize = bytes[offset + 6] << 21 | bytes[offset + 7] << 14 | bytes[offset + 8] << 7 | bytes[offset + 9];
            var footerPresent = (flags & 16) >> 4;
            if (footerPresent) return returnSize + 20;
            return returnSize + 10;
        };
        var app_getId3Offset = function getId3Offset(bytes, offset) {
            if (offset === void 0) offset = 0;
            bytes = app_byte_helpers_toUint8(bytes);
            if (bytes.length - offset < 10 || !app_byte_helpers_bytesMatch(bytes, app_ID3, {
                offset
            })) return offset;
            offset += app_getId3Size(bytes, offset);
            return getId3Offset(bytes, offset);
        };
        new Uint8Array([ 79, 112, 117, 115, 72, 101, 97, 100 ]);
        var app_normalizePath = function normalizePath(path) {
            if (typeof path === "string") return app_stringToBytes(path);
            if (typeof path === "number") return path;
            return path;
        };
        var app_normalizePaths = function normalizePaths(paths) {
            if (!Array.isArray(paths)) return [ app_normalizePath(paths) ];
            return paths.map((function(p) {
                return app_normalizePath(p);
            }));
        };
        var app_DESCRIPTORS;
        var app_parseDescriptors = function parseDescriptors(bytes) {
            bytes = app_byte_helpers_toUint8(bytes);
            var results = [];
            var i = 0;
            while (bytes.length > i) {
                var tag = bytes[i];
                var size = 0;
                var headerSize = 0;
                headerSize++;
                var byte = bytes[headerSize];
                headerSize++;
                while (byte & 128) {
                    size = (byte & 127) << 7;
                    byte = bytes[headerSize];
                    headerSize++;
                }
                size += byte & 127;
                for (var z = 0; z < app_DESCRIPTORS.length; z++) {
                    var _DESCRIPTORS$z = app_DESCRIPTORS[z], id = _DESCRIPTORS$z.id, parser = _DESCRIPTORS$z.parser;
                    if (tag === id) {
                        results.push(parser(bytes.subarray(headerSize, headerSize + size)));
                        break;
                    }
                }
                i += size + headerSize;
            }
            return results;
        };
        app_DESCRIPTORS = [ {
            id: 3,
            parser: function parser(bytes) {
                var desc = {
                    tag: 3,
                    id: bytes[0] << 8 | bytes[1],
                    flags: bytes[2],
                    size: 3,
                    dependsOnEsId: 0,
                    ocrEsId: 0,
                    descriptors: [],
                    url: ""
                };
                if (desc.flags & 128) {
                    desc.dependsOnEsId = bytes[desc.size] << 8 | bytes[desc.size + 1];
                    desc.size += 2;
                }
                if (desc.flags & 64) {
                    var len = bytes[desc.size];
                    desc.url = app_byte_helpers_bytesToString(bytes.subarray(desc.size + 1, desc.size + 1 + len));
                    desc.size += len;
                }
                if (desc.flags & 32) {
                    desc.ocrEsId = bytes[desc.size] << 8 | bytes[desc.size + 1];
                    desc.size += 2;
                }
                desc.descriptors = app_parseDescriptors(bytes.subarray(desc.size)) || [];
                return desc;
            }
        }, {
            id: 4,
            parser: function parser(bytes) {
                var desc = {
                    tag: 4,
                    oti: bytes[0],
                    streamType: bytes[1],
                    bufferSize: bytes[2] << 16 | bytes[3] << 8 | bytes[4],
                    maxBitrate: bytes[5] << 24 | bytes[6] << 16 | bytes[7] << 8 | bytes[8],
                    avgBitrate: bytes[9] << 24 | bytes[10] << 16 | bytes[11] << 8 | bytes[12],
                    descriptors: app_parseDescriptors(bytes.subarray(13))
                };
                return desc;
            }
        }, {
            id: 5,
            parser: function parser(bytes) {
                return {
                    tag: 5,
                    bytes
                };
            }
        }, {
            id: 6,
            parser: function parser(bytes) {
                return {
                    tag: 6,
                    bytes
                };
            }
        } ];
        var app_findBox = function findBox(bytes, paths, complete) {
            if (complete === void 0) complete = false;
            paths = app_normalizePaths(paths);
            bytes = app_byte_helpers_toUint8(bytes);
            var results = [];
            if (!paths.length) return results;
            var i = 0;
            while (i < bytes.length) {
                var size = (bytes[i] << 24 | bytes[i + 1] << 16 | bytes[i + 2] << 8 | bytes[i + 3]) >>> 0;
                var type = bytes.subarray(i + 4, i + 8);
                if (size === 0) break;
                var end = i + size;
                if (end > bytes.length) {
                    if (complete) break;
                    end = bytes.length;
                }
                var data = bytes.subarray(i + 8, end);
                if (app_byte_helpers_bytesMatch(type, paths[0])) if (paths.length === 1) results.push(data); else results.push.apply(results, findBox(data, paths.slice(1), complete));
                i = end;
            }
            return results;
        };
        var app_EBML_TAGS = {
            EBML: app_byte_helpers_toUint8([ 26, 69, 223, 163 ]),
            DocType: app_byte_helpers_toUint8([ 66, 130 ]),
            Segment: app_byte_helpers_toUint8([ 24, 83, 128, 103 ]),
            SegmentInfo: app_byte_helpers_toUint8([ 21, 73, 169, 102 ]),
            Tracks: app_byte_helpers_toUint8([ 22, 84, 174, 107 ]),
            Track: app_byte_helpers_toUint8([ 174 ]),
            TrackNumber: app_byte_helpers_toUint8([ 215 ]),
            DefaultDuration: app_byte_helpers_toUint8([ 35, 227, 131 ]),
            TrackEntry: app_byte_helpers_toUint8([ 174 ]),
            TrackType: app_byte_helpers_toUint8([ 131 ]),
            FlagDefault: app_byte_helpers_toUint8([ 136 ]),
            CodecID: app_byte_helpers_toUint8([ 134 ]),
            CodecPrivate: app_byte_helpers_toUint8([ 99, 162 ]),
            VideoTrack: app_byte_helpers_toUint8([ 224 ]),
            AudioTrack: app_byte_helpers_toUint8([ 225 ]),
            Cluster: app_byte_helpers_toUint8([ 31, 67, 182, 117 ]),
            Timestamp: app_byte_helpers_toUint8([ 231 ]),
            TimestampScale: app_byte_helpers_toUint8([ 42, 215, 177 ]),
            BlockGroup: app_byte_helpers_toUint8([ 160 ]),
            BlockDuration: app_byte_helpers_toUint8([ 155 ]),
            Block: app_byte_helpers_toUint8([ 161 ]),
            SimpleBlock: app_byte_helpers_toUint8([ 163 ])
        };
        var app_LENGTH_TABLE = [ 128, 64, 32, 16, 8, 4, 2, 1 ];
        var app_getLength = function getLength(byte) {
            var len = 1;
            for (var i = 0; i < app_LENGTH_TABLE.length; i++) {
                if (byte & app_LENGTH_TABLE[i]) break;
                len++;
            }
            return len;
        };
        var app_getvint = function getvint(bytes, offset, removeLength, signed) {
            if (removeLength === void 0) removeLength = true;
            if (signed === void 0) signed = false;
            var length = app_getLength(bytes[offset]);
            var valueBytes = bytes.subarray(offset, offset + length);
            if (removeLength) {
                valueBytes = Array.prototype.slice.call(bytes, offset, offset + length);
                valueBytes[0] ^= app_LENGTH_TABLE[length - 1];
            }
            return {
                length,
                value: app_byte_helpers_bytesToNumber(valueBytes, {
                    signed
                }),
                bytes: valueBytes
            };
        };
        var app_ebml_helpers_normalizePath = function normalizePath(path) {
            if (typeof path === "string") return path.match(/.{1,2}/g).map((function(p) {
                return normalizePath(p);
            }));
            if (typeof path === "number") return app_numberToBytes(path);
            return path;
        };
        var app_ebml_helpers_normalizePaths = function normalizePaths(paths) {
            if (!Array.isArray(paths)) return [ app_ebml_helpers_normalizePath(paths) ];
            return paths.map((function(p) {
                return app_ebml_helpers_normalizePath(p);
            }));
        };
        var app_getInfinityDataSize = function getInfinityDataSize(id, bytes, offset) {
            if (offset >= bytes.length) return bytes.length;
            var innerid = app_getvint(bytes, offset, false);
            if (app_byte_helpers_bytesMatch(id.bytes, innerid.bytes)) return offset;
            var dataHeader = app_getvint(bytes, offset + innerid.length);
            return getInfinityDataSize(id, bytes, offset + dataHeader.length + dataHeader.value + innerid.length);
        };
        var app_findEbml = function findEbml(bytes, paths) {
            paths = app_ebml_helpers_normalizePaths(paths);
            bytes = app_byte_helpers_toUint8(bytes);
            var results = [];
            if (!paths.length) return results;
            var i = 0;
            while (i < bytes.length) {
                var id = app_getvint(bytes, i, false);
                var dataHeader = app_getvint(bytes, i + id.length);
                var dataStart = i + id.length + dataHeader.length;
                if (dataHeader.value === 127) {
                    dataHeader.value = app_getInfinityDataSize(id, bytes, dataStart);
                    if (dataHeader.value !== bytes.length) dataHeader.value -= dataStart;
                }
                var dataEnd = dataStart + dataHeader.value > bytes.length ? bytes.length : dataStart + dataHeader.value;
                var data = bytes.subarray(dataStart, dataEnd);
                if (app_byte_helpers_bytesMatch(paths[0], id.bytes)) if (paths.length === 1) results.push(data); else results = results.concat(findEbml(data, paths.slice(1)));
                var totalLength = id.length + dataHeader.length + data.length;
                i += totalLength;
            }
            return results;
        };
        var app_NAL_TYPE_ONE = app_byte_helpers_toUint8([ 0, 0, 0, 1 ]);
        var app_NAL_TYPE_TWO = app_byte_helpers_toUint8([ 0, 0, 1 ]);
        var app_EMULATION_PREVENTION = app_byte_helpers_toUint8([ 0, 0, 3 ]);
        var app_discardEmulationPreventionBytes = function discardEmulationPreventionBytes(bytes) {
            var positions = [];
            var i = 1;
            while (i < bytes.length - 2) {
                if (app_byte_helpers_bytesMatch(bytes.subarray(i, i + 3), app_EMULATION_PREVENTION)) {
                    positions.push(i + 2);
                    i++;
                }
                i++;
            }
            if (positions.length === 0) return bytes;
            var newLength = bytes.length - positions.length;
            var newData = new Uint8Array(newLength);
            var sourceIndex = 0;
            for (i = 0; i < newLength; sourceIndex++, i++) {
                if (sourceIndex === positions[0]) {
                    sourceIndex++;
                    positions.shift();
                }
                newData[i] = bytes[sourceIndex];
            }
            return newData;
        };
        var app_findNal = function findNal(bytes, dataType, types, nalLimit) {
            if (nalLimit === void 0) nalLimit = 1 / 0;
            bytes = app_byte_helpers_toUint8(bytes);
            types = [].concat(types);
            var i = 0;
            var nalStart;
            var nalsFound = 0;
            while (i < bytes.length && (nalsFound < nalLimit || nalStart)) {
                var nalOffset = void 0;
                if (app_byte_helpers_bytesMatch(bytes.subarray(i), app_NAL_TYPE_ONE)) nalOffset = 4; else if (app_byte_helpers_bytesMatch(bytes.subarray(i), app_NAL_TYPE_TWO)) nalOffset = 3;
                if (!nalOffset) {
                    i++;
                    continue;
                }
                nalsFound++;
                if (nalStart) return app_discardEmulationPreventionBytes(bytes.subarray(nalStart, i));
                var nalType = void 0;
                if (dataType === "h264") nalType = bytes[i + nalOffset] & 31; else if (dataType === "h265") nalType = bytes[i + nalOffset] >> 1 & 63;
                if (types.indexOf(nalType) !== -1) nalStart = i + nalOffset;
                i += nalOffset + (dataType === "h264" ? 1 : 2);
            }
            return bytes.subarray(0, 0);
        };
        var app_findH264Nal = function findH264Nal(bytes, type, nalLimit) {
            return app_findNal(bytes, "h264", type, nalLimit);
        };
        var app_findH265Nal = function findH265Nal(bytes, type, nalLimit) {
            return app_findNal(bytes, "h265", type, nalLimit);
        };
        var app_CONSTANTS = {
            webm: app_byte_helpers_toUint8([ 119, 101, 98, 109 ]),
            matroska: app_byte_helpers_toUint8([ 109, 97, 116, 114, 111, 115, 107, 97 ]),
            flac: app_byte_helpers_toUint8([ 102, 76, 97, 67 ]),
            ogg: app_byte_helpers_toUint8([ 79, 103, 103, 83 ]),
            ac3: app_byte_helpers_toUint8([ 11, 119 ]),
            riff: app_byte_helpers_toUint8([ 82, 73, 70, 70 ]),
            avi: app_byte_helpers_toUint8([ 65, 86, 73 ]),
            wav: app_byte_helpers_toUint8([ 87, 65, 86, 69 ]),
            "3gp": app_byte_helpers_toUint8([ 102, 116, 121, 112, 51, 103 ]),
            mp4: app_byte_helpers_toUint8([ 102, 116, 121, 112 ]),
            fmp4: app_byte_helpers_toUint8([ 115, 116, 121, 112 ]),
            mov: app_byte_helpers_toUint8([ 102, 116, 121, 112, 113, 116 ]),
            moov: app_byte_helpers_toUint8([ 109, 111, 111, 118 ]),
            moof: app_byte_helpers_toUint8([ 109, 111, 111, 102 ])
        };
        var app_isLikely = {
            aac: function aac(bytes) {
                var offset = app_getId3Offset(bytes);
                return app_byte_helpers_bytesMatch(bytes, [ 255, 16 ], {
                    offset,
                    mask: [ 255, 22 ]
                });
            },
            mp3: function mp3(bytes) {
                var offset = app_getId3Offset(bytes);
                return app_byte_helpers_bytesMatch(bytes, [ 255, 2 ], {
                    offset,
                    mask: [ 255, 6 ]
                });
            },
            webm: function webm(bytes) {
                var docType = app_findEbml(bytes, [ app_EBML_TAGS.EBML, app_EBML_TAGS.DocType ])[0];
                return app_byte_helpers_bytesMatch(docType, app_CONSTANTS.webm);
            },
            mkv: function mkv(bytes) {
                var docType = app_findEbml(bytes, [ app_EBML_TAGS.EBML, app_EBML_TAGS.DocType ])[0];
                return app_byte_helpers_bytesMatch(docType, app_CONSTANTS.matroska);
            },
            mp4: function mp4(bytes) {
                if (app_isLikely["3gp"](bytes) || app_isLikely.mov(bytes)) return false;
                if (app_byte_helpers_bytesMatch(bytes, app_CONSTANTS.mp4, {
                    offset: 4
                }) || app_byte_helpers_bytesMatch(bytes, app_CONSTANTS.fmp4, {
                    offset: 4
                })) return true;
                if (app_byte_helpers_bytesMatch(bytes, app_CONSTANTS.moof, {
                    offset: 4
                }) || app_byte_helpers_bytesMatch(bytes, app_CONSTANTS.moov, {
                    offset: 4
                })) return true;
            },
            mov: function mov(bytes) {
                return app_byte_helpers_bytesMatch(bytes, app_CONSTANTS.mov, {
                    offset: 4
                });
            },
            "3gp": function gp(bytes) {
                return app_byte_helpers_bytesMatch(bytes, app_CONSTANTS["3gp"], {
                    offset: 4
                });
            },
            ac3: function ac3(bytes) {
                var offset = app_getId3Offset(bytes);
                return app_byte_helpers_bytesMatch(bytes, app_CONSTANTS.ac3, {
                    offset
                });
            },
            ts: function ts(bytes) {
                if (bytes.length < 189 && bytes.length >= 1) return bytes[0] === 71;
                var i = 0;
                while (i + 188 < bytes.length && i < 188) {
                    if (bytes[i] === 71 && bytes[i + 188] === 71) return true;
                    i += 1;
                }
                return false;
            },
            flac: function flac(bytes) {
                var offset = app_getId3Offset(bytes);
                return app_byte_helpers_bytesMatch(bytes, app_CONSTANTS.flac, {
                    offset
                });
            },
            ogg: function ogg(bytes) {
                return app_byte_helpers_bytesMatch(bytes, app_CONSTANTS.ogg);
            },
            avi: function avi(bytes) {
                return app_byte_helpers_bytesMatch(bytes, app_CONSTANTS.riff) && app_byte_helpers_bytesMatch(bytes, app_CONSTANTS.avi, {
                    offset: 8
                });
            },
            wav: function wav(bytes) {
                return app_byte_helpers_bytesMatch(bytes, app_CONSTANTS.riff) && app_byte_helpers_bytesMatch(bytes, app_CONSTANTS.wav, {
                    offset: 8
                });
            },
            h264: function h264(bytes) {
                return app_findH264Nal(bytes, 7, 3).length;
            },
            h265: function h265(bytes) {
                return app_findH265Nal(bytes, [ 32, 33 ], 3).length;
            }
        };
        var app_isLikelyTypes = Object.keys(app_isLikely).filter((function(t) {
            return t !== "ts" && t !== "h264" && t !== "h265";
        })).concat([ "ts", "h264", "h265" ]);
        app_isLikelyTypes.forEach((function(type) {
            var isLikelyFn = app_isLikely[type];
            app_isLikely[type] = function(bytes) {
                return isLikelyFn(app_byte_helpers_toUint8(bytes));
            };
        }));
        var js_app_isLikely = app_isLikely;
        var app_detectContainerForBytes = function detectContainerForBytes(bytes) {
            bytes = app_byte_helpers_toUint8(bytes);
            for (var i = 0; i < app_isLikelyTypes.length; i++) {
                var type = app_isLikelyTypes[i];
                if (js_app_isLikely[type](bytes)) return type;
            }
            return "";
        };
        var app_isLikelyFmp4MediaSegment = function isLikelyFmp4MediaSegment(bytes) {
            return app_findBox(bytes, [ "moof" ]).length > 0;
        };
        var app_clock = __webpack_require__(622);
        /**
 * @license
 * Video.js 8.21.0 <http://videojs.com/>
 * Copyright Brightcove, Inc. <https://www.brightcove.com/>
 * Available under Apache License Version 2.0
 * <https://github.com/videojs/video.js/blob/main/LICENSE>
 *
 * Includes vtt.js <https://github.com/mozilla/vtt.js>
 * Available under Apache License Version 2.0
 * <https://github.com/mozilla/vtt.js/blob/main/LICENSE>
 */
        var app_version$6 = "8.21.0";
        const app_hooks_ = {};
        const app_hooks = function(type, fn) {
            app_hooks_[type] = app_hooks_[type] || [];
            if (fn) app_hooks_[type] = app_hooks_[type].concat(fn);
            return app_hooks_[type];
        };
        const app_hook = function(type, fn) {
            app_hooks(type, fn);
        };
        const app_removeHook = function(type, fn) {
            const index = app_hooks(type).indexOf(fn);
            if (index <= -1) return false;
            app_hooks_[type] = app_hooks_[type].slice();
            app_hooks_[type].splice(index, 1);
            return true;
        };
        const app_hookOnce = function(type, fn) {
            app_hooks(type, [].concat(fn).map((original => {
                const wrapper = (...args) => {
                    app_removeHook(type, wrapper);
                    return original(...args);
                };
                return wrapper;
            })));
        };
        const app_FullscreenApi = {
            prefixed: true
        };
        const app_apiMap = [ [ "requestFullscreen", "exitFullscreen", "fullscreenElement", "fullscreenEnabled", "fullscreenchange", "fullscreenerror", "fullscreen" ], [ "webkitRequestFullscreen", "webkitExitFullscreen", "webkitFullscreenElement", "webkitFullscreenEnabled", "webkitfullscreenchange", "webkitfullscreenerror", "-webkit-full-screen" ] ];
        const app_specApi = app_apiMap[0];
        let app_browserApi;
        for (let i = 0; i < app_apiMap.length; i++) if (app_apiMap[i][1] in app_document_default()) {
            app_browserApi = app_apiMap[i];
            break;
        }
        if (app_browserApi) {
            for (let i = 0; i < app_browserApi.length; i++) app_FullscreenApi[app_specApi[i]] = app_browserApi[i];
            app_FullscreenApi.prefixed = app_browserApi[0] !== app_specApi[0];
        }
        let app_video_es_history = [];
        const app_LogByTypeFactory = (name, log, styles) => (type, level, args) => {
            const lvl = log.levels[level];
            const lvlRegExp = new RegExp(`^(${lvl})$`);
            let resultName = name;
            if (type !== "log") args.unshift(type.toUpperCase() + ":");
            if (styles) {
                resultName = `%c${name}`;
                args.unshift(styles);
            }
            args.unshift(resultName + ":");
            if (app_video_es_history) {
                app_video_es_history.push([].concat(args));
                const splice = app_video_es_history.length - 1e3;
                app_video_es_history.splice(0, splice > 0 ? splice : 0);
            }
            if (!app_window_default().console) return;
            let fn = app_window_default().console[type];
            if (!fn && type === "debug") fn = app_window_default().console.info || app_window_default().console.log;
            if (!fn || !lvl || !lvlRegExp.test(type)) return;
            fn[Array.isArray(args) ? "apply" : "call"](app_window_default().console, args);
        };
        function app_createLogger$1(name, delimiter = ":", styles = "") {
            let level = "info";
            let logByType;
            function log(...args) {
                logByType("log", level, args);
            }
            logByType = app_LogByTypeFactory(name, log, styles);
            log.createLogger = (subName, subDelimiter, subStyles) => {
                const resultDelimiter = subDelimiter !== void 0 ? subDelimiter : delimiter;
                const resultStyles = subStyles !== void 0 ? subStyles : styles;
                const resultName = `${name} ${resultDelimiter} ${subName}`;
                return app_createLogger$1(resultName, resultDelimiter, resultStyles);
            };
            log.createNewLogger = (newName, newDelimiter, newStyles) => app_createLogger$1(newName, newDelimiter, newStyles);
            log.levels = {
                all: "debug|log|warn|error",
                off: "",
                debug: "debug|log|warn|error",
                info: "log|warn|error",
                warn: "warn|error",
                error: "error",
                DEFAULT: level
            };
            log.level = lvl => {
                if (typeof lvl === "string") {
                    if (!log.levels.hasOwnProperty(lvl)) throw new Error(`"${lvl}" in not a valid log level`);
                    level = lvl;
                }
                return level;
            };
            log.history = () => app_video_es_history ? [].concat(app_video_es_history) : [];
            log.history.filter = fname => (app_video_es_history || []).filter((historyItem => new RegExp(`.*${fname}.*`).test(historyItem[0])));
            log.history.clear = () => {
                if (app_video_es_history) app_video_es_history.length = 0;
            };
            log.history.disable = () => {
                if (app_video_es_history !== null) {
                    app_video_es_history.length = 0;
                    app_video_es_history = null;
                }
            };
            log.history.enable = () => {
                if (app_video_es_history === null) app_video_es_history = [];
            };
            log.error = (...args) => logByType("error", level, args);
            log.warn = (...args) => logByType("warn", level, args);
            log.debug = (...args) => logByType("debug", level, args);
            return log;
        }
        const app_log$1 = app_createLogger$1("VIDEOJS");
        const app_createLogger = app_log$1.createLogger;
        const app_video_es_toString = Object.prototype.toString;
        const app_keys = function(object) {
            return app_video_es_isObject(object) ? Object.keys(object) : [];
        };
        function app_each(object, fn) {
            app_keys(object).forEach((key => fn(object[key], key)));
        }
        function app_reduce(object, fn, initial = 0) {
            return app_keys(object).reduce(((accum, key) => fn(accum, object[key], key)), initial);
        }
        function app_video_es_isObject(value) {
            return !!value && typeof value === "object";
        }
        function app_isPlain(value) {
            return app_video_es_isObject(value) && app_video_es_toString.call(value) === "[object Object]" && value.constructor === Object;
        }
        function app_merge$1(...sources) {
            const result = {};
            sources.forEach((source => {
                if (!source) return;
                app_each(source, ((value, key) => {
                    if (!app_isPlain(value)) {
                        result[key] = value;
                        return;
                    }
                    if (!app_isPlain(result[key])) result[key] = {};
                    result[key] = app_merge$1(result[key], value);
                }));
            }));
            return result;
        }
        function app_video_es_values(source = {}) {
            const result = [];
            for (const key in source) if (source.hasOwnProperty(key)) {
                const value = source[key];
                result.push(value);
            }
            return result;
        }
        function app_defineLazyProperty(obj, key, getValue, setter = true) {
            const set = value => Object.defineProperty(obj, key, {
                value,
                enumerable: true,
                writable: true
            });
            const options = {
                configurable: true,
                enumerable: true,
                get() {
                    const value = getValue();
                    set(value);
                    return value;
                }
            };
            if (setter) options.set = set;
            return Object.defineProperty(obj, key, options);
        }
        var app_Obj = Object.freeze({
            __proto__: null,
            each: app_each,
            reduce: app_reduce,
            isObject: app_video_es_isObject,
            isPlain: app_isPlain,
            merge: app_merge$1,
            values: app_video_es_values,
            defineLazyProperty: app_defineLazyProperty
        });
        let app_IS_IPOD = false;
        let app_IOS_VERSION = null;
        let app_IS_ANDROID = false;
        let app_ANDROID_VERSION;
        let app_IS_FIREFOX = false;
        let app_IS_EDGE = false;
        let app_IS_CHROMIUM = false;
        let app_IS_CHROME = false;
        let app_CHROMIUM_VERSION = null;
        let app_CHROME_VERSION = null;
        const app_IS_CHROMECAST_RECEIVER = Boolean(app_window_default().cast && app_window_default().cast.framework && app_window_default().cast.framework.CastReceiverContext);
        let app_IE_VERSION = null;
        let app_IS_SAFARI = false;
        let app_IS_WINDOWS = false;
        let app_IS_IPAD = false;
        let app_IS_IPHONE = false;
        let app_IS_TIZEN = false;
        let app_IS_WEBOS = false;
        let app_IS_SMART_TV = false;
        const app_TOUCH_ENABLED = Boolean(app_isReal() && ("ontouchstart" in app_window_default() || app_window_default().navigator.maxTouchPoints || app_window_default().DocumentTouch && app_window_default().document instanceof app_window_default().DocumentTouch));
        const app_UAD = app_window_default().navigator && app_window_default().navigator.userAgentData;
        if (app_UAD && app_UAD.platform && app_UAD.brands) {
            app_IS_ANDROID = app_UAD.platform === "Android";
            app_IS_EDGE = Boolean(app_UAD.brands.find((b => b.brand === "Microsoft Edge")));
            app_IS_CHROMIUM = Boolean(app_UAD.brands.find((b => b.brand === "Chromium")));
            app_IS_CHROME = !app_IS_EDGE && app_IS_CHROMIUM;
            app_CHROMIUM_VERSION = app_CHROME_VERSION = (app_UAD.brands.find((b => b.brand === "Chromium")) || {}).version || null;
            app_IS_WINDOWS = app_UAD.platform === "Windows";
        }
        if (!app_IS_CHROMIUM) {
            const USER_AGENT = app_window_default().navigator && app_window_default().navigator.userAgent || "";
            app_IS_IPOD = /iPod/i.test(USER_AGENT);
            app_IOS_VERSION = function() {
                const match = USER_AGENT.match(/OS (\d+)_/i);
                if (match && match[1]) return match[1];
                return null;
            }();
            app_IS_ANDROID = /Android/i.test(USER_AGENT);
            app_ANDROID_VERSION = function() {
                const match = USER_AGENT.match(/Android (\d+)(?:\.(\d+))?(?:\.(\d+))*/i);
                if (!match) return null;
                const major = match[1] && parseFloat(match[1]);
                const minor = match[2] && parseFloat(match[2]);
                if (major && minor) return parseFloat(match[1] + "." + match[2]); else if (major) return major;
                return null;
            }();
            app_IS_FIREFOX = /Firefox/i.test(USER_AGENT);
            app_IS_EDGE = /Edg/i.test(USER_AGENT);
            app_IS_CHROMIUM = /Chrome/i.test(USER_AGENT) || /CriOS/i.test(USER_AGENT);
            app_IS_CHROME = !app_IS_EDGE && app_IS_CHROMIUM;
            app_CHROMIUM_VERSION = app_CHROME_VERSION = function() {
                const match = USER_AGENT.match(/(Chrome|CriOS)\/(\d+)/);
                if (match && match[2]) return parseFloat(match[2]);
                return null;
            }();
            app_IE_VERSION = function() {
                const result = /MSIE\s(\d+)\.\d/.exec(USER_AGENT);
                let version = result && parseFloat(result[1]);
                if (!version && /Trident\/7.0/i.test(USER_AGENT) && /rv:11.0/.test(USER_AGENT)) version = 11;
                return version;
            }();
            app_IS_TIZEN = /Tizen/i.test(USER_AGENT);
            app_IS_WEBOS = /Web0S/i.test(USER_AGENT);
            app_IS_SMART_TV = app_IS_TIZEN || app_IS_WEBOS;
            app_IS_SAFARI = /Safari/i.test(USER_AGENT) && !app_IS_CHROME && !app_IS_ANDROID && !app_IS_EDGE && !app_IS_SMART_TV;
            app_IS_WINDOWS = /Windows/i.test(USER_AGENT);
            app_IS_IPAD = /iPad/i.test(USER_AGENT) || app_IS_SAFARI && app_TOUCH_ENABLED && !/iPhone/i.test(USER_AGENT);
            app_IS_IPHONE = /iPhone/i.test(USER_AGENT) && !app_IS_IPAD;
        }
        const app_IS_IOS = app_IS_IPHONE || app_IS_IPAD || app_IS_IPOD;
        const app_IS_ANY_SAFARI = (app_IS_SAFARI || app_IS_IOS) && !app_IS_CHROME;
        var app_video_es_browser = Object.freeze({
            __proto__: null,
            get IS_IPOD() {
                return app_IS_IPOD;
            },
            get IOS_VERSION() {
                return app_IOS_VERSION;
            },
            get IS_ANDROID() {
                return app_IS_ANDROID;
            },
            get ANDROID_VERSION() {
                return app_ANDROID_VERSION;
            },
            get IS_FIREFOX() {
                return app_IS_FIREFOX;
            },
            get IS_EDGE() {
                return app_IS_EDGE;
            },
            get IS_CHROMIUM() {
                return app_IS_CHROMIUM;
            },
            get IS_CHROME() {
                return app_IS_CHROME;
            },
            get CHROMIUM_VERSION() {
                return app_CHROMIUM_VERSION;
            },
            get CHROME_VERSION() {
                return app_CHROME_VERSION;
            },
            IS_CHROMECAST_RECEIVER: app_IS_CHROMECAST_RECEIVER,
            get IE_VERSION() {
                return app_IE_VERSION;
            },
            get IS_SAFARI() {
                return app_IS_SAFARI;
            },
            get IS_WINDOWS() {
                return app_IS_WINDOWS;
            },
            get IS_IPAD() {
                return app_IS_IPAD;
            },
            get IS_IPHONE() {
                return app_IS_IPHONE;
            },
            get IS_TIZEN() {
                return app_IS_TIZEN;
            },
            get IS_WEBOS() {
                return app_IS_WEBOS;
            },
            get IS_SMART_TV() {
                return app_IS_SMART_TV;
            },
            TOUCH_ENABLED: app_TOUCH_ENABLED,
            IS_IOS: app_IS_IOS,
            IS_ANY_SAFARI: app_IS_ANY_SAFARI
        });
        function app_isNonBlankString(str) {
            return typeof str === "string" && Boolean(str.trim());
        }
        function app_throwIfWhitespace(str) {
            if (str.indexOf(" ") >= 0) throw new Error("class has illegal whitespace characters");
        }
        function app_isReal() {
            return app_document_default() === app_window_default().document;
        }
        function app_isEl(value) {
            return app_video_es_isObject(value) && value.nodeType === 1;
        }
        function app_isInFrame() {
            try {
                return app_window_default().parent !== app_window_default().self;
            } catch (x) {
                return true;
            }
        }
        function app_createQuerier(method) {
            return function(selector, context) {
                if (!app_isNonBlankString(selector)) return app_document_default()[method](null);
                if (app_isNonBlankString(context)) context = app_document_default().querySelector(context);
                const ctx = app_isEl(context) ? context : app_document_default();
                return ctx[method] && ctx[method](selector);
            };
        }
        function app_createEl(tagName = "div", properties = {}, attributes = {}, content) {
            const el = app_document_default().createElement(tagName);
            Object.getOwnPropertyNames(properties).forEach((function(propName) {
                const val = properties[propName];
                if (propName === "textContent") app_textContent(el, val); else if (el[propName] !== val || propName === "tabIndex") el[propName] = val;
            }));
            Object.getOwnPropertyNames(attributes).forEach((function(attrName) {
                el.setAttribute(attrName, attributes[attrName]);
            }));
            if (content) app_appendContent(el, content);
            return el;
        }
        function app_textContent(el, text) {
            if (typeof el.textContent === "undefined") el.innerText = text; else el.textContent = text;
            return el;
        }
        function app_prependTo(child, parent) {
            if (parent.firstChild) parent.insertBefore(child, parent.firstChild); else parent.appendChild(child);
        }
        function app_hasClass(element, classToCheck) {
            app_throwIfWhitespace(classToCheck);
            return element.classList.contains(classToCheck);
        }
        function app_addClass(element, ...classesToAdd) {
            element.classList.add(...classesToAdd.reduce(((prev, current) => prev.concat(current.split(/\s+/))), []));
            return element;
        }
        function app_removeClass(element, ...classesToRemove) {
            if (!element) {
                app_log$1.warn("removeClass was called with an element that doesn't exist");
                return null;
            }
            element.classList.remove(...classesToRemove.reduce(((prev, current) => prev.concat(current.split(/\s+/))), []));
            return element;
        }
        function app_toggleClass(element, classToToggle, predicate) {
            if (typeof predicate === "function") predicate = predicate(element, classToToggle);
            if (typeof predicate !== "boolean") predicate = void 0;
            classToToggle.split(/\s+/).forEach((className => element.classList.toggle(className, predicate)));
            return element;
        }
        function app_setAttributes(el, attributes) {
            Object.getOwnPropertyNames(attributes).forEach((function(attrName) {
                const attrValue = attributes[attrName];
                if (attrValue === null || typeof attrValue === "undefined" || attrValue === false) el.removeAttribute(attrName); else el.setAttribute(attrName, attrValue === true ? "" : attrValue);
            }));
        }
        function app_getAttributes(tag) {
            const obj = {};
            const knownBooleans = [ "autoplay", "controls", "playsinline", "loop", "muted", "default", "defaultMuted" ];
            if (tag && tag.attributes && tag.attributes.length > 0) {
                const attrs = tag.attributes;
                for (let i = attrs.length - 1; i >= 0; i--) {
                    const attrName = attrs[i].name;
                    let attrVal = attrs[i].value;
                    if (knownBooleans.includes(attrName)) attrVal = attrVal !== null ? true : false;
                    obj[attrName] = attrVal;
                }
            }
            return obj;
        }
        function app_getAttribute(el, attribute) {
            return el.getAttribute(attribute);
        }
        function app_setAttribute(el, attribute, value) {
            el.setAttribute(attribute, value);
        }
        function app_removeAttribute(el, attribute) {
            el.removeAttribute(attribute);
        }
        function app_blockTextSelection() {
            app_document_default().body.focus();
            app_document_default().onselectstart = function() {
                return false;
            };
        }
        function app_unblockTextSelection() {
            app_document_default().onselectstart = function() {
                return true;
            };
        }
        function app_getBoundingClientRect(el) {
            if (el && el.getBoundingClientRect && el.parentNode) {
                const rect = el.getBoundingClientRect();
                const result = {};
                [ "bottom", "height", "left", "right", "top", "width" ].forEach((k => {
                    if (rect[k] !== void 0) result[k] = rect[k];
                }));
                if (!result.height) result.height = parseFloat(app_computedStyle(el, "height"));
                if (!result.width) result.width = parseFloat(app_computedStyle(el, "width"));
                return result;
            }
        }
        function app_findPosition(el) {
            if (!el || el && !el.offsetParent) return {
                left: 0,
                top: 0,
                width: 0,
                height: 0
            };
            const width = el.offsetWidth;
            const height = el.offsetHeight;
            let left = 0;
            let top = 0;
            while (el.offsetParent && el !== app_document_default()[app_FullscreenApi.fullscreenElement]) {
                left += el.offsetLeft;
                top += el.offsetTop;
                el = el.offsetParent;
            }
            return {
                left,
                top,
                width,
                height
            };
        }
        function app_getPointerPosition(el, event) {
            const translated = {
                x: 0,
                y: 0
            };
            if (app_IS_IOS) {
                let item = el;
                while (item && item.nodeName.toLowerCase() !== "html") {
                    const transform = app_computedStyle(item, "transform");
                    if (/^matrix/.test(transform)) {
                        const values = transform.slice(7, -1).split(/,\s/).map(Number);
                        translated.x += values[4];
                        translated.y += values[5];
                    } else if (/^matrix3d/.test(transform)) {
                        const values = transform.slice(9, -1).split(/,\s/).map(Number);
                        translated.x += values[12];
                        translated.y += values[13];
                    }
                    if (item.assignedSlot && item.assignedSlot.parentElement && app_window_default().WebKitCSSMatrix) {
                        const transformValue = app_window_default().getComputedStyle(item.assignedSlot.parentElement).transform;
                        const matrix = new (app_window_default().WebKitCSSMatrix)(transformValue);
                        translated.x += matrix.m41;
                        translated.y += matrix.m42;
                    }
                    item = item.parentNode || item.host;
                }
            }
            const position = {};
            const boxTarget = app_findPosition(event.target);
            const box = app_findPosition(el);
            const boxW = box.width;
            const boxH = box.height;
            let offsetY = event.offsetY - (box.top - boxTarget.top);
            let offsetX = event.offsetX - (box.left - boxTarget.left);
            if (event.changedTouches) {
                offsetX = event.changedTouches[0].pageX - box.left;
                offsetY = event.changedTouches[0].pageY + box.top;
                if (app_IS_IOS) {
                    offsetX -= translated.x;
                    offsetY -= translated.y;
                }
            }
            position.y = 1 - Math.max(0, Math.min(1, offsetY / boxH));
            position.x = Math.max(0, Math.min(1, offsetX / boxW));
            return position;
        }
        function app_isTextNode(value) {
            return app_video_es_isObject(value) && value.nodeType === 3;
        }
        function app_emptyEl(el) {
            while (el.firstChild) el.removeChild(el.firstChild);
            return el;
        }
        function app_normalizeContent(content) {
            if (typeof content === "function") content = content();
            return (Array.isArray(content) ? content : [ content ]).map((value => {
                if (typeof value === "function") value = value();
                if (app_isEl(value) || app_isTextNode(value)) return value;
                if (typeof value === "string" && /\S/.test(value)) return app_document_default().createTextNode(value);
            })).filter((value => value));
        }
        function app_appendContent(el, content) {
            app_normalizeContent(content).forEach((node => el.appendChild(node)));
            return el;
        }
        function app_insertContent(el, content) {
            return app_appendContent(app_emptyEl(el), content);
        }
        function app_isSingleLeftClick(event) {
            if (event.button === void 0 && event.buttons === void 0) return true;
            if (event.button === 0 && event.buttons === void 0) return true;
            if (event.type === "mouseup" && event.button === 0 && event.buttons === 0) return true;
            if (event.type === "mousedown" && event.button === 0 && event.buttons === 0) return true;
            if (event.button !== 0 || event.buttons !== 1) return false;
            return true;
        }
        const app_$ = app_createQuerier("querySelector");
        const app_$$ = app_createQuerier("querySelectorAll");
        function app_computedStyle(el, prop) {
            if (!el || !prop) return "";
            if (typeof app_window_default().getComputedStyle === "function") {
                let computedStyleValue;
                try {
                    computedStyleValue = app_window_default().getComputedStyle(el);
                } catch (e) {
                    return "";
                }
                return computedStyleValue ? computedStyleValue.getPropertyValue(prop) || computedStyleValue[prop] : "";
            }
            return "";
        }
        function app_copyStyleSheetsToWindow(win) {
            [ ...app_document_default().styleSheets ].forEach((styleSheet => {
                try {
                    const cssRules = [ ...styleSheet.cssRules ].map((rule => rule.cssText)).join("");
                    const style = app_document_default().createElement("style");
                    style.textContent = cssRules;
                    win.document.head.appendChild(style);
                } catch (e) {
                    const link = app_document_default().createElement("link");
                    link.rel = "stylesheet";
                    link.type = styleSheet.type;
                    link.media = styleSheet.media.mediaText;
                    link.href = styleSheet.href;
                    win.document.head.appendChild(link);
                }
            }));
        }
        var app_Dom = Object.freeze({
            __proto__: null,
            isReal: app_isReal,
            isEl: app_isEl,
            isInFrame: app_isInFrame,
            createEl: app_createEl,
            textContent: app_textContent,
            prependTo: app_prependTo,
            hasClass: app_hasClass,
            addClass: app_addClass,
            removeClass: app_removeClass,
            toggleClass: app_toggleClass,
            setAttributes: app_setAttributes,
            getAttributes: app_getAttributes,
            getAttribute: app_getAttribute,
            setAttribute: app_setAttribute,
            removeAttribute: app_removeAttribute,
            blockTextSelection: app_blockTextSelection,
            unblockTextSelection: app_unblockTextSelection,
            getBoundingClientRect: app_getBoundingClientRect,
            findPosition: app_findPosition,
            getPointerPosition: app_getPointerPosition,
            isTextNode: app_isTextNode,
            emptyEl: app_emptyEl,
            normalizeContent: app_normalizeContent,
            appendContent: app_appendContent,
            insertContent: app_insertContent,
            isSingleLeftClick: app_isSingleLeftClick,
            $: app_$,
            $$: app_$$,
            computedStyle: app_computedStyle,
            copyStyleSheetsToWindow: app_copyStyleSheetsToWindow
        });
        let app_windowLoaded = false;
        let app_videojs$1;
        const app_autoSetup = function() {
            if (app_videojs$1.options.autoSetup === false) return;
            const vids = Array.prototype.slice.call(app_document_default().getElementsByTagName("video"));
            const audios = Array.prototype.slice.call(app_document_default().getElementsByTagName("audio"));
            const divs = Array.prototype.slice.call(app_document_default().getElementsByTagName("video-js"));
            const mediaEls = vids.concat(audios, divs);
            if (mediaEls && mediaEls.length > 0) for (let i = 0, e = mediaEls.length; i < e; i++) {
                const mediaEl = mediaEls[i];
                if (mediaEl && mediaEl.getAttribute) {
                    if (mediaEl.player === void 0) {
                        const options = mediaEl.getAttribute("data-setup");
                        if (options !== null) app_videojs$1(mediaEl);
                    }
                } else {
                    app_autoSetupTimeout(1);
                    break;
                }
            } else if (!app_windowLoaded) app_autoSetupTimeout(1);
        };
        function app_autoSetupTimeout(wait, vjs) {
            if (!app_isReal()) return;
            if (vjs) app_videojs$1 = vjs;
            app_window_default().setTimeout(app_autoSetup, wait);
        }
        function app_setWindowLoaded() {
            app_windowLoaded = true;
            app_window_default().removeEventListener("load", app_setWindowLoaded);
        }
        if (app_isReal()) if (app_document_default().readyState === "complete") app_setWindowLoaded(); else app_window_default().addEventListener("load", app_setWindowLoaded);
        const app_createStyleElement = function(className) {
            const style = app_document_default().createElement("style");
            style.className = className;
            return style;
        };
        const app_setTextContent = function(el, content) {
            if (el.styleSheet) el.styleSheet.cssText = content; else el.textContent = content;
        };
        var app_DomData = new WeakMap;
        const app_initialGuid = 3;
        let app_guid = app_initialGuid;
        function app_newGUID() {
            return app_guid++;
        }
        function app_cleanUpEvents(elem, type) {
            if (!app_DomData.has(elem)) return;
            const data = app_DomData.get(elem);
            if (data.handlers[type].length === 0) {
                delete data.handlers[type];
                if (elem.removeEventListener) elem.removeEventListener(type, data.dispatcher, false); else if (elem.detachEvent) elem.detachEvent("on" + type, data.dispatcher);
            }
            if (Object.getOwnPropertyNames(data.handlers).length <= 0) {
                delete data.handlers;
                delete data.dispatcher;
                delete data.disabled;
            }
            if (Object.getOwnPropertyNames(data).length === 0) app_DomData.delete(elem);
        }
        function app_handleMultipleEvents(fn, elem, types, callback) {
            types.forEach((function(type) {
                fn(elem, type, callback);
            }));
        }
        function app_fixEvent(event) {
            if (event.fixed_) return event;
            function returnTrue() {
                return true;
            }
            function returnFalse() {
                return false;
            }
            if (!event || !event.isPropagationStopped || !event.isImmediatePropagationStopped) {
                const old = event || app_window_default().event;
                event = {};
                const deprecatedProps = [ "layerX", "layerY", "keyLocation", "path", "webkitMovementX", "webkitMovementY", "mozPressure", "mozInputSource" ];
                for (const key in old) if (!deprecatedProps.includes(key)) if (!(key === "returnValue" && old.preventDefault)) event[key] = old[key];
                if (!event.target) event.target = event.srcElement || app_document_default();
                if (!event.relatedTarget) event.relatedTarget = event.fromElement === event.target ? event.toElement : event.fromElement;
                event.preventDefault = function() {
                    if (old.preventDefault) old.preventDefault();
                    event.returnValue = false;
                    old.returnValue = false;
                    event.defaultPrevented = true;
                };
                event.defaultPrevented = false;
                event.stopPropagation = function() {
                    if (old.stopPropagation) old.stopPropagation();
                    event.cancelBubble = true;
                    old.cancelBubble = true;
                    event.isPropagationStopped = returnTrue;
                };
                event.isPropagationStopped = returnFalse;
                event.stopImmediatePropagation = function() {
                    if (old.stopImmediatePropagation) old.stopImmediatePropagation();
                    event.isImmediatePropagationStopped = returnTrue;
                    event.stopPropagation();
                };
                event.isImmediatePropagationStopped = returnFalse;
                if (event.clientX !== null && event.clientX !== void 0) {
                    const doc = app_document_default().documentElement;
                    const body = app_document_default().body;
                    event.pageX = event.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
                    event.pageY = event.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
                }
                event.which = event.charCode || event.keyCode;
                if (event.button !== null && event.button !== void 0) event.button = event.button & 1 ? 0 : event.button & 4 ? 1 : event.button & 2 ? 2 : 0;
            }
            event.fixed_ = true;
            return event;
        }
        let app_supportsPassive;
        const js_app_supportsPassive = function() {
            if (typeof app_supportsPassive !== "boolean") {
                app_supportsPassive = false;
                try {
                    const opts = Object.defineProperty({}, "passive", {
                        get() {
                            app_supportsPassive = true;
                        }
                    });
                    app_window_default().addEventListener("test", null, opts);
                    app_window_default().removeEventListener("test", null, opts);
                } catch (e) {}
            }
            return app_supportsPassive;
        };
        const app_passiveEvents = [ "touchstart", "touchmove" ];
        function app_on(elem, type, fn) {
            if (Array.isArray(type)) return app_handleMultipleEvents(app_on, elem, type, fn);
            if (!app_DomData.has(elem)) app_DomData.set(elem, {});
            const data = app_DomData.get(elem);
            if (!data.handlers) data.handlers = {};
            if (!data.handlers[type]) data.handlers[type] = [];
            if (!fn.guid) fn.guid = app_newGUID();
            data.handlers[type].push(fn);
            if (!data.dispatcher) {
                data.disabled = false;
                data.dispatcher = function(event, hash) {
                    if (data.disabled) return;
                    event = app_fixEvent(event);
                    const handlers = data.handlers[event.type];
                    if (handlers) {
                        const handlersCopy = handlers.slice(0);
                        for (let m = 0, n = handlersCopy.length; m < n; m++) if (event.isImmediatePropagationStopped()) break; else try {
                            handlersCopy[m].call(elem, event, hash);
                        } catch (e) {
                            app_log$1.error(e);
                        }
                    }
                };
            }
            if (data.handlers[type].length === 1) if (elem.addEventListener) {
                let options = false;
                if (js_app_supportsPassive() && app_passiveEvents.indexOf(type) > -1) options = {
                    passive: true
                };
                elem.addEventListener(type, data.dispatcher, options);
            } else if (elem.attachEvent) elem.attachEvent("on" + type, data.dispatcher);
        }
        function app_off(elem, type, fn) {
            if (!app_DomData.has(elem)) return;
            const data = app_DomData.get(elem);
            if (!data.handlers) return;
            if (Array.isArray(type)) return app_handleMultipleEvents(app_off, elem, type, fn);
            const removeType = function(el, t) {
                data.handlers[t] = [];
                app_cleanUpEvents(el, t);
            };
            if (type === void 0) {
                for (const t in data.handlers) if (Object.prototype.hasOwnProperty.call(data.handlers || {}, t)) removeType(elem, t);
                return;
            }
            const handlers = data.handlers[type];
            if (!handlers) return;
            if (!fn) {
                removeType(elem, type);
                return;
            }
            if (fn.guid) for (let n = 0; n < handlers.length; n++) if (handlers[n].guid === fn.guid) handlers.splice(n--, 1);
            app_cleanUpEvents(elem, type);
        }
        function app_trigger(elem, event, hash) {
            const elemData = app_DomData.has(elem) ? app_DomData.get(elem) : {};
            const parent = elem.parentNode || elem.ownerDocument;
            if (typeof event === "string") event = {
                type: event,
                target: elem
            }; else if (!event.target) event.target = elem;
            event = app_fixEvent(event);
            if (elemData.dispatcher) elemData.dispatcher.call(elem, event, hash);
            if (parent && !event.isPropagationStopped() && event.bubbles === true) app_trigger.call(null, parent, event, hash); else if (!parent && !event.defaultPrevented && event.target && event.target[event.type]) {
                if (!app_DomData.has(event.target)) app_DomData.set(event.target, {});
                const targetData = app_DomData.get(event.target);
                if (event.target[event.type]) {
                    targetData.disabled = true;
                    if (typeof event.target[event.type] === "function") event.target[event.type]();
                    targetData.disabled = false;
                }
            }
            return !event.defaultPrevented;
        }
        function app_one(elem, type, fn) {
            if (Array.isArray(type)) return app_handleMultipleEvents(app_one, elem, type, fn);
            const func = function() {
                app_off(elem, type, func);
                fn.apply(this, arguments);
            };
            func.guid = fn.guid = fn.guid || app_newGUID();
            app_on(elem, type, func);
        }
        function app_any(elem, type, fn) {
            const func = function() {
                app_off(elem, type, func);
                fn.apply(this, arguments);
            };
            func.guid = fn.guid = fn.guid || app_newGUID();
            app_on(elem, type, func);
        }
        var app_Events = Object.freeze({
            __proto__: null,
            fixEvent: app_fixEvent,
            on: app_on,
            off: app_off,
            trigger: app_trigger,
            one: app_one,
            any: app_any
        });
        const app_UPDATE_REFRESH_INTERVAL = 30;
        const app_bind_ = function(context, fn, uid) {
            if (!fn.guid) fn.guid = app_newGUID();
            const bound = fn.bind(context);
            bound.guid = uid ? uid + "_" + fn.guid : fn.guid;
            return bound;
        };
        const app_throttle = function(fn, wait) {
            let last = app_window_default().performance.now();
            const throttled = function(...args) {
                const now = app_window_default().performance.now();
                if (now - last >= wait) {
                    fn(...args);
                    last = now;
                }
            };
            return throttled;
        };
        const app_debounce$1 = function(func, wait, immediate, context = app_window_default()) {
            let timeout;
            const cancel = () => {
                context.clearTimeout(timeout);
                timeout = null;
            };
            const debounced = function() {
                const self = this;
                const args = arguments;
                let later = function() {
                    timeout = null;
                    later = null;
                    if (!immediate) func.apply(self, args);
                };
                if (!timeout && immediate) func.apply(self, args);
                context.clearTimeout(timeout);
                timeout = context.setTimeout(later, wait);
            };
            debounced.cancel = cancel;
            return debounced;
        };
        var app_Fn = Object.freeze({
            __proto__: null,
            UPDATE_REFRESH_INTERVAL: app_UPDATE_REFRESH_INTERVAL,
            bind_: app_bind_,
            throttle: app_throttle,
            debounce: app_debounce$1
        });
        let app_EVENT_MAP;
        class app_EventTarget$2 {
            on(type, fn) {
                const ael = this.addEventListener;
                this.addEventListener = () => {};
                app_on(this, type, fn);
                this.addEventListener = ael;
            }
            off(type, fn) {
                app_off(this, type, fn);
            }
            one(type, fn) {
                const ael = this.addEventListener;
                this.addEventListener = () => {};
                app_one(this, type, fn);
                this.addEventListener = ael;
            }
            any(type, fn) {
                const ael = this.addEventListener;
                this.addEventListener = () => {};
                app_any(this, type, fn);
                this.addEventListener = ael;
            }
            trigger(event) {
                const type = event.type || event;
                if (typeof event === "string") event = {
                    type
                };
                event = app_fixEvent(event);
                if (this.allowedEvents_[type] && this["on" + type]) this["on" + type](event);
                app_trigger(this, event);
            }
            queueTrigger(event) {
                if (!app_EVENT_MAP) app_EVENT_MAP = new Map;
                const type = event.type || event;
                let map = app_EVENT_MAP.get(this);
                if (!map) {
                    map = new Map;
                    app_EVENT_MAP.set(this, map);
                }
                const oldTimeout = map.get(type);
                map.delete(type);
                app_window_default().clearTimeout(oldTimeout);
                const timeout = app_window_default().setTimeout((() => {
                    map.delete(type);
                    if (map.size === 0) {
                        map = null;
                        app_EVENT_MAP.delete(this);
                    }
                    this.trigger(event);
                }), 0);
                map.set(type, timeout);
            }
        }
        app_EventTarget$2.prototype.allowedEvents_ = {};
        app_EventTarget$2.prototype.addEventListener = app_EventTarget$2.prototype.on;
        app_EventTarget$2.prototype.removeEventListener = app_EventTarget$2.prototype.off;
        app_EventTarget$2.prototype.dispatchEvent = app_EventTarget$2.prototype.trigger;
        const app_objName = obj => {
            if (typeof obj.name === "function") return obj.name();
            if (typeof obj.name === "string") return obj.name;
            if (obj.name_) return obj.name_;
            if (obj.constructor && obj.constructor.name) return obj.constructor.name;
            return typeof obj;
        };
        const app_isEvented = object => object instanceof app_EventTarget$2 || !!object.eventBusEl_ && [ "on", "one", "off", "trigger" ].every((k => typeof object[k] === "function"));
        const app_addEventedCallback = (target, callback) => {
            if (app_isEvented(target)) callback(); else {
                if (!target.eventedCallbacks) target.eventedCallbacks = [];
                target.eventedCallbacks.push(callback);
            }
        };
        const app_isValidEventType = type => typeof type === "string" && /\S/.test(type) || Array.isArray(type) && !!type.length;
        const app_validateTarget = (target, obj, fnName) => {
            if (!target || !target.nodeName && !app_isEvented(target)) throw new Error(`Invalid target for ${app_objName(obj)}#${fnName}; must be a DOM node or evented object.`);
        };
        const app_validateEventType = (type, obj, fnName) => {
            if (!app_isValidEventType(type)) throw new Error(`Invalid event type for ${app_objName(obj)}#${fnName}; must be a non-empty string or array.`);
        };
        const app_validateListener = (listener, obj, fnName) => {
            if (typeof listener !== "function") throw new Error(`Invalid listener for ${app_objName(obj)}#${fnName}; must be a function.`);
        };
        const app_normalizeListenArgs = (self, args, fnName) => {
            const isTargetingSelf = args.length < 3 || args[0] === self || args[0] === self.eventBusEl_;
            let target;
            let type;
            let listener;
            if (isTargetingSelf) {
                target = self.eventBusEl_;
                if (args.length >= 3) args.shift();
                [type, listener] = args;
            } else {
                target = args[0];
                type = args[1];
                listener = args[2];
            }
            app_validateTarget(target, self, fnName);
            app_validateEventType(type, self, fnName);
            app_validateListener(listener, self, fnName);
            listener = app_bind_(self, listener);
            return {
                isTargetingSelf,
                target,
                type,
                listener
            };
        };
        const app_listen = (target, method, type, listener) => {
            app_validateTarget(target, target, method);
            if (target.nodeName) app_Events[method](target, type, listener); else target[method](type, listener);
        };
        const app_EventedMixin = {
            on(...args) {
                const {isTargetingSelf, target, type, listener} = app_normalizeListenArgs(this, args, "on");
                app_listen(target, "on", type, listener);
                if (!isTargetingSelf) {
                    const removeListenerOnDispose = () => this.off(target, type, listener);
                    removeListenerOnDispose.guid = listener.guid;
                    const removeRemoverOnTargetDispose = () => this.off("dispose", removeListenerOnDispose);
                    removeRemoverOnTargetDispose.guid = listener.guid;
                    app_listen(this, "on", "dispose", removeListenerOnDispose);
                    app_listen(target, "on", "dispose", removeRemoverOnTargetDispose);
                }
            },
            one(...args) {
                const {isTargetingSelf, target, type, listener} = app_normalizeListenArgs(this, args, "one");
                if (isTargetingSelf) app_listen(target, "one", type, listener); else {
                    const wrapper = (...largs) => {
                        this.off(target, type, wrapper);
                        listener.apply(null, largs);
                    };
                    wrapper.guid = listener.guid;
                    app_listen(target, "one", type, wrapper);
                }
            },
            any(...args) {
                const {isTargetingSelf, target, type, listener} = app_normalizeListenArgs(this, args, "any");
                if (isTargetingSelf) app_listen(target, "any", type, listener); else {
                    const wrapper = (...largs) => {
                        this.off(target, type, wrapper);
                        listener.apply(null, largs);
                    };
                    wrapper.guid = listener.guid;
                    app_listen(target, "any", type, wrapper);
                }
            },
            off(targetOrType, typeOrListener, listener) {
                if (!targetOrType || app_isValidEventType(targetOrType)) app_off(this.eventBusEl_, targetOrType, typeOrListener); else {
                    const target = targetOrType;
                    const type = typeOrListener;
                    app_validateTarget(target, this, "off");
                    app_validateEventType(type, this, "off");
                    app_validateListener(listener, this, "off");
                    listener = app_bind_(this, listener);
                    this.off("dispose", listener);
                    if (target.nodeName) {
                        app_off(target, type, listener);
                        app_off(target, "dispose", listener);
                    } else if (app_isEvented(target)) {
                        target.off(type, listener);
                        target.off("dispose", listener);
                    }
                }
            },
            trigger(event, hash) {
                app_validateTarget(this.eventBusEl_, this, "trigger");
                const type = event && typeof event !== "string" ? event.type : event;
                if (!app_isValidEventType(type)) throw new Error(`Invalid event type for ${app_objName(this)}#trigger; ` + "must be a non-empty string or object with a type key that has a non-empty value.");
                return app_trigger(this.eventBusEl_, event, hash);
            }
        };
        function app_evented(target, options = {}) {
            const {eventBusKey} = options;
            if (eventBusKey) {
                if (!target[eventBusKey].nodeName) throw new Error(`The eventBusKey "${eventBusKey}" does not refer to an element.`);
                target.eventBusEl_ = target[eventBusKey];
            } else target.eventBusEl_ = app_createEl("span", {
                className: "vjs-event-bus"
            });
            Object.assign(target, app_EventedMixin);
            if (target.eventedCallbacks) target.eventedCallbacks.forEach((callback => {
                callback();
            }));
            target.on("dispose", (() => {
                target.off();
                [ target, target.el_, target.eventBusEl_ ].forEach((function(val) {
                    if (val && app_DomData.has(val)) app_DomData.delete(val);
                }));
                app_window_default().setTimeout((() => {
                    target.eventBusEl_ = null;
                }), 0);
            }));
            return target;
        }
        const app_StatefulMixin = {
            state: {},
            setState(stateUpdates) {
                if (typeof stateUpdates === "function") stateUpdates = stateUpdates();
                let changes;
                app_each(stateUpdates, ((value, key) => {
                    if (this.state[key] !== value) {
                        changes = changes || {};
                        changes[key] = {
                            from: this.state[key],
                            to: value
                        };
                    }
                    this.state[key] = value;
                }));
                if (changes && app_isEvented(this)) this.trigger({
                    changes,
                    type: "statechanged"
                });
                return changes;
            }
        };
        function app_stateful(target, defaultState) {
            Object.assign(target, app_StatefulMixin);
            target.state = Object.assign({}, target.state, defaultState);
            if (typeof target.handleStateChanged === "function" && app_isEvented(target)) target.on("statechanged", target.handleStateChanged);
            return target;
        }
        const app_toLowerCase = function(string) {
            if (typeof string !== "string") return string;
            return string.replace(/./, (w => w.toLowerCase()));
        };
        const app_toTitleCase$1 = function(string) {
            if (typeof string !== "string") return string;
            return string.replace(/./, (w => w.toUpperCase()));
        };
        const app_titleCaseEquals = function(str1, str2) {
            return app_toTitleCase$1(str1) === app_toTitleCase$1(str2);
        };
        var app_Str = Object.freeze({
            __proto__: null,
            toLowerCase: app_toLowerCase,
            toTitleCase: app_toTitleCase$1,
            titleCaseEquals: app_titleCaseEquals
        });
        class app_Component$1 {
            constructor(player, options, ready) {
                if (!player && this.play) this.player_ = player = this; else this.player_ = player;
                this.isDisposed_ = false;
                this.parentComponent_ = null;
                this.options_ = app_merge$1({}, this.options_);
                options = this.options_ = app_merge$1(this.options_, options);
                this.id_ = options.id || options.el && options.el.id;
                if (!this.id_) {
                    const id = player && player.id && player.id() || "no_player";
                    this.id_ = `${id}_component_${app_newGUID()}`;
                }
                this.name_ = options.name || null;
                if (options.el) this.el_ = options.el; else if (options.createEl !== false) this.el_ = this.createEl();
                if (options.className && this.el_) options.className.split(" ").forEach((c => this.addClass(c)));
                [ "on", "off", "one", "any", "trigger" ].forEach((fn => {
                    this[fn] = void 0;
                }));
                if (options.evented !== false) {
                    app_evented(this, {
                        eventBusKey: this.el_ ? "el_" : null
                    });
                    this.handleLanguagechange = this.handleLanguagechange.bind(this);
                    this.on(this.player_, "languagechange", this.handleLanguagechange);
                }
                app_stateful(this, this.constructor.defaultState);
                this.children_ = [];
                this.childIndex_ = {};
                this.childNameIndex_ = {};
                this.setTimeoutIds_ = new Set;
                this.setIntervalIds_ = new Set;
                this.rafIds_ = new Set;
                this.namedRafs_ = new Map;
                this.clearingTimersOnDispose_ = false;
                if (options.initChildren !== false) this.initChildren();
                this.ready(ready);
                if (options.reportTouchActivity !== false) this.enableTouchActivity();
            }
            dispose(options = {}) {
                if (this.isDisposed_) return;
                if (this.readyQueue_) this.readyQueue_.length = 0;
                this.trigger({
                    type: "dispose",
                    bubbles: false
                });
                this.isDisposed_ = true;
                if (this.children_) for (let i = this.children_.length - 1; i >= 0; i--) if (this.children_[i].dispose) this.children_[i].dispose();
                this.children_ = null;
                this.childIndex_ = null;
                this.childNameIndex_ = null;
                this.parentComponent_ = null;
                if (this.el_) {
                    if (this.el_.parentNode) if (options.restoreEl) this.el_.parentNode.replaceChild(options.restoreEl, this.el_); else this.el_.parentNode.removeChild(this.el_);
                    this.el_ = null;
                }
                this.player_ = null;
            }
            isDisposed() {
                return Boolean(this.isDisposed_);
            }
            player() {
                return this.player_;
            }
            options(obj) {
                if (!obj) return this.options_;
                this.options_ = app_merge$1(this.options_, obj);
                return this.options_;
            }
            el() {
                return this.el_;
            }
            createEl(tagName, properties, attributes) {
                return app_createEl(tagName, properties, attributes);
            }
            localize(string, tokens, defaultValue = string) {
                const code = this.player_.language && this.player_.language();
                const languages = this.player_.languages && this.player_.languages();
                const language = languages && languages[code];
                const primaryCode = code && code.split("-")[0];
                const primaryLang = languages && languages[primaryCode];
                let localizedString = defaultValue;
                if (language && language[string]) localizedString = language[string]; else if (primaryLang && primaryLang[string]) localizedString = primaryLang[string];
                if (tokens) localizedString = localizedString.replace(/\{(\d+)\}/g, (function(match, index) {
                    const value = tokens[index - 1];
                    let ret = value;
                    if (typeof value === "undefined") ret = match;
                    return ret;
                }));
                return localizedString;
            }
            handleLanguagechange() {}
            contentEl() {
                return this.contentEl_ || this.el_;
            }
            id() {
                return this.id_;
            }
            name() {
                return this.name_;
            }
            children() {
                return this.children_;
            }
            getChildById(id) {
                return this.childIndex_[id];
            }
            getChild(name) {
                if (!name) return;
                return this.childNameIndex_[name];
            }
            getDescendant(...names) {
                names = names.reduce(((acc, n) => acc.concat(n)), []);
                let currentChild = this;
                for (let i = 0; i < names.length; i++) {
                    currentChild = currentChild.getChild(names[i]);
                    if (!currentChild || !currentChild.getChild) return;
                }
                return currentChild;
            }
            setIcon(iconName, el = this.el()) {
                if (!this.player_.options_.experimentalSvgIcons) return;
                const xmlnsURL = "http://www.w3.org/2000/svg";
                const iconContainer = app_createEl("span", {
                    className: "vjs-icon-placeholder vjs-svg-icon"
                }, {
                    "aria-hidden": "true"
                });
                const svgEl = app_document_default().createElementNS(xmlnsURL, "svg");
                svgEl.setAttributeNS(null, "viewBox", "0 0 512 512");
                const useEl = app_document_default().createElementNS(xmlnsURL, "use");
                svgEl.appendChild(useEl);
                useEl.setAttributeNS(null, "href", `#vjs-icon-${iconName}`);
                iconContainer.appendChild(svgEl);
                if (this.iconIsSet_) el.replaceChild(iconContainer, el.querySelector(".vjs-icon-placeholder")); else el.appendChild(iconContainer);
                this.iconIsSet_ = true;
                return iconContainer;
            }
            addChild(child, options = {}, index = this.children_.length) {
                let component;
                let componentName;
                if (typeof child === "string") {
                    componentName = app_toTitleCase$1(child);
                    const componentClassName = options.componentClass || componentName;
                    options.name = componentName;
                    const ComponentClass = app_Component$1.getComponent(componentClassName);
                    if (!ComponentClass) throw new Error(`Component ${componentClassName} does not exist`);
                    if (typeof ComponentClass !== "function") return null;
                    component = new ComponentClass(this.player_ || this, options);
                } else component = child;
                if (component.parentComponent_) component.parentComponent_.removeChild(component);
                this.children_.splice(index, 0, component);
                component.parentComponent_ = this;
                if (typeof component.id === "function") this.childIndex_[component.id()] = component;
                componentName = componentName || component.name && app_toTitleCase$1(component.name());
                if (componentName) {
                    this.childNameIndex_[componentName] = component;
                    this.childNameIndex_[app_toLowerCase(componentName)] = component;
                }
                if (typeof component.el === "function" && component.el()) {
                    let refNode = null;
                    if (this.children_[index + 1]) if (this.children_[index + 1].el_) refNode = this.children_[index + 1].el_; else if (app_isEl(this.children_[index + 1])) refNode = this.children_[index + 1];
                    this.contentEl().insertBefore(component.el(), refNode);
                }
                return component;
            }
            removeChild(component) {
                if (typeof component === "string") component = this.getChild(component);
                if (!component || !this.children_) return;
                let childFound = false;
                for (let i = this.children_.length - 1; i >= 0; i--) if (this.children_[i] === component) {
                    childFound = true;
                    this.children_.splice(i, 1);
                    break;
                }
                if (!childFound) return;
                component.parentComponent_ = null;
                this.childIndex_[component.id()] = null;
                this.childNameIndex_[app_toTitleCase$1(component.name())] = null;
                this.childNameIndex_[app_toLowerCase(component.name())] = null;
                const compEl = component.el();
                if (compEl && compEl.parentNode === this.contentEl()) this.contentEl().removeChild(component.el());
            }
            initChildren() {
                const children = this.options_.children;
                if (children) {
                    const parentOptions = this.options_;
                    const handleAdd = child => {
                        const name = child.name;
                        let opts = child.opts;
                        if (parentOptions[name] !== void 0) opts = parentOptions[name];
                        if (opts === false) return;
                        if (opts === true) opts = {};
                        opts.playerOptions = this.options_.playerOptions;
                        const newChild = this.addChild(name, opts);
                        if (newChild) this[name] = newChild;
                    };
                    let workingChildren;
                    const Tech = app_Component$1.getComponent("Tech");
                    if (Array.isArray(children)) workingChildren = children; else workingChildren = Object.keys(children);
                    workingChildren.concat(Object.keys(this.options_).filter((function(child) {
                        return !workingChildren.some((function(wchild) {
                            if (typeof wchild === "string") return child === wchild;
                            return child === wchild.name;
                        }));
                    }))).map((child => {
                        let name;
                        let opts;
                        if (typeof child === "string") {
                            name = child;
                            opts = children[name] || this.options_[name] || {};
                        } else {
                            name = child.name;
                            opts = child;
                        }
                        return {
                            name,
                            opts
                        };
                    })).filter((child => {
                        const c = app_Component$1.getComponent(child.opts.componentClass || app_toTitleCase$1(child.name));
                        return c && !Tech.isTech(c);
                    })).forEach(handleAdd);
                }
            }
            buildCSSClass() {
                return "";
            }
            ready(fn, sync = false) {
                if (!fn) return;
                if (!this.isReady_) {
                    this.readyQueue_ = this.readyQueue_ || [];
                    this.readyQueue_.push(fn);
                    return;
                }
                if (sync) fn.call(this); else this.setTimeout(fn, 1);
            }
            triggerReady() {
                this.isReady_ = true;
                this.setTimeout((function() {
                    const readyQueue = this.readyQueue_;
                    this.readyQueue_ = [];
                    if (readyQueue && readyQueue.length > 0) readyQueue.forEach((function(fn) {
                        fn.call(this);
                    }), this);
                    this.trigger("ready");
                }), 1);
            }
            $(selector, context) {
                return app_$(selector, context || this.contentEl());
            }
            $$(selector, context) {
                return app_$$(selector, context || this.contentEl());
            }
            hasClass(classToCheck) {
                return app_hasClass(this.el_, classToCheck);
            }
            addClass(...classesToAdd) {
                app_addClass(this.el_, ...classesToAdd);
            }
            removeClass(...classesToRemove) {
                app_removeClass(this.el_, ...classesToRemove);
            }
            toggleClass(classToToggle, predicate) {
                app_toggleClass(this.el_, classToToggle, predicate);
            }
            show() {
                this.removeClass("vjs-hidden");
            }
            hide() {
                this.addClass("vjs-hidden");
            }
            lockShowing() {
                this.addClass("vjs-lock-showing");
            }
            unlockShowing() {
                this.removeClass("vjs-lock-showing");
            }
            getAttribute(attribute) {
                return app_getAttribute(this.el_, attribute);
            }
            setAttribute(attribute, value) {
                app_setAttribute(this.el_, attribute, value);
            }
            removeAttribute(attribute) {
                app_removeAttribute(this.el_, attribute);
            }
            width(num, skipListeners) {
                return this.dimension("width", num, skipListeners);
            }
            height(num, skipListeners) {
                return this.dimension("height", num, skipListeners);
            }
            dimensions(width, height) {
                this.width(width, true);
                this.height(height);
            }
            dimension(widthOrHeight, num, skipListeners) {
                if (num !== void 0) {
                    if (num === null || num !== num) num = 0;
                    if (("" + num).indexOf("%") !== -1 || ("" + num).indexOf("px") !== -1) this.el_.style[widthOrHeight] = num; else if (num === "auto") this.el_.style[widthOrHeight] = ""; else this.el_.style[widthOrHeight] = num + "px";
                    if (!skipListeners) this.trigger("componentresize");
                    return;
                }
                if (!this.el_) return 0;
                const val = this.el_.style[widthOrHeight];
                const pxIndex = val.indexOf("px");
                if (pxIndex !== -1) return parseInt(val.slice(0, pxIndex), 10);
                return parseInt(this.el_["offset" + app_toTitleCase$1(widthOrHeight)], 10);
            }
            currentDimension(widthOrHeight) {
                let computedWidthOrHeight = 0;
                if (widthOrHeight !== "width" && widthOrHeight !== "height") throw new Error("currentDimension only accepts width or height value");
                computedWidthOrHeight = app_computedStyle(this.el_, widthOrHeight);
                computedWidthOrHeight = parseFloat(computedWidthOrHeight);
                if (computedWidthOrHeight === 0 || isNaN(computedWidthOrHeight)) {
                    const rule = `offset${app_toTitleCase$1(widthOrHeight)}`;
                    computedWidthOrHeight = this.el_[rule];
                }
                return computedWidthOrHeight;
            }
            currentDimensions() {
                return {
                    width: this.currentDimension("width"),
                    height: this.currentDimension("height")
                };
            }
            currentWidth() {
                return this.currentDimension("width");
            }
            currentHeight() {
                return this.currentDimension("height");
            }
            getPositions() {
                const rect = this.el_.getBoundingClientRect();
                const boundingClientRect = {
                    x: rect.x,
                    y: rect.y,
                    width: rect.width,
                    height: rect.height,
                    top: rect.top,
                    right: rect.right,
                    bottom: rect.bottom,
                    left: rect.left
                };
                const center = {
                    x: rect.left + rect.width / 2,
                    y: rect.top + rect.height / 2,
                    width: 0,
                    height: 0,
                    top: rect.top + rect.height / 2,
                    right: rect.left + rect.width / 2,
                    bottom: rect.top + rect.height / 2,
                    left: rect.left + rect.width / 2
                };
                return {
                    boundingClientRect,
                    center
                };
            }
            focus() {
                this.el_.focus();
            }
            blur() {
                this.el_.blur();
            }
            handleKeyDown(event) {
                if (this.player_) {
                    if (event.key !== "Tab" && !(this.player_.options_.playerOptions.spatialNavigation && this.player_.options_.playerOptions.spatialNavigation.enabled)) event.stopPropagation();
                    this.player_.handleKeyDown(event);
                }
            }
            handleKeyPress(event) {
                this.handleKeyDown(event);
            }
            emitTapEvents() {
                let touchStart = 0;
                let firstTouch = null;
                const tapMovementThreshold = 10;
                const touchTimeThreshold = 200;
                let couldBeTap;
                this.on("touchstart", (function(event) {
                    if (event.touches.length === 1) {
                        firstTouch = {
                            pageX: event.touches[0].pageX,
                            pageY: event.touches[0].pageY
                        };
                        touchStart = app_window_default().performance.now();
                        couldBeTap = true;
                    }
                }));
                this.on("touchmove", (function(event) {
                    if (event.touches.length > 1) couldBeTap = false; else if (firstTouch) {
                        const xdiff = event.touches[0].pageX - firstTouch.pageX;
                        const ydiff = event.touches[0].pageY - firstTouch.pageY;
                        const touchDistance = Math.sqrt(xdiff * xdiff + ydiff * ydiff);
                        if (touchDistance > tapMovementThreshold) couldBeTap = false;
                    }
                }));
                const noTap = function() {
                    couldBeTap = false;
                };
                this.on("touchleave", noTap);
                this.on("touchcancel", noTap);
                this.on("touchend", (function(event) {
                    firstTouch = null;
                    if (couldBeTap === true) {
                        const touchTime = app_window_default().performance.now() - touchStart;
                        if (touchTime < touchTimeThreshold) {
                            event.preventDefault();
                            this.trigger("tap");
                        }
                    }
                }));
            }
            enableTouchActivity() {
                if (!this.player() || !this.player().reportUserActivity) return;
                const report = app_bind_(this.player(), this.player().reportUserActivity);
                let touchHolding;
                this.on("touchstart", (function() {
                    report();
                    this.clearInterval(touchHolding);
                    touchHolding = this.setInterval(report, 250);
                }));
                const touchEnd = function(event) {
                    report();
                    this.clearInterval(touchHolding);
                };
                this.on("touchmove", report);
                this.on("touchend", touchEnd);
                this.on("touchcancel", touchEnd);
            }
            setTimeout(fn, timeout) {
                var timeoutId;
                fn = app_bind_(this, fn);
                this.clearTimersOnDispose_();
                timeoutId = app_window_default().setTimeout((() => {
                    if (this.setTimeoutIds_.has(timeoutId)) this.setTimeoutIds_.delete(timeoutId);
                    fn();
                }), timeout);
                this.setTimeoutIds_.add(timeoutId);
                return timeoutId;
            }
            clearTimeout(timeoutId) {
                if (this.setTimeoutIds_.has(timeoutId)) {
                    this.setTimeoutIds_.delete(timeoutId);
                    app_window_default().clearTimeout(timeoutId);
                }
                return timeoutId;
            }
            setInterval(fn, interval) {
                fn = app_bind_(this, fn);
                this.clearTimersOnDispose_();
                const intervalId = app_window_default().setInterval(fn, interval);
                this.setIntervalIds_.add(intervalId);
                return intervalId;
            }
            clearInterval(intervalId) {
                if (this.setIntervalIds_.has(intervalId)) {
                    this.setIntervalIds_.delete(intervalId);
                    app_window_default().clearInterval(intervalId);
                }
                return intervalId;
            }
            requestAnimationFrame(fn) {
                this.clearTimersOnDispose_();
                var id;
                fn = app_bind_(this, fn);
                id = app_window_default().requestAnimationFrame((() => {
                    if (this.rafIds_.has(id)) this.rafIds_.delete(id);
                    fn();
                }));
                this.rafIds_.add(id);
                return id;
            }
            requestNamedAnimationFrame(name, fn) {
                if (this.namedRafs_.has(name)) this.cancelNamedAnimationFrame(name);
                this.clearTimersOnDispose_();
                fn = app_bind_(this, fn);
                const id = this.requestAnimationFrame((() => {
                    fn();
                    if (this.namedRafs_.has(name)) this.namedRafs_.delete(name);
                }));
                this.namedRafs_.set(name, id);
                return name;
            }
            cancelNamedAnimationFrame(name) {
                if (!this.namedRafs_.has(name)) return;
                this.cancelAnimationFrame(this.namedRafs_.get(name));
                this.namedRafs_.delete(name);
            }
            cancelAnimationFrame(id) {
                if (this.rafIds_.has(id)) {
                    this.rafIds_.delete(id);
                    app_window_default().cancelAnimationFrame(id);
                }
                return id;
            }
            clearTimersOnDispose_() {
                if (this.clearingTimersOnDispose_) return;
                this.clearingTimersOnDispose_ = true;
                this.one("dispose", (() => {
                    [ [ "namedRafs_", "cancelNamedAnimationFrame" ], [ "rafIds_", "cancelAnimationFrame" ], [ "setTimeoutIds_", "clearTimeout" ], [ "setIntervalIds_", "clearInterval" ] ].forEach((([idName, cancelName]) => {
                        this[idName].forEach(((val, key) => this[cancelName](key)));
                    }));
                    this.clearingTimersOnDispose_ = false;
                }));
            }
            getIsDisabled() {
                return Boolean(this.el_.disabled);
            }
            getIsExpresslyInert() {
                return this.el_.inert && !this.el_.ownerDocument.documentElement.inert;
            }
            getIsFocusable(el) {
                const element = el || this.el_;
                return element.tabIndex >= 0 && !(this.getIsDisabled() || this.getIsExpresslyInert());
            }
            getIsAvailableToBeFocused(el) {
                function isVisibleStyleProperty(element) {
                    const elementStyle = app_window_default().getComputedStyle(element, null);
                    const thisVisibility = elementStyle.getPropertyValue("visibility");
                    const thisDisplay = elementStyle.getPropertyValue("display");
                    const invisibleStyle = [ "hidden", "collapse" ];
                    return thisDisplay !== "none" && !invisibleStyle.includes(thisVisibility);
                }
                function isBeingRendered(element) {
                    if (!isVisibleStyleProperty(element.parentElement)) return false;
                    if (!isVisibleStyleProperty(element) || element.style.opacity === "0" || app_window_default().getComputedStyle(element).height === "0px" || app_window_default().getComputedStyle(element).width === "0px") return false;
                    return true;
                }
                function isVisible(element) {
                    if (element.offsetWidth + element.offsetHeight + element.getBoundingClientRect().height + element.getBoundingClientRect().width === 0) return false;
                    const elementCenter = {
                        x: element.getBoundingClientRect().left + element.offsetWidth / 2,
                        y: element.getBoundingClientRect().top + element.offsetHeight / 2
                    };
                    if (elementCenter.x < 0) return false;
                    if (elementCenter.x > (app_document_default().documentElement.clientWidth || app_window_default().innerWidth)) return false;
                    if (elementCenter.y < 0) return false;
                    if (elementCenter.y > (app_document_default().documentElement.clientHeight || app_window_default().innerHeight)) return false;
                    let pointContainer = app_document_default().elementFromPoint(elementCenter.x, elementCenter.y);
                    while (pointContainer) {
                        if (pointContainer === element) return true;
                        if (pointContainer.parentNode) pointContainer = pointContainer.parentNode; else return false;
                    }
                }
                if (!el) el = this.el();
                if (isVisible(el) && isBeingRendered(el) && (!el.parentElement || el.tabIndex >= 0)) return true;
                return false;
            }
            static registerComponent(name, ComponentToRegister) {
                if (typeof name !== "string" || !name) throw new Error(`Illegal component name, "${name}"; must be a non-empty string.`);
                const Tech = app_Component$1.getComponent("Tech");
                const isTech = Tech && Tech.isTech(ComponentToRegister);
                const isComp = app_Component$1 === ComponentToRegister || app_Component$1.prototype.isPrototypeOf(ComponentToRegister.prototype);
                if (isTech || !isComp) {
                    let reason;
                    if (isTech) reason = "techs must be registered using Tech.registerTech()"; else reason = "must be a Component subclass";
                    throw new Error(`Illegal component, "${name}"; ${reason}.`);
                }
                name = app_toTitleCase$1(name);
                if (!app_Component$1.components_) app_Component$1.components_ = {};
                const Player = app_Component$1.getComponent("Player");
                if (name === "Player" && Player && Player.players) {
                    const players = Player.players;
                    const playerNames = Object.keys(players);
                    if (players && playerNames.length > 0 && playerNames.map((pname => players[pname])).every(Boolean)) throw new Error("Can not register Player component after player has been created.");
                }
                app_Component$1.components_[name] = ComponentToRegister;
                app_Component$1.components_[app_toLowerCase(name)] = ComponentToRegister;
                return ComponentToRegister;
            }
            static getComponent(name) {
                if (!name || !app_Component$1.components_) return;
                return app_Component$1.components_[name];
            }
        }
        app_Component$1.registerComponent("Component", app_Component$1);
        function app_rangeCheck(fnName, index, maxIndex) {
            if (typeof index !== "number" || index < 0 || index > maxIndex) throw new Error(`Failed to execute '${fnName}' on 'TimeRanges': The index provided (${index}) is non-numeric or out of bounds (0-${maxIndex}).`);
        }
        function app_getRange(fnName, valueIndex, ranges, rangeIndex) {
            app_rangeCheck(fnName, rangeIndex, ranges.length - 1);
            return ranges[rangeIndex][valueIndex];
        }
        function app_createTimeRangesObj(ranges) {
            let timeRangesObj;
            if (ranges === void 0 || ranges.length === 0) timeRangesObj = {
                length: 0,
                start() {
                    throw new Error("This TimeRanges object is empty");
                },
                end() {
                    throw new Error("This TimeRanges object is empty");
                }
            }; else timeRangesObj = {
                length: ranges.length,
                start: app_getRange.bind(null, "start", 0, ranges),
                end: app_getRange.bind(null, "end", 1, ranges)
            };
            if (app_window_default().Symbol && app_window_default().Symbol.iterator) timeRangesObj[app_window_default().Symbol.iterator] = () => (ranges || []).values();
            return timeRangesObj;
        }
        function app_createTimeRanges$1(start, end) {
            if (Array.isArray(start)) return app_createTimeRangesObj(start); else if (start === void 0 || end === void 0) return app_createTimeRangesObj();
            return app_createTimeRangesObj([ [ start, end ] ]);
        }
        const app_defaultImplementation = function(seconds, guide) {
            seconds = seconds < 0 ? 0 : seconds;
            let s = Math.floor(seconds % 60);
            let m = Math.floor(seconds / 60 % 60);
            let h = Math.floor(seconds / 3600);
            const gm = Math.floor(guide / 60 % 60);
            const gh = Math.floor(guide / 3600);
            if (isNaN(seconds) || seconds === 1 / 0) h = m = s = "-";
            h = h > 0 || gh > 0 ? h + ":" : "";
            m = ((h || gm >= 10) && m < 10 ? "0" + m : m) + ":";
            s = s < 10 ? "0" + s : s;
            return h + m + s;
        };
        let app_implementation = app_defaultImplementation;
        function app_setFormatTime(customImplementation) {
            app_implementation = customImplementation;
        }
        function app_resetFormatTime() {
            app_implementation = app_defaultImplementation;
        }
        function app_formatTime(seconds, guide = seconds) {
            return app_implementation(seconds, guide);
        }
        var app_Time = Object.freeze({
            __proto__: null,
            createTimeRanges: app_createTimeRanges$1,
            createTimeRange: app_createTimeRanges$1,
            setFormatTime: app_setFormatTime,
            resetFormatTime: app_resetFormatTime,
            formatTime: app_formatTime
        });
        function app_bufferedPercent(buffered, duration) {
            let bufferedDuration = 0;
            let start;
            let end;
            if (!duration) return 0;
            if (!buffered || !buffered.length) buffered = app_createTimeRanges$1(0, 0);
            for (let i = 0; i < buffered.length; i++) {
                start = buffered.start(i);
                end = buffered.end(i);
                if (end > duration) end = duration;
                bufferedDuration += end - start;
            }
            return bufferedDuration / duration;
        }
        function app_MediaError(value) {
            if (value instanceof app_MediaError) return value;
            if (typeof value === "number") this.code = value; else if (typeof value === "string") this.message = value; else if (app_video_es_isObject(value)) {
                if (typeof value.code === "number") this.code = value.code;
                Object.assign(this, value);
            }
            if (!this.message) this.message = app_MediaError.defaultMessages[this.code] || "";
        }
        app_MediaError.prototype.code = 0;
        app_MediaError.prototype.message = "";
        app_MediaError.prototype.status = null;
        app_MediaError.prototype.metadata = null;
        app_MediaError.errorTypes = [ "MEDIA_ERR_CUSTOM", "MEDIA_ERR_ABORTED", "MEDIA_ERR_NETWORK", "MEDIA_ERR_DECODE", "MEDIA_ERR_SRC_NOT_SUPPORTED", "MEDIA_ERR_ENCRYPTED" ];
        app_MediaError.defaultMessages = {
            1: "You aborted the media playback",
            2: "A network error caused the media download to fail part-way.",
            3: "The media playback was aborted due to a corruption problem or because the media used features your browser did not support.",
            4: "The media could not be loaded, either because the server or network failed or because the format is not supported.",
            5: "The media is encrypted and we do not have the keys to decrypt it."
        };
        app_MediaError.MEDIA_ERR_CUSTOM = 0;
        app_MediaError.prototype.MEDIA_ERR_CUSTOM = 0;
        app_MediaError.MEDIA_ERR_ABORTED = 1;
        app_MediaError.prototype.MEDIA_ERR_ABORTED = 1;
        app_MediaError.MEDIA_ERR_NETWORK = 2;
        app_MediaError.prototype.MEDIA_ERR_NETWORK = 2;
        app_MediaError.MEDIA_ERR_DECODE = 3;
        app_MediaError.prototype.MEDIA_ERR_DECODE = 3;
        app_MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED = 4;
        app_MediaError.prototype.MEDIA_ERR_SRC_NOT_SUPPORTED = 4;
        app_MediaError.MEDIA_ERR_ENCRYPTED = 5;
        app_MediaError.prototype.MEDIA_ERR_ENCRYPTED = 5;
        function app_isPromise(value) {
            return value !== void 0 && value !== null && typeof value.then === "function";
        }
        function app_silencePromise(value) {
            if (app_isPromise(value)) value.then(null, (e => {}));
        }
        const app_trackToJson_ = function(track) {
            const ret = [ "kind", "label", "language", "id", "inBandMetadataTrackDispatchType", "mode", "src" ].reduce(((acc, prop, i) => {
                if (track[prop]) acc[prop] = track[prop];
                return acc;
            }), {
                cues: track.cues && Array.prototype.map.call(track.cues, (function(cue) {
                    return {
                        startTime: cue.startTime,
                        endTime: cue.endTime,
                        text: cue.text,
                        id: cue.id
                    };
                }))
            });
            return ret;
        };
        const app_textTracksToJson = function(tech) {
            const trackEls = tech.$$("track");
            const trackObjs = Array.prototype.map.call(trackEls, (t => t.track));
            const tracks = Array.prototype.map.call(trackEls, (function(trackEl) {
                const json = app_trackToJson_(trackEl.track);
                if (trackEl.src) json.src = trackEl.src;
                return json;
            }));
            return tracks.concat(Array.prototype.filter.call(tech.textTracks(), (function(track) {
                return trackObjs.indexOf(track) === -1;
            })).map(app_trackToJson_));
        };
        const app_jsonToTextTracks = function(json, tech) {
            json.forEach((function(track) {
                const addedTrack = tech.addRemoteTextTrack(track).track;
                if (!track.src && track.cues) track.cues.forEach((cue => addedTrack.addCue(cue)));
            }));
            return tech.textTracks();
        };
        var app_textTrackConverter = {
            textTracksToJson: app_textTracksToJson,
            jsonToTextTracks: app_jsonToTextTracks,
            trackToJson_: app_trackToJson_
        };
        const app_MODAL_CLASS_NAME = "vjs-modal-dialog";
        class app_ModalDialog extends app_Component$1 {
            constructor(player, options) {
                super(player, options);
                this.handleKeyDown_ = e => this.handleKeyDown(e);
                this.close_ = e => this.close(e);
                this.opened_ = this.hasBeenOpened_ = this.hasBeenFilled_ = false;
                this.closeable(!this.options_.uncloseable);
                this.content(this.options_.content);
                this.contentEl_ = app_createEl("div", {
                    className: `${app_MODAL_CLASS_NAME}-content`
                }, {
                    role: "document"
                });
                this.descEl_ = app_createEl("p", {
                    className: `${app_MODAL_CLASS_NAME}-description vjs-control-text`,
                    id: this.el().getAttribute("aria-describedby")
                });
                app_textContent(this.descEl_, this.description());
                this.el_.appendChild(this.descEl_);
                this.el_.appendChild(this.contentEl_);
            }
            createEl() {
                return super.createEl("div", {
                    className: this.buildCSSClass(),
                    tabIndex: -1
                }, {
                    "aria-describedby": `${this.id()}_description`,
                    "aria-hidden": "true",
                    "aria-label": this.label(),
                    role: "dialog",
                    "aria-live": "polite"
                });
            }
            dispose() {
                this.contentEl_ = null;
                this.descEl_ = null;
                this.previouslyActiveEl_ = null;
                super.dispose();
            }
            buildCSSClass() {
                return `${app_MODAL_CLASS_NAME} vjs-hidden ${super.buildCSSClass()}`;
            }
            label() {
                return this.localize(this.options_.label || "Modal Window");
            }
            description() {
                let desc = this.options_.description || this.localize("This is a modal window.");
                if (this.closeable()) desc += " " + this.localize("This modal can be closed by pressing the Escape key or activating the close button.");
                return desc;
            }
            open() {
                if (this.opened_) {
                    if (this.options_.fillAlways) this.fill();
                    return;
                }
                const player = this.player();
                this.trigger("beforemodalopen");
                this.opened_ = true;
                if (this.options_.fillAlways || !this.hasBeenOpened_ && !this.hasBeenFilled_) this.fill();
                this.wasPlaying_ = !player.paused();
                if (this.options_.pauseOnOpen && this.wasPlaying_) player.pause();
                this.on("keydown", this.handleKeyDown_);
                this.hadControls_ = player.controls();
                player.controls(false);
                this.show();
                this.conditionalFocus_();
                this.el().setAttribute("aria-hidden", "false");
                this.trigger("modalopen");
                this.hasBeenOpened_ = true;
            }
            opened(value) {
                if (typeof value === "boolean") this[value ? "open" : "close"]();
                return this.opened_;
            }
            close() {
                if (!this.opened_) return;
                const player = this.player();
                this.trigger("beforemodalclose");
                this.opened_ = false;
                if (this.wasPlaying_ && this.options_.pauseOnOpen) player.play();
                this.off("keydown", this.handleKeyDown_);
                if (this.hadControls_) player.controls(true);
                this.hide();
                this.el().setAttribute("aria-hidden", "true");
                this.trigger({
                    type: "modalclose",
                    bubbles: true
                });
                this.conditionalBlur_();
                if (this.options_.temporary) this.dispose();
            }
            closeable(value) {
                if (typeof value === "boolean") {
                    const closeable = this.closeable_ = !!value;
                    let close = this.getChild("closeButton");
                    if (closeable && !close) {
                        const temp = this.contentEl_;
                        this.contentEl_ = this.el_;
                        close = this.addChild("closeButton", {
                            controlText: "Close Modal Dialog"
                        });
                        this.contentEl_ = temp;
                        this.on(close, "close", this.close_);
                    }
                    if (!closeable && close) {
                        this.off(close, "close", this.close_);
                        this.removeChild(close);
                        close.dispose();
                    }
                }
                return this.closeable_;
            }
            fill() {
                this.fillWith(this.content());
            }
            fillWith(content) {
                const contentEl = this.contentEl();
                const parentEl = contentEl.parentNode;
                const nextSiblingEl = contentEl.nextSibling;
                this.trigger("beforemodalfill");
                this.hasBeenFilled_ = true;
                parentEl.removeChild(contentEl);
                this.empty();
                app_insertContent(contentEl, content);
                this.trigger("modalfill");
                if (nextSiblingEl) parentEl.insertBefore(contentEl, nextSiblingEl); else parentEl.appendChild(contentEl);
                const closeButton = this.getChild("closeButton");
                if (closeButton) parentEl.appendChild(closeButton.el_);
                this.trigger("aftermodalfill");
            }
            empty() {
                this.trigger("beforemodalempty");
                app_emptyEl(this.contentEl());
                this.trigger("modalempty");
            }
            content(value) {
                if (typeof value !== "undefined") this.content_ = value;
                return this.content_;
            }
            conditionalFocus_() {
                const activeEl = app_document_default().activeElement;
                const playerEl = this.player_.el_;
                this.previouslyActiveEl_ = null;
                if (playerEl.contains(activeEl) || playerEl === activeEl) {
                    this.previouslyActiveEl_ = activeEl;
                    this.focus();
                }
            }
            conditionalBlur_() {
                if (this.previouslyActiveEl_) {
                    this.previouslyActiveEl_.focus();
                    this.previouslyActiveEl_ = null;
                }
            }
            handleKeyDown(event) {
                this.trigger({
                    type: "modalKeydown",
                    originalEvent: event,
                    target: this,
                    bubbles: true
                });
                event.stopPropagation();
                if (event.key === "Escape" && this.closeable()) {
                    event.preventDefault();
                    this.close();
                    return;
                }
                if (event.key !== "Tab") return;
                const focusableEls = this.focusableEls_();
                const activeEl = this.el_.querySelector(":focus");
                let focusIndex;
                for (let i = 0; i < focusableEls.length; i++) if (activeEl === focusableEls[i]) {
                    focusIndex = i;
                    break;
                }
                if (app_document_default().activeElement === this.el_) focusIndex = 0;
                if (event.shiftKey && focusIndex === 0) {
                    focusableEls[focusableEls.length - 1].focus();
                    event.preventDefault();
                } else if (!event.shiftKey && focusIndex === focusableEls.length - 1) {
                    focusableEls[0].focus();
                    event.preventDefault();
                }
            }
            focusableEls_() {
                const allChildren = this.el_.querySelectorAll("*");
                return Array.prototype.filter.call(allChildren, (child => (child instanceof app_window_default().HTMLAnchorElement || child instanceof app_window_default().HTMLAreaElement) && child.hasAttribute("href") || (child instanceof app_window_default().HTMLInputElement || child instanceof app_window_default().HTMLSelectElement || child instanceof app_window_default().HTMLTextAreaElement || child instanceof app_window_default().HTMLButtonElement) && !child.hasAttribute("disabled") || child instanceof app_window_default().HTMLIFrameElement || child instanceof app_window_default().HTMLObjectElement || child instanceof app_window_default().HTMLEmbedElement || child.hasAttribute("tabindex") && child.getAttribute("tabindex") !== -1 || child.hasAttribute("contenteditable")));
            }
        }
        app_ModalDialog.prototype.options_ = {
            pauseOnOpen: true,
            temporary: true
        };
        app_Component$1.registerComponent("ModalDialog", app_ModalDialog);
        class app_TrackList extends app_EventTarget$2 {
            constructor(tracks = []) {
                super();
                this.tracks_ = [];
                Object.defineProperty(this, "length", {
                    get() {
                        return this.tracks_.length;
                    }
                });
                for (let i = 0; i < tracks.length; i++) this.addTrack(tracks[i]);
            }
            addTrack(track) {
                const index = this.tracks_.length;
                if (!("" + index in this)) Object.defineProperty(this, index, {
                    get() {
                        return this.tracks_[index];
                    }
                });
                if (this.tracks_.indexOf(track) === -1) {
                    this.tracks_.push(track);
                    this.trigger({
                        track,
                        type: "addtrack",
                        target: this
                    });
                }
                track.labelchange_ = () => {
                    this.trigger({
                        track,
                        type: "labelchange",
                        target: this
                    });
                };
                if (app_isEvented(track)) track.addEventListener("labelchange", track.labelchange_);
            }
            removeTrack(rtrack) {
                let track;
                for (let i = 0, l = this.length; i < l; i++) if (this[i] === rtrack) {
                    track = this[i];
                    if (track.off) track.off();
                    this.tracks_.splice(i, 1);
                    break;
                }
                if (!track) return;
                this.trigger({
                    track,
                    type: "removetrack",
                    target: this
                });
            }
            getTrackById(id) {
                let result = null;
                for (let i = 0, l = this.length; i < l; i++) {
                    const track = this[i];
                    if (track.id === id) {
                        result = track;
                        break;
                    }
                }
                return result;
            }
        }
        app_TrackList.prototype.allowedEvents_ = {
            change: "change",
            addtrack: "addtrack",
            removetrack: "removetrack",
            labelchange: "labelchange"
        };
        for (const event in app_TrackList.prototype.allowedEvents_) app_TrackList.prototype["on" + event] = null;
        const app_disableOthers$1 = function(list, track) {
            for (let i = 0; i < list.length; i++) {
                if (!Object.keys(list[i]).length || track.id === list[i].id) continue;
                list[i].enabled = false;
            }
        };
        class app_AudioTrackList extends app_TrackList {
            constructor(tracks = []) {
                for (let i = tracks.length - 1; i >= 0; i--) if (tracks[i].enabled) {
                    app_disableOthers$1(tracks, tracks[i]);
                    break;
                }
                super(tracks);
                this.changing_ = false;
            }
            addTrack(track) {
                if (track.enabled) app_disableOthers$1(this, track);
                super.addTrack(track);
                if (!track.addEventListener) return;
                track.enabledChange_ = () => {
                    if (this.changing_) return;
                    this.changing_ = true;
                    app_disableOthers$1(this, track);
                    this.changing_ = false;
                    this.trigger("change");
                };
                track.addEventListener("enabledchange", track.enabledChange_);
            }
            removeTrack(rtrack) {
                super.removeTrack(rtrack);
                if (rtrack.removeEventListener && rtrack.enabledChange_) {
                    rtrack.removeEventListener("enabledchange", rtrack.enabledChange_);
                    rtrack.enabledChange_ = null;
                }
            }
        }
        const app_disableOthers = function(list, track) {
            for (let i = 0; i < list.length; i++) {
                if (!Object.keys(list[i]).length || track.id === list[i].id) continue;
                list[i].selected = false;
            }
        };
        class app_VideoTrackList extends app_TrackList {
            constructor(tracks = []) {
                for (let i = tracks.length - 1; i >= 0; i--) if (tracks[i].selected) {
                    app_disableOthers(tracks, tracks[i]);
                    break;
                }
                super(tracks);
                this.changing_ = false;
                Object.defineProperty(this, "selectedIndex", {
                    get() {
                        for (let i = 0; i < this.length; i++) if (this[i].selected) return i;
                        return -1;
                    },
                    set() {}
                });
            }
            addTrack(track) {
                if (track.selected) app_disableOthers(this, track);
                super.addTrack(track);
                if (!track.addEventListener) return;
                track.selectedChange_ = () => {
                    if (this.changing_) return;
                    this.changing_ = true;
                    app_disableOthers(this, track);
                    this.changing_ = false;
                    this.trigger("change");
                };
                track.addEventListener("selectedchange", track.selectedChange_);
            }
            removeTrack(rtrack) {
                super.removeTrack(rtrack);
                if (rtrack.removeEventListener && rtrack.selectedChange_) {
                    rtrack.removeEventListener("selectedchange", rtrack.selectedChange_);
                    rtrack.selectedChange_ = null;
                }
            }
        }
        class app_TextTrackList extends app_TrackList {
            addTrack(track) {
                super.addTrack(track);
                if (!this.queueChange_) this.queueChange_ = () => this.queueTrigger("change");
                if (!this.triggerSelectedlanguagechange) this.triggerSelectedlanguagechange_ = () => this.trigger("selectedlanguagechange");
                track.addEventListener("modechange", this.queueChange_);
                const nonLanguageTextTrackKind = [ "metadata", "chapters" ];
                if (nonLanguageTextTrackKind.indexOf(track.kind) === -1) track.addEventListener("modechange", this.triggerSelectedlanguagechange_);
            }
            removeTrack(rtrack) {
                super.removeTrack(rtrack);
                if (rtrack.removeEventListener) {
                    if (this.queueChange_) rtrack.removeEventListener("modechange", this.queueChange_);
                    if (this.selectedlanguagechange_) rtrack.removeEventListener("modechange", this.triggerSelectedlanguagechange_);
                }
            }
        }
        class app_HtmlTrackElementList {
            constructor(trackElements = []) {
                this.trackElements_ = [];
                Object.defineProperty(this, "length", {
                    get() {
                        return this.trackElements_.length;
                    }
                });
                for (let i = 0, length = trackElements.length; i < length; i++) this.addTrackElement_(trackElements[i]);
            }
            addTrackElement_(trackElement) {
                const index = this.trackElements_.length;
                if (!("" + index in this)) Object.defineProperty(this, index, {
                    get() {
                        return this.trackElements_[index];
                    }
                });
                if (this.trackElements_.indexOf(trackElement) === -1) this.trackElements_.push(trackElement);
            }
            getTrackElementByTrack_(track) {
                let trackElement_;
                for (let i = 0, length = this.trackElements_.length; i < length; i++) if (track === this.trackElements_[i].track) {
                    trackElement_ = this.trackElements_[i];
                    break;
                }
                return trackElement_;
            }
            removeTrackElement_(trackElement) {
                for (let i = 0, length = this.trackElements_.length; i < length; i++) if (trackElement === this.trackElements_[i]) {
                    if (this.trackElements_[i].track && typeof this.trackElements_[i].track.off === "function") this.trackElements_[i].track.off();
                    if (typeof this.trackElements_[i].off === "function") this.trackElements_[i].off();
                    this.trackElements_.splice(i, 1);
                    break;
                }
            }
        }
        class app_TextTrackCueList {
            constructor(cues) {
                app_TextTrackCueList.prototype.setCues_.call(this, cues);
                Object.defineProperty(this, "length", {
                    get() {
                        return this.length_;
                    }
                });
            }
            setCues_(cues) {
                const oldLength = this.length || 0;
                let i = 0;
                const l = cues.length;
                this.cues_ = cues;
                this.length_ = cues.length;
                const defineProp = function(index) {
                    if (!("" + index in this)) Object.defineProperty(this, "" + index, {
                        get() {
                            return this.cues_[index];
                        }
                    });
                };
                if (oldLength < l) {
                    i = oldLength;
                    for (;i < l; i++) defineProp.call(this, i);
                }
            }
            getCueById(id) {
                let result = null;
                for (let i = 0, l = this.length; i < l; i++) {
                    const cue = this[i];
                    if (cue.id === id) {
                        result = cue;
                        break;
                    }
                }
                return result;
            }
        }
        const app_VideoTrackKind = {
            alternative: "alternative",
            captions: "captions",
            main: "main",
            sign: "sign",
            subtitles: "subtitles",
            commentary: "commentary"
        };
        const app_AudioTrackKind = {
            alternative: "alternative",
            descriptions: "descriptions",
            main: "main",
            "main-desc": "main-desc",
            translation: "translation",
            commentary: "commentary"
        };
        const app_TextTrackKind = {
            subtitles: "subtitles",
            captions: "captions",
            descriptions: "descriptions",
            chapters: "chapters",
            metadata: "metadata"
        };
        const app_TextTrackMode = {
            disabled: "disabled",
            hidden: "hidden",
            showing: "showing"
        };
        class app_Track extends app_EventTarget$2 {
            constructor(options = {}) {
                super();
                const trackProps = {
                    id: options.id || "vjs_track_" + app_newGUID(),
                    kind: options.kind || "",
                    language: options.language || ""
                };
                let label = options.label || "";
                for (const key in trackProps) Object.defineProperty(this, key, {
                    get() {
                        return trackProps[key];
                    },
                    set() {}
                });
                Object.defineProperty(this, "label", {
                    get() {
                        return label;
                    },
                    set(newLabel) {
                        if (newLabel !== label) {
                            label = newLabel;
                            this.trigger("labelchange");
                        }
                    }
                });
            }
        }
        const app_parseUrl = function(url) {
            return new URL(url, app_document_default().baseURI);
        };
        const app_getAbsoluteURL = function(url) {
            return new URL(url, app_document_default().baseURI).href;
        };
        const app_getFileExtension = function(path) {
            if (typeof path === "string") {
                const splitPathRe = /^(\/?)([\s\S]*?)((?:\.{1,2}|[^\/]+?)(\.([^\.\/\?]+)))(?:[\/]*|[\?].*)$/;
                const pathParts = splitPathRe.exec(path);
                if (pathParts) return pathParts.pop().toLowerCase();
            }
            return "";
        };
        const app_isCrossOrigin = function(url, winLoc = app_window_default().location) {
            return app_parseUrl(url).origin !== winLoc.origin;
        };
        var app_Url = Object.freeze({
            __proto__: null,
            parseUrl: app_parseUrl,
            getAbsoluteURL: app_getAbsoluteURL,
            getFileExtension: app_getFileExtension,
            isCrossOrigin: app_isCrossOrigin
        });
        const app_parseCues = function(srcContent, track) {
            const parser = new (app_window_default().WebVTT.Parser)(app_window_default(), app_window_default().vttjs, app_window_default().WebVTT.StringDecoder());
            const errors = [];
            parser.oncue = function(cue) {
                track.addCue(cue);
            };
            parser.onparsingerror = function(error) {
                errors.push(error);
            };
            parser.onflush = function() {
                track.trigger({
                    type: "loadeddata",
                    target: track
                });
            };
            parser.parse(srcContent);
            if (errors.length > 0) {
                if (app_window_default().console && app_window_default().console.groupCollapsed) app_window_default().console.groupCollapsed(`Text Track parsing errors for ${track.src}`);
                errors.forEach((error => app_log$1.error(error)));
                if (app_window_default().console && app_window_default().console.groupEnd) app_window_default().console.groupEnd();
            }
            parser.flush();
        };
        const app_loadTrack = function(src, track) {
            const opts = {
                uri: src
            };
            const crossOrigin = app_isCrossOrigin(src);
            if (crossOrigin) opts.cors = crossOrigin;
            const withCredentials = track.tech_.crossOrigin() === "use-credentials";
            if (withCredentials) opts.withCredentials = withCredentials;
            app_lib_default()(opts, app_bind_(this, (function(err, response, responseBody) {
                if (err) return app_log$1.error(err, response);
                track.loaded_ = true;
                if (typeof app_window_default().WebVTT !== "function") {
                    if (track.tech_) track.tech_.any([ "vttjsloaded", "vttjserror" ], (event => {
                        if (event.type === "vttjserror") {
                            app_log$1.error(`vttjs failed to load, stopping trying to process ${track.src}`);
                            return;
                        }
                        return app_parseCues(responseBody, track);
                    }));
                } else app_parseCues(responseBody, track);
            })));
        };
        class app_TextTrack extends app_Track {
            constructor(options = {}) {
                if (!options.tech) throw new Error("A tech was not provided.");
                const settings = app_merge$1(options, {
                    kind: app_TextTrackKind[options.kind] || "subtitles",
                    language: options.language || options.srclang || ""
                });
                let mode = app_TextTrackMode[settings.mode] || "disabled";
                const default_ = settings.default;
                if (settings.kind === "metadata" || settings.kind === "chapters") mode = "hidden";
                super(settings);
                this.tech_ = settings.tech;
                this.cues_ = [];
                this.activeCues_ = [];
                this.preload_ = this.tech_.preloadTextTracks !== false;
                const cues = new app_TextTrackCueList(this.cues_);
                const activeCues = new app_TextTrackCueList(this.activeCues_);
                let changed = false;
                this.timeupdateHandler = app_bind_(this, (function(event = {}) {
                    if (this.tech_.isDisposed()) return;
                    if (!this.tech_.isReady_) {
                        if (event.type !== "timeupdate") this.rvf_ = this.tech_.requestVideoFrameCallback(this.timeupdateHandler);
                        return;
                    }
                    this.activeCues = this.activeCues;
                    if (changed) {
                        this.trigger("cuechange");
                        changed = false;
                    }
                    if (event.type !== "timeupdate") this.rvf_ = this.tech_.requestVideoFrameCallback(this.timeupdateHandler);
                }));
                const disposeHandler = () => {
                    this.stopTracking();
                };
                this.tech_.one("dispose", disposeHandler);
                if (mode !== "disabled") this.startTracking();
                Object.defineProperties(this, {
                    default: {
                        get() {
                            return default_;
                        },
                        set() {}
                    },
                    mode: {
                        get() {
                            return mode;
                        },
                        set(newMode) {
                            if (!app_TextTrackMode[newMode]) return;
                            if (mode === newMode) return;
                            mode = newMode;
                            if (!this.preload_ && mode !== "disabled" && this.cues.length === 0) app_loadTrack(this.src, this);
                            this.stopTracking();
                            if (mode !== "disabled") this.startTracking();
                            this.trigger("modechange");
                        }
                    },
                    cues: {
                        get() {
                            if (!this.loaded_) return null;
                            return cues;
                        },
                        set() {}
                    },
                    activeCues: {
                        get() {
                            if (!this.loaded_) return null;
                            if (this.cues.length === 0) return activeCues;
                            const ct = this.tech_.currentTime();
                            const active = [];
                            for (let i = 0, l = this.cues.length; i < l; i++) {
                                const cue = this.cues[i];
                                if (cue.startTime <= ct && cue.endTime >= ct) active.push(cue);
                            }
                            changed = false;
                            if (active.length !== this.activeCues_.length) changed = true; else for (let i = 0; i < active.length; i++) if (this.activeCues_.indexOf(active[i]) === -1) changed = true;
                            this.activeCues_ = active;
                            activeCues.setCues_(this.activeCues_);
                            return activeCues;
                        },
                        set() {}
                    }
                });
                if (settings.src) {
                    this.src = settings.src;
                    if (!this.preload_) this.loaded_ = true;
                    if (this.preload_ || settings.kind !== "subtitles" && settings.kind !== "captions") app_loadTrack(this.src, this);
                } else this.loaded_ = true;
            }
            startTracking() {
                this.rvf_ = this.tech_.requestVideoFrameCallback(this.timeupdateHandler);
                this.tech_.on("timeupdate", this.timeupdateHandler);
            }
            stopTracking() {
                if (this.rvf_) {
                    this.tech_.cancelVideoFrameCallback(this.rvf_);
                    this.rvf_ = void 0;
                }
                this.tech_.off("timeupdate", this.timeupdateHandler);
            }
            addCue(originalCue) {
                let cue = originalCue;
                if (!("getCueAsHTML" in cue)) {
                    cue = new (app_window_default().vttjs.VTTCue)(originalCue.startTime, originalCue.endTime, originalCue.text);
                    for (const prop in originalCue) if (!(prop in cue)) cue[prop] = originalCue[prop];
                    cue.id = originalCue.id;
                    cue.originalCue_ = originalCue;
                }
                const tracks = this.tech_.textTracks();
                for (let i = 0; i < tracks.length; i++) if (tracks[i] !== this) tracks[i].removeCue(cue);
                this.cues_.push(cue);
                this.cues.setCues_(this.cues_);
            }
            removeCue(removeCue) {
                let i = this.cues_.length;
                while (i--) {
                    const cue = this.cues_[i];
                    if (cue === removeCue || cue.originalCue_ && cue.originalCue_ === removeCue) {
                        this.cues_.splice(i, 1);
                        this.cues.setCues_(this.cues_);
                        break;
                    }
                }
            }
        }
        app_TextTrack.prototype.allowedEvents_ = {
            cuechange: "cuechange"
        };
        class app_AudioTrack extends app_Track {
            constructor(options = {}) {
                const settings = app_merge$1(options, {
                    kind: app_AudioTrackKind[options.kind] || ""
                });
                super(settings);
                let enabled = false;
                Object.defineProperty(this, "enabled", {
                    get() {
                        return enabled;
                    },
                    set(newEnabled) {
                        if (typeof newEnabled !== "boolean" || newEnabled === enabled) return;
                        enabled = newEnabled;
                        this.trigger("enabledchange");
                    }
                });
                if (settings.enabled) this.enabled = settings.enabled;
                this.loaded_ = true;
            }
        }
        class app_VideoTrack extends app_Track {
            constructor(options = {}) {
                const settings = app_merge$1(options, {
                    kind: app_VideoTrackKind[options.kind] || ""
                });
                super(settings);
                let selected = false;
                Object.defineProperty(this, "selected", {
                    get() {
                        return selected;
                    },
                    set(newSelected) {
                        if (typeof newSelected !== "boolean" || newSelected === selected) return;
                        selected = newSelected;
                        this.trigger("selectedchange");
                    }
                });
                if (settings.selected) this.selected = settings.selected;
            }
        }
        class app_HTMLTrackElement extends app_EventTarget$2 {
            constructor(options = {}) {
                super();
                let readyState;
                const track = new app_TextTrack(options);
                this.kind = track.kind;
                this.src = track.src;
                this.srclang = track.language;
                this.label = track.label;
                this.default = track.default;
                Object.defineProperties(this, {
                    readyState: {
                        get() {
                            return readyState;
                        }
                    },
                    track: {
                        get() {
                            return track;
                        }
                    }
                });
                readyState = app_HTMLTrackElement.NONE;
                track.addEventListener("loadeddata", (() => {
                    readyState = app_HTMLTrackElement.LOADED;
                    this.trigger({
                        type: "load",
                        target: this
                    });
                }));
            }
        }
        app_HTMLTrackElement.prototype.allowedEvents_ = {
            load: "load"
        };
        app_HTMLTrackElement.NONE = 0;
        app_HTMLTrackElement.LOADING = 1;
        app_HTMLTrackElement.LOADED = 2;
        app_HTMLTrackElement.ERROR = 3;
        const app_NORMAL = {
            audio: {
                ListClass: app_AudioTrackList,
                TrackClass: app_AudioTrack,
                capitalName: "Audio"
            },
            video: {
                ListClass: app_VideoTrackList,
                TrackClass: app_VideoTrack,
                capitalName: "Video"
            },
            text: {
                ListClass: app_TextTrackList,
                TrackClass: app_TextTrack,
                capitalName: "Text"
            }
        };
        Object.keys(app_NORMAL).forEach((function(type) {
            app_NORMAL[type].getterName = `${type}Tracks`;
            app_NORMAL[type].privateName = `${type}Tracks_`;
        }));
        const app_REMOTE = {
            remoteText: {
                ListClass: app_TextTrackList,
                TrackClass: app_TextTrack,
                capitalName: "RemoteText",
                getterName: "remoteTextTracks",
                privateName: "remoteTextTracks_"
            },
            remoteTextEl: {
                ListClass: app_HtmlTrackElementList,
                TrackClass: app_HTMLTrackElement,
                capitalName: "RemoteTextTrackEls",
                getterName: "remoteTextTrackEls",
                privateName: "remoteTextTrackEls_"
            }
        };
        const app_ALL = Object.assign({}, app_NORMAL, app_REMOTE);
        app_REMOTE.names = Object.keys(app_REMOTE);
        app_NORMAL.names = Object.keys(app_NORMAL);
        app_ALL.names = [].concat(app_REMOTE.names).concat(app_NORMAL.names);
        function app_createTrackHelper(self, kind, label, language, options = {}) {
            const tracks = self.textTracks();
            options.kind = kind;
            if (label) options.label = label;
            if (language) options.language = language;
            options.tech = self;
            const track = new app_ALL.text.TrackClass(options);
            tracks.addTrack(track);
            return track;
        }
        class app_Tech extends app_Component$1 {
            constructor(options = {}, ready = function() {}) {
                options.reportTouchActivity = false;
                super(null, options, ready);
                this.onDurationChange_ = e => this.onDurationChange(e);
                this.trackProgress_ = e => this.trackProgress(e);
                this.trackCurrentTime_ = e => this.trackCurrentTime(e);
                this.stopTrackingCurrentTime_ = e => this.stopTrackingCurrentTime(e);
                this.disposeSourceHandler_ = e => this.disposeSourceHandler(e);
                this.queuedHanders_ = new Set;
                this.hasStarted_ = false;
                this.on("playing", (function() {
                    this.hasStarted_ = true;
                }));
                this.on("loadstart", (function() {
                    this.hasStarted_ = false;
                }));
                app_ALL.names.forEach((name => {
                    const props = app_ALL[name];
                    if (options && options[props.getterName]) this[props.privateName] = options[props.getterName];
                }));
                if (!this.featuresProgressEvents) this.manualProgressOn();
                if (!this.featuresTimeupdateEvents) this.manualTimeUpdatesOn();
                [ "Text", "Audio", "Video" ].forEach((track => {
                    if (options[`native${track}Tracks`] === false) this[`featuresNative${track}Tracks`] = false;
                }));
                if (options.nativeCaptions === false || options.nativeTextTracks === false) this.featuresNativeTextTracks = false; else if (options.nativeCaptions === true || options.nativeTextTracks === true) this.featuresNativeTextTracks = true;
                if (!this.featuresNativeTextTracks) this.emulateTextTracks();
                this.preloadTextTracks = options.preloadTextTracks !== false;
                this.autoRemoteTextTracks_ = new app_ALL.text.ListClass;
                this.initTrackListeners();
                if (!options.nativeControlsForTouch) this.emitTapEvents();
                if (this.constructor) this.name_ = this.constructor.name || "Unknown Tech";
            }
            triggerSourceset(src) {
                if (!this.isReady_) this.one("ready", (() => this.setTimeout((() => this.triggerSourceset(src)), 1)));
                this.trigger({
                    src,
                    type: "sourceset"
                });
            }
            manualProgressOn() {
                this.on("durationchange", this.onDurationChange_);
                this.manualProgress = true;
                this.one("ready", this.trackProgress_);
            }
            manualProgressOff() {
                this.manualProgress = false;
                this.stopTrackingProgress();
                this.off("durationchange", this.onDurationChange_);
            }
            trackProgress(event) {
                this.stopTrackingProgress();
                this.progressInterval = this.setInterval(app_bind_(this, (function() {
                    const numBufferedPercent = this.bufferedPercent();
                    if (this.bufferedPercent_ !== numBufferedPercent) this.trigger("progress");
                    this.bufferedPercent_ = numBufferedPercent;
                    if (numBufferedPercent === 1) this.stopTrackingProgress();
                })), 500);
            }
            onDurationChange(event) {
                this.duration_ = this.duration();
            }
            buffered() {
                return app_createTimeRanges$1(0, 0);
            }
            bufferedPercent() {
                return app_bufferedPercent(this.buffered(), this.duration_);
            }
            stopTrackingProgress() {
                this.clearInterval(this.progressInterval);
            }
            manualTimeUpdatesOn() {
                this.manualTimeUpdates = true;
                this.on("play", this.trackCurrentTime_);
                this.on("pause", this.stopTrackingCurrentTime_);
            }
            manualTimeUpdatesOff() {
                this.manualTimeUpdates = false;
                this.stopTrackingCurrentTime();
                this.off("play", this.trackCurrentTime_);
                this.off("pause", this.stopTrackingCurrentTime_);
            }
            trackCurrentTime() {
                if (this.currentTimeInterval) this.stopTrackingCurrentTime();
                this.currentTimeInterval = this.setInterval((function() {
                    this.trigger({
                        type: "timeupdate",
                        target: this,
                        manuallyTriggered: true
                    });
                }), 250);
            }
            stopTrackingCurrentTime() {
                this.clearInterval(this.currentTimeInterval);
                this.trigger({
                    type: "timeupdate",
                    target: this,
                    manuallyTriggered: true
                });
            }
            dispose() {
                this.clearTracks(app_NORMAL.names);
                if (this.manualProgress) this.manualProgressOff();
                if (this.manualTimeUpdates) this.manualTimeUpdatesOff();
                super.dispose();
            }
            clearTracks(types) {
                types = [].concat(types);
                types.forEach((type => {
                    const list = this[`${type}Tracks`]() || [];
                    let i = list.length;
                    while (i--) {
                        const track = list[i];
                        if (type === "text") this.removeRemoteTextTrack(track);
                        list.removeTrack(track);
                    }
                }));
            }
            cleanupAutoTextTracks() {
                const list = this.autoRemoteTextTracks_ || [];
                let i = list.length;
                while (i--) {
                    const track = list[i];
                    this.removeRemoteTextTrack(track);
                }
            }
            reset() {}
            crossOrigin() {}
            setCrossOrigin() {}
            error(err) {
                if (err !== void 0) {
                    this.error_ = new app_MediaError(err);
                    this.trigger("error");
                }
                return this.error_;
            }
            played() {
                if (this.hasStarted_) return app_createTimeRanges$1(0, 0);
                return app_createTimeRanges$1();
            }
            play() {}
            setScrubbing(_isScrubbing) {}
            scrubbing() {}
            setCurrentTime(_seconds) {
                if (this.manualTimeUpdates) this.trigger({
                    type: "timeupdate",
                    target: this,
                    manuallyTriggered: true
                });
            }
            initTrackListeners() {
                app_NORMAL.names.forEach((name => {
                    const props = app_NORMAL[name];
                    const trackListChanges = () => {
                        this.trigger(`${name}trackchange`);
                    };
                    const tracks = this[props.getterName]();
                    tracks.addEventListener("removetrack", trackListChanges);
                    tracks.addEventListener("addtrack", trackListChanges);
                    this.on("dispose", (() => {
                        tracks.removeEventListener("removetrack", trackListChanges);
                        tracks.removeEventListener("addtrack", trackListChanges);
                    }));
                }));
            }
            addWebVttScript_() {
                if (app_window_default().WebVTT) return;
                if (app_document_default().body.contains(this.el())) {
                    if (!this.options_["vtt.js"] && app_isPlain(app_browser_index_default()) && Object.keys(app_browser_index_default()).length > 0) {
                        this.trigger("vttjsloaded");
                        return;
                    }
                    const script = app_document_default().createElement("script");
                    script.src = this.options_["vtt.js"] || "https://vjs.zencdn.net/vttjs/0.14.1/vtt.min.js";
                    script.onload = () => {
                        this.trigger("vttjsloaded");
                    };
                    script.onerror = () => {
                        this.trigger("vttjserror");
                    };
                    this.on("dispose", (() => {
                        script.onload = null;
                        script.onerror = null;
                    }));
                    app_window_default().WebVTT = true;
                    this.el().parentNode.appendChild(script);
                } else this.ready(this.addWebVttScript_);
            }
            emulateTextTracks() {
                const tracks = this.textTracks();
                const remoteTracks = this.remoteTextTracks();
                const handleAddTrack = e => tracks.addTrack(e.track);
                const handleRemoveTrack = e => tracks.removeTrack(e.track);
                remoteTracks.on("addtrack", handleAddTrack);
                remoteTracks.on("removetrack", handleRemoveTrack);
                this.addWebVttScript_();
                const updateDisplay = () => this.trigger("texttrackchange");
                const textTracksChanges = () => {
                    updateDisplay();
                    for (let i = 0; i < tracks.length; i++) {
                        const track = tracks[i];
                        track.removeEventListener("cuechange", updateDisplay);
                        if (track.mode === "showing") track.addEventListener("cuechange", updateDisplay);
                    }
                };
                textTracksChanges();
                tracks.addEventListener("change", textTracksChanges);
                tracks.addEventListener("addtrack", textTracksChanges);
                tracks.addEventListener("removetrack", textTracksChanges);
                this.on("dispose", (function() {
                    remoteTracks.off("addtrack", handleAddTrack);
                    remoteTracks.off("removetrack", handleRemoveTrack);
                    tracks.removeEventListener("change", textTracksChanges);
                    tracks.removeEventListener("addtrack", textTracksChanges);
                    tracks.removeEventListener("removetrack", textTracksChanges);
                    for (let i = 0; i < tracks.length; i++) {
                        const track = tracks[i];
                        track.removeEventListener("cuechange", updateDisplay);
                    }
                }));
            }
            addTextTrack(kind, label, language) {
                if (!kind) throw new Error("TextTrack kind is required but was not provided");
                return app_createTrackHelper(this, kind, label, language);
            }
            createRemoteTextTrack(options) {
                const track = app_merge$1(options, {
                    tech: this
                });
                return new app_REMOTE.remoteTextEl.TrackClass(track);
            }
            addRemoteTextTrack(options = {}, manualCleanup) {
                const htmlTrackElement = this.createRemoteTextTrack(options);
                if (typeof manualCleanup !== "boolean") manualCleanup = false;
                this.remoteTextTrackEls().addTrackElement_(htmlTrackElement);
                this.remoteTextTracks().addTrack(htmlTrackElement.track);
                if (manualCleanup === false) this.ready((() => this.autoRemoteTextTracks_.addTrack(htmlTrackElement.track)));
                return htmlTrackElement;
            }
            removeRemoteTextTrack(track) {
                const trackElement = this.remoteTextTrackEls().getTrackElementByTrack_(track);
                this.remoteTextTrackEls().removeTrackElement_(trackElement);
                this.remoteTextTracks().removeTrack(track);
                this.autoRemoteTextTracks_.removeTrack(track);
            }
            getVideoPlaybackQuality() {
                return {};
            }
            requestPictureInPicture() {
                return Promise.reject();
            }
            disablePictureInPicture() {
                return true;
            }
            setDisablePictureInPicture() {}
            requestVideoFrameCallback(cb) {
                const id = app_newGUID();
                if (!this.isReady_ || this.paused()) {
                    this.queuedHanders_.add(id);
                    this.one("playing", (() => {
                        if (this.queuedHanders_.has(id)) {
                            this.queuedHanders_.delete(id);
                            cb();
                        }
                    }));
                } else this.requestNamedAnimationFrame(id, cb);
                return id;
            }
            cancelVideoFrameCallback(id) {
                if (this.queuedHanders_.has(id)) this.queuedHanders_.delete(id); else this.cancelNamedAnimationFrame(id);
            }
            setPoster() {}
            playsinline() {}
            setPlaysinline() {}
            overrideNativeAudioTracks(override) {}
            overrideNativeVideoTracks(override) {}
            canPlayType(_type) {
                return "";
            }
            static canPlayType(_type) {
                return "";
            }
            static canPlaySource(srcObj, options) {
                return app_Tech.canPlayType(srcObj.type);
            }
            static isTech(component) {
                return component.prototype instanceof app_Tech || component instanceof app_Tech || component === app_Tech;
            }
            static registerTech(name, tech) {
                if (!app_Tech.techs_) app_Tech.techs_ = {};
                if (!app_Tech.isTech(tech)) throw new Error(`Tech ${name} must be a Tech`);
                if (!app_Tech.canPlayType) throw new Error("Techs must have a static canPlayType method on them");
                if (!app_Tech.canPlaySource) throw new Error("Techs must have a static canPlaySource method on them");
                name = app_toTitleCase$1(name);
                app_Tech.techs_[name] = tech;
                app_Tech.techs_[app_toLowerCase(name)] = tech;
                if (name !== "Tech") app_Tech.defaultTechOrder_.push(name);
                return tech;
            }
            static getTech(name) {
                if (!name) return;
                if (app_Tech.techs_ && app_Tech.techs_[name]) return app_Tech.techs_[name];
                name = app_toTitleCase$1(name);
                if (app_window_default() && app_window_default().videojs && app_window_default().videojs[name]) {
                    app_log$1.warn(`The ${name} tech was added to the videojs object when it should be registered using videojs.registerTech(name, tech)`);
                    return app_window_default().videojs[name];
                }
            }
        }
        app_ALL.names.forEach((function(name) {
            const props = app_ALL[name];
            app_Tech.prototype[props.getterName] = function() {
                this[props.privateName] = this[props.privateName] || new props.ListClass;
                return this[props.privateName];
            };
        }));
        app_Tech.prototype.featuresVolumeControl = true;
        app_Tech.prototype.featuresMuteControl = true;
        app_Tech.prototype.featuresFullscreenResize = false;
        app_Tech.prototype.featuresPlaybackRate = false;
        app_Tech.prototype.featuresProgressEvents = false;
        app_Tech.prototype.featuresSourceset = false;
        app_Tech.prototype.featuresTimeupdateEvents = false;
        app_Tech.prototype.featuresNativeTextTracks = false;
        app_Tech.prototype.featuresVideoFrameCallback = false;
        app_Tech.withSourceHandlers = function(_Tech) {
            _Tech.registerSourceHandler = function(handler, index) {
                let handlers = _Tech.sourceHandlers;
                if (!handlers) handlers = _Tech.sourceHandlers = [];
                if (index === void 0) index = handlers.length;
                handlers.splice(index, 0, handler);
            };
            _Tech.canPlayType = function(type) {
                const handlers = _Tech.sourceHandlers || [];
                let can;
                for (let i = 0; i < handlers.length; i++) {
                    can = handlers[i].canPlayType(type);
                    if (can) return can;
                }
                return "";
            };
            _Tech.selectSourceHandler = function(source, options) {
                const handlers = _Tech.sourceHandlers || [];
                let can;
                for (let i = 0; i < handlers.length; i++) {
                    can = handlers[i].canHandleSource(source, options);
                    if (can) return handlers[i];
                }
                return null;
            };
            _Tech.canPlaySource = function(srcObj, options) {
                const sh = _Tech.selectSourceHandler(srcObj, options);
                if (sh) return sh.canHandleSource(srcObj, options);
                return "";
            };
            const deferrable = [ "seekable", "seeking", "duration" ];
            deferrable.forEach((function(fnName) {
                const originalFn = this[fnName];
                if (typeof originalFn !== "function") return;
                this[fnName] = function() {
                    if (this.sourceHandler_ && this.sourceHandler_[fnName]) return this.sourceHandler_[fnName].apply(this.sourceHandler_, arguments);
                    return originalFn.apply(this, arguments);
                };
            }), _Tech.prototype);
            _Tech.prototype.setSource = function(source) {
                let sh = _Tech.selectSourceHandler(source, this.options_);
                if (!sh) if (_Tech.nativeSourceHandler) sh = _Tech.nativeSourceHandler; else app_log$1.error("No source handler found for the current source.");
                this.disposeSourceHandler();
                this.off("dispose", this.disposeSourceHandler_);
                if (sh !== _Tech.nativeSourceHandler) this.currentSource_ = source;
                this.sourceHandler_ = sh.handleSource(source, this, this.options_);
                this.one("dispose", this.disposeSourceHandler_);
            };
            _Tech.prototype.disposeSourceHandler = function() {
                if (this.currentSource_) {
                    this.clearTracks([ "audio", "video" ]);
                    this.currentSource_ = null;
                }
                this.cleanupAutoTextTracks();
                if (this.sourceHandler_) {
                    if (this.sourceHandler_.dispose) this.sourceHandler_.dispose();
                    this.sourceHandler_ = null;
                }
            };
        };
        app_Component$1.registerComponent("Tech", app_Tech);
        app_Tech.registerTech("Tech", app_Tech);
        app_Tech.defaultTechOrder_ = [];
        const app_middlewares = {};
        const app_middlewareInstances = {};
        const app_TERMINATOR = {};
        function app_use(type, middleware) {
            app_middlewares[type] = app_middlewares[type] || [];
            app_middlewares[type].push(middleware);
        }
        function app_setSource(player, src, next) {
            player.setTimeout((() => app_setSourceHelper(src, app_middlewares[src.type], next, player)), 1);
        }
        function app_setTech(middleware, tech) {
            middleware.forEach((mw => mw.setTech && mw.setTech(tech)));
        }
        function app_get(middleware, tech, method) {
            return middleware.reduceRight(app_middlewareIterator(method), tech[method]());
        }
        function app_set(middleware, tech, method, arg) {
            return tech[method](middleware.reduce(app_middlewareIterator(method), arg));
        }
        function app_mediate(middleware, tech, method, arg = null) {
            const callMethod = "call" + app_toTitleCase$1(method);
            const middlewareValue = middleware.reduce(app_middlewareIterator(callMethod), arg);
            const terminated = middlewareValue === app_TERMINATOR;
            const returnValue = terminated ? null : tech[method](middlewareValue);
            app_executeRight(middleware, method, returnValue, terminated);
            return returnValue;
        }
        const app_allowedGetters = {
            buffered: 1,
            currentTime: 1,
            duration: 1,
            muted: 1,
            played: 1,
            paused: 1,
            seekable: 1,
            volume: 1,
            ended: 1
        };
        const app_allowedSetters = {
            setCurrentTime: 1,
            setMuted: 1,
            setVolume: 1
        };
        const app_allowedMediators = {
            play: 1,
            pause: 1
        };
        function app_middlewareIterator(method) {
            return (value, mw) => {
                if (value === app_TERMINATOR) return app_TERMINATOR;
                if (mw[method]) return mw[method](value);
                return value;
            };
        }
        function app_executeRight(mws, method, value, terminated) {
            for (let i = mws.length - 1; i >= 0; i--) {
                const mw = mws[i];
                if (mw[method]) mw[method](terminated, value);
            }
        }
        function app_clearCacheForPlayer(player) {
            if (app_middlewareInstances.hasOwnProperty(player.id())) delete app_middlewareInstances[player.id()];
        }
        function app_getOrCreateFactory(player, mwFactory) {
            const mws = app_middlewareInstances[player.id()];
            let mw = null;
            if (mws === void 0 || mws === null) {
                mw = mwFactory(player);
                app_middlewareInstances[player.id()] = [ [ mwFactory, mw ] ];
                return mw;
            }
            for (let i = 0; i < mws.length; i++) {
                const [mwf, mwi] = mws[i];
                if (mwf !== mwFactory) continue;
                mw = mwi;
            }
            if (mw === null) {
                mw = mwFactory(player);
                mws.push([ mwFactory, mw ]);
            }
            return mw;
        }
        function app_setSourceHelper(src = {}, middleware = [], next, player, acc = [], lastRun = false) {
            const [mwFactory, ...mwrest] = middleware;
            if (typeof mwFactory === "string") app_setSourceHelper(src, app_middlewares[mwFactory], next, player, acc, lastRun); else if (mwFactory) {
                const mw = app_getOrCreateFactory(player, mwFactory);
                if (!mw.setSource) {
                    acc.push(mw);
                    return app_setSourceHelper(src, mwrest, next, player, acc, lastRun);
                }
                mw.setSource(Object.assign({}, src), (function(err, _src) {
                    if (err) return app_setSourceHelper(src, mwrest, next, player, acc, lastRun);
                    acc.push(mw);
                    app_setSourceHelper(_src, src.type === _src.type ? mwrest : app_middlewares[_src.type], next, player, acc, lastRun);
                }));
            } else if (mwrest.length) app_setSourceHelper(src, mwrest, next, player, acc, lastRun); else if (lastRun) next(src, acc); else app_setSourceHelper(src, app_middlewares["*"], next, player, acc, true);
        }
        const app_MimetypesKind = {
            opus: "video/ogg",
            ogv: "video/ogg",
            mp4: "video/mp4",
            mov: "video/mp4",
            m4v: "video/mp4",
            mkv: "video/x-matroska",
            m4a: "audio/mp4",
            mp3: "audio/mpeg",
            aac: "audio/aac",
            caf: "audio/x-caf",
            flac: "audio/flac",
            oga: "audio/ogg",
            wav: "audio/wav",
            m3u8: "application/x-mpegURL",
            mpd: "application/dash+xml",
            jpg: "image/jpeg",
            jpeg: "image/jpeg",
            gif: "image/gif",
            png: "image/png",
            svg: "image/svg+xml",
            webp: "image/webp"
        };
        const app_getMimetype = function(src = "") {
            const ext = app_getFileExtension(src);
            const mimetype = app_MimetypesKind[ext.toLowerCase()];
            return mimetype || "";
        };
        const app_findMimetype = (player, src) => {
            if (!src) return "";
            if (player.cache_.source.src === src && player.cache_.source.type) return player.cache_.source.type;
            const matchingSources = player.cache_.sources.filter((s => s.src === src));
            if (matchingSources.length) return matchingSources[0].type;
            const sources = player.$$("source");
            for (let i = 0; i < sources.length; i++) {
                const s = sources[i];
                if (s.type && s.src && s.src === src) return s.type;
            }
            return app_getMimetype(src);
        };
        const app_filterSource = function(src) {
            if (Array.isArray(src)) {
                let newsrc = [];
                src.forEach((function(srcobj) {
                    srcobj = app_filterSource(srcobj);
                    if (Array.isArray(srcobj)) newsrc = newsrc.concat(srcobj); else if (app_video_es_isObject(srcobj)) newsrc.push(srcobj);
                }));
                src = newsrc;
            } else if (typeof src === "string" && src.trim()) src = [ app_fixSource({
                src
            }) ]; else if (app_video_es_isObject(src) && typeof src.src === "string" && src.src && src.src.trim()) src = [ app_fixSource(src) ]; else src = [];
            return src;
        };
        function app_fixSource(src) {
            if (!src.type) {
                const mimetype = app_getMimetype(src.src);
                if (mimetype) src.type = mimetype;
            }
            return src;
        }
        var app_icons = '<svg xmlns="http://www.w3.org/2000/svg">\n  <defs>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-play">\n      <path d="M16 10v28l22-14z"></path>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-pause">\n      <path d="M12 38h8V10h-8v28zm16-28v28h8V10h-8z"></path>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-audio">\n      <path d="M24 2C14.06 2 6 10.06 6 20v14c0 3.31 2.69 6 6 6h6V24h-8v-4c0-7.73 6.27-14 14-14s14 6.27 14 14v4h-8v16h6c3.31 0 6-2.69 6-6V20c0-9.94-8.06-18-18-18z"></path>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-captions">\n      <path d="M38 8H10c-2.21 0-4 1.79-4 4v24c0 2.21 1.79 4 4 4h28c2.21 0 4-1.79 4-4V12c0-2.21-1.79-4-4-4zM22 22h-3v-1h-4v6h4v-1h3v2a2 2 0 0 1-2 2h-6a2 2 0 0 1-2-2v-8a2 2 0 0 1 2-2h6a2 2 0 0 1 2 2v2zm14 0h-3v-1h-4v6h4v-1h3v2a2 2 0 0 1-2 2h-6a2 2 0 0 1-2-2v-8a2 2 0 0 1 2-2h6a2 2 0 0 1 2 2v2z"></path>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-subtitles">\n      <path d="M40 8H8c-2.21 0-4 1.79-4 4v24c0 2.21 1.79 4 4 4h32c2.21 0 4-1.79 4-4V12c0-2.21-1.79-4-4-4zM8 24h8v4H8v-4zm20 12H8v-4h20v4zm12 0h-8v-4h8v4zm0-8H20v-4h20v4z"></path>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-fullscreen-enter">\n      <path d="M14 28h-4v10h10v-4h-6v-6zm-4-8h4v-6h6v-4H10v10zm24 14h-6v4h10V28h-4v6zm-6-24v4h6v6h4V10H28z"></path>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-fullscreen-exit">\n      <path d="M10 32h6v6h4V28H10v4zm6-16h-6v4h10V10h-4v6zm12 22h4v-6h6v-4H28v10zm4-22v-6h-4v10h10v-4h-6z"></path>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-play-circle">\n      <path d="M20 33l12-9-12-9v18zm4-29C12.95 4 4 12.95 4 24s8.95 20 20 20 20-8.95 20-20S35.05 4 24 4zm0 36c-8.82 0-16-7.18-16-16S15.18 8 24 8s16 7.18 16 16-7.18 16-16 16z"></path>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-volume-mute">\n      <path d="M33 24c0-3.53-2.04-6.58-5-8.05v4.42l4.91 4.91c.06-.42.09-.85.09-1.28zm5 0c0 1.88-.41 3.65-1.08 5.28l3.03 3.03C41.25 29.82 42 27 42 24c0-8.56-5.99-15.72-14-17.54v4.13c5.78 1.72 10 7.07 10 13.41zM8.55 6L6 8.55 15.45 18H6v12h8l10 10V26.55l8.51 8.51c-1.34 1.03-2.85 1.86-4.51 2.36v4.13a17.94 17.94 0 0 0 7.37-3.62L39.45 42 42 39.45l-18-18L8.55 6zM24 8l-4.18 4.18L24 16.36V8z"></path>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-volume-low">\n      <path d="M14 18v12h8l10 10V8L22 18h-8z"></path>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-volume-medium">\n      <path d="M37 24c0-3.53-2.04-6.58-5-8.05v16.11c2.96-1.48 5-4.53 5-8.06zm-27-6v12h8l10 10V8L18 18h-8z"></path>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-volume-high">\n      <path d="M6 18v12h8l10 10V8L14 18H6zm27 6c0-3.53-2.04-6.58-5-8.05v16.11c2.96-1.48 5-4.53 5-8.06zM28 6.46v4.13c5.78 1.72 10 7.07 10 13.41s-4.22 11.69-10 13.41v4.13c8.01-1.82 14-8.97 14-17.54S36.01 8.28 28 6.46z"></path>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-spinner">\n      <path d="M18.8 21l9.53-16.51C26.94 4.18 25.49 4 24 4c-4.8 0-9.19 1.69-12.64 4.51l7.33 12.69.11-.2zm24.28-3c-1.84-5.85-6.3-10.52-11.99-12.68L23.77 18h19.31zm.52 2H28.62l.58 1 9.53 16.5C41.99 33.94 44 29.21 44 24c0-1.37-.14-2.71-.4-4zm-26.53 4l-7.8-13.5C6.01 14.06 4 18.79 4 24c0 1.37.14 2.71.4 4h14.98l-2.31-4zM4.92 30c1.84 5.85 6.3 10.52 11.99 12.68L24.23 30H4.92zm22.54 0l-7.8 13.51c1.4.31 2.85.49 4.34.49 4.8 0 9.19-1.69 12.64-4.51L29.31 26.8 27.46 30z"></path>\n    </symbol>\n    <symbol viewBox="0 0 24 24" id="vjs-icon-hd">\n      <path d="M19 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-8 12H9.5v-2h-2v2H6V9h1.5v2.5h2V9H11v6zm2-6h4c.55 0 1 .45 1 1v4c0 .55-.45 1-1 1h-4V9zm1.5 4.5h2v-3h-2v3z"></path>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-chapters">\n      <path d="M6 26h4v-4H6v4zm0 8h4v-4H6v4zm0-16h4v-4H6v4zm8 8h28v-4H14v4zm0 8h28v-4H14v4zm0-20v4h28v-4H14z"></path>\n    </symbol>\n    <symbol viewBox="0 0 40 40" id="vjs-icon-downloading">\n      <path d="M18.208 36.875q-3.208-.292-5.979-1.729-2.771-1.438-4.812-3.729-2.042-2.292-3.188-5.229-1.146-2.938-1.146-6.23 0-6.583 4.334-11.416 4.333-4.834 10.833-5.5v3.166q-5.167.75-8.583 4.646Q6.25 14.75 6.25 19.958q0 5.209 3.396 9.104 3.396 3.896 8.562 4.646zM20 28.417L11.542 20l2.083-2.083 4.917 4.916v-11.25h2.916v11.25l4.875-4.916L28.417 20zm1.792 8.458v-3.167q1.833-.25 3.541-.958 1.709-.708 3.167-1.875l2.333 2.292q-1.958 1.583-4.25 2.541-2.291.959-4.791 1.167zm6.791-27.792q-1.541-1.125-3.25-1.854-1.708-.729-3.541-1.021V3.042q2.5.25 4.77 1.208 2.271.958 4.271 2.5zm4.584 21.584l-2.25-2.25q1.166-1.5 1.854-3.209.687-1.708.937-3.541h3.209q-.292 2.5-1.229 4.791-.938 2.292-2.521 4.209zm.541-12.417q-.291-1.833-.958-3.562-.667-1.73-1.833-3.188l2.375-2.208q1.541 1.916 2.458 4.208.917 2.292 1.167 4.75z"></path>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-file-download">\n      <path d="M10.8 40.55q-1.35 0-2.375-1T7.4 37.15v-7.7h3.4v7.7h26.35v-7.7h3.4v7.7q0 1.4-1 2.4t-2.4 1zM24 32.1L13.9 22.05l2.45-2.45 5.95 5.95V7.15h3.4v18.4l5.95-5.95 2.45 2.45z"></path>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-file-download-done">\n      <path d="M9.8 40.5v-3.45h28.4v3.45zm9.2-9.05L7.4 19.85l2.45-2.35L19 26.65l19.2-19.2 2.4 2.4z"></path>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-file-download-off">\n      <path d="M4.9 4.75L43.25 43.1 41 45.3l-4.75-4.75q-.05.05-.075.025-.025-.025-.075-.025H10.8q-1.35 0-2.375-1T7.4 37.15v-7.7h3.4v7.7h22.05l-7-7-1.85 1.8L13.9 21.9l1.85-1.85L2.7 7zm26.75 14.7l2.45 2.45-3.75 3.8-2.45-2.5zM25.7 7.15V21.1l-3.4-3.45V7.15z"></path>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-share">\n      <path d="M36 32.17c-1.52 0-2.89.59-3.93 1.54L17.82 25.4c.11-.45.18-.92.18-1.4s-.07-.95-.18-1.4l14.1-8.23c1.07 1 2.5 1.62 4.08 1.62 3.31 0 6-2.69 6-6s-2.69-6-6-6-6 2.69-6 6c0 .48.07.95.18 1.4l-14.1 8.23c-1.07-1-2.5-1.62-4.08-1.62-3.31 0-6 2.69-6 6s2.69 6 6 6c1.58 0 3.01-.62 4.08-1.62l14.25 8.31c-.1.42-.16.86-.16 1.31A5.83 5.83 0 1 0 36 32.17z"></path>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-cog">\n      <path d="M38.86 25.95c.08-.64.14-1.29.14-1.95s-.06-1.31-.14-1.95l4.23-3.31c.38-.3.49-.84.24-1.28l-4-6.93c-.25-.43-.77-.61-1.22-.43l-4.98 2.01c-1.03-.79-2.16-1.46-3.38-1.97L29 4.84c-.09-.47-.5-.84-1-.84h-8c-.5 0-.91.37-.99.84l-.75 5.3a14.8 14.8 0 0 0-3.38 1.97L9.9 10.1a1 1 0 0 0-1.22.43l-4 6.93c-.25.43-.14.97.24 1.28l4.22 3.31C9.06 22.69 9 23.34 9 24s.06 1.31.14 1.95l-4.22 3.31c-.38.3-.49.84-.24 1.28l4 6.93c.25.43.77.61 1.22.43l4.98-2.01c1.03.79 2.16 1.46 3.38 1.97l.75 5.3c.08.47.49.84.99.84h8c.5 0 .91-.37.99-.84l.75-5.3a14.8 14.8 0 0 0 3.38-1.97l4.98 2.01a1 1 0 0 0 1.22-.43l4-6.93c.25-.43.14-.97-.24-1.28l-4.22-3.31zM24 31c-3.87 0-7-3.13-7-7s3.13-7 7-7 7 3.13 7 7-3.13 7-7 7z"></path>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-square">\n      <path d="M36 8H12c-2.21 0-4 1.79-4 4v24c0 2.21 1.79 4 4 4h24c2.21 0 4-1.79 4-4V12c0-2.21-1.79-4-4-4zm0 28H12V12h24v24z"></path>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-circle">\n      <circle cx="24" cy="24" r="20"></circle>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-circle-outline">\n      <path d="M24 4C12.95 4 4 12.95 4 24s8.95 20 20 20 20-8.95 20-20S35.05 4 24 4zm0 36c-8.82 0-16-7.18-16-16S15.18 8 24 8s16 7.18 16 16-7.18 16-16 16z"></path>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-circle-inner-circle">\n      <path d="M24 4C12.97 4 4 12.97 4 24s8.97 20 20 20 20-8.97 20-20S35.03 4 24 4zm0 36c-8.82 0-16-7.18-16-16S15.18 8 24 8s16 7.18 16 16-7.18 16-16 16zm6-16c0 3.31-2.69 6-6 6s-6-2.69-6-6 2.69-6 6-6 6 2.69 6 6z"></path>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-cancel">\n      <path d="M24 4C12.95 4 4 12.95 4 24s8.95 20 20 20 20-8.95 20-20S35.05 4 24 4zm10 27.17L31.17 34 24 26.83 16.83 34 14 31.17 21.17 24 14 16.83 16.83 14 24 21.17 31.17 14 34 16.83 26.83 24 34 31.17z"></path>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-replay">\n      <path d="M24 10V2L14 12l10 10v-8c6.63 0 12 5.37 12 12s-5.37 12-12 12-12-5.37-12-12H8c0 8.84 7.16 16 16 16s16-7.16 16-16-7.16-16-16-16z"></path>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-repeat">\n      <path d="M14 14h20v6l8-8-8-8v6H10v12h4v-8zm20 20H14v-6l-8 8 8 8v-6h24V26h-4v8z"></path>\n    </symbol>\n    <symbol viewBox="0 96 48 48" id="vjs-icon-replay-5">\n      <path d="M17.689 98l-8.697 8.696 8.697 8.697 2.486-2.485-4.32-4.319h1.302c4.93 0 9.071 1.722 12.424 5.165 3.352 3.443 5.029 7.638 5.029 12.584h3.55c0-2.958-.553-5.73-1.658-8.313-1.104-2.583-2.622-4.841-4.555-6.774-1.932-1.932-4.19-3.45-6.773-4.555-2.584-1.104-5.355-1.657-8.313-1.657H15.5l4.615-4.615zm-8.08 21.659v13.861h11.357v5.008H9.609V143h12.7c.834 0 1.55-.298 2.146-.894.596-.597.895-1.31.895-2.145v-7.781c0-.835-.299-1.55-.895-2.147a2.929 2.929 0 0 0-2.147-.894h-8.227v-5.096H25.35v-4.384z"></path>\n    </symbol>\n    <symbol viewBox="0 96 48 48" id="vjs-icon-replay-10">\n      <path d="M42.315 125.63c0-4.997-1.694-9.235-5.08-12.713-3.388-3.479-7.571-5.218-12.552-5.218h-1.315l4.363 4.363-2.51 2.51-8.787-8.786L25.221 97l2.45 2.45-4.662 4.663h1.375c2.988 0 5.788.557 8.397 1.673 2.61 1.116 4.892 2.65 6.844 4.602 1.953 1.953 3.487 4.234 4.602 6.844 1.116 2.61 1.674 5.41 1.674 8.398zM8.183 142v-19.657H3.176V117.8h9.643V142zm13.63 0c-1.156 0-2.127-.393-2.912-1.178-.778-.778-1.168-1.746-1.168-2.902v-16.04c0-1.156.393-2.127 1.178-2.912.779-.779 1.746-1.168 2.902-1.168h7.696c1.156 0 2.126.392 2.911 1.177.779.78 1.168 1.747 1.168 2.903v16.04c0 1.156-.392 2.127-1.177 2.912-.779.779-1.746 1.168-2.902 1.168zm.556-4.636h6.583v-15.02H22.37z"></path>\n    </symbol>\n    <symbol viewBox="0 96 48 48" id="vjs-icon-replay-30">\n      <path d="M26.047 97l-8.733 8.732 8.733 8.733 2.496-2.494-4.336-4.338h1.307c4.95 0 9.108 1.73 12.474 5.187 3.367 3.458 5.051 7.668 5.051 12.635h3.565c0-2.97-.556-5.751-1.665-8.346-1.109-2.594-2.633-4.862-4.574-6.802-1.94-1.941-4.208-3.466-6.803-4.575-2.594-1.109-5.375-1.664-8.345-1.664H23.85l4.634-4.634zM2.555 117.531v4.688h10.297v5.25H5.873v4.687h6.979v5.156H2.555V142H13.36c1.061 0 1.95-.395 2.668-1.186.718-.79 1.076-1.772 1.076-2.94v-16.218c0-1.168-.358-2.149-1.076-2.94-.717-.79-1.607-1.185-2.668-1.185zm22.482.14c-1.149 0-2.11.39-2.885 1.165-.78.78-1.172 1.744-1.172 2.893v15.943c0 1.149.388 2.11 1.163 2.885.78.78 1.745 1.172 2.894 1.172h7.649c1.148 0 2.11-.388 2.884-1.163.78-.78 1.17-1.745 1.17-2.894v-15.943c0-1.15-.386-2.111-1.16-2.885-.78-.78-1.746-1.172-2.894-1.172zm.553 4.518h6.545v14.93H25.59z"></path>\n    </symbol>\n    <symbol viewBox="0 96 48 48" id="vjs-icon-forward-5">\n      <path d="M29.508 97l-2.431 2.43 4.625 4.625h-1.364c-2.965 0-5.742.554-8.332 1.66-2.589 1.107-4.851 2.629-6.788 4.566-1.937 1.937-3.458 4.2-4.565 6.788-1.107 2.59-1.66 5.367-1.66 8.331h3.557c0-4.957 1.68-9.16 5.04-12.611 3.36-3.45 7.51-5.177 12.451-5.177h1.304l-4.326 4.33 2.49 2.49 8.715-8.716zm-9.783 21.61v13.89h11.382v5.018H19.725V142h12.727a2.93 2.93 0 0 0 2.15-.896 2.93 2.93 0 0 0 .896-2.15v-7.798c0-.837-.299-1.554-.896-2.152a2.93 2.93 0 0 0-2.15-.896h-8.245V123h11.29v-4.392z"></path>\n    </symbol>\n    <symbol viewBox="0 96 48 48" id="vjs-icon-forward-10">\n      <path d="M23.119 97l-2.386 2.383 4.538 4.538h-1.339c-2.908 0-5.633.543-8.173 1.63-2.54 1.085-4.76 2.577-6.66 4.478-1.9 1.9-3.392 4.12-4.478 6.66-1.085 2.54-1.629 5.264-1.629 8.172h3.49c0-4.863 1.648-8.986 4.944-12.372 3.297-3.385 7.368-5.078 12.216-5.078h1.279l-4.245 4.247 2.443 2.442 8.55-8.55zm-9.52 21.45v4.42h4.871V142h4.513v-23.55zm18.136 0c-1.125 0-2.066.377-2.824 1.135-.764.764-1.148 1.709-1.148 2.834v15.612c0 1.124.38 2.066 1.139 2.824.764.764 1.708 1.145 2.833 1.145h7.489c1.125 0 2.066-.378 2.824-1.136.764-.764 1.145-1.709 1.145-2.833v-15.612c0-1.125-.378-2.067-1.136-2.825-.764-.764-1.708-1.145-2.833-1.145zm.54 4.42h6.408v14.617h-6.407z"></path>\n    </symbol>\n    <symbol viewBox="0 96 48 48" id="vjs-icon-forward-30">\n      <path d="M25.549 97l-2.437 2.434 4.634 4.635H26.38c-2.97 0-5.753.555-8.347 1.664-2.594 1.109-4.861 2.633-6.802 4.574-1.94 1.94-3.465 4.207-4.574 6.802-1.109 2.594-1.664 5.377-1.664 8.347h3.565c0-4.967 1.683-9.178 5.05-12.636 3.366-3.458 7.525-5.187 12.475-5.187h1.307l-4.335 4.338 2.495 2.494 8.732-8.732zm-11.553 20.53v4.689h10.297v5.249h-6.978v4.688h6.978v5.156H13.996V142h10.808c1.06 0 1.948-.395 2.666-1.186.718-.79 1.077-1.771 1.077-2.94v-16.217c0-1.169-.36-2.15-1.077-2.94-.718-.79-1.605-1.186-2.666-1.186zm21.174.168c-1.149 0-2.11.389-2.884 1.163-.78.78-1.172 1.745-1.172 2.894v15.942c0 1.15.388 2.11 1.162 2.885.78.78 1.745 1.17 2.894 1.17h7.649c1.149 0 2.11-.386 2.885-1.16.78-.78 1.17-1.746 1.17-2.895v-15.942c0-1.15-.387-2.11-1.161-2.885-.78-.78-1.745-1.172-2.894-1.172zm.552 4.516h6.542v14.931h-6.542z"></path>\n    </symbol>\n    <symbol viewBox="0 0 512 512" id="vjs-icon-audio-description">\n      <g fill-rule="evenodd"><path d="M227.29 381.351V162.993c50.38-1.017 89.108-3.028 117.631 17.126 27.374 19.342 48.734 56.965 44.89 105.325-4.067 51.155-41.335 94.139-89.776 98.475-24.085 2.155-71.972 0-71.972 0s-.84-1.352-.773-2.568m48.755-54.804c31.43 1.26 53.208-16.633 56.495-45.386 4.403-38.51-21.188-63.552-58.041-60.796v103.612c-.036 1.466.575 2.22 1.546 2.57"></path><path d="M383.78 381.328c13.336 3.71 17.387-11.06 23.215-21.408 12.722-22.571 22.294-51.594 22.445-84.774.221-47.594-18.343-82.517-35.6-106.182h-8.51c-.587 3.874 2.226 7.315 3.865 10.276 13.166 23.762 25.367 56.553 25.54 94.194.2 43.176-14.162 79.278-30.955 107.894"></path><path d="M425.154 381.328c13.336 3.71 17.384-11.061 23.215-21.408 12.721-22.571 22.291-51.594 22.445-84.774.221-47.594-18.343-82.517-35.6-106.182h-8.511c-.586 3.874 2.226 7.315 3.866 10.276 13.166 23.762 25.367 56.553 25.54 94.194.2 43.176-14.162 79.278-30.955 107.894"></path><path d="M466.26 381.328c13.337 3.71 17.385-11.061 23.216-21.408 12.722-22.571 22.292-51.594 22.445-84.774.221-47.594-18.343-82.517-35.6-106.182h-8.51c-.587 3.874 2.225 7.315 3.865 10.276 13.166 23.762 25.367 56.553 25.54 94.194.2 43.176-14.162 79.278-30.955 107.894M4.477 383.005H72.58l18.573-28.484 64.169-.135s.065 19.413.065 28.62h48.756V160.307h-58.816c-5.653 9.537-140.85 222.697-140.85 222.697zm152.667-145.282v71.158l-40.453-.27 40.453-70.888z"></path></g>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-next-item">\n      <path d="M12 36l17-12-17-12v24zm20-24v24h4V12h-4z"></path>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-previous-item">\n      <path d="M12 12h4v24h-4zm7 12l17 12V12z"></path>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-shuffle">\n      <path d="M21.17 18.34L10.83 8 8 10.83l10.34 10.34 2.83-2.83zM29 8l4.09 4.09L8 37.17 10.83 40l25.09-25.09L40 19V8H29zm.66 18.83l-2.83 2.83 6.26 6.26L29 40h11V29l-4.09 4.09-6.25-6.26z"></path>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-cast">\n      <path d="M42 6H6c-2.21 0-4 1.79-4 4v6h4v-6h36v28H28v4h14c2.21 0 4-1.79 4-4V10c0-2.21-1.79-4-4-4zM2 36v6h6c0-3.31-2.69-6-6-6zm0-8v4c5.52 0 10 4.48 10 10h4c0-7.73-6.27-14-14-14zm0-8v4c9.94 0 18 8.06 18 18h4c0-12.15-9.85-22-22-22z"></path>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-picture-in-picture-enter">\n      <path d="M38 22H22v11.99h16V22zm8 16V9.96C46 7.76 44.2 6 42 6H6C3.8 6 2 7.76 2 9.96V38c0 2.2 1.8 4 4 4h36c2.2 0 4-1.8 4-4zm-4 .04H6V9.94h36v28.1z"></path>\n    </symbol>\n    <symbol viewBox="0 0 22 18" id="vjs-icon-picture-in-picture-exit">\n      <path d="M18 4H4v10h14V4zm4 12V1.98C22 .88 21.1 0 20 0H2C.9 0 0 .88 0 1.98V16c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2zm-2 .02H2V1.97h18v14.05z"></path>\n      <path fill="none" d="M-1-3h24v24H-1z"></path>\n    </symbol>\n    <symbol viewBox="0 0 1792 1792" id="vjs-icon-facebook">\n      <path d="M1343 12v264h-157q-86 0-116 36t-30 108v189h293l-39 296h-254v759H734V905H479V609h255V391q0-186 104-288.5T1115 0q147 0 228 12z"></path>\n    </symbol>\n    <symbol viewBox="0 0 1792 1792" id="vjs-icon-linkedin">\n      <path d="M477 625v991H147V625h330zm21-306q1 73-50.5 122T312 490h-2q-82 0-132-49t-50-122q0-74 51.5-122.5T314 148t133 48.5T498 319zm1166 729v568h-329v-530q0-105-40.5-164.5T1168 862q-63 0-105.5 34.5T999 982q-11 30-11 81v553H659q2-399 2-647t-1-296l-1-48h329v144h-2q20-32 41-56t56.5-52 87-43.5T1285 602q171 0 275 113.5t104 332.5z"></path>\n    </symbol>\n    <symbol viewBox="0 0 1200 1227" id="vjs-icon-twitter">\n      <path d="M714.163 519.284L1160.89 0H1055.03L667.137 450.887L357.328 0H0L468.492 681.821L0 1226.37H105.866L515.491 750.218L842.672 1226.37H1200L714.137 519.284H714.163ZM569.165 687.828L521.697 619.934L144.011 79.6944H306.615L611.412 515.685L658.88 583.579L1055.08 1150.3H892.476L569.165 687.854V687.828Z"/>\n    </symbol>\n    <symbol viewBox="0 0 1792 1792" id="vjs-icon-tumblr">\n      <path d="M1328 1329l80 237q-23 35-111 66t-177 32q-104 2-190.5-26T787 1564t-95-106-55.5-120-16.5-118V676H452V461q72-26 129-69.5t91-90 58-102 34-99T779 12q1-5 4.5-8.5T791 0h244v424h333v252h-334v518q0 30 6.5 56t22.5 52.5 49.5 41.5 81.5 14q78-2 134-29z"></path>\n    </symbol>\n    <symbol viewBox="0 0 1792 1792" id="vjs-icon-pinterest">\n      <path d="M1664 896q0 209-103 385.5T1281.5 1561 896 1664q-111 0-218-32 59-93 78-164 9-34 54-211 20 39 73 67.5t114 28.5q121 0 216-68.5t147-188.5 52-270q0-114-59.5-214T1180 449t-255-63q-105 0-196 29t-154.5 77-109 110.5-67 129.5T377 866q0 104 40 183t117 111q30 12 38-20 2-7 8-31t8-30q6-23-11-43-51-61-51-151 0-151 104.5-259.5T904 517q151 0 235.5 82t84.5 213q0 170-68.5 289T980 1220q-61 0-98-43.5T859 1072q8-35 26.5-93.5t30-103T927 800q0-50-27-83t-77-33q-62 0-105 57t-43 142q0 73 25 122l-99 418q-17 70-13 177-206-91-333-281T128 896q0-209 103-385.5T510.5 231 896 128t385.5 103T1561 510.5 1664 896z"></path>\n    </symbol>\n  </defs>\n</svg>';
        const app_backKeyCode = app_IS_TIZEN ? 10009 : app_IS_WEBOS ? 461 : 8;
        const app_SpatialNavKeyCodes = {
            codes: {
                play: 415,
                pause: 19,
                ff: 417,
                rw: 412,
                back: app_backKeyCode
            },
            names: {
                415: "play",
                19: "pause",
                417: "ff",
                412: "rw",
                [app_backKeyCode]: "back"
            },
            isEventKey(event, keyName) {
                keyName = keyName.toLowerCase();
                if (this.names[event.keyCode] && this.names[event.keyCode] === keyName) return true;
                return false;
            },
            getEventName(event) {
                if (this.names[event.keyCode]) return this.names[event.keyCode]; else if (this.codes[event.code]) {
                    const code = this.codes[event.code];
                    return this.names[code];
                }
                return null;
            }
        };
        const app_STEP_SECONDS$1 = 5;
        class app_SpatialNavigation extends app_EventTarget$2 {
            constructor(player) {
                super();
                this.player_ = player;
                this.focusableComponents = [];
                this.isListening_ = false;
                this.isPaused_ = false;
                this.onKeyDown_ = this.onKeyDown_.bind(this);
                this.lastFocusedComponent_ = null;
            }
            start() {
                if (this.isListening_) return;
                this.player_.on("keydown", this.onKeyDown_);
                this.player_.on("modalKeydown", this.onKeyDown_);
                this.player_.on("loadedmetadata", (() => {
                    this.focus(this.updateFocusableComponents()[0]);
                }));
                this.player_.on("modalclose", (() => {
                    this.refocusComponent();
                }));
                this.player_.on("focusin", this.handlePlayerFocus_.bind(this));
                this.player_.on("focusout", this.handlePlayerBlur_.bind(this));
                this.isListening_ = true;
                if (this.player_.errorDisplay) this.player_.errorDisplay.on("aftermodalfill", (() => {
                    this.updateFocusableComponents();
                    if (this.focusableComponents.length) if (this.focusableComponents.length > 1) this.focusableComponents[1].focus(); else this.focusableComponents[0].focus();
                }));
            }
            stop() {
                this.player_.off("keydown", this.onKeyDown_);
                this.isListening_ = false;
            }
            onKeyDown_(event) {
                const actualEvent = event.originalEvent ? event.originalEvent : event;
                if ([ "ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown" ].includes(actualEvent.key)) {
                    if (this.isPaused_) return;
                    actualEvent.preventDefault();
                    const direction = actualEvent.key.substring(5).toLowerCase();
                    this.move(direction);
                } else if (app_SpatialNavKeyCodes.isEventKey(actualEvent, "play") || app_SpatialNavKeyCodes.isEventKey(actualEvent, "pause") || app_SpatialNavKeyCodes.isEventKey(actualEvent, "ff") || app_SpatialNavKeyCodes.isEventKey(actualEvent, "rw")) {
                    actualEvent.preventDefault();
                    const action = app_SpatialNavKeyCodes.getEventName(actualEvent);
                    this.performMediaAction_(action);
                } else if (app_SpatialNavKeyCodes.isEventKey(actualEvent, "Back") && event.target && typeof event.target.closeable === "function" && event.target.closeable()) {
                    actualEvent.preventDefault();
                    event.target.close();
                }
            }
            performMediaAction_(key) {
                if (this.player_) switch (key) {
                  case "play":
                    if (this.player_.paused()) this.player_.play();
                    break;

                  case "pause":
                    if (!this.player_.paused()) this.player_.pause();
                    break;

                  case "ff":
                    this.userSeek_(this.player_.currentTime() + app_STEP_SECONDS$1);
                    break;

                  case "rw":
                    this.userSeek_(this.player_.currentTime() - app_STEP_SECONDS$1);
                    break;
                }
            }
            userSeek_(ct) {
                if (this.player_.liveTracker && this.player_.liveTracker.isLive()) this.player_.liveTracker.nextSeekedFromUser();
                this.player_.currentTime(ct);
            }
            pause() {
                this.isPaused_ = true;
            }
            resume() {
                this.isPaused_ = false;
            }
            handlePlayerBlur_(event) {
                const nextFocusedElement = event.relatedTarget;
                let isChildrenOfPlayer = null;
                const currentComponent = this.getCurrentComponent(event.target);
                if (nextFocusedElement) {
                    isChildrenOfPlayer = Boolean(nextFocusedElement.closest(".video-js"));
                    if (nextFocusedElement.classList.contains("vjs-text-track-settings") && !this.isPaused_) this.searchForTrackSelect_();
                }
                if (!event.currentTarget.contains(event.relatedTarget) && !isChildrenOfPlayer || !nextFocusedElement) if (currentComponent && currentComponent.name() === "CloseButton") this.refocusComponent(); else {
                    this.pause();
                    if (currentComponent && currentComponent.el()) this.lastFocusedComponent_ = currentComponent;
                }
            }
            handlePlayerFocus_() {
                if (this.getCurrentComponent() && this.getCurrentComponent().getIsFocusable()) this.resume();
            }
            updateFocusableComponents() {
                const player = this.player_;
                const focusableComponents = [];
                function searchForChildrenCandidates(componentsArray) {
                    for (const i of componentsArray) {
                        if (i.hasOwnProperty("el_") && i.getIsFocusable() && i.getIsAvailableToBeFocused(i.el())) focusableComponents.push(i);
                        if (i.hasOwnProperty("children_") && i.children_.length > 0) searchForChildrenCandidates(i.children_);
                    }
                }
                player.children_.forEach((value => {
                    if (value.hasOwnProperty("el_")) if (value.getIsFocusable && value.getIsAvailableToBeFocused && value.getIsFocusable() && value.getIsAvailableToBeFocused(value.el())) {
                        focusableComponents.push(value);
                        return;
                    } else if (value.hasOwnProperty("children_") && value.children_.length > 0) searchForChildrenCandidates(value.children_); else if (value.hasOwnProperty("items") && value.items.length > 0) searchForChildrenCandidates(value.items); else if (this.findSuitableDOMChild(value)) focusableComponents.push(value);
                    if (value.name_ === "ErrorDisplay" && value.opened_) {
                        const buttonContainer = value.el_.querySelector(".vjs-errors-ok-button-container");
                        if (buttonContainer) {
                            const modalButtons = buttonContainer.querySelectorAll("button");
                            modalButtons.forEach(((element, index) => {
                                focusableComponents.push({
                                    name: () => "ModalButton" + (index + 1),
                                    el: () => element,
                                    getPositions: () => {
                                        const rect = element.getBoundingClientRect();
                                        const boundingClientRect = {
                                            x: rect.x,
                                            y: rect.y,
                                            width: rect.width,
                                            height: rect.height,
                                            top: rect.top,
                                            right: rect.right,
                                            bottom: rect.bottom,
                                            left: rect.left
                                        };
                                        const center = {
                                            x: rect.left + rect.width / 2,
                                            y: rect.top + rect.height / 2,
                                            width: 0,
                                            height: 0,
                                            top: rect.top + rect.height / 2,
                                            right: rect.left + rect.width / 2,
                                            bottom: rect.top + rect.height / 2,
                                            left: rect.left + rect.width / 2
                                        };
                                        return {
                                            boundingClientRect,
                                            center
                                        };
                                    },
                                    getIsAvailableToBeFocused: () => true,
                                    getIsFocusable: el => true,
                                    focus: () => element.focus()
                                });
                            }));
                        }
                    }
                }));
                this.focusableComponents = focusableComponents;
                return this.focusableComponents;
            }
            findSuitableDOMChild(component) {
                function searchForSuitableChild(node) {
                    if (component.getIsFocusable(node) && component.getIsAvailableToBeFocused(node)) return node;
                    for (let i = 0; i < node.children.length; i++) {
                        const child = node.children[i];
                        const suitableChild = searchForSuitableChild(child);
                        if (suitableChild) return suitableChild;
                    }
                    return null;
                }
                if (component.el()) return searchForSuitableChild(component.el());
                return null;
            }
            getCurrentComponent(target) {
                this.updateFocusableComponents();
                const curComp = target || document.activeElement;
                if (this.focusableComponents.length) for (const i of this.focusableComponents) if (i.el() === curComp) return i;
            }
            add(component) {
                const focusableComponents = [ ...this.focusableComponents ];
                if (component.hasOwnProperty("el_") && component.getIsFocusable() && component.getIsAvailableToBeFocused(component.el())) focusableComponents.push(component);
                this.focusableComponents = focusableComponents;
                this.trigger({
                    type: "focusableComponentsChanged",
                    focusableComponents: this.focusableComponents
                });
            }
            remove(component) {
                for (let i = 0; i < this.focusableComponents.length; i++) if (this.focusableComponents[i].name() === component.name()) {
                    this.focusableComponents.splice(i, 1);
                    this.trigger({
                        type: "focusableComponentsChanged",
                        focusableComponents: this.focusableComponents
                    });
                    return;
                }
            }
            clear() {
                if (this.focusableComponents.length > 0) {
                    this.focusableComponents = [];
                    this.trigger({
                        type: "focusableComponentsChanged",
                        focusableComponents: this.focusableComponents
                    });
                }
            }
            move(direction) {
                const currentFocusedComponent = this.getCurrentComponent();
                if (!currentFocusedComponent) return;
                const currentPositions = currentFocusedComponent.getPositions();
                const candidates = this.focusableComponents.filter((component => component !== currentFocusedComponent && this.isInDirection_(currentPositions.boundingClientRect, component.getPositions().boundingClientRect, direction)));
                const bestCandidate = this.findBestCandidate_(currentPositions.center, candidates, direction);
                if (bestCandidate) this.focus(bestCandidate); else this.trigger({
                    type: "endOfFocusableComponents",
                    direction,
                    focusedComponent: currentFocusedComponent
                });
            }
            findBestCandidate_(currentCenter, candidates, direction) {
                let minDistance = 1 / 0;
                let bestCandidate = null;
                for (const candidate of candidates) {
                    const candidateCenter = candidate.getPositions().center;
                    const distance = this.calculateDistance_(currentCenter, candidateCenter, direction);
                    if (distance < minDistance) {
                        minDistance = distance;
                        bestCandidate = candidate;
                    }
                }
                return bestCandidate;
            }
            isInDirection_(srcRect, targetRect, direction) {
                switch (direction) {
                  case "right":
                    return targetRect.left >= srcRect.right;

                  case "left":
                    return targetRect.right <= srcRect.left;

                  case "down":
                    return targetRect.top >= srcRect.bottom;

                  case "up":
                    return targetRect.bottom <= srcRect.top;

                  default:
                    return false;
                }
            }
            refocusComponent() {
                if (this.lastFocusedComponent_) {
                    if (!this.player_.userActive()) this.player_.userActive(true);
                    this.updateFocusableComponents();
                    for (let i = 0; i < this.focusableComponents.length; i++) if (this.focusableComponents[i].name() === this.lastFocusedComponent_.name()) {
                        this.focus(this.focusableComponents[i]);
                        return;
                    }
                } else this.focus(this.updateFocusableComponents()[0]);
            }
            focus(component) {
                if (typeof component !== "object") return;
                if (component.getIsAvailableToBeFocused(component.el())) component.focus(); else if (this.findSuitableDOMChild(component)) this.findSuitableDOMChild(component).focus();
            }
            calculateDistance_(center1, center2, direction) {
                const dx = Math.abs(center1.x - center2.x);
                const dy = Math.abs(center1.y - center2.y);
                let distance;
                switch (direction) {
                  case "right":
                  case "left":
                    distance = dx + dy * 100;
                    break;

                  case "up":
                    distance = dy * 2 + dx * .5;
                    break;

                  case "down":
                    distance = dy * 5 + dx;
                    break;

                  default:
                    distance = dx + dy;
                }
                return distance;
            }
            searchForTrackSelect_() {
                const spatialNavigation = this;
                for (const component of spatialNavigation.updateFocusableComponents()) if (component.constructor.name === "TextTrackSelect") {
                    spatialNavigation.focus(component);
                    break;
                }
            }
        }
        class app_MediaLoader extends app_Component$1 {
            constructor(player, options, ready) {
                const options_ = app_merge$1({
                    createEl: false
                }, options);
                super(player, options_, ready);
                if (!options.playerOptions.sources || options.playerOptions.sources.length === 0) for (let i = 0, j = options.playerOptions.techOrder; i < j.length; i++) {
                    const techName = app_toTitleCase$1(j[i]);
                    let tech = app_Tech.getTech(techName);
                    if (!techName) tech = app_Component$1.getComponent(techName);
                    if (tech && tech.isSupported()) {
                        player.loadTech_(techName);
                        break;
                    }
                } else player.src(options.playerOptions.sources);
            }
        }
        app_Component$1.registerComponent("MediaLoader", app_MediaLoader);
        class app_ClickableComponent extends app_Component$1 {
            constructor(player, options) {
                super(player, options);
                if (this.options_.controlText) this.controlText(this.options_.controlText);
                this.handleMouseOver_ = e => this.handleMouseOver(e);
                this.handleMouseOut_ = e => this.handleMouseOut(e);
                this.handleClick_ = e => this.handleClick(e);
                this.handleKeyDown_ = e => this.handleKeyDown(e);
                this.emitTapEvents();
                this.enable();
            }
            createEl(tag = "div", props = {}, attributes = {}) {
                props = Object.assign({
                    className: this.buildCSSClass(),
                    tabIndex: 0
                }, props);
                if (tag === "button") app_log$1.error(`Creating a ClickableComponent with an HTML element of ${tag} is not supported; use a Button instead.`);
                attributes = Object.assign({
                    role: "button"
                }, attributes);
                this.tabIndex_ = props.tabIndex;
                const el = app_createEl(tag, props, attributes);
                if (!this.player_.options_.experimentalSvgIcons) el.appendChild(app_createEl("span", {
                    className: "vjs-icon-placeholder"
                }, {
                    "aria-hidden": true
                }));
                this.createControlTextEl(el);
                return el;
            }
            dispose() {
                this.controlTextEl_ = null;
                super.dispose();
            }
            createControlTextEl(el) {
                this.controlTextEl_ = app_createEl("span", {
                    className: "vjs-control-text"
                }, {
                    "aria-live": "polite"
                });
                if (el) el.appendChild(this.controlTextEl_);
                this.controlText(this.controlText_, el);
                return this.controlTextEl_;
            }
            controlText(text, el = this.el()) {
                if (text === void 0) return this.controlText_ || "Need Text";
                const localizedText = this.localize(text);
                this.controlText_ = text;
                app_textContent(this.controlTextEl_, localizedText);
                if (!this.nonIconControl && !this.player_.options_.noUITitleAttributes) el.setAttribute("title", localizedText);
            }
            buildCSSClass() {
                return `vjs-control vjs-button ${super.buildCSSClass()}`;
            }
            enable() {
                if (!this.enabled_) {
                    this.enabled_ = true;
                    this.removeClass("vjs-disabled");
                    this.el_.setAttribute("aria-disabled", "false");
                    if (typeof this.tabIndex_ !== "undefined") this.el_.setAttribute("tabIndex", this.tabIndex_);
                    this.on([ "tap", "click" ], this.handleClick_);
                    this.on("keydown", this.handleKeyDown_);
                }
            }
            disable() {
                this.enabled_ = false;
                this.addClass("vjs-disabled");
                this.el_.setAttribute("aria-disabled", "true");
                if (typeof this.tabIndex_ !== "undefined") this.el_.removeAttribute("tabIndex");
                this.off("mouseover", this.handleMouseOver_);
                this.off("mouseout", this.handleMouseOut_);
                this.off([ "tap", "click" ], this.handleClick_);
                this.off("keydown", this.handleKeyDown_);
            }
            handleLanguagechange() {
                this.controlText(this.controlText_);
            }
            handleClick(event) {
                if (this.options_.clickHandler) this.options_.clickHandler.call(this, arguments);
            }
            handleKeyDown(event) {
                if (event.key === " " || event.key === "Enter") {
                    event.preventDefault();
                    event.stopPropagation();
                    this.trigger("click");
                } else super.handleKeyDown(event);
            }
        }
        app_Component$1.registerComponent("ClickableComponent", app_ClickableComponent);
        class app_PosterImage extends app_ClickableComponent {
            constructor(player, options) {
                super(player, options);
                this.update();
                this.update_ = e => this.update(e);
                player.on("posterchange", this.update_);
            }
            dispose() {
                this.player().off("posterchange", this.update_);
                super.dispose();
            }
            createEl() {
                return app_createEl("div", {
                    className: "vjs-poster"
                });
            }
            crossOrigin(value) {
                if (typeof value === "undefined") {
                    if (this.$("img")) return this.$("img").crossOrigin; else if (this.player_.tech_ && this.player_.tech_.isReady_) return this.player_.crossOrigin();
                    return this.player_.options_.crossOrigin || this.player_.options_.crossorigin || null;
                }
                if (value !== null && value !== "anonymous" && value !== "use-credentials") {
                    this.player_.log.warn(`crossOrigin must be null,  "anonymous" or "use-credentials", given "${value}"`);
                    return;
                }
                if (this.$("img")) this.$("img").crossOrigin = value;
                return;
            }
            update(event) {
                const url = this.player().poster();
                this.setSrc(url);
                if (url) this.show(); else this.hide();
            }
            setSrc(url) {
                if (!url) {
                    this.el_.textContent = "";
                    return;
                }
                if (!this.$("img")) this.el_.appendChild(app_createEl("picture", {
                    className: "vjs-poster",
                    tabIndex: -1
                }, {}, app_createEl("img", {
                    loading: "lazy",
                    crossOrigin: this.crossOrigin()
                }, {
                    alt: ""
                })));
                this.$("img").src = url;
            }
            handleClick(event) {
                if (!this.player_.controls()) return;
                if (this.player_.tech(true)) this.player_.tech(true).focus();
                if (this.player_.paused()) app_silencePromise(this.player_.play()); else this.player_.pause();
            }
        }
        app_PosterImage.prototype.crossorigin = app_PosterImage.prototype.crossOrigin;
        app_Component$1.registerComponent("PosterImage", app_PosterImage);
        const app_darkGray = "#222";
        const app_lightGray = "#ccc";
        const app_fontMap = {
            monospace: "monospace",
            sansSerif: "sans-serif",
            serif: "serif",
            monospaceSansSerif: '"Andale Mono", "Lucida Console", monospace',
            monospaceSerif: '"Courier New", monospace',
            proportionalSansSerif: "sans-serif",
            proportionalSerif: "serif",
            casual: '"Comic Sans MS", Impact, fantasy',
            script: '"Monotype Corsiva", cursive',
            smallcaps: '"Andale Mono", "Lucida Console", monospace, sans-serif'
        };
        function app_constructColor(color, opacity) {
            let hex;
            if (color.length === 4) hex = color[1] + color[1] + color[2] + color[2] + color[3] + color[3]; else if (color.length === 7) hex = color.slice(1); else throw new Error("Invalid color code provided, " + color + "; must be formatted as e.g. #f0e or #f604e2.");
            return "rgba(" + parseInt(hex.slice(0, 2), 16) + "," + parseInt(hex.slice(2, 4), 16) + "," + parseInt(hex.slice(4, 6), 16) + "," + opacity + ")";
        }
        function app_tryUpdateStyle(el, style, rule) {
            try {
                el.style[style] = rule;
            } catch (e) {
                return;
            }
        }
        function app_getCSSPositionValue(position) {
            return position ? `${position}px` : "";
        }
        class app_TextTrackDisplay extends app_Component$1 {
            constructor(player, options, ready) {
                super(player, options, ready);
                const updateDisplayTextHandler = e => this.updateDisplay(e);
                const updateDisplayHandler = e => {
                    this.updateDisplayOverlay();
                    this.updateDisplay(e);
                };
                player.on("loadstart", (e => this.toggleDisplay(e)));
                player.on("texttrackchange", updateDisplayTextHandler);
                player.on("loadedmetadata", (e => {
                    this.updateDisplayOverlay();
                    this.preselectTrack(e);
                }));
                player.ready(app_bind_(this, (function() {
                    if (player.tech_ && player.tech_.featuresNativeTextTracks) {
                        this.hide();
                        return;
                    }
                    player.on("fullscreenchange", updateDisplayHandler);
                    player.on("playerresize", updateDisplayHandler);
                    const screenOrientation = app_window_default().screen.orientation || app_window_default();
                    const changeOrientationEvent = app_window_default().screen.orientation ? "change" : "orientationchange";
                    screenOrientation.addEventListener(changeOrientationEvent, updateDisplayHandler);
                    player.on("dispose", (() => screenOrientation.removeEventListener(changeOrientationEvent, updateDisplayHandler)));
                    const tracks = this.options_.playerOptions.tracks || [];
                    for (let i = 0; i < tracks.length; i++) this.player_.addRemoteTextTrack(tracks[i], true);
                    this.preselectTrack();
                })));
            }
            preselectTrack() {
                const modes = {
                    captions: 1,
                    subtitles: 1
                };
                const trackList = this.player_.textTracks();
                const userPref = this.player_.cache_.selectedLanguage;
                let firstDesc;
                let firstCaptions;
                let preferredTrack;
                for (let i = 0; i < trackList.length; i++) {
                    const track = trackList[i];
                    if (userPref && userPref.enabled && userPref.language && userPref.language === track.language && track.kind in modes) {
                        if (track.kind === userPref.kind) preferredTrack = track; else if (!preferredTrack) preferredTrack = track;
                    } else if (userPref && !userPref.enabled) {
                        preferredTrack = null;
                        firstDesc = null;
                        firstCaptions = null;
                    } else if (track.default) if (track.kind === "descriptions" && !firstDesc) firstDesc = track; else if (track.kind in modes && !firstCaptions) firstCaptions = track;
                }
                if (preferredTrack) preferredTrack.mode = "showing"; else if (firstCaptions) firstCaptions.mode = "showing"; else if (firstDesc) firstDesc.mode = "showing";
            }
            toggleDisplay() {
                if (this.player_.tech_ && this.player_.tech_.featuresNativeTextTracks) this.hide(); else this.show();
            }
            createEl() {
                return super.createEl("div", {
                    className: "vjs-text-track-display"
                }, {
                    translate: "yes",
                    "aria-live": "off",
                    "aria-atomic": "true"
                });
            }
            clearDisplay() {
                if (typeof app_window_default().WebVTT === "function") app_window_default().WebVTT.processCues(app_window_default(), [], this.el_);
            }
            updateDisplay() {
                const tracks = this.player_.textTracks();
                const allowMultipleShowingTracks = this.options_.allowMultipleShowingTracks;
                this.clearDisplay();
                if (allowMultipleShowingTracks) {
                    const showingTracks = [];
                    for (let i = 0; i < tracks.length; ++i) {
                        const track = tracks[i];
                        if (track.mode !== "showing") continue;
                        showingTracks.push(track);
                    }
                    this.updateForTrack(showingTracks);
                    return;
                }
                let descriptionsTrack = null;
                let captionsSubtitlesTrack = null;
                let i = tracks.length;
                while (i--) {
                    const track = tracks[i];
                    if (track.mode === "showing") if (track.kind === "descriptions") descriptionsTrack = track; else captionsSubtitlesTrack = track;
                }
                if (captionsSubtitlesTrack) {
                    if (this.getAttribute("aria-live") !== "off") this.setAttribute("aria-live", "off");
                    this.updateForTrack(captionsSubtitlesTrack);
                } else if (descriptionsTrack) {
                    if (this.getAttribute("aria-live") !== "assertive") this.setAttribute("aria-live", "assertive");
                    this.updateForTrack(descriptionsTrack);
                }
                if (!app_window_default().CSS.supports("inset", "10px")) {
                    const textTrackDisplay = this.el_;
                    const vjsTextTrackCues = textTrackDisplay.querySelectorAll(".vjs-text-track-cue");
                    const controlBarHeight = this.player_.controlBar.el_.getBoundingClientRect().height;
                    const playerHeight = this.player_.el_.getBoundingClientRect().height;
                    textTrackDisplay.style = "";
                    app_tryUpdateStyle(textTrackDisplay, "position", "relative");
                    app_tryUpdateStyle(textTrackDisplay, "height", playerHeight - controlBarHeight + "px");
                    app_tryUpdateStyle(textTrackDisplay, "top", "unset");
                    if (app_IS_SMART_TV) app_tryUpdateStyle(textTrackDisplay, "bottom", playerHeight + "px"); else app_tryUpdateStyle(textTrackDisplay, "bottom", "0px");
                    if (vjsTextTrackCues.length > 0) vjsTextTrackCues.forEach((vjsTextTrackCue => {
                        if (vjsTextTrackCue.style.inset) {
                            const insetStyles = vjsTextTrackCue.style.inset.split(" ");
                            if (insetStyles.length === 3) Object.assign(vjsTextTrackCue.style, {
                                top: insetStyles[0],
                                right: insetStyles[1],
                                bottom: insetStyles[2],
                                left: "unset"
                            });
                        }
                    }));
                }
            }
            updateDisplayOverlay() {
                if (!this.player_.videoHeight() || !app_window_default().CSS.supports("inset-inline: 10px")) return;
                const playerWidth = this.player_.currentWidth();
                const playerHeight = this.player_.currentHeight();
                const playerAspectRatio = playerWidth / playerHeight;
                const videoAspectRatio = this.player_.videoWidth() / this.player_.videoHeight();
                let insetInlineMatch = 0;
                let insetBlockMatch = 0;
                if (Math.abs(playerAspectRatio - videoAspectRatio) > .1) if (playerAspectRatio > videoAspectRatio) insetInlineMatch = Math.round((playerWidth - playerHeight * videoAspectRatio) / 2); else insetBlockMatch = Math.round((playerHeight - playerWidth / videoAspectRatio) / 2);
                app_tryUpdateStyle(this.el_, "insetInline", app_getCSSPositionValue(insetInlineMatch));
                app_tryUpdateStyle(this.el_, "insetBlock", app_getCSSPositionValue(insetBlockMatch));
            }
            updateDisplayState(track) {
                const overrides = this.player_.textTrackSettings.getValues();
                const cues = track.activeCues;
                let i = cues.length;
                while (i--) {
                    const cue = cues[i];
                    if (!cue) continue;
                    const cueDiv = cue.displayState;
                    if (overrides.color) cueDiv.firstChild.style.color = overrides.color;
                    if (overrides.textOpacity) app_tryUpdateStyle(cueDiv.firstChild, "color", app_constructColor(overrides.color || "#fff", overrides.textOpacity));
                    if (overrides.backgroundColor) cueDiv.firstChild.style.backgroundColor = overrides.backgroundColor;
                    if (overrides.backgroundOpacity) app_tryUpdateStyle(cueDiv.firstChild, "backgroundColor", app_constructColor(overrides.backgroundColor || "#000", overrides.backgroundOpacity));
                    if (overrides.windowColor) if (overrides.windowOpacity) app_tryUpdateStyle(cueDiv, "backgroundColor", app_constructColor(overrides.windowColor, overrides.windowOpacity)); else cueDiv.style.backgroundColor = overrides.windowColor;
                    if (overrides.edgeStyle) if (overrides.edgeStyle === "dropshadow") cueDiv.firstChild.style.textShadow = `2px 2px 3px ${app_darkGray}, 2px 2px 4px ${app_darkGray}, 2px 2px 5px ${app_darkGray}`; else if (overrides.edgeStyle === "raised") cueDiv.firstChild.style.textShadow = `1px 1px ${app_darkGray}, 2px 2px ${app_darkGray}, 3px 3px ${app_darkGray}`; else if (overrides.edgeStyle === "depressed") cueDiv.firstChild.style.textShadow = `1px 1px ${app_lightGray}, 0 1px ${app_lightGray}, -1px -1px ${app_darkGray}, 0 -1px ${app_darkGray}`; else if (overrides.edgeStyle === "uniform") cueDiv.firstChild.style.textShadow = `0 0 4px ${app_darkGray}, 0 0 4px ${app_darkGray}, 0 0 4px ${app_darkGray}, 0 0 4px ${app_darkGray}`;
                    if (overrides.fontPercent && overrides.fontPercent !== 1) {
                        const fontSize = app_window_default().parseFloat(cueDiv.style.fontSize);
                        cueDiv.style.fontSize = fontSize * overrides.fontPercent + "px";
                        cueDiv.style.height = "auto";
                        cueDiv.style.top = "auto";
                    }
                    if (overrides.fontFamily && overrides.fontFamily !== "default") if (overrides.fontFamily === "small-caps") cueDiv.firstChild.style.fontVariant = "small-caps"; else cueDiv.firstChild.style.fontFamily = app_fontMap[overrides.fontFamily];
                }
            }
            updateForTrack(tracks) {
                if (!Array.isArray(tracks)) tracks = [ tracks ];
                if (typeof app_window_default().WebVTT !== "function" || tracks.every((track => !track.activeCues))) return;
                const cues = [];
                for (let i = 0; i < tracks.length; ++i) {
                    const track = tracks[i];
                    for (let j = 0; j < track.activeCues.length; ++j) cues.push(track.activeCues[j]);
                }
                app_window_default().WebVTT.processCues(app_window_default(), cues, this.el_);
                for (let i = 0; i < tracks.length; ++i) {
                    const track = tracks[i];
                    for (let j = 0; j < track.activeCues.length; ++j) {
                        const cueEl = track.activeCues[j].displayState;
                        app_addClass(cueEl, "vjs-text-track-cue", "vjs-text-track-cue-" + (track.language ? track.language : i));
                        if (track.language) app_setAttribute(cueEl, "lang", track.language);
                    }
                    if (this.player_.textTrackSettings) this.updateDisplayState(track);
                }
            }
        }
        app_Component$1.registerComponent("TextTrackDisplay", app_TextTrackDisplay);
        class app_LoadingSpinner extends app_Component$1 {
            createEl() {
                const isAudio = this.player_.isAudio();
                const playerType = this.localize(isAudio ? "Audio Player" : "Video Player");
                const controlText = app_createEl("span", {
                    className: "vjs-control-text",
                    textContent: this.localize("{1} is loading.", [ playerType ])
                });
                const el = super.createEl("div", {
                    className: "vjs-loading-spinner",
                    dir: "ltr"
                });
                el.appendChild(controlText);
                return el;
            }
            handleLanguagechange() {
                this.$(".vjs-control-text").textContent = this.localize("{1} is loading.", [ this.player_.isAudio() ? "Audio Player" : "Video Player" ]);
            }
        }
        app_Component$1.registerComponent("LoadingSpinner", app_LoadingSpinner);
        class app_Button extends app_ClickableComponent {
            createEl(tag, props = {}, attributes = {}) {
                tag = "button";
                props = Object.assign({
                    className: this.buildCSSClass()
                }, props);
                attributes = Object.assign({
                    type: "button"
                }, attributes);
                const el = app_createEl(tag, props, attributes);
                if (!this.player_.options_.experimentalSvgIcons) el.appendChild(app_createEl("span", {
                    className: "vjs-icon-placeholder"
                }, {
                    "aria-hidden": true
                }));
                this.createControlTextEl(el);
                return el;
            }
            addChild(child, options = {}) {
                const className = this.constructor.name;
                app_log$1.warn(`Adding an actionable (user controllable) child to a Button (${className}) is not supported; use a ClickableComponent instead.`);
                return app_Component$1.prototype.addChild.call(this, child, options);
            }
            enable() {
                super.enable();
                this.el_.removeAttribute("disabled");
            }
            disable() {
                super.disable();
                this.el_.setAttribute("disabled", "disabled");
            }
            handleKeyDown(event) {
                if (event.key === " " || event.key === "Enter") {
                    event.stopPropagation();
                    return;
                }
                super.handleKeyDown(event);
            }
        }
        app_Component$1.registerComponent("Button", app_Button);
        class app_BigPlayButton extends app_Button {
            constructor(player, options) {
                super(player, options);
                this.mouseused_ = false;
                this.setIcon("play");
                this.on("mousedown", (e => this.handleMouseDown(e)));
            }
            buildCSSClass() {
                return "vjs-big-play-button";
            }
            handleClick(event) {
                const playPromise = this.player_.play();
                if (this.mouseused_ && "clientX" in event && "clientY" in event) {
                    app_silencePromise(playPromise);
                    if (this.player_.tech(true)) this.player_.tech(true).focus();
                    return;
                }
                const cb = this.player_.getChild("controlBar");
                const playToggle = cb && cb.getChild("playToggle");
                if (!playToggle) {
                    this.player_.tech(true).focus();
                    return;
                }
                const playFocus = () => playToggle.focus();
                if (app_isPromise(playPromise)) playPromise.then(playFocus, (() => {})); else this.setTimeout(playFocus, 1);
            }
            handleKeyDown(event) {
                this.mouseused_ = false;
                super.handleKeyDown(event);
            }
            handleMouseDown(event) {
                this.mouseused_ = true;
            }
        }
        app_BigPlayButton.prototype.controlText_ = "Play Video";
        app_Component$1.registerComponent("BigPlayButton", app_BigPlayButton);
        class app_CloseButton extends app_Button {
            constructor(player, options) {
                super(player, options);
                this.setIcon("cancel");
                this.controlText(options && options.controlText || this.localize("Close"));
            }
            buildCSSClass() {
                return `vjs-close-button ${super.buildCSSClass()}`;
            }
            handleClick(event) {
                this.trigger({
                    type: "close",
                    bubbles: false
                });
            }
            handleKeyDown(event) {
                if (event.key === "Escape") {
                    event.preventDefault();
                    event.stopPropagation();
                    this.trigger("click");
                } else super.handleKeyDown(event);
            }
        }
        app_Component$1.registerComponent("CloseButton", app_CloseButton);
        class app_PlayToggle extends app_Button {
            constructor(player, options = {}) {
                super(player, options);
                options.replay = options.replay === void 0 || options.replay;
                this.setIcon("play");
                this.on(player, "play", (e => this.handlePlay(e)));
                this.on(player, "pause", (e => this.handlePause(e)));
                if (options.replay) this.on(player, "ended", (e => this.handleEnded(e)));
            }
            buildCSSClass() {
                return `vjs-play-control ${super.buildCSSClass()}`;
            }
            handleClick(event) {
                if (this.player_.paused()) app_silencePromise(this.player_.play()); else this.player_.pause();
            }
            handleSeeked(event) {
                this.removeClass("vjs-ended");
                if (this.player_.paused()) this.handlePause(event); else this.handlePlay(event);
            }
            handlePlay(event) {
                this.removeClass("vjs-ended", "vjs-paused");
                this.addClass("vjs-playing");
                this.setIcon("pause");
                this.controlText("Pause");
            }
            handlePause(event) {
                this.removeClass("vjs-playing");
                this.addClass("vjs-paused");
                this.setIcon("play");
                this.controlText("Play");
            }
            handleEnded(event) {
                this.removeClass("vjs-playing");
                this.addClass("vjs-ended");
                this.setIcon("replay");
                this.controlText("Replay");
                this.one(this.player_, "seeked", (e => this.handleSeeked(e)));
            }
        }
        app_PlayToggle.prototype.controlText_ = "Play";
        app_Component$1.registerComponent("PlayToggle", app_PlayToggle);
        class app_TimeDisplay extends app_Component$1 {
            constructor(player, options) {
                super(player, options);
                this.on(player, [ "timeupdate", "ended", "seeking" ], (e => this.update(e)));
                this.updateTextNode_();
            }
            createEl() {
                const className = this.buildCSSClass();
                const el = super.createEl("div", {
                    className: `${className} vjs-time-control vjs-control`
                });
                const span = app_createEl("span", {
                    className: "vjs-control-text",
                    textContent: `${this.localize(this.labelText_)}¬†`
                }, {
                    role: "presentation"
                });
                el.appendChild(span);
                this.contentEl_ = app_createEl("span", {
                    className: `${className}-display`
                }, {
                    role: "presentation"
                });
                el.appendChild(this.contentEl_);
                return el;
            }
            dispose() {
                this.contentEl_ = null;
                this.textNode_ = null;
                super.dispose();
            }
            update(event) {
                if (!this.player_.options_.enableSmoothSeeking && event.type === "seeking") return;
                this.updateContent(event);
            }
            updateTextNode_(time = 0) {
                time = app_formatTime(time);
                if (this.formattedTime_ === time) return;
                this.formattedTime_ = time;
                this.requestNamedAnimationFrame("TimeDisplay#updateTextNode_", (() => {
                    if (!this.contentEl_) return;
                    let oldNode = this.textNode_;
                    if (oldNode && this.contentEl_.firstChild !== oldNode) {
                        oldNode = null;
                        app_log$1.warn("TimeDisplay#updateTextnode_: Prevented replacement of text node element since it was no longer a child of this node. Appending a new node instead.");
                    }
                    this.textNode_ = app_document_default().createTextNode(this.formattedTime_);
                    if (!this.textNode_) return;
                    if (oldNode) this.contentEl_.replaceChild(this.textNode_, oldNode); else this.contentEl_.appendChild(this.textNode_);
                }));
            }
            updateContent(event) {}
        }
        app_TimeDisplay.prototype.labelText_ = "Time";
        app_TimeDisplay.prototype.controlText_ = "Time";
        app_Component$1.registerComponent("TimeDisplay", app_TimeDisplay);
        class app_CurrentTimeDisplay extends app_TimeDisplay {
            buildCSSClass() {
                return "vjs-current-time";
            }
            updateContent(event) {
                let time;
                if (this.player_.ended()) time = this.player_.duration(); else time = this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();
                this.updateTextNode_(time);
            }
        }
        app_CurrentTimeDisplay.prototype.labelText_ = "Current Time";
        app_CurrentTimeDisplay.prototype.controlText_ = "Current Time";
        app_Component$1.registerComponent("CurrentTimeDisplay", app_CurrentTimeDisplay);
        class app_DurationDisplay extends app_TimeDisplay {
            constructor(player, options) {
                super(player, options);
                const updateContent = e => this.updateContent(e);
                this.on(player, "durationchange", updateContent);
                this.on(player, "loadstart", updateContent);
                this.on(player, "loadedmetadata", updateContent);
            }
            buildCSSClass() {
                return "vjs-duration";
            }
            updateContent(event) {
                const duration = this.player_.duration();
                this.updateTextNode_(duration);
            }
        }
        app_DurationDisplay.prototype.labelText_ = "Duration";
        app_DurationDisplay.prototype.controlText_ = "Duration";
        app_Component$1.registerComponent("DurationDisplay", app_DurationDisplay);
        class app_TimeDivider extends app_Component$1 {
            createEl() {
                const el = super.createEl("div", {
                    className: "vjs-time-control vjs-time-divider"
                }, {
                    "aria-hidden": true
                });
                const div = super.createEl("div");
                const span = super.createEl("span", {
                    textContent: "/"
                });
                div.appendChild(span);
                el.appendChild(div);
                return el;
            }
        }
        app_Component$1.registerComponent("TimeDivider", app_TimeDivider);
        class app_RemainingTimeDisplay extends app_TimeDisplay {
            constructor(player, options) {
                super(player, options);
                this.on(player, "durationchange", (e => this.updateContent(e)));
            }
            buildCSSClass() {
                return "vjs-remaining-time";
            }
            createEl() {
                const el = super.createEl();
                if (this.options_.displayNegative !== false) el.insertBefore(app_createEl("span", {}, {
                    "aria-hidden": true
                }, "-"), this.contentEl_);
                return el;
            }
            updateContent(event) {
                if (typeof this.player_.duration() !== "number") return;
                let time;
                if (this.player_.ended()) time = 0; else if (this.player_.remainingTimeDisplay) time = this.player_.remainingTimeDisplay(); else time = this.player_.remainingTime();
                this.updateTextNode_(time);
            }
        }
        app_RemainingTimeDisplay.prototype.labelText_ = "Remaining Time";
        app_RemainingTimeDisplay.prototype.controlText_ = "Remaining Time";
        app_Component$1.registerComponent("RemainingTimeDisplay", app_RemainingTimeDisplay);
        class app_LiveDisplay extends app_Component$1 {
            constructor(player, options) {
                super(player, options);
                this.updateShowing();
                this.on(this.player(), "durationchange", (e => this.updateShowing(e)));
            }
            createEl() {
                const el = super.createEl("div", {
                    className: "vjs-live-control vjs-control"
                });
                this.contentEl_ = app_createEl("div", {
                    className: "vjs-live-display"
                }, {
                    "aria-live": "off"
                });
                this.contentEl_.appendChild(app_createEl("span", {
                    className: "vjs-control-text",
                    textContent: `${this.localize("Stream Type")}¬†`
                }));
                this.contentEl_.appendChild(app_document_default().createTextNode(this.localize("LIVE")));
                el.appendChild(this.contentEl_);
                return el;
            }
            dispose() {
                this.contentEl_ = null;
                super.dispose();
            }
            updateShowing(event) {
                if (this.player().duration() === 1 / 0) this.show(); else this.hide();
            }
        }
        app_Component$1.registerComponent("LiveDisplay", app_LiveDisplay);
        class app_SeekToLive extends app_Button {
            constructor(player, options) {
                super(player, options);
                this.updateLiveEdgeStatus();
                if (this.player_.liveTracker) {
                    this.updateLiveEdgeStatusHandler_ = e => this.updateLiveEdgeStatus(e);
                    this.on(this.player_.liveTracker, "liveedgechange", this.updateLiveEdgeStatusHandler_);
                }
            }
            createEl() {
                const el = super.createEl("button", {
                    className: "vjs-seek-to-live-control vjs-control"
                });
                this.setIcon("circle", el);
                this.textEl_ = app_createEl("span", {
                    className: "vjs-seek-to-live-text",
                    textContent: this.localize("LIVE")
                }, {
                    "aria-hidden": "true"
                });
                el.appendChild(this.textEl_);
                return el;
            }
            updateLiveEdgeStatus() {
                if (!this.player_.liveTracker || this.player_.liveTracker.atLiveEdge()) {
                    this.setAttribute("aria-disabled", true);
                    this.addClass("vjs-at-live-edge");
                    this.controlText("Seek to live, currently playing live");
                } else {
                    this.setAttribute("aria-disabled", false);
                    this.removeClass("vjs-at-live-edge");
                    this.controlText("Seek to live, currently behind live");
                }
            }
            handleClick() {
                this.player_.liveTracker.seekToLiveEdge();
            }
            dispose() {
                if (this.player_.liveTracker) this.off(this.player_.liveTracker, "liveedgechange", this.updateLiveEdgeStatusHandler_);
                this.textEl_ = null;
                super.dispose();
            }
        }
        app_SeekToLive.prototype.controlText_ = "Seek to live, currently playing live";
        app_Component$1.registerComponent("SeekToLive", app_SeekToLive);
        function app_clamp(number, min, max) {
            number = Number(number);
            return Math.min(max, Math.max(min, isNaN(number) ? min : number));
        }
        var app_Num = Object.freeze({
            __proto__: null,
            clamp: app_clamp
        });
        class app_Slider extends app_Component$1 {
            constructor(player, options) {
                super(player, options);
                this.handleMouseDown_ = e => this.handleMouseDown(e);
                this.handleMouseUp_ = e => this.handleMouseUp(e);
                this.handleKeyDown_ = e => this.handleKeyDown(e);
                this.handleClick_ = e => this.handleClick(e);
                this.handleMouseMove_ = e => this.handleMouseMove(e);
                this.update_ = e => this.update(e);
                this.bar = this.getChild(this.options_.barName);
                this.vertical(!!this.options_.vertical);
                this.enable();
            }
            enabled() {
                return this.enabled_;
            }
            enable() {
                if (this.enabled()) return;
                this.on("mousedown", this.handleMouseDown_);
                this.on("touchstart", this.handleMouseDown_);
                this.on("keydown", this.handleKeyDown_);
                this.on("click", this.handleClick_);
                this.on(this.player_, "controlsvisible", this.update);
                if (this.playerEvent) this.on(this.player_, this.playerEvent, this.update);
                this.removeClass("disabled");
                this.setAttribute("tabindex", 0);
                this.enabled_ = true;
            }
            disable() {
                if (!this.enabled()) return;
                const doc = this.bar.el_.ownerDocument;
                this.off("mousedown", this.handleMouseDown_);
                this.off("touchstart", this.handleMouseDown_);
                this.off("keydown", this.handleKeyDown_);
                this.off("click", this.handleClick_);
                this.off(this.player_, "controlsvisible", this.update_);
                this.off(doc, "mousemove", this.handleMouseMove_);
                this.off(doc, "mouseup", this.handleMouseUp_);
                this.off(doc, "touchmove", this.handleMouseMove_);
                this.off(doc, "touchend", this.handleMouseUp_);
                this.removeAttribute("tabindex");
                this.addClass("disabled");
                if (this.playerEvent) this.off(this.player_, this.playerEvent, this.update);
                this.enabled_ = false;
            }
            createEl(type, props = {}, attributes = {}) {
                props.className = props.className + " vjs-slider";
                props = Object.assign({
                    tabIndex: 0
                }, props);
                attributes = Object.assign({
                    role: "slider",
                    "aria-valuenow": 0,
                    "aria-valuemin": 0,
                    "aria-valuemax": 100
                }, attributes);
                return super.createEl(type, props, attributes);
            }
            handleMouseDown(event) {
                const doc = this.bar.el_.ownerDocument;
                if (event.type === "mousedown") event.preventDefault();
                if (event.type === "touchstart" && !app_IS_CHROME) event.preventDefault();
                app_blockTextSelection();
                this.addClass("vjs-sliding");
                this.trigger("slideractive");
                this.on(doc, "mousemove", this.handleMouseMove_);
                this.on(doc, "mouseup", this.handleMouseUp_);
                this.on(doc, "touchmove", this.handleMouseMove_);
                this.on(doc, "touchend", this.handleMouseUp_);
                this.handleMouseMove(event, true);
            }
            handleMouseMove(event) {}
            handleMouseUp(event) {
                const doc = this.bar.el_.ownerDocument;
                app_unblockTextSelection();
                this.removeClass("vjs-sliding");
                this.trigger("sliderinactive");
                this.off(doc, "mousemove", this.handleMouseMove_);
                this.off(doc, "mouseup", this.handleMouseUp_);
                this.off(doc, "touchmove", this.handleMouseMove_);
                this.off(doc, "touchend", this.handleMouseUp_);
                this.update();
            }
            update() {
                if (!this.el_ || !this.bar) return;
                const progress = this.getProgress();
                if (progress === this.progress_) return progress;
                this.progress_ = progress;
                this.requestNamedAnimationFrame("Slider#update", (() => {
                    const sizeKey = this.vertical() ? "height" : "width";
                    this.bar.el().style[sizeKey] = (progress * 100).toFixed(2) + "%";
                }));
                return progress;
            }
            getProgress() {
                return Number(app_clamp(this.getPercent(), 0, 1).toFixed(4));
            }
            calculateDistance(event) {
                const position = app_getPointerPosition(this.el_, event);
                if (this.vertical()) return position.y;
                return position.x;
            }
            handleKeyDown(event) {
                const spatialNavOptions = this.options_.playerOptions.spatialNavigation;
                const spatialNavEnabled = spatialNavOptions && spatialNavOptions.enabled;
                const horizontalSeek = spatialNavOptions && spatialNavOptions.horizontalSeek;
                if (spatialNavEnabled) if (horizontalSeek && event.key === "ArrowLeft" || !horizontalSeek && event.key === "ArrowDown") {
                    event.preventDefault();
                    event.stopPropagation();
                    this.stepBack();
                } else if (horizontalSeek && event.key === "ArrowRight" || !horizontalSeek && event.key === "ArrowUp") {
                    event.preventDefault();
                    event.stopPropagation();
                    this.stepForward();
                } else super.handleKeyDown(event); else if (event.key === "ArrowLeft" || event.key === "ArrowDown") {
                    event.preventDefault();
                    event.stopPropagation();
                    this.stepBack();
                } else if (event.key === "ArrowUp" || event.key === "ArrowRight") {
                    event.preventDefault();
                    event.stopPropagation();
                    this.stepForward();
                } else super.handleKeyDown(event);
            }
            handleClick(event) {
                event.stopPropagation();
                event.preventDefault();
            }
            vertical(bool) {
                if (bool === void 0) return this.vertical_ || false;
                this.vertical_ = !!bool;
                if (this.vertical_) this.addClass("vjs-slider-vertical"); else this.addClass("vjs-slider-horizontal");
            }
        }
        app_Component$1.registerComponent("Slider", app_Slider);
        const app_percentify = (time, end) => app_clamp(time / end * 100, 0, 100).toFixed(2) + "%";
        class app_LoadProgressBar extends app_Component$1 {
            constructor(player, options) {
                super(player, options);
                this.partEls_ = [];
                this.on(player, "progress", (e => this.update(e)));
            }
            createEl() {
                const el = super.createEl("div", {
                    className: "vjs-load-progress"
                });
                const wrapper = app_createEl("span", {
                    className: "vjs-control-text"
                });
                const loadedText = app_createEl("span", {
                    textContent: this.localize("Loaded")
                });
                const separator = app_document_default().createTextNode(": ");
                this.percentageEl_ = app_createEl("span", {
                    className: "vjs-control-text-loaded-percentage",
                    textContent: "0%"
                });
                el.appendChild(wrapper);
                wrapper.appendChild(loadedText);
                wrapper.appendChild(separator);
                wrapper.appendChild(this.percentageEl_);
                return el;
            }
            dispose() {
                this.partEls_ = null;
                this.percentageEl_ = null;
                super.dispose();
            }
            update(event) {
                this.requestNamedAnimationFrame("LoadProgressBar#update", (() => {
                    const liveTracker = this.player_.liveTracker;
                    const buffered = this.player_.buffered();
                    const duration = liveTracker && liveTracker.isLive() ? liveTracker.seekableEnd() : this.player_.duration();
                    const bufferedEnd = this.player_.bufferedEnd();
                    const children = this.partEls_;
                    const percent = app_percentify(bufferedEnd, duration);
                    if (this.percent_ !== percent) {
                        this.el_.style.width = percent;
                        app_textContent(this.percentageEl_, percent);
                        this.percent_ = percent;
                    }
                    for (let i = 0; i < buffered.length; i++) {
                        const start = buffered.start(i);
                        const end = buffered.end(i);
                        let part = children[i];
                        if (!part) {
                            part = this.el_.appendChild(app_createEl());
                            children[i] = part;
                        }
                        if (part.dataset.start === start && part.dataset.end === end) continue;
                        part.dataset.start = start;
                        part.dataset.end = end;
                        part.style.left = app_percentify(start, bufferedEnd);
                        part.style.width = app_percentify(end - start, bufferedEnd);
                    }
                    for (let i = children.length; i > buffered.length; i--) this.el_.removeChild(children[i - 1]);
                    children.length = buffered.length;
                }));
            }
        }
        app_Component$1.registerComponent("LoadProgressBar", app_LoadProgressBar);
        class app_TimeTooltip extends app_Component$1 {
            constructor(player, options) {
                super(player, options);
                this.update = app_throttle(app_bind_(this, this.update), app_UPDATE_REFRESH_INTERVAL);
            }
            createEl() {
                return super.createEl("div", {
                    className: "vjs-time-tooltip"
                }, {
                    "aria-hidden": "true"
                });
            }
            update(seekBarRect, seekBarPoint, content) {
                const tooltipRect = app_findPosition(this.el_);
                const playerRect = app_getBoundingClientRect(this.player_.el());
                const seekBarPointPx = seekBarRect.width * seekBarPoint;
                if (!playerRect || !tooltipRect) return;
                let spaceLeftOfPoint = seekBarRect.left - playerRect.left + seekBarPointPx;
                let spaceRightOfPoint = seekBarRect.width - seekBarPointPx + (playerRect.right - seekBarRect.right);
                if (!spaceRightOfPoint) {
                    spaceRightOfPoint = seekBarRect.width - seekBarPointPx;
                    spaceLeftOfPoint = seekBarPointPx;
                }
                let pullTooltipBy = tooltipRect.width / 2;
                if (spaceLeftOfPoint < pullTooltipBy) pullTooltipBy += pullTooltipBy - spaceLeftOfPoint; else if (spaceRightOfPoint < pullTooltipBy) pullTooltipBy = spaceRightOfPoint;
                if (pullTooltipBy < 0) pullTooltipBy = 0; else if (pullTooltipBy > tooltipRect.width) pullTooltipBy = tooltipRect.width;
                pullTooltipBy = Math.round(pullTooltipBy);
                this.el_.style.right = `-${pullTooltipBy}px`;
                this.write(content);
            }
            write(content) {
                app_textContent(this.el_, content);
            }
            updateTime(seekBarRect, seekBarPoint, time, cb) {
                this.requestNamedAnimationFrame("TimeTooltip#updateTime", (() => {
                    let content;
                    const duration = this.player_.duration();
                    if (this.player_.liveTracker && this.player_.liveTracker.isLive()) {
                        const liveWindow = this.player_.liveTracker.liveWindow();
                        const secondsBehind = liveWindow - seekBarPoint * liveWindow;
                        content = (secondsBehind < 1 ? "" : "-") + app_formatTime(secondsBehind, liveWindow);
                    } else content = app_formatTime(time, duration);
                    this.update(seekBarRect, seekBarPoint, content);
                    if (cb) cb();
                }));
            }
        }
        app_Component$1.registerComponent("TimeTooltip", app_TimeTooltip);
        class app_PlayProgressBar extends app_Component$1 {
            constructor(player, options) {
                super(player, options);
                this.setIcon("circle");
                this.update = app_throttle(app_bind_(this, this.update), app_UPDATE_REFRESH_INTERVAL);
            }
            createEl() {
                return super.createEl("div", {
                    className: "vjs-play-progress vjs-slider-bar"
                }, {
                    "aria-hidden": "true"
                });
            }
            update(seekBarRect, seekBarPoint) {
                const timeTooltip = this.getChild("timeTooltip");
                if (!timeTooltip) return;
                const time = this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();
                timeTooltip.updateTime(seekBarRect, seekBarPoint, time);
            }
        }
        app_PlayProgressBar.prototype.options_ = {
            children: []
        };
        if (!app_IS_IOS && !app_IS_ANDROID) app_PlayProgressBar.prototype.options_.children.push("timeTooltip");
        app_Component$1.registerComponent("PlayProgressBar", app_PlayProgressBar);
        class app_MouseTimeDisplay extends app_Component$1 {
            constructor(player, options) {
                super(player, options);
                this.update = app_throttle(app_bind_(this, this.update), app_UPDATE_REFRESH_INTERVAL);
            }
            createEl() {
                return super.createEl("div", {
                    className: "vjs-mouse-display"
                });
            }
            update(seekBarRect, seekBarPoint) {
                const time = seekBarPoint * this.player_.duration();
                this.getChild("timeTooltip").updateTime(seekBarRect, seekBarPoint, time, (() => {
                    this.el_.style.left = `${seekBarRect.width * seekBarPoint}px`;
                }));
            }
        }
        app_MouseTimeDisplay.prototype.options_ = {
            children: [ "timeTooltip" ]
        };
        app_Component$1.registerComponent("MouseTimeDisplay", app_MouseTimeDisplay);
        const app_STEP_SECONDS = 5;
        const app_PAGE_KEY_MULTIPLIER = 12;
        class app_SeekBar extends app_Slider {
            constructor(player, options) {
                options = app_merge$1(app_SeekBar.prototype.options_, options);
                options.children = [ ...options.children ];
                const shouldDisableSeekWhileScrubbingOnMobile = player.options_.disableSeekWhileScrubbingOnMobile && (app_IS_IOS || app_IS_ANDROID);
                if (!app_IS_IOS && !app_IS_ANDROID || shouldDisableSeekWhileScrubbingOnMobile) options.children.splice(1, 0, "mouseTimeDisplay");
                super(player, options);
                this.shouldDisableSeekWhileScrubbingOnMobile_ = shouldDisableSeekWhileScrubbingOnMobile;
                this.pendingSeekTime_ = null;
                this.setEventHandlers_();
            }
            setEventHandlers_() {
                this.update_ = app_bind_(this, this.update);
                this.update = app_throttle(this.update_, app_UPDATE_REFRESH_INTERVAL);
                this.on(this.player_, [ "durationchange", "timeupdate" ], this.update);
                this.on(this.player_, [ "ended" ], this.update_);
                if (this.player_.liveTracker) this.on(this.player_.liveTracker, "liveedgechange", this.update);
                this.updateInterval = null;
                this.enableIntervalHandler_ = e => this.enableInterval_(e);
                this.disableIntervalHandler_ = e => this.disableInterval_(e);
                this.on(this.player_, [ "playing" ], this.enableIntervalHandler_);
                this.on(this.player_, [ "ended", "pause", "waiting" ], this.disableIntervalHandler_);
                if ("hidden" in app_document_default() && "visibilityState" in app_document_default()) this.on(app_document_default(), "visibilitychange", this.toggleVisibility_);
            }
            toggleVisibility_(e) {
                if (app_document_default().visibilityState === "hidden") {
                    this.cancelNamedAnimationFrame("SeekBar#update");
                    this.cancelNamedAnimationFrame("Slider#update");
                    this.disableInterval_(e);
                } else {
                    if (!this.player_.ended() && !this.player_.paused()) this.enableInterval_();
                    this.update();
                }
            }
            enableInterval_() {
                if (this.updateInterval) return;
                this.updateInterval = this.setInterval(this.update, app_UPDATE_REFRESH_INTERVAL);
            }
            disableInterval_(e) {
                if (this.player_.liveTracker && this.player_.liveTracker.isLive() && e && e.type !== "ended") return;
                if (!this.updateInterval) return;
                this.clearInterval(this.updateInterval);
                this.updateInterval = null;
            }
            createEl() {
                return super.createEl("div", {
                    className: "vjs-progress-holder"
                }, {
                    "aria-label": this.localize("Progress Bar")
                });
            }
            update(event) {
                if (app_document_default().visibilityState === "hidden") return;
                const percent = super.update();
                this.requestNamedAnimationFrame("SeekBar#update", (() => {
                    const currentTime = this.player_.ended() ? this.player_.duration() : this.getCurrentTime_();
                    const liveTracker = this.player_.liveTracker;
                    let duration = this.player_.duration();
                    if (liveTracker && liveTracker.isLive()) duration = this.player_.liveTracker.liveCurrentTime();
                    if (this.percent_ !== percent) {
                        this.el_.setAttribute("aria-valuenow", (percent * 100).toFixed(2));
                        this.percent_ = percent;
                    }
                    if (this.currentTime_ !== currentTime || this.duration_ !== duration) {
                        this.el_.setAttribute("aria-valuetext", this.localize("progress bar timing: currentTime={1} duration={2}", [ app_formatTime(currentTime, duration), app_formatTime(duration, duration) ], "{1} of {2}"));
                        this.currentTime_ = currentTime;
                        this.duration_ = duration;
                    }
                    if (this.bar) this.bar.update(app_getBoundingClientRect(this.el()), this.getProgress());
                }));
                return percent;
            }
            userSeek_(ct) {
                if (this.player_.liveTracker && this.player_.liveTracker.isLive()) this.player_.liveTracker.nextSeekedFromUser();
                this.player_.currentTime(ct);
            }
            getCurrentTime_() {
                return this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();
            }
            getPercent() {
                if (this.pendingSeekTime_) return this.pendingSeekTime_ / this.player_.duration();
                const currentTime = this.getCurrentTime_();
                let percent;
                const liveTracker = this.player_.liveTracker;
                if (liveTracker && liveTracker.isLive()) {
                    percent = (currentTime - liveTracker.seekableStart()) / liveTracker.liveWindow();
                    if (liveTracker.atLiveEdge()) percent = 1;
                } else percent = currentTime / this.player_.duration();
                return percent;
            }
            handleMouseDown(event) {
                if (!app_isSingleLeftClick(event)) return;
                event.stopPropagation();
                this.videoWasPlaying = !this.player_.paused();
                if (!this.shouldDisableSeekWhileScrubbingOnMobile_) this.player_.pause();
                super.handleMouseDown(event);
            }
            handleMouseMove(event, mouseDown = false) {
                if (!app_isSingleLeftClick(event) || isNaN(this.player_.duration())) return;
                if (!mouseDown && !this.player_.scrubbing()) this.player_.scrubbing(true);
                let newTime;
                const distance = this.calculateDistance(event);
                const liveTracker = this.player_.liveTracker;
                if (!liveTracker || !liveTracker.isLive()) {
                    newTime = distance * this.player_.duration();
                    if (newTime === this.player_.duration()) newTime -= .1;
                } else {
                    if (distance >= .99) {
                        liveTracker.seekToLiveEdge();
                        return;
                    }
                    const seekableStart = liveTracker.seekableStart();
                    const seekableEnd = liveTracker.liveCurrentTime();
                    newTime = seekableStart + distance * liveTracker.liveWindow();
                    if (newTime >= seekableEnd) newTime = seekableEnd;
                    if (newTime <= seekableStart) newTime = seekableStart + .1;
                    if (newTime === 1 / 0) return;
                }
                if (this.shouldDisableSeekWhileScrubbingOnMobile_) this.pendingSeekTime_ = newTime; else this.userSeek_(newTime);
                if (this.player_.options_.enableSmoothSeeking) this.update();
            }
            enable() {
                super.enable();
                const mouseTimeDisplay = this.getChild("mouseTimeDisplay");
                if (!mouseTimeDisplay) return;
                mouseTimeDisplay.show();
            }
            disable() {
                super.disable();
                const mouseTimeDisplay = this.getChild("mouseTimeDisplay");
                if (!mouseTimeDisplay) return;
                mouseTimeDisplay.hide();
            }
            handleMouseUp(event) {
                super.handleMouseUp(event);
                if (event) event.stopPropagation();
                this.player_.scrubbing(false);
                if (this.pendingSeekTime_) {
                    this.userSeek_(this.pendingSeekTime_);
                    this.pendingSeekTime_ = null;
                }
                this.player_.trigger({
                    type: "timeupdate",
                    target: this,
                    manuallyTriggered: true
                });
                if (this.videoWasPlaying) app_silencePromise(this.player_.play()); else this.update_();
            }
            stepForward() {
                this.userSeek_(this.player_.currentTime() + app_STEP_SECONDS);
            }
            stepBack() {
                this.userSeek_(this.player_.currentTime() - app_STEP_SECONDS);
            }
            handleAction(event) {
                if (this.player_.paused()) this.player_.play(); else this.player_.pause();
            }
            handleKeyDown(event) {
                const liveTracker = this.player_.liveTracker;
                if (event.key === " " || event.key === "Enter") {
                    event.preventDefault();
                    event.stopPropagation();
                    this.handleAction(event);
                } else if (event.key === "Home") {
                    event.preventDefault();
                    event.stopPropagation();
                    this.userSeek_(0);
                } else if (event.key === "End") {
                    event.preventDefault();
                    event.stopPropagation();
                    if (liveTracker && liveTracker.isLive()) this.userSeek_(liveTracker.liveCurrentTime()); else this.userSeek_(this.player_.duration());
                } else if (/^[0-9]$/.test(event.key)) {
                    event.preventDefault();
                    event.stopPropagation();
                    const gotoFraction = parseInt(event.key, 10) * .1;
                    if (liveTracker && liveTracker.isLive()) this.userSeek_(liveTracker.seekableStart() + liveTracker.liveWindow() * gotoFraction); else this.userSeek_(this.player_.duration() * gotoFraction);
                } else if (event.key === "PageDown") {
                    event.preventDefault();
                    event.stopPropagation();
                    this.userSeek_(this.player_.currentTime() - app_STEP_SECONDS * app_PAGE_KEY_MULTIPLIER);
                } else if (event.key === "PageUp") {
                    event.preventDefault();
                    event.stopPropagation();
                    this.userSeek_(this.player_.currentTime() + app_STEP_SECONDS * app_PAGE_KEY_MULTIPLIER);
                } else super.handleKeyDown(event);
            }
            dispose() {
                this.disableInterval_();
                this.off(this.player_, [ "durationchange", "timeupdate" ], this.update);
                this.off(this.player_, [ "ended" ], this.update_);
                if (this.player_.liveTracker) this.off(this.player_.liveTracker, "liveedgechange", this.update);
                this.off(this.player_, [ "playing" ], this.enableIntervalHandler_);
                this.off(this.player_, [ "ended", "pause", "waiting" ], this.disableIntervalHandler_);
                if ("hidden" in app_document_default() && "visibilityState" in app_document_default()) this.off(app_document_default(), "visibilitychange", this.toggleVisibility_);
                super.dispose();
            }
        }
        app_SeekBar.prototype.options_ = {
            children: [ "loadProgressBar", "playProgressBar" ],
            barName: "playProgressBar"
        };
        app_Component$1.registerComponent("SeekBar", app_SeekBar);
        class app_ProgressControl extends app_Component$1 {
            constructor(player, options) {
                super(player, options);
                this.handleMouseMove = app_throttle(app_bind_(this, this.handleMouseMove), app_UPDATE_REFRESH_INTERVAL);
                this.throttledHandleMouseSeek = app_throttle(app_bind_(this, this.handleMouseSeek), app_UPDATE_REFRESH_INTERVAL);
                this.handleMouseUpHandler_ = e => this.handleMouseUp(e);
                this.handleMouseDownHandler_ = e => this.handleMouseDown(e);
                this.enable();
            }
            createEl() {
                return super.createEl("div", {
                    className: "vjs-progress-control vjs-control"
                });
            }
            handleMouseMove(event) {
                const seekBar = this.getChild("seekBar");
                if (!seekBar) return;
                const playProgressBar = seekBar.getChild("playProgressBar");
                const mouseTimeDisplay = seekBar.getChild("mouseTimeDisplay");
                if (!playProgressBar && !mouseTimeDisplay) return;
                const seekBarEl = seekBar.el();
                const seekBarRect = app_findPosition(seekBarEl);
                let seekBarPoint = app_getPointerPosition(seekBarEl, event).x;
                seekBarPoint = app_clamp(seekBarPoint, 0, 1);
                if (mouseTimeDisplay) mouseTimeDisplay.update(seekBarRect, seekBarPoint);
                if (playProgressBar) playProgressBar.update(seekBarRect, seekBar.getProgress());
            }
            handleMouseSeek(event) {
                const seekBar = this.getChild("seekBar");
                if (seekBar) seekBar.handleMouseMove(event);
            }
            enabled() {
                return this.enabled_;
            }
            disable() {
                this.children().forEach((child => child.disable && child.disable()));
                if (!this.enabled()) return;
                this.off([ "mousedown", "touchstart" ], this.handleMouseDownHandler_);
                this.off(this.el_, [ "mousemove", "touchmove" ], this.handleMouseMove);
                this.removeListenersAddedOnMousedownAndTouchstart();
                this.addClass("disabled");
                this.enabled_ = false;
                if (this.player_.scrubbing()) {
                    const seekBar = this.getChild("seekBar");
                    this.player_.scrubbing(false);
                    if (seekBar.videoWasPlaying) app_silencePromise(this.player_.play());
                }
            }
            enable() {
                this.children().forEach((child => child.enable && child.enable()));
                if (this.enabled()) return;
                this.on([ "mousedown", "touchstart" ], this.handleMouseDownHandler_);
                this.on(this.el_, [ "mousemove", "touchmove" ], this.handleMouseMove);
                this.removeClass("disabled");
                this.enabled_ = true;
            }
            removeListenersAddedOnMousedownAndTouchstart() {
                const doc = this.el_.ownerDocument;
                this.off(doc, "mousemove", this.throttledHandleMouseSeek);
                this.off(doc, "touchmove", this.throttledHandleMouseSeek);
                this.off(doc, "mouseup", this.handleMouseUpHandler_);
                this.off(doc, "touchend", this.handleMouseUpHandler_);
            }
            handleMouseDown(event) {
                const doc = this.el_.ownerDocument;
                const seekBar = this.getChild("seekBar");
                if (seekBar) seekBar.handleMouseDown(event);
                this.on(doc, "mousemove", this.throttledHandleMouseSeek);
                this.on(doc, "touchmove", this.throttledHandleMouseSeek);
                this.on(doc, "mouseup", this.handleMouseUpHandler_);
                this.on(doc, "touchend", this.handleMouseUpHandler_);
            }
            handleMouseUp(event) {
                const seekBar = this.getChild("seekBar");
                if (seekBar) seekBar.handleMouseUp(event);
                this.removeListenersAddedOnMousedownAndTouchstart();
            }
        }
        app_ProgressControl.prototype.options_ = {
            children: [ "seekBar" ]
        };
        app_Component$1.registerComponent("ProgressControl", app_ProgressControl);
        class app_PictureInPictureToggle extends app_Button {
            constructor(player, options) {
                super(player, options);
                this.setIcon("picture-in-picture-enter");
                this.on(player, [ "enterpictureinpicture", "leavepictureinpicture" ], (e => this.handlePictureInPictureChange(e)));
                this.on(player, [ "disablepictureinpicturechanged", "loadedmetadata" ], (e => this.handlePictureInPictureEnabledChange(e)));
                this.on(player, [ "loadedmetadata", "audioonlymodechange", "audiopostermodechange" ], (() => this.handlePictureInPictureAudioModeChange()));
                this.disable();
            }
            buildCSSClass() {
                return `vjs-picture-in-picture-control vjs-hidden ${super.buildCSSClass()}`;
            }
            handlePictureInPictureAudioModeChange() {
                const isSourceAudio = this.player_.currentType().substring(0, 5) === "audio";
                const isAudioMode = isSourceAudio || this.player_.audioPosterMode() || this.player_.audioOnlyMode();
                if (!isAudioMode) {
                    this.show();
                    return;
                }
                if (this.player_.isInPictureInPicture()) this.player_.exitPictureInPicture();
                this.hide();
            }
            handlePictureInPictureEnabledChange() {
                if (app_document_default().pictureInPictureEnabled && this.player_.disablePictureInPicture() === false || this.player_.options_.enableDocumentPictureInPicture && "documentPictureInPicture" in app_window_default()) this.enable(); else this.disable();
            }
            handlePictureInPictureChange(event) {
                if (this.player_.isInPictureInPicture()) {
                    this.setIcon("picture-in-picture-exit");
                    this.controlText("Exit Picture-in-Picture");
                } else {
                    this.setIcon("picture-in-picture-enter");
                    this.controlText("Picture-in-Picture");
                }
                this.handlePictureInPictureEnabledChange();
            }
            handleClick(event) {
                if (!this.player_.isInPictureInPicture()) this.player_.requestPictureInPicture(); else this.player_.exitPictureInPicture();
            }
            show() {
                if (typeof app_document_default().exitPictureInPicture !== "function") return;
                super.show();
            }
        }
        app_PictureInPictureToggle.prototype.controlText_ = "Picture-in-Picture";
        app_Component$1.registerComponent("PictureInPictureToggle", app_PictureInPictureToggle);
        class app_FullscreenToggle extends app_Button {
            constructor(player, options) {
                super(player, options);
                this.setIcon("fullscreen-enter");
                this.on(player, "fullscreenchange", (e => this.handleFullscreenChange(e)));
                if (app_document_default()[player.fsApi_.fullscreenEnabled] === false) this.disable();
            }
            buildCSSClass() {
                return `vjs-fullscreen-control ${super.buildCSSClass()}`;
            }
            handleFullscreenChange(event) {
                if (this.player_.isFullscreen()) {
                    this.controlText("Exit Fullscreen");
                    this.setIcon("fullscreen-exit");
                } else {
                    this.controlText("Fullscreen");
                    this.setIcon("fullscreen-enter");
                }
            }
            handleClick(event) {
                if (!this.player_.isFullscreen()) this.player_.requestFullscreen(); else this.player_.exitFullscreen();
            }
        }
        app_FullscreenToggle.prototype.controlText_ = "Fullscreen";
        app_Component$1.registerComponent("FullscreenToggle", app_FullscreenToggle);
        const app_checkVolumeSupport = function(self, player) {
            if (player.tech_ && !player.tech_.featuresVolumeControl) self.addClass("vjs-hidden");
            self.on(player, "loadstart", (function() {
                if (!player.tech_.featuresVolumeControl) self.addClass("vjs-hidden"); else self.removeClass("vjs-hidden");
            }));
        };
        class app_VolumeLevel extends app_Component$1 {
            createEl() {
                const el = super.createEl("div", {
                    className: "vjs-volume-level"
                });
                this.setIcon("circle", el);
                el.appendChild(super.createEl("span", {
                    className: "vjs-control-text"
                }));
                return el;
            }
        }
        app_Component$1.registerComponent("VolumeLevel", app_VolumeLevel);
        class app_VolumeLevelTooltip extends app_Component$1 {
            constructor(player, options) {
                super(player, options);
                this.update = app_throttle(app_bind_(this, this.update), app_UPDATE_REFRESH_INTERVAL);
            }
            createEl() {
                return super.createEl("div", {
                    className: "vjs-volume-tooltip"
                }, {
                    "aria-hidden": "true"
                });
            }
            update(rangeBarRect, rangeBarPoint, vertical, content) {
                if (!vertical) {
                    const tooltipRect = app_getBoundingClientRect(this.el_);
                    const playerRect = app_getBoundingClientRect(this.player_.el());
                    const volumeBarPointPx = rangeBarRect.width * rangeBarPoint;
                    if (!playerRect || !tooltipRect) return;
                    const spaceLeftOfPoint = rangeBarRect.left - playerRect.left + volumeBarPointPx;
                    const spaceRightOfPoint = rangeBarRect.width - volumeBarPointPx + (playerRect.right - rangeBarRect.right);
                    let pullTooltipBy = tooltipRect.width / 2;
                    if (spaceLeftOfPoint < pullTooltipBy) pullTooltipBy += pullTooltipBy - spaceLeftOfPoint; else if (spaceRightOfPoint < pullTooltipBy) pullTooltipBy = spaceRightOfPoint;
                    if (pullTooltipBy < 0) pullTooltipBy = 0; else if (pullTooltipBy > tooltipRect.width) pullTooltipBy = tooltipRect.width;
                    this.el_.style.right = `-${pullTooltipBy}px`;
                }
                this.write(`${content}%`);
            }
            write(content) {
                app_textContent(this.el_, content);
            }
            updateVolume(rangeBarRect, rangeBarPoint, vertical, volume, cb) {
                this.requestNamedAnimationFrame("VolumeLevelTooltip#updateVolume", (() => {
                    this.update(rangeBarRect, rangeBarPoint, vertical, volume.toFixed(0));
                    if (cb) cb();
                }));
            }
        }
        app_Component$1.registerComponent("VolumeLevelTooltip", app_VolumeLevelTooltip);
        class app_MouseVolumeLevelDisplay extends app_Component$1 {
            constructor(player, options) {
                super(player, options);
                this.update = app_throttle(app_bind_(this, this.update), app_UPDATE_REFRESH_INTERVAL);
            }
            createEl() {
                return super.createEl("div", {
                    className: "vjs-mouse-display"
                });
            }
            update(rangeBarRect, rangeBarPoint, vertical) {
                const volume = 100 * rangeBarPoint;
                this.getChild("volumeLevelTooltip").updateVolume(rangeBarRect, rangeBarPoint, vertical, volume, (() => {
                    if (vertical) this.el_.style.bottom = `${rangeBarRect.height * rangeBarPoint}px`; else this.el_.style.left = `${rangeBarRect.width * rangeBarPoint}px`;
                }));
            }
        }
        app_MouseVolumeLevelDisplay.prototype.options_ = {
            children: [ "volumeLevelTooltip" ]
        };
        app_Component$1.registerComponent("MouseVolumeLevelDisplay", app_MouseVolumeLevelDisplay);
        class app_VolumeBar extends app_Slider {
            constructor(player, options) {
                super(player, options);
                this.on("slideractive", (e => this.updateLastVolume_(e)));
                this.on(player, "volumechange", (e => this.updateARIAAttributes(e)));
                player.ready((() => this.updateARIAAttributes()));
            }
            createEl() {
                return super.createEl("div", {
                    className: "vjs-volume-bar vjs-slider-bar"
                }, {
                    "aria-label": this.localize("Volume Level"),
                    "aria-live": "polite"
                });
            }
            handleMouseDown(event) {
                if (!app_isSingleLeftClick(event)) return;
                super.handleMouseDown(event);
            }
            handleMouseMove(event) {
                const mouseVolumeLevelDisplay = this.getChild("mouseVolumeLevelDisplay");
                if (mouseVolumeLevelDisplay) {
                    const volumeBarEl = this.el();
                    const volumeBarRect = app_getBoundingClientRect(volumeBarEl);
                    const vertical = this.vertical();
                    let volumeBarPoint = app_getPointerPosition(volumeBarEl, event);
                    volumeBarPoint = vertical ? volumeBarPoint.y : volumeBarPoint.x;
                    volumeBarPoint = app_clamp(volumeBarPoint, 0, 1);
                    mouseVolumeLevelDisplay.update(volumeBarRect, volumeBarPoint, vertical);
                }
                if (!app_isSingleLeftClick(event)) return;
                this.checkMuted();
                this.player_.volume(this.calculateDistance(event));
            }
            checkMuted() {
                if (this.player_.muted()) this.player_.muted(false);
            }
            getPercent() {
                if (this.player_.muted()) return 0;
                return this.player_.volume();
            }
            stepForward() {
                this.checkMuted();
                this.player_.volume(this.player_.volume() + .1);
            }
            stepBack() {
                this.checkMuted();
                this.player_.volume(this.player_.volume() - .1);
            }
            updateARIAAttributes(event) {
                const ariaValue = this.player_.muted() ? 0 : this.volumeAsPercentage_();
                this.el_.setAttribute("aria-valuenow", ariaValue);
                this.el_.setAttribute("aria-valuetext", ariaValue + "%");
            }
            volumeAsPercentage_() {
                return Math.round(this.player_.volume() * 100);
            }
            updateLastVolume_() {
                const volumeBeforeDrag = this.player_.volume();
                this.one("sliderinactive", (() => {
                    if (this.player_.volume() === 0) this.player_.lastVolume_(volumeBeforeDrag);
                }));
            }
        }
        app_VolumeBar.prototype.options_ = {
            children: [ "volumeLevel" ],
            barName: "volumeLevel"
        };
        if (!app_IS_IOS && !app_IS_ANDROID) app_VolumeBar.prototype.options_.children.splice(0, 0, "mouseVolumeLevelDisplay");
        app_VolumeBar.prototype.playerEvent = "volumechange";
        app_Component$1.registerComponent("VolumeBar", app_VolumeBar);
        class app_VolumeControl extends app_Component$1 {
            constructor(player, options = {}) {
                options.vertical = options.vertical || false;
                if (typeof options.volumeBar === "undefined" || app_isPlain(options.volumeBar)) {
                    options.volumeBar = options.volumeBar || {};
                    options.volumeBar.vertical = options.vertical;
                }
                super(player, options);
                app_checkVolumeSupport(this, player);
                this.throttledHandleMouseMove = app_throttle(app_bind_(this, this.handleMouseMove), app_UPDATE_REFRESH_INTERVAL);
                this.handleMouseUpHandler_ = e => this.handleMouseUp(e);
                this.on("mousedown", (e => this.handleMouseDown(e)));
                this.on("touchstart", (e => this.handleMouseDown(e)));
                this.on("mousemove", (e => this.handleMouseMove(e)));
                this.on(this.volumeBar, [ "focus", "slideractive" ], (() => {
                    this.volumeBar.addClass("vjs-slider-active");
                    this.addClass("vjs-slider-active");
                    this.trigger("slideractive");
                }));
                this.on(this.volumeBar, [ "blur", "sliderinactive" ], (() => {
                    this.volumeBar.removeClass("vjs-slider-active");
                    this.removeClass("vjs-slider-active");
                    this.trigger("sliderinactive");
                }));
            }
            createEl() {
                let orientationClass = "vjs-volume-horizontal";
                if (this.options_.vertical) orientationClass = "vjs-volume-vertical";
                return super.createEl("div", {
                    className: `vjs-volume-control vjs-control ${orientationClass}`
                });
            }
            handleMouseDown(event) {
                const doc = this.el_.ownerDocument;
                this.on(doc, "mousemove", this.throttledHandleMouseMove);
                this.on(doc, "touchmove", this.throttledHandleMouseMove);
                this.on(doc, "mouseup", this.handleMouseUpHandler_);
                this.on(doc, "touchend", this.handleMouseUpHandler_);
            }
            handleMouseUp(event) {
                const doc = this.el_.ownerDocument;
                this.off(doc, "mousemove", this.throttledHandleMouseMove);
                this.off(doc, "touchmove", this.throttledHandleMouseMove);
                this.off(doc, "mouseup", this.handleMouseUpHandler_);
                this.off(doc, "touchend", this.handleMouseUpHandler_);
            }
            handleMouseMove(event) {
                this.volumeBar.handleMouseMove(event);
            }
        }
        app_VolumeControl.prototype.options_ = {
            children: [ "volumeBar" ]
        };
        app_Component$1.registerComponent("VolumeControl", app_VolumeControl);
        const app_checkMuteSupport = function(self, player) {
            if (player.tech_ && !player.tech_.featuresMuteControl) self.addClass("vjs-hidden");
            self.on(player, "loadstart", (function() {
                if (!player.tech_.featuresMuteControl) self.addClass("vjs-hidden"); else self.removeClass("vjs-hidden");
            }));
        };
        class app_MuteToggle extends app_Button {
            constructor(player, options) {
                super(player, options);
                app_checkMuteSupport(this, player);
                this.on(player, [ "loadstart", "volumechange" ], (e => this.update(e)));
            }
            buildCSSClass() {
                return `vjs-mute-control ${super.buildCSSClass()}`;
            }
            handleClick(event) {
                const vol = this.player_.volume();
                const lastVolume = this.player_.lastVolume_();
                if (vol === 0) {
                    const volumeToSet = lastVolume < .1 ? .1 : lastVolume;
                    this.player_.volume(volumeToSet);
                    this.player_.muted(false);
                } else this.player_.muted(this.player_.muted() ? false : true);
            }
            update(event) {
                this.updateIcon_();
                this.updateControlText_();
            }
            updateIcon_() {
                const vol = this.player_.volume();
                let level = 3;
                this.setIcon("volume-high");
                if (app_IS_IOS && this.player_.tech_ && this.player_.tech_.el_) this.player_.muted(this.player_.tech_.el_.muted);
                if (vol === 0 || this.player_.muted()) {
                    this.setIcon("volume-mute");
                    level = 0;
                } else if (vol < .33) {
                    this.setIcon("volume-low");
                    level = 1;
                } else if (vol < .67) {
                    this.setIcon("volume-medium");
                    level = 2;
                }
                app_removeClass(this.el_, [ 0, 1, 2, 3 ].reduce(((str, i) => str + `${i ? " " : ""}vjs-vol-${i}`), ""));
                app_addClass(this.el_, `vjs-vol-${level}`);
            }
            updateControlText_() {
                const soundOff = this.player_.muted() || this.player_.volume() === 0;
                const text = soundOff ? "Unmute" : "Mute";
                if (this.controlText() !== text) this.controlText(text);
            }
        }
        app_MuteToggle.prototype.controlText_ = "Mute";
        app_Component$1.registerComponent("MuteToggle", app_MuteToggle);
        class app_VolumePanel extends app_Component$1 {
            constructor(player, options = {}) {
                if (typeof options.inline !== "undefined") options.inline = options.inline; else options.inline = true;
                if (typeof options.volumeControl === "undefined" || app_isPlain(options.volumeControl)) {
                    options.volumeControl = options.volumeControl || {};
                    options.volumeControl.vertical = !options.inline;
                }
                super(player, options);
                this.handleKeyPressHandler_ = e => this.handleKeyPress(e);
                this.on(player, [ "loadstart" ], (e => this.volumePanelState_(e)));
                this.on(this.muteToggle, "keyup", (e => this.handleKeyPress(e)));
                this.on(this.volumeControl, "keyup", (e => this.handleVolumeControlKeyUp(e)));
                this.on("keydown", (e => this.handleKeyPress(e)));
                this.on("mouseover", (e => this.handleMouseOver(e)));
                this.on("mouseout", (e => this.handleMouseOut(e)));
                this.on(this.volumeControl, [ "slideractive" ], this.sliderActive_);
                this.on(this.volumeControl, [ "sliderinactive" ], this.sliderInactive_);
            }
            sliderActive_() {
                this.addClass("vjs-slider-active");
            }
            sliderInactive_() {
                this.removeClass("vjs-slider-active");
            }
            volumePanelState_() {
                if (this.volumeControl.hasClass("vjs-hidden") && this.muteToggle.hasClass("vjs-hidden")) this.addClass("vjs-hidden");
                if (this.volumeControl.hasClass("vjs-hidden") && !this.muteToggle.hasClass("vjs-hidden")) this.addClass("vjs-mute-toggle-only");
            }
            createEl() {
                let orientationClass = "vjs-volume-panel-horizontal";
                if (!this.options_.inline) orientationClass = "vjs-volume-panel-vertical";
                return super.createEl("div", {
                    className: `vjs-volume-panel vjs-control ${orientationClass}`
                });
            }
            dispose() {
                this.handleMouseOut();
                super.dispose();
            }
            handleVolumeControlKeyUp(event) {
                if (event.key === "Escape") this.muteToggle.focus();
            }
            handleMouseOver(event) {
                this.addClass("vjs-hover");
                app_on(app_document_default(), "keyup", this.handleKeyPressHandler_);
            }
            handleMouseOut(event) {
                this.removeClass("vjs-hover");
                app_off(app_document_default(), "keyup", this.handleKeyPressHandler_);
            }
            handleKeyPress(event) {
                if (event.key === "Escape") this.handleMouseOut();
            }
        }
        app_VolumePanel.prototype.options_ = {
            children: [ "muteToggle", "volumeControl" ]
        };
        app_Component$1.registerComponent("VolumePanel", app_VolumePanel);
        class app_SkipForward extends app_Button {
            constructor(player, options) {
                super(player, options);
                this.validOptions = [ 5, 10, 30 ];
                this.skipTime = this.getSkipForwardTime();
                if (this.skipTime && this.validOptions.includes(this.skipTime)) {
                    this.setIcon(`forward-${this.skipTime}`);
                    this.controlText(this.localize("Skip forward {1} seconds", [ this.skipTime.toLocaleString(player.language()) ]));
                    this.show();
                } else this.hide();
            }
            getSkipForwardTime() {
                const playerOptions = this.options_.playerOptions;
                return playerOptions.controlBar && playerOptions.controlBar.skipButtons && playerOptions.controlBar.skipButtons.forward;
            }
            buildCSSClass() {
                return `vjs-skip-forward-${this.getSkipForwardTime()} ${super.buildCSSClass()}`;
            }
            handleClick(event) {
                if (isNaN(this.player_.duration())) return;
                const currentVideoTime = this.player_.currentTime();
                const liveTracker = this.player_.liveTracker;
                const duration = liveTracker && liveTracker.isLive() ? liveTracker.seekableEnd() : this.player_.duration();
                let newTime;
                if (currentVideoTime + this.skipTime <= duration) newTime = currentVideoTime + this.skipTime; else newTime = duration;
                this.player_.currentTime(newTime);
            }
            handleLanguagechange() {
                this.controlText(this.localize("Skip forward {1} seconds", [ this.skipTime ]));
            }
        }
        app_SkipForward.prototype.controlText_ = "Skip Forward";
        app_Component$1.registerComponent("SkipForward", app_SkipForward);
        class app_SkipBackward extends app_Button {
            constructor(player, options) {
                super(player, options);
                this.validOptions = [ 5, 10, 30 ];
                this.skipTime = this.getSkipBackwardTime();
                if (this.skipTime && this.validOptions.includes(this.skipTime)) {
                    this.setIcon(`replay-${this.skipTime}`);
                    this.controlText(this.localize("Skip backward {1} seconds", [ this.skipTime.toLocaleString(player.language()) ]));
                    this.show();
                } else this.hide();
            }
            getSkipBackwardTime() {
                const playerOptions = this.options_.playerOptions;
                return playerOptions.controlBar && playerOptions.controlBar.skipButtons && playerOptions.controlBar.skipButtons.backward;
            }
            buildCSSClass() {
                return `vjs-skip-backward-${this.getSkipBackwardTime()} ${super.buildCSSClass()}`;
            }
            handleClick(event) {
                const currentVideoTime = this.player_.currentTime();
                const liveTracker = this.player_.liveTracker;
                const seekableStart = liveTracker && liveTracker.isLive() && liveTracker.seekableStart();
                let newTime;
                if (seekableStart && currentVideoTime - this.skipTime <= seekableStart) newTime = seekableStart; else if (currentVideoTime >= this.skipTime) newTime = currentVideoTime - this.skipTime; else newTime = 0;
                this.player_.currentTime(newTime);
            }
            handleLanguagechange() {
                this.controlText(this.localize("Skip backward {1} seconds", [ this.skipTime ]));
            }
        }
        app_SkipBackward.prototype.controlText_ = "Skip Backward";
        app_Component$1.registerComponent("SkipBackward", app_SkipBackward);
        class app_Menu extends app_Component$1 {
            constructor(player, options) {
                super(player, options);
                if (options) this.menuButton_ = options.menuButton;
                this.focusedChild_ = -1;
                this.on("keydown", (e => this.handleKeyDown(e)));
                this.boundHandleBlur_ = e => this.handleBlur(e);
                this.boundHandleTapClick_ = e => this.handleTapClick(e);
            }
            addEventListenerForItem(component) {
                if (!(component instanceof app_Component$1)) return;
                this.on(component, "blur", this.boundHandleBlur_);
                this.on(component, [ "tap", "click" ], this.boundHandleTapClick_);
            }
            removeEventListenerForItem(component) {
                if (!(component instanceof app_Component$1)) return;
                this.off(component, "blur", this.boundHandleBlur_);
                this.off(component, [ "tap", "click" ], this.boundHandleTapClick_);
            }
            removeChild(component) {
                if (typeof component === "string") component = this.getChild(component);
                this.removeEventListenerForItem(component);
                super.removeChild(component);
            }
            addItem(component) {
                const childComponent = this.addChild(component);
                if (childComponent) this.addEventListenerForItem(childComponent);
            }
            createEl() {
                const contentElType = this.options_.contentElType || "ul";
                this.contentEl_ = app_createEl(contentElType, {
                    className: "vjs-menu-content"
                });
                this.contentEl_.setAttribute("role", "menu");
                const el = super.createEl("div", {
                    append: this.contentEl_,
                    className: "vjs-menu"
                });
                el.appendChild(this.contentEl_);
                app_on(el, "click", (function(event) {
                    event.preventDefault();
                    event.stopImmediatePropagation();
                }));
                return el;
            }
            dispose() {
                this.contentEl_ = null;
                this.boundHandleBlur_ = null;
                this.boundHandleTapClick_ = null;
                super.dispose();
            }
            handleBlur(event) {
                const relatedTarget = event.relatedTarget || app_document_default().activeElement;
                if (!this.children().some((element => element.el() === relatedTarget))) {
                    const btn = this.menuButton_;
                    if (btn && btn.buttonPressed_ && relatedTarget !== btn.el().firstChild) btn.unpressButton();
                }
            }
            handleTapClick(event) {
                if (this.menuButton_) {
                    this.menuButton_.unpressButton();
                    const childComponents = this.children();
                    if (!Array.isArray(childComponents)) return;
                    const foundComponent = childComponents.filter((component => component.el() === event.target))[0];
                    if (!foundComponent) return;
                    if (foundComponent.name() !== "CaptionSettingsMenuItem") this.menuButton_.focus();
                }
            }
            handleKeyDown(event) {
                if (event.key === "ArrowLeft" || event.key === "ArrowDown") {
                    event.preventDefault();
                    event.stopPropagation();
                    this.stepForward();
                } else if (event.key === "ArrowRight" || event.key === "ArrowUp") {
                    event.preventDefault();
                    event.stopPropagation();
                    this.stepBack();
                }
            }
            stepForward() {
                let stepChild = 0;
                if (this.focusedChild_ !== void 0) stepChild = this.focusedChild_ + 1;
                this.focus(stepChild);
            }
            stepBack() {
                let stepChild = 0;
                if (this.focusedChild_ !== void 0) stepChild = this.focusedChild_ - 1;
                this.focus(stepChild);
            }
            focus(item = 0) {
                const children = this.children().slice();
                const haveTitle = children.length && children[0].hasClass("vjs-menu-title");
                if (haveTitle) children.shift();
                if (children.length > 0) {
                    if (item < 0) item = 0; else if (item >= children.length) item = children.length - 1;
                    this.focusedChild_ = item;
                    children[item].el_.focus();
                }
            }
        }
        app_Component$1.registerComponent("Menu", app_Menu);
        class app_MenuButton extends app_Component$1 {
            constructor(player, options = {}) {
                super(player, options);
                this.menuButton_ = new app_Button(player, options);
                this.menuButton_.controlText(this.controlText_);
                this.menuButton_.el_.setAttribute("aria-haspopup", "true");
                const buttonClass = app_Button.prototype.buildCSSClass();
                this.menuButton_.el_.className = this.buildCSSClass() + " " + buttonClass;
                this.menuButton_.removeClass("vjs-control");
                this.addChild(this.menuButton_);
                this.update();
                this.enabled_ = true;
                const handleClick = e => this.handleClick(e);
                this.handleMenuKeyUp_ = e => this.handleMenuKeyUp(e);
                this.on(this.menuButton_, "tap", handleClick);
                this.on(this.menuButton_, "click", handleClick);
                this.on(this.menuButton_, "keydown", (e => this.handleKeyDown(e)));
                this.on(this.menuButton_, "mouseenter", (() => {
                    this.addClass("vjs-hover");
                    this.menu.show();
                    app_on(app_document_default(), "keyup", this.handleMenuKeyUp_);
                }));
                this.on("mouseleave", (e => this.handleMouseLeave(e)));
                this.on("keydown", (e => this.handleSubmenuKeyDown(e)));
            }
            update() {
                const menu = this.createMenu();
                if (this.menu) {
                    this.menu.dispose();
                    this.removeChild(this.menu);
                }
                this.menu = menu;
                this.addChild(menu);
                this.buttonPressed_ = false;
                this.menuButton_.el_.setAttribute("aria-expanded", "false");
                if (this.items && this.items.length <= this.hideThreshold_) {
                    this.hide();
                    this.menu.contentEl_.removeAttribute("role");
                } else {
                    this.show();
                    this.menu.contentEl_.setAttribute("role", "menu");
                }
            }
            createMenu() {
                const menu = new app_Menu(this.player_, {
                    menuButton: this
                });
                this.hideThreshold_ = 0;
                if (this.options_.title) {
                    const titleEl = app_createEl("li", {
                        className: "vjs-menu-title",
                        textContent: app_toTitleCase$1(this.options_.title),
                        tabIndex: -1
                    });
                    const titleComponent = new app_Component$1(this.player_, {
                        el: titleEl
                    });
                    menu.addItem(titleComponent);
                }
                this.items = this.createItems();
                if (this.items) for (let i = 0; i < this.items.length; i++) menu.addItem(this.items[i]);
                return menu;
            }
            createItems() {}
            createEl() {
                return super.createEl("div", {
                    className: this.buildWrapperCSSClass()
                }, {});
            }
            setIcon(name) {
                super.setIcon(name, this.menuButton_.el_);
            }
            buildWrapperCSSClass() {
                let menuButtonClass = "vjs-menu-button";
                if (this.options_.inline === true) menuButtonClass += "-inline"; else menuButtonClass += "-popup";
                const buttonClass = app_Button.prototype.buildCSSClass();
                return `vjs-menu-button ${menuButtonClass} ${buttonClass} ${super.buildCSSClass()}`;
            }
            buildCSSClass() {
                let menuButtonClass = "vjs-menu-button";
                if (this.options_.inline === true) menuButtonClass += "-inline"; else menuButtonClass += "-popup";
                return `vjs-menu-button ${menuButtonClass} ${super.buildCSSClass()}`;
            }
            controlText(text, el = this.menuButton_.el()) {
                return this.menuButton_.controlText(text, el);
            }
            dispose() {
                this.handleMouseLeave();
                super.dispose();
            }
            handleClick(event) {
                if (this.buttonPressed_) this.unpressButton(); else this.pressButton();
            }
            handleMouseLeave(event) {
                this.removeClass("vjs-hover");
                app_off(app_document_default(), "keyup", this.handleMenuKeyUp_);
            }
            focus() {
                this.menuButton_.focus();
            }
            blur() {
                this.menuButton_.blur();
            }
            handleKeyDown(event) {
                if (event.key === "Escape" || event.key === "Tab") {
                    if (this.buttonPressed_) this.unpressButton();
                    if (!event.key === "Tab") {
                        event.preventDefault();
                        this.menuButton_.focus();
                    }
                } else if (event.key === "Up" || event.key === "Down" && !(this.player_.options_.playerOptions.spatialNavigation && this.player_.options_.playerOptions.spatialNavigation.enabled)) if (!this.buttonPressed_) {
                    event.preventDefault();
                    this.pressButton();
                }
            }
            handleMenuKeyUp(event) {
                if (event.key === "Escape" || event.key === "Tab") this.removeClass("vjs-hover");
            }
            handleSubmenuKeyPress(event) {
                this.handleSubmenuKeyDown(event);
            }
            handleSubmenuKeyDown(event) {
                if (event.key === "Escape" || event.key === "Tab") {
                    if (this.buttonPressed_) this.unpressButton();
                    if (!event.key === "Tab") {
                        event.preventDefault();
                        this.menuButton_.focus();
                    }
                }
            }
            pressButton() {
                if (this.enabled_) {
                    this.buttonPressed_ = true;
                    this.menu.show();
                    this.menu.lockShowing();
                    this.menuButton_.el_.setAttribute("aria-expanded", "true");
                    if (app_IS_IOS && app_isInFrame()) return;
                    this.menu.focus();
                }
            }
            unpressButton() {
                if (this.enabled_) {
                    this.buttonPressed_ = false;
                    this.menu.unlockShowing();
                    this.menu.hide();
                    this.menuButton_.el_.setAttribute("aria-expanded", "false");
                }
            }
            disable() {
                this.unpressButton();
                this.enabled_ = false;
                this.addClass("vjs-disabled");
                this.menuButton_.disable();
            }
            enable() {
                this.enabled_ = true;
                this.removeClass("vjs-disabled");
                this.menuButton_.enable();
            }
        }
        app_Component$1.registerComponent("MenuButton", app_MenuButton);
        class app_TrackButton extends app_MenuButton {
            constructor(player, options) {
                const tracks = options.tracks;
                super(player, options);
                if (this.items.length <= 1) this.hide();
                if (!tracks) return;
                const updateHandler = app_bind_(this, this.update);
                tracks.addEventListener("removetrack", updateHandler);
                tracks.addEventListener("addtrack", updateHandler);
                tracks.addEventListener("labelchange", updateHandler);
                this.player_.on("ready", updateHandler);
                this.player_.on("dispose", (function() {
                    tracks.removeEventListener("removetrack", updateHandler);
                    tracks.removeEventListener("addtrack", updateHandler);
                    tracks.removeEventListener("labelchange", updateHandler);
                }));
            }
        }
        app_Component$1.registerComponent("TrackButton", app_TrackButton);
        class app_MenuItem extends app_ClickableComponent {
            constructor(player, options) {
                super(player, options);
                this.selectable = options.selectable;
                this.isSelected_ = options.selected || false;
                this.multiSelectable = options.multiSelectable;
                this.selected(this.isSelected_);
                if (this.selectable) if (this.multiSelectable) this.el_.setAttribute("role", "menuitemcheckbox"); else this.el_.setAttribute("role", "menuitemradio"); else this.el_.setAttribute("role", "menuitem");
            }
            createEl(type, props, attrs) {
                this.nonIconControl = true;
                const el = super.createEl("li", Object.assign({
                    className: "vjs-menu-item",
                    tabIndex: -1
                }, props), attrs);
                const menuItemEl = app_createEl("span", {
                    className: "vjs-menu-item-text",
                    textContent: this.localize(this.options_.label)
                });
                if (this.player_.options_.experimentalSvgIcons) el.appendChild(menuItemEl); else el.replaceChild(menuItemEl, el.querySelector(".vjs-icon-placeholder"));
                return el;
            }
            handleKeyDown(event) {
                if (![ "Tab", "Escape", "ArrowUp", "ArrowLeft", "ArrowRight", "ArrowDown" ].includes(event.key)) super.handleKeyDown(event);
            }
            handleClick(event) {
                this.selected(true);
            }
            selected(selected) {
                if (this.selectable) if (selected) {
                    this.addClass("vjs-selected");
                    this.el_.setAttribute("aria-checked", "true");
                    this.controlText(", selected");
                    this.isSelected_ = true;
                } else {
                    this.removeClass("vjs-selected");
                    this.el_.setAttribute("aria-checked", "false");
                    this.controlText("");
                    this.isSelected_ = false;
                }
            }
        }
        app_Component$1.registerComponent("MenuItem", app_MenuItem);
        class app_TextTrackMenuItem extends app_MenuItem {
            constructor(player, options) {
                const track = options.track;
                const tracks = player.textTracks();
                options.label = track.label || track.language || "Unknown";
                options.selected = track.mode === "showing";
                super(player, options);
                this.track = track;
                this.kinds = (options.kinds || [ options.kind || this.track.kind ]).filter(Boolean);
                const changeHandler = (...args) => {
                    this.handleTracksChange.apply(this, args);
                };
                const selectedLanguageChangeHandler = (...args) => {
                    this.handleSelectedLanguageChange.apply(this, args);
                };
                player.on([ "loadstart", "texttrackchange" ], changeHandler);
                tracks.addEventListener("change", changeHandler);
                tracks.addEventListener("selectedlanguagechange", selectedLanguageChangeHandler);
                this.on("dispose", (function() {
                    player.off([ "loadstart", "texttrackchange" ], changeHandler);
                    tracks.removeEventListener("change", changeHandler);
                    tracks.removeEventListener("selectedlanguagechange", selectedLanguageChangeHandler);
                }));
                if (tracks.onchange === void 0) {
                    let event;
                    this.on([ "tap", "click" ], (function() {
                        if (typeof app_window_default().Event !== "object") try {
                            event = new (app_window_default().Event)("change");
                        } catch (err) {}
                        if (!event) {
                            event = app_document_default().createEvent("Event");
                            event.initEvent("change", true, true);
                        }
                        tracks.dispatchEvent(event);
                    }));
                }
                this.handleTracksChange();
            }
            handleClick(event) {
                const referenceTrack = this.track;
                const tracks = this.player_.textTracks();
                super.handleClick(event);
                if (!tracks) return;
                for (let i = 0; i < tracks.length; i++) {
                    const track = tracks[i];
                    if (this.kinds.indexOf(track.kind) === -1) continue;
                    if (track === referenceTrack) {
                        if (track.mode !== "showing") track.mode = "showing";
                    } else if (track.mode !== "disabled") track.mode = "disabled";
                }
            }
            handleTracksChange(event) {
                const shouldBeSelected = this.track.mode === "showing";
                if (shouldBeSelected !== this.isSelected_) this.selected(shouldBeSelected);
            }
            handleSelectedLanguageChange(event) {
                if (this.track.mode === "showing") {
                    const selectedLanguage = this.player_.cache_.selectedLanguage;
                    if (selectedLanguage && selectedLanguage.enabled && selectedLanguage.language === this.track.language && selectedLanguage.kind !== this.track.kind) return;
                    this.player_.cache_.selectedLanguage = {
                        enabled: true,
                        language: this.track.language,
                        kind: this.track.kind
                    };
                }
            }
            dispose() {
                this.track = null;
                super.dispose();
            }
        }
        app_Component$1.registerComponent("TextTrackMenuItem", app_TextTrackMenuItem);
        class app_OffTextTrackMenuItem extends app_TextTrackMenuItem {
            constructor(player, options) {
                options.track = {
                    player,
                    kind: options.kind,
                    kinds: options.kinds,
                    default: false,
                    mode: "disabled"
                };
                if (!options.kinds) options.kinds = [ options.kind ];
                if (options.label) options.track.label = options.label; else options.track.label = options.kinds.join(" and ") + " off";
                options.selectable = true;
                options.multiSelectable = false;
                super(player, options);
            }
            handleTracksChange(event) {
                const tracks = this.player().textTracks();
                let shouldBeSelected = true;
                for (let i = 0, l = tracks.length; i < l; i++) {
                    const track = tracks[i];
                    if (this.options_.kinds.indexOf(track.kind) > -1 && track.mode === "showing") {
                        shouldBeSelected = false;
                        break;
                    }
                }
                if (shouldBeSelected !== this.isSelected_) this.selected(shouldBeSelected);
            }
            handleSelectedLanguageChange(event) {
                const tracks = this.player().textTracks();
                let allHidden = true;
                for (let i = 0, l = tracks.length; i < l; i++) {
                    const track = tracks[i];
                    if ([ "captions", "descriptions", "subtitles" ].indexOf(track.kind) > -1 && track.mode === "showing") {
                        allHidden = false;
                        break;
                    }
                }
                if (allHidden) this.player_.cache_.selectedLanguage = {
                    enabled: false
                };
            }
            handleLanguagechange() {
                this.$(".vjs-menu-item-text").textContent = this.player_.localize(this.options_.label);
                super.handleLanguagechange();
            }
        }
        app_Component$1.registerComponent("OffTextTrackMenuItem", app_OffTextTrackMenuItem);
        class app_TextTrackButton extends app_TrackButton {
            constructor(player, options = {}) {
                options.tracks = player.textTracks();
                super(player, options);
            }
            createItems(items = [], TrackMenuItem = app_TextTrackMenuItem) {
                let label;
                if (this.label_) label = `${this.label_} off`;
                items.push(new app_OffTextTrackMenuItem(this.player_, {
                    kinds: this.kinds_,
                    kind: this.kind_,
                    label
                }));
                this.hideThreshold_ += 1;
                const tracks = this.player_.textTracks();
                if (!Array.isArray(this.kinds_)) this.kinds_ = [ this.kind_ ];
                for (let i = 0; i < tracks.length; i++) {
                    const track = tracks[i];
                    if (this.kinds_.indexOf(track.kind) > -1) {
                        const item = new TrackMenuItem(this.player_, {
                            track,
                            kinds: this.kinds_,
                            kind: this.kind_,
                            selectable: true,
                            multiSelectable: false
                        });
                        item.addClass(`vjs-${track.kind}-menu-item`);
                        items.push(item);
                    }
                }
                return items;
            }
        }
        app_Component$1.registerComponent("TextTrackButton", app_TextTrackButton);
        class app_ChaptersTrackMenuItem extends app_MenuItem {
            constructor(player, options) {
                const track = options.track;
                const cue = options.cue;
                const currentTime = player.currentTime();
                options.selectable = true;
                options.multiSelectable = false;
                options.label = cue.text;
                options.selected = cue.startTime <= currentTime && currentTime < cue.endTime;
                super(player, options);
                this.track = track;
                this.cue = cue;
            }
            handleClick(event) {
                super.handleClick();
                this.player_.currentTime(this.cue.startTime);
            }
        }
        app_Component$1.registerComponent("ChaptersTrackMenuItem", app_ChaptersTrackMenuItem);
        class app_ChaptersButton extends app_TextTrackButton {
            constructor(player, options, ready) {
                super(player, options, ready);
                this.setIcon("chapters");
                this.selectCurrentItem_ = () => {
                    this.items.forEach((item => {
                        item.selected(this.track_.activeCues[0] === item.cue);
                    }));
                };
            }
            buildCSSClass() {
                return `vjs-chapters-button ${super.buildCSSClass()}`;
            }
            buildWrapperCSSClass() {
                return `vjs-chapters-button ${super.buildWrapperCSSClass()}`;
            }
            update(event) {
                if (event && event.track && event.track.kind !== "chapters") return;
                const track = this.findChaptersTrack();
                if (track !== this.track_) {
                    this.setTrack(track);
                    super.update();
                } else if (!this.items || track && track.cues && track.cues.length !== this.items.length) super.update();
            }
            setTrack(track) {
                if (this.track_ === track) return;
                if (!this.updateHandler_) this.updateHandler_ = this.update.bind(this);
                if (this.track_) {
                    const remoteTextTrackEl = this.player_.remoteTextTrackEls().getTrackElementByTrack_(this.track_);
                    if (remoteTextTrackEl) remoteTextTrackEl.removeEventListener("load", this.updateHandler_);
                    this.track_.removeEventListener("cuechange", this.selectCurrentItem_);
                    this.track_ = null;
                }
                this.track_ = track;
                if (this.track_) {
                    this.track_.mode = "hidden";
                    const remoteTextTrackEl = this.player_.remoteTextTrackEls().getTrackElementByTrack_(this.track_);
                    if (remoteTextTrackEl) remoteTextTrackEl.addEventListener("load", this.updateHandler_);
                    this.track_.addEventListener("cuechange", this.selectCurrentItem_);
                }
            }
            findChaptersTrack() {
                const tracks = this.player_.textTracks() || [];
                for (let i = tracks.length - 1; i >= 0; i--) {
                    const track = tracks[i];
                    if (track.kind === this.kind_) return track;
                }
            }
            getMenuCaption() {
                if (this.track_ && this.track_.label) return this.track_.label;
                return this.localize(app_toTitleCase$1(this.kind_));
            }
            createMenu() {
                this.options_.title = this.getMenuCaption();
                return super.createMenu();
            }
            createItems() {
                const items = [];
                if (!this.track_) return items;
                const cues = this.track_.cues;
                if (!cues) return items;
                for (let i = 0, l = cues.length; i < l; i++) {
                    const cue = cues[i];
                    const mi = new app_ChaptersTrackMenuItem(this.player_, {
                        track: this.track_,
                        cue
                    });
                    items.push(mi);
                }
                return items;
            }
        }
        app_ChaptersButton.prototype.kind_ = "chapters";
        app_ChaptersButton.prototype.controlText_ = "Chapters";
        app_Component$1.registerComponent("ChaptersButton", app_ChaptersButton);
        class app_DescriptionsButton extends app_TextTrackButton {
            constructor(player, options, ready) {
                super(player, options, ready);
                this.setIcon("audio-description");
                const tracks = player.textTracks();
                const changeHandler = app_bind_(this, this.handleTracksChange);
                tracks.addEventListener("change", changeHandler);
                this.on("dispose", (function() {
                    tracks.removeEventListener("change", changeHandler);
                }));
            }
            handleTracksChange(event) {
                const tracks = this.player().textTracks();
                let disabled = false;
                for (let i = 0, l = tracks.length; i < l; i++) {
                    const track = tracks[i];
                    if (track.kind !== this.kind_ && track.mode === "showing") {
                        disabled = true;
                        break;
                    }
                }
                if (disabled) this.disable(); else this.enable();
            }
            buildCSSClass() {
                return `vjs-descriptions-button ${super.buildCSSClass()}`;
            }
            buildWrapperCSSClass() {
                return `vjs-descriptions-button ${super.buildWrapperCSSClass()}`;
            }
        }
        app_DescriptionsButton.prototype.kind_ = "descriptions";
        app_DescriptionsButton.prototype.controlText_ = "Descriptions";
        app_Component$1.registerComponent("DescriptionsButton", app_DescriptionsButton);
        class app_SubtitlesButton extends app_TextTrackButton {
            constructor(player, options, ready) {
                super(player, options, ready);
                this.setIcon("subtitles");
            }
            buildCSSClass() {
                return `vjs-subtitles-button ${super.buildCSSClass()}`;
            }
            buildWrapperCSSClass() {
                return `vjs-subtitles-button ${super.buildWrapperCSSClass()}`;
            }
        }
        app_SubtitlesButton.prototype.kind_ = "subtitles";
        app_SubtitlesButton.prototype.controlText_ = "Subtitles";
        app_Component$1.registerComponent("SubtitlesButton", app_SubtitlesButton);
        class app_CaptionSettingsMenuItem extends app_TextTrackMenuItem {
            constructor(player, options) {
                options.track = {
                    player,
                    kind: options.kind,
                    label: options.kind + " settings",
                    selectable: false,
                    default: false,
                    mode: "disabled"
                };
                options.selectable = false;
                options.name = "CaptionSettingsMenuItem";
                super(player, options);
                this.addClass("vjs-texttrack-settings");
                this.controlText(", opens " + options.kind + " settings dialog");
            }
            handleClick(event) {
                this.player().getChild("textTrackSettings").open();
            }
            handleLanguagechange() {
                this.$(".vjs-menu-item-text").textContent = this.player_.localize(this.options_.kind + " settings");
                super.handleLanguagechange();
            }
        }
        app_Component$1.registerComponent("CaptionSettingsMenuItem", app_CaptionSettingsMenuItem);
        class app_CaptionsButton extends app_TextTrackButton {
            constructor(player, options, ready) {
                super(player, options, ready);
                this.setIcon("captions");
            }
            buildCSSClass() {
                return `vjs-captions-button ${super.buildCSSClass()}`;
            }
            buildWrapperCSSClass() {
                return `vjs-captions-button ${super.buildWrapperCSSClass()}`;
            }
            createItems() {
                const items = [];
                if (!(this.player().tech_ && this.player().tech_.featuresNativeTextTracks) && this.player().getChild("textTrackSettings")) {
                    items.push(new app_CaptionSettingsMenuItem(this.player_, {
                        kind: this.kind_
                    }));
                    this.hideThreshold_ += 1;
                }
                return super.createItems(items);
            }
        }
        app_CaptionsButton.prototype.kind_ = "captions";
        app_CaptionsButton.prototype.controlText_ = "Captions";
        app_Component$1.registerComponent("CaptionsButton", app_CaptionsButton);
        class app_SubsCapsMenuItem extends app_TextTrackMenuItem {
            createEl(type, props, attrs) {
                const el = super.createEl(type, props, attrs);
                const parentSpan = el.querySelector(".vjs-menu-item-text");
                if (this.options_.track.kind === "captions") {
                    if (this.player_.options_.experimentalSvgIcons) this.setIcon("captions", el); else parentSpan.appendChild(app_createEl("span", {
                        className: "vjs-icon-placeholder"
                    }, {
                        "aria-hidden": true
                    }));
                    parentSpan.appendChild(app_createEl("span", {
                        className: "vjs-control-text",
                        textContent: ` ${this.localize("Captions")}`
                    }));
                }
                return el;
            }
        }
        app_Component$1.registerComponent("SubsCapsMenuItem", app_SubsCapsMenuItem);
        class app_SubsCapsButton extends app_TextTrackButton {
            constructor(player, options = {}) {
                super(player, options);
                this.label_ = "subtitles";
                this.setIcon("subtitles");
                if ([ "en", "en-us", "en-ca", "fr-ca" ].indexOf(this.player_.language_) > -1) {
                    this.label_ = "captions";
                    this.setIcon("captions");
                }
                this.menuButton_.controlText(app_toTitleCase$1(this.label_));
            }
            buildCSSClass() {
                return `vjs-subs-caps-button ${super.buildCSSClass()}`;
            }
            buildWrapperCSSClass() {
                return `vjs-subs-caps-button ${super.buildWrapperCSSClass()}`;
            }
            createItems() {
                let items = [];
                if (!(this.player().tech_ && this.player().tech_.featuresNativeTextTracks) && this.player().getChild("textTrackSettings")) {
                    items.push(new app_CaptionSettingsMenuItem(this.player_, {
                        kind: this.label_
                    }));
                    this.hideThreshold_ += 1;
                }
                items = super.createItems(items, app_SubsCapsMenuItem);
                return items;
            }
        }
        app_SubsCapsButton.prototype.kinds_ = [ "captions", "subtitles" ];
        app_SubsCapsButton.prototype.controlText_ = "Subtitles";
        app_Component$1.registerComponent("SubsCapsButton", app_SubsCapsButton);
        class app_AudioTrackMenuItem extends app_MenuItem {
            constructor(player, options) {
                const track = options.track;
                const tracks = player.audioTracks();
                options.label = track.label || track.language || "Unknown";
                options.selected = track.enabled;
                super(player, options);
                this.track = track;
                this.addClass(`vjs-${track.kind}-menu-item`);
                const changeHandler = (...args) => {
                    this.handleTracksChange.apply(this, args);
                };
                tracks.addEventListener("change", changeHandler);
                this.on("dispose", (() => {
                    tracks.removeEventListener("change", changeHandler);
                }));
            }
            createEl(type, props, attrs) {
                const el = super.createEl(type, props, attrs);
                const parentSpan = el.querySelector(".vjs-menu-item-text");
                if ([ "main-desc", "descriptions" ].indexOf(this.options_.track.kind) >= 0) {
                    parentSpan.appendChild(app_createEl("span", {
                        className: "vjs-icon-placeholder"
                    }, {
                        "aria-hidden": true
                    }));
                    parentSpan.appendChild(app_createEl("span", {
                        className: "vjs-control-text",
                        textContent: " " + this.localize("Descriptions")
                    }));
                }
                return el;
            }
            handleClick(event) {
                super.handleClick(event);
                this.track.enabled = true;
                if (this.player_.tech_.featuresNativeAudioTracks) {
                    const tracks = this.player_.audioTracks();
                    for (let i = 0; i < tracks.length; i++) {
                        const track = tracks[i];
                        if (track === this.track) continue;
                        track.enabled = track === this.track;
                    }
                }
            }
            handleTracksChange(event) {
                this.selected(this.track.enabled);
            }
        }
        app_Component$1.registerComponent("AudioTrackMenuItem", app_AudioTrackMenuItem);
        class app_AudioTrackButton extends app_TrackButton {
            constructor(player, options = {}) {
                options.tracks = player.audioTracks();
                super(player, options);
                this.setIcon("audio");
            }
            buildCSSClass() {
                return `vjs-audio-button ${super.buildCSSClass()}`;
            }
            buildWrapperCSSClass() {
                return `vjs-audio-button ${super.buildWrapperCSSClass()}`;
            }
            createItems(items = []) {
                this.hideThreshold_ = 1;
                const tracks = this.player_.audioTracks();
                for (let i = 0; i < tracks.length; i++) {
                    const track = tracks[i];
                    items.push(new app_AudioTrackMenuItem(this.player_, {
                        track,
                        selectable: true,
                        multiSelectable: false
                    }));
                }
                return items;
            }
        }
        app_AudioTrackButton.prototype.controlText_ = "Audio Track";
        app_Component$1.registerComponent("AudioTrackButton", app_AudioTrackButton);
        class app_PlaybackRateMenuItem extends app_MenuItem {
            constructor(player, options) {
                const label = options.rate;
                const rate = parseFloat(label, 10);
                options.label = label;
                options.selected = rate === player.playbackRate();
                options.selectable = true;
                options.multiSelectable = false;
                super(player, options);
                this.label = label;
                this.rate = rate;
                this.on(player, "ratechange", (e => this.update(e)));
            }
            handleClick(event) {
                super.handleClick();
                this.player().playbackRate(this.rate);
            }
            update(event) {
                this.selected(this.player().playbackRate() === this.rate);
            }
        }
        app_PlaybackRateMenuItem.prototype.contentElType = "button";
        app_Component$1.registerComponent("PlaybackRateMenuItem", app_PlaybackRateMenuItem);
        class app_PlaybackRateMenuButton extends app_MenuButton {
            constructor(player, options) {
                super(player, options);
                this.menuButton_.el_.setAttribute("aria-describedby", this.labelElId_);
                this.updateVisibility();
                this.updateLabel();
                this.on(player, "loadstart", (e => this.updateVisibility(e)));
                this.on(player, "ratechange", (e => this.updateLabel(e)));
                this.on(player, "playbackrateschange", (e => this.handlePlaybackRateschange(e)));
            }
            createEl() {
                const el = super.createEl();
                this.labelElId_ = "vjs-playback-rate-value-label-" + this.id_;
                this.labelEl_ = app_createEl("div", {
                    className: "vjs-playback-rate-value",
                    id: this.labelElId_,
                    textContent: "1x"
                });
                el.appendChild(this.labelEl_);
                return el;
            }
            dispose() {
                this.labelEl_ = null;
                super.dispose();
            }
            buildCSSClass() {
                return `vjs-playback-rate ${super.buildCSSClass()}`;
            }
            buildWrapperCSSClass() {
                return `vjs-playback-rate ${super.buildWrapperCSSClass()}`;
            }
            createItems() {
                const rates = this.playbackRates();
                const items = [];
                for (let i = rates.length - 1; i >= 0; i--) items.push(new app_PlaybackRateMenuItem(this.player(), {
                    rate: rates[i] + "x"
                }));
                return items;
            }
            handlePlaybackRateschange(event) {
                this.update();
            }
            playbackRates() {
                const player = this.player();
                return player.playbackRates && player.playbackRates() || [];
            }
            playbackRateSupported() {
                return this.player().tech_ && this.player().tech_.featuresPlaybackRate && this.playbackRates() && this.playbackRates().length > 0;
            }
            updateVisibility(event) {
                if (this.playbackRateSupported()) this.removeClass("vjs-hidden"); else this.addClass("vjs-hidden");
            }
            updateLabel(event) {
                if (this.playbackRateSupported()) this.labelEl_.textContent = this.player().playbackRate() + "x";
            }
        }
        app_PlaybackRateMenuButton.prototype.controlText_ = "Playback Rate";
        app_Component$1.registerComponent("PlaybackRateMenuButton", app_PlaybackRateMenuButton);
        class app_Spacer extends app_Component$1 {
            buildCSSClass() {
                return `vjs-spacer ${super.buildCSSClass()}`;
            }
            createEl(tag = "div", props = {}, attributes = {}) {
                if (!props.className) props.className = this.buildCSSClass();
                return super.createEl(tag, props, attributes);
            }
        }
        app_Component$1.registerComponent("Spacer", app_Spacer);
        class app_CustomControlSpacer extends app_Spacer {
            buildCSSClass() {
                return `vjs-custom-control-spacer ${super.buildCSSClass()}`;
            }
            createEl() {
                return super.createEl("div", {
                    className: this.buildCSSClass(),
                    textContent: "¬†"
                });
            }
        }
        app_Component$1.registerComponent("CustomControlSpacer", app_CustomControlSpacer);
        class app_ControlBar extends app_Component$1 {
            createEl() {
                return super.createEl("div", {
                    className: "vjs-control-bar",
                    dir: "ltr"
                });
            }
        }
        app_ControlBar.prototype.options_ = {
            children: [ "playToggle", "skipBackward", "skipForward", "volumePanel", "currentTimeDisplay", "timeDivider", "durationDisplay", "progressControl", "liveDisplay", "seekToLive", "remainingTimeDisplay", "customControlSpacer", "playbackRateMenuButton", "chaptersButton", "descriptionsButton", "subsCapsButton", "audioTrackButton", "pictureInPictureToggle", "fullscreenToggle" ]
        };
        app_Component$1.registerComponent("ControlBar", app_ControlBar);
        class app_ErrorDisplay extends app_ModalDialog {
            constructor(player, options) {
                super(player, options);
                this.on(player, "error", (e => {
                    this.open(e);
                }));
            }
            buildCSSClass() {
                return `vjs-error-display ${super.buildCSSClass()}`;
            }
            content() {
                const error = this.player().error();
                return error ? this.localize(error.message) : "";
            }
        }
        app_ErrorDisplay.prototype.options_ = Object.assign({}, app_ModalDialog.prototype.options_, {
            pauseOnOpen: false,
            fillAlways: true,
            temporary: false,
            uncloseable: true
        });
        app_Component$1.registerComponent("ErrorDisplay", app_ErrorDisplay);
        class app_TextTrackSelect extends app_Component$1 {
            constructor(player, options = {}) {
                super(player, options);
                this.el_.setAttribute("aria-labelledby", this.selectLabelledbyIds);
            }
            createEl() {
                this.selectLabelledbyIds = [ this.options_.legendId, this.options_.labelId ].join(" ").trim();
                const selectoptions = app_createEl("select", {
                    id: this.options_.id
                }, {}, this.options_.SelectOptions.map((optionText => {
                    const optionId = (this.options_.labelId ? this.options_.labelId : `vjs-track-option-${app_newGUID()}`) + "-" + optionText[1].replace(/\W+/g, "");
                    const option = app_createEl("option", {
                        id: optionId,
                        value: this.localize(optionText[0]),
                        textContent: this.localize(optionText[1])
                    });
                    option.setAttribute("aria-labelledby", `${this.selectLabelledbyIds} ${optionId}`);
                    return option;
                })));
                return selectoptions;
            }
        }
        app_Component$1.registerComponent("TextTrackSelect", app_TextTrackSelect);
        class app_TextTrackFieldset extends app_Component$1 {
            constructor(player, options = {}) {
                super(player, options);
                const legendElement = app_createEl("legend", {
                    textContent: this.localize(this.options_.legendText),
                    id: this.options_.legendId
                });
                this.el().appendChild(legendElement);
                const selects = this.options_.selects;
                for (const i of selects) {
                    const selectConfig = this.options_.selectConfigs[i];
                    const selectClassName = selectConfig.className;
                    const id = selectConfig.id.replace("%s", this.options_.id_);
                    let span = null;
                    const guid = `vjs_select_${app_newGUID()}`;
                    if (this.options_.type === "colors") {
                        span = app_createEl("span", {
                            className: selectClassName
                        });
                        const label = app_createEl("label", {
                            id,
                            className: "vjs-label",
                            textContent: this.localize(selectConfig.label)
                        });
                        label.setAttribute("for", guid);
                        span.appendChild(label);
                    }
                    const textTrackSelect = new app_TextTrackSelect(player, {
                        SelectOptions: selectConfig.options,
                        legendId: this.options_.legendId,
                        id: guid,
                        labelId: id
                    });
                    this.addChild(textTrackSelect);
                    if (this.options_.type === "colors") {
                        span.appendChild(textTrackSelect.el());
                        this.el().appendChild(span);
                    }
                }
            }
            createEl() {
                const el = app_createEl("fieldset", {
                    className: this.options_.className
                });
                return el;
            }
        }
        app_Component$1.registerComponent("TextTrackFieldset", app_TextTrackFieldset);
        class app_TextTrackSettingsColors extends app_Component$1 {
            constructor(player, options = {}) {
                super(player, options);
                const id_ = this.options_.textTrackComponentid;
                const ElFgColorFieldset = new app_TextTrackFieldset(player, {
                    id_,
                    legendId: `captions-text-legend-${id_}`,
                    legendText: this.localize("Text"),
                    className: "vjs-fg vjs-track-setting",
                    selects: this.options_.fieldSets[0],
                    selectConfigs: this.options_.selectConfigs,
                    type: "colors"
                });
                this.addChild(ElFgColorFieldset);
                const ElBgColorFieldset = new app_TextTrackFieldset(player, {
                    id_,
                    legendId: `captions-background-${id_}`,
                    legendText: this.localize("Text Background"),
                    className: "vjs-bg vjs-track-setting",
                    selects: this.options_.fieldSets[1],
                    selectConfigs: this.options_.selectConfigs,
                    type: "colors"
                });
                this.addChild(ElBgColorFieldset);
                const ElWinColorFieldset = new app_TextTrackFieldset(player, {
                    id_,
                    legendId: `captions-window-${id_}`,
                    legendText: this.localize("Caption Area Background"),
                    className: "vjs-window vjs-track-setting",
                    selects: this.options_.fieldSets[2],
                    selectConfigs: this.options_.selectConfigs,
                    type: "colors"
                });
                this.addChild(ElWinColorFieldset);
            }
            createEl() {
                const el = app_createEl("div", {
                    className: "vjs-track-settings-colors"
                });
                return el;
            }
        }
        app_Component$1.registerComponent("TextTrackSettingsColors", app_TextTrackSettingsColors);
        class app_TextTrackSettingsFont extends app_Component$1 {
            constructor(player, options = {}) {
                super(player, options);
                const id_ = this.options_.textTrackComponentid;
                const ElFgColorFieldset = new app_TextTrackFieldset(player, {
                    id_,
                    legendId: `captions-font-size-${id_}`,
                    legendText: "Font Size",
                    className: "vjs-font-percent vjs-track-setting",
                    selects: this.options_.fieldSets[0],
                    selectConfigs: this.options_.selectConfigs,
                    type: "font"
                });
                this.addChild(ElFgColorFieldset);
                const ElBgColorFieldset = new app_TextTrackFieldset(player, {
                    id_,
                    legendId: `captions-edge-style-${id_}`,
                    legendText: this.localize("Text Edge Style"),
                    className: "vjs-edge-style vjs-track-setting",
                    selects: this.options_.fieldSets[1],
                    selectConfigs: this.options_.selectConfigs,
                    type: "font"
                });
                this.addChild(ElBgColorFieldset);
                const ElWinColorFieldset = new app_TextTrackFieldset(player, {
                    id_,
                    legendId: `captions-font-family-${id_}`,
                    legendText: this.localize("Font Family"),
                    className: "vjs-font-family vjs-track-setting",
                    selects: this.options_.fieldSets[2],
                    selectConfigs: this.options_.selectConfigs,
                    type: "font"
                });
                this.addChild(ElWinColorFieldset);
            }
            createEl() {
                const el = app_createEl("div", {
                    className: "vjs-track-settings-font"
                });
                return el;
            }
        }
        app_Component$1.registerComponent("TextTrackSettingsFont", app_TextTrackSettingsFont);
        class app_TrackSettingsControls extends app_Component$1 {
            constructor(player, options = {}) {
                super(player, options);
                const defaultsDescription = this.localize("restore all settings to the default values");
                const resetButton = new app_Button(player, {
                    controlText: defaultsDescription,
                    className: "vjs-default-button"
                });
                resetButton.el().classList.remove("vjs-control", "vjs-button");
                resetButton.el().textContent = this.localize("Reset");
                this.addChild(resetButton);
                const doneButton = new app_Button(player, {
                    controlText: defaultsDescription,
                    className: "vjs-done-button"
                });
                doneButton.el().classList.remove("vjs-control", "vjs-button");
                doneButton.el().textContent = this.localize("Done");
                this.addChild(doneButton);
            }
            createEl() {
                const el = app_createEl("div", {
                    className: "vjs-track-settings-controls"
                });
                return el;
            }
        }
        app_Component$1.registerComponent("TrackSettingsControls", app_TrackSettingsControls);
        const app_LOCAL_STORAGE_KEY$1 = "vjs-text-track-settings";
        const app_COLOR_BLACK = [ "#000", "Black" ];
        const app_COLOR_BLUE = [ "#00F", "Blue" ];
        const app_COLOR_CYAN = [ "#0FF", "Cyan" ];
        const app_COLOR_GREEN = [ "#0F0", "Green" ];
        const app_COLOR_MAGENTA = [ "#F0F", "Magenta" ];
        const app_COLOR_RED = [ "#F00", "Red" ];
        const app_COLOR_WHITE = [ "#FFF", "White" ];
        const app_COLOR_YELLOW = [ "#FF0", "Yellow" ];
        const app_OPACITY_OPAQUE = [ "1", "Opaque" ];
        const app_OPACITY_SEMI = [ "0.5", "Semi-Transparent" ];
        const app_OPACITY_TRANS = [ "0", "Transparent" ];
        const app_selectConfigs = {
            backgroundColor: {
                selector: ".vjs-bg-color > select",
                id: "captions-background-color-%s",
                label: "Color",
                options: [ app_COLOR_BLACK, app_COLOR_WHITE, app_COLOR_RED, app_COLOR_GREEN, app_COLOR_BLUE, app_COLOR_YELLOW, app_COLOR_MAGENTA, app_COLOR_CYAN ],
                className: "vjs-bg-color"
            },
            backgroundOpacity: {
                selector: ".vjs-bg-opacity > select",
                id: "captions-background-opacity-%s",
                label: "Opacity",
                options: [ app_OPACITY_OPAQUE, app_OPACITY_SEMI, app_OPACITY_TRANS ],
                className: "vjs-bg-opacity vjs-opacity"
            },
            color: {
                selector: ".vjs-text-color > select",
                id: "captions-foreground-color-%s",
                label: "Color",
                options: [ app_COLOR_WHITE, app_COLOR_BLACK, app_COLOR_RED, app_COLOR_GREEN, app_COLOR_BLUE, app_COLOR_YELLOW, app_COLOR_MAGENTA, app_COLOR_CYAN ],
                className: "vjs-text-color"
            },
            edgeStyle: {
                selector: ".vjs-edge-style > select",
                id: "",
                label: "Text Edge Style",
                options: [ [ "none", "None" ], [ "raised", "Raised" ], [ "depressed", "Depressed" ], [ "uniform", "Uniform" ], [ "dropshadow", "Drop shadow" ] ]
            },
            fontFamily: {
                selector: ".vjs-font-family > select",
                id: "",
                label: "Font Family",
                options: [ [ "proportionalSansSerif", "Proportional Sans-Serif" ], [ "monospaceSansSerif", "Monospace Sans-Serif" ], [ "proportionalSerif", "Proportional Serif" ], [ "monospaceSerif", "Monospace Serif" ], [ "casual", "Casual" ], [ "script", "Script" ], [ "small-caps", "Small Caps" ] ]
            },
            fontPercent: {
                selector: ".vjs-font-percent > select",
                id: "",
                label: "Font Size",
                options: [ [ "0.50", "50%" ], [ "0.75", "75%" ], [ "1.00", "100%" ], [ "1.25", "125%" ], [ "1.50", "150%" ], [ "1.75", "175%" ], [ "2.00", "200%" ], [ "3.00", "300%" ], [ "4.00", "400%" ] ],
                default: 2,
                parser: v => v === "1.00" ? null : Number(v)
            },
            textOpacity: {
                selector: ".vjs-text-opacity > select",
                id: "captions-foreground-opacity-%s",
                label: "Opacity",
                options: [ app_OPACITY_OPAQUE, app_OPACITY_SEMI ],
                className: "vjs-text-opacity vjs-opacity"
            },
            windowColor: {
                selector: ".vjs-window-color > select",
                id: "captions-window-color-%s",
                label: "Color",
                className: "vjs-window-color"
            },
            windowOpacity: {
                selector: ".vjs-window-opacity > select",
                id: "captions-window-opacity-%s",
                label: "Opacity",
                options: [ app_OPACITY_TRANS, app_OPACITY_SEMI, app_OPACITY_OPAQUE ],
                className: "vjs-window-opacity vjs-opacity"
            }
        };
        app_selectConfigs.windowColor.options = app_selectConfigs.backgroundColor.options;
        function app_parseOptionValue(value, parser) {
            if (parser) value = parser(value);
            if (value && value !== "none") return value;
        }
        function app_getSelectedOptionValue(el, parser) {
            const value = el.options[el.options.selectedIndex].value;
            return app_parseOptionValue(value, parser);
        }
        function app_setSelectedOption(el, value, parser) {
            if (!value) return;
            for (let i = 0; i < el.options.length; i++) if (app_parseOptionValue(el.options[i].value, parser) === value) {
                el.selectedIndex = i;
                break;
            }
        }
        class app_TextTrackSettings extends app_ModalDialog {
            constructor(player, options) {
                options.temporary = false;
                super(player, options);
                this.updateDisplay = this.updateDisplay.bind(this);
                this.fill();
                this.hasBeenOpened_ = this.hasBeenFilled_ = true;
                this.renderModalComponents(player);
                this.endDialog = app_createEl("p", {
                    className: "vjs-control-text",
                    textContent: this.localize("End of dialog window.")
                });
                this.el().appendChild(this.endDialog);
                this.setDefaults();
                if (options.persistTextTrackSettings === void 0) this.options_.persistTextTrackSettings = this.options_.playerOptions.persistTextTrackSettings;
                this.bindFunctionsToSelectsAndButtons();
                if (this.options_.persistTextTrackSettings) this.restoreSettings();
            }
            renderModalComponents(player) {
                const textTrackSettingsColors = new app_TextTrackSettingsColors(player, {
                    textTrackComponentid: this.id_,
                    selectConfigs: app_selectConfigs,
                    fieldSets: [ [ "color", "textOpacity" ], [ "backgroundColor", "backgroundOpacity" ], [ "windowColor", "windowOpacity" ] ]
                });
                this.addChild(textTrackSettingsColors);
                const textTrackSettingsFont = new app_TextTrackSettingsFont(player, {
                    textTrackComponentid: this.id_,
                    selectConfigs: app_selectConfigs,
                    fieldSets: [ [ "fontPercent" ], [ "edgeStyle" ], [ "fontFamily" ] ]
                });
                this.addChild(textTrackSettingsFont);
                const trackSettingsControls = new app_TrackSettingsControls(player);
                this.addChild(trackSettingsControls);
            }
            bindFunctionsToSelectsAndButtons() {
                this.on(this.$(".vjs-done-button"), [ "click", "tap" ], (() => {
                    this.saveSettings();
                    this.close();
                }));
                this.on(this.$(".vjs-default-button"), [ "click", "tap" ], (() => {
                    this.setDefaults();
                    this.updateDisplay();
                }));
                app_each(app_selectConfigs, (config => {
                    this.on(this.$(config.selector), "change", this.updateDisplay);
                }));
            }
            dispose() {
                this.endDialog = null;
                super.dispose();
            }
            label() {
                return this.localize("Caption Settings Dialog");
            }
            description() {
                return this.localize("Beginning of dialog window. Escape will cancel and close the window.");
            }
            buildCSSClass() {
                return super.buildCSSClass() + " vjs-text-track-settings";
            }
            getValues() {
                return app_reduce(app_selectConfigs, ((accum, config, key) => {
                    const value = app_getSelectedOptionValue(this.$(config.selector), config.parser);
                    if (value !== void 0) accum[key] = value;
                    return accum;
                }), {});
            }
            setValues(values) {
                app_each(app_selectConfigs, ((config, key) => {
                    app_setSelectedOption(this.$(config.selector), values[key], config.parser);
                }));
            }
            setDefaults() {
                app_each(app_selectConfigs, (config => {
                    const index = config.hasOwnProperty("default") ? config.default : 0;
                    this.$(config.selector).selectedIndex = index;
                }));
            }
            restoreSettings() {
                let values;
                try {
                    values = JSON.parse(app_window_default().localStorage.getItem(app_LOCAL_STORAGE_KEY$1));
                } catch (err) {
                    app_log$1.warn(err);
                }
                if (values) this.setValues(values);
            }
            saveSettings() {
                if (!this.options_.persistTextTrackSettings) return;
                const values = this.getValues();
                try {
                    if (Object.keys(values).length) app_window_default().localStorage.setItem(app_LOCAL_STORAGE_KEY$1, JSON.stringify(values)); else app_window_default().localStorage.removeItem(app_LOCAL_STORAGE_KEY$1);
                } catch (err) {
                    app_log$1.warn(err);
                }
            }
            updateDisplay() {
                const ttDisplay = this.player_.getChild("textTrackDisplay");
                if (ttDisplay) ttDisplay.updateDisplay();
            }
            handleLanguagechange() {
                this.fill();
                this.renderModalComponents(this.player_);
                this.bindFunctionsToSelectsAndButtons();
            }
        }
        app_Component$1.registerComponent("TextTrackSettings", app_TextTrackSettings);
        class app_ResizeManager extends app_Component$1 {
            constructor(player, options) {
                let RESIZE_OBSERVER_AVAILABLE = options.ResizeObserver || app_window_default().ResizeObserver;
                if (options.ResizeObserver === null) RESIZE_OBSERVER_AVAILABLE = false;
                const options_ = app_merge$1({
                    createEl: !RESIZE_OBSERVER_AVAILABLE,
                    reportTouchActivity: false
                }, options);
                super(player, options_);
                this.ResizeObserver = options.ResizeObserver || app_window_default().ResizeObserver;
                this.loadListener_ = null;
                this.resizeObserver_ = null;
                this.debouncedHandler_ = app_debounce$1((() => {
                    this.resizeHandler();
                }), 100, false, this);
                if (RESIZE_OBSERVER_AVAILABLE) {
                    this.resizeObserver_ = new this.ResizeObserver(this.debouncedHandler_);
                    this.resizeObserver_.observe(player.el());
                } else {
                    this.loadListener_ = () => {
                        if (!this.el_ || !this.el_.contentWindow) return;
                        const debouncedHandler_ = this.debouncedHandler_;
                        let unloadListener_ = this.unloadListener_ = function() {
                            app_off(this, "resize", debouncedHandler_);
                            app_off(this, "unload", unloadListener_);
                            unloadListener_ = null;
                        };
                        app_on(this.el_.contentWindow, "unload", unloadListener_);
                        app_on(this.el_.contentWindow, "resize", debouncedHandler_);
                    };
                    this.one("load", this.loadListener_);
                }
            }
            createEl() {
                return super.createEl("iframe", {
                    className: "vjs-resize-manager",
                    tabIndex: -1,
                    title: this.localize("No content")
                }, {
                    "aria-hidden": "true"
                });
            }
            resizeHandler() {
                if (!this.player_ || !this.player_.trigger) return;
                this.player_.trigger("playerresize");
            }
            dispose() {
                if (this.debouncedHandler_) this.debouncedHandler_.cancel();
                if (this.resizeObserver_) {
                    if (this.player_.el()) this.resizeObserver_.unobserve(this.player_.el());
                    this.resizeObserver_.disconnect();
                }
                if (this.loadListener_) this.off("load", this.loadListener_);
                if (this.el_ && this.el_.contentWindow && this.unloadListener_) this.unloadListener_.call(this.el_.contentWindow);
                this.ResizeObserver = null;
                this.resizeObserver = null;
                this.debouncedHandler_ = null;
                this.loadListener_ = null;
                super.dispose();
            }
        }
        app_Component$1.registerComponent("ResizeManager", app_ResizeManager);
        const app_defaults$1 = {
            trackingThreshold: 20,
            liveTolerance: 15
        };
        class app_LiveTracker extends app_Component$1 {
            constructor(player, options) {
                const options_ = app_merge$1(app_defaults$1, options, {
                    createEl: false
                });
                super(player, options_);
                this.trackLiveHandler_ = () => this.trackLive_();
                this.handlePlay_ = e => this.handlePlay(e);
                this.handleFirstTimeupdate_ = e => this.handleFirstTimeupdate(e);
                this.handleSeeked_ = e => this.handleSeeked(e);
                this.seekToLiveEdge_ = e => this.seekToLiveEdge(e);
                this.reset_();
                this.on(this.player_, "durationchange", (e => this.handleDurationchange(e)));
                this.on(this.player_, "canplay", (() => this.toggleTracking()));
            }
            trackLive_() {
                const seekable = this.player_.seekable();
                if (!seekable || !seekable.length) return;
                const newTime = Number(app_window_default().performance.now().toFixed(4));
                const deltaTime = this.lastTime_ === -1 ? 0 : (newTime - this.lastTime_) / 1e3;
                this.lastTime_ = newTime;
                this.pastSeekEnd_ = this.pastSeekEnd() + deltaTime;
                const liveCurrentTime = this.liveCurrentTime();
                const currentTime = this.player_.currentTime();
                let isBehind = this.player_.paused() || this.seekedBehindLive_ || Math.abs(liveCurrentTime - currentTime) > this.options_.liveTolerance;
                if (!this.timeupdateSeen_ || liveCurrentTime === 1 / 0) isBehind = false;
                if (isBehind !== this.behindLiveEdge_) {
                    this.behindLiveEdge_ = isBehind;
                    this.trigger("liveedgechange");
                }
            }
            handleDurationchange() {
                this.toggleTracking();
            }
            toggleTracking() {
                if (this.player_.duration() === 1 / 0 && this.liveWindow() >= this.options_.trackingThreshold) {
                    if (this.player_.options_.liveui) this.player_.addClass("vjs-liveui");
                    this.startTracking();
                } else {
                    this.player_.removeClass("vjs-liveui");
                    this.stopTracking();
                }
            }
            startTracking() {
                if (this.isTracking()) return;
                if (!this.timeupdateSeen_) this.timeupdateSeen_ = this.player_.hasStarted();
                this.trackingInterval_ = this.setInterval(this.trackLiveHandler_, app_UPDATE_REFRESH_INTERVAL);
                this.trackLive_();
                this.on(this.player_, [ "play", "pause" ], this.trackLiveHandler_);
                if (!this.timeupdateSeen_) {
                    this.one(this.player_, "play", this.handlePlay_);
                    this.one(this.player_, "timeupdate", this.handleFirstTimeupdate_);
                } else this.on(this.player_, "seeked", this.handleSeeked_);
            }
            handleFirstTimeupdate() {
                this.timeupdateSeen_ = true;
                this.on(this.player_, "seeked", this.handleSeeked_);
            }
            handleSeeked() {
                const timeDiff = Math.abs(this.liveCurrentTime() - this.player_.currentTime());
                this.seekedBehindLive_ = this.nextSeekedFromUser_ && timeDiff > 2;
                this.nextSeekedFromUser_ = false;
                this.trackLive_();
            }
            handlePlay() {
                this.one(this.player_, "timeupdate", this.seekToLiveEdge_);
            }
            reset_() {
                this.lastTime_ = -1;
                this.pastSeekEnd_ = 0;
                this.lastSeekEnd_ = -1;
                this.behindLiveEdge_ = true;
                this.timeupdateSeen_ = false;
                this.seekedBehindLive_ = false;
                this.nextSeekedFromUser_ = false;
                this.clearInterval(this.trackingInterval_);
                this.trackingInterval_ = null;
                this.off(this.player_, [ "play", "pause" ], this.trackLiveHandler_);
                this.off(this.player_, "seeked", this.handleSeeked_);
                this.off(this.player_, "play", this.handlePlay_);
                this.off(this.player_, "timeupdate", this.handleFirstTimeupdate_);
                this.off(this.player_, "timeupdate", this.seekToLiveEdge_);
            }
            nextSeekedFromUser() {
                this.nextSeekedFromUser_ = true;
            }
            stopTracking() {
                if (!this.isTracking()) return;
                this.reset_();
                this.trigger("liveedgechange");
            }
            seekableEnd() {
                const seekable = this.player_.seekable();
                const seekableEnds = [];
                let i = seekable ? seekable.length : 0;
                while (i--) seekableEnds.push(seekable.end(i));
                return seekableEnds.length ? seekableEnds.sort()[seekableEnds.length - 1] : 1 / 0;
            }
            seekableStart() {
                const seekable = this.player_.seekable();
                const seekableStarts = [];
                let i = seekable ? seekable.length : 0;
                while (i--) seekableStarts.push(seekable.start(i));
                return seekableStarts.length ? seekableStarts.sort()[0] : 0;
            }
            liveWindow() {
                const liveCurrentTime = this.liveCurrentTime();
                if (liveCurrentTime === 1 / 0) return 0;
                return liveCurrentTime - this.seekableStart();
            }
            isLive() {
                return this.isTracking();
            }
            atLiveEdge() {
                return !this.behindLiveEdge();
            }
            liveCurrentTime() {
                return this.pastSeekEnd() + this.seekableEnd();
            }
            pastSeekEnd() {
                const seekableEnd = this.seekableEnd();
                if (this.lastSeekEnd_ !== -1 && seekableEnd !== this.lastSeekEnd_) this.pastSeekEnd_ = 0;
                this.lastSeekEnd_ = seekableEnd;
                return this.pastSeekEnd_;
            }
            behindLiveEdge() {
                return this.behindLiveEdge_;
            }
            isTracking() {
                return typeof this.trackingInterval_ === "number";
            }
            seekToLiveEdge() {
                this.seekedBehindLive_ = false;
                if (this.atLiveEdge()) return;
                this.nextSeekedFromUser_ = false;
                this.player_.currentTime(this.liveCurrentTime());
            }
            dispose() {
                this.stopTracking();
                super.dispose();
            }
        }
        app_Component$1.registerComponent("LiveTracker", app_LiveTracker);
        class app_TitleBar extends app_Component$1 {
            constructor(player, options) {
                super(player, options);
                this.on("statechanged", (e => this.updateDom_()));
                this.updateDom_();
            }
            createEl() {
                this.els = {
                    title: app_createEl("div", {
                        className: "vjs-title-bar-title",
                        id: `vjs-title-bar-title-${app_newGUID()}`
                    }),
                    description: app_createEl("div", {
                        className: "vjs-title-bar-description",
                        id: `vjs-title-bar-description-${app_newGUID()}`
                    })
                };
                return app_createEl("div", {
                    className: "vjs-title-bar"
                }, {}, app_video_es_values(this.els));
            }
            updateDom_() {
                const tech = this.player_.tech_;
                const techEl = tech && tech.el_;
                const techAriaAttrs = {
                    title: "aria-labelledby",
                    description: "aria-describedby"
                };
                [ "title", "description" ].forEach((k => {
                    const value = this.state[k];
                    const el = this.els[k];
                    const techAriaAttr = techAriaAttrs[k];
                    app_emptyEl(el);
                    if (value) app_textContent(el, value);
                    if (techEl) {
                        techEl.removeAttribute(techAriaAttr);
                        if (value) techEl.setAttribute(techAriaAttr, el.id);
                    }
                }));
                if (this.state.title || this.state.description) this.show(); else this.hide();
            }
            update(options) {
                this.setState(options);
            }
            dispose() {
                const tech = this.player_.tech_;
                const techEl = tech && tech.el_;
                if (techEl) {
                    techEl.removeAttribute("aria-labelledby");
                    techEl.removeAttribute("aria-describedby");
                }
                super.dispose();
                this.els = null;
            }
        }
        app_Component$1.registerComponent("TitleBar", app_TitleBar);
        const app_video_es_defaults = {
            initialDisplay: 4e3,
            position: [],
            takeFocus: false
        };
        class app_TransientButton extends app_Button {
            constructor(player, options) {
                options = app_merge$1(app_video_es_defaults, options);
                super(player, options);
                this.controlText(options.controlText);
                this.hide();
                this.on(this.player_, [ "useractive", "userinactive" ], (e => {
                    this.removeClass("force-display");
                }));
            }
            buildCSSClass() {
                return `vjs-transient-button focus-visible ${this.options_.position.map((c => `vjs-${c}`)).join(" ")}`;
            }
            createEl() {
                const el = app_createEl("button", {}, {
                    type: "button",
                    class: this.buildCSSClass()
                }, app_createEl("span"));
                this.controlTextEl_ = el.querySelector("span");
                return el;
            }
            show() {
                super.show();
                this.addClass("force-display");
                if (this.options_.takeFocus) this.el().focus({
                    preventScroll: true
                });
                this.forceDisplayTimeout = this.player_.setTimeout((() => {
                    this.removeClass("force-display");
                }), this.options_.initialDisplay);
            }
            hide() {
                this.removeClass("force-display");
                super.hide();
            }
            dispose() {
                this.player_.clearTimeout(this.forceDisplayTimeout);
                super.dispose();
            }
        }
        app_Component$1.registerComponent("TransientButton", app_TransientButton);
        const app_sourcesetLoad = tech => {
            const el = tech.el();
            if (el.hasAttribute("src")) {
                tech.triggerSourceset(el.src);
                return true;
            }
            const sources = tech.$$("source");
            const srcUrls = [];
            let src = "";
            if (!sources.length) return false;
            for (let i = 0; i < sources.length; i++) {
                const url = sources[i].src;
                if (url && srcUrls.indexOf(url) === -1) srcUrls.push(url);
            }
            if (!srcUrls.length) return false;
            if (srcUrls.length === 1) src = srcUrls[0];
            tech.triggerSourceset(src);
            return true;
        };
        const app_innerHTMLDescriptorPolyfill = Object.defineProperty({}, "innerHTML", {
            get() {
                return this.cloneNode(true).innerHTML;
            },
            set(v) {
                const dummy = app_document_default().createElement(this.nodeName.toLowerCase());
                dummy.innerHTML = v;
                const docFrag = app_document_default().createDocumentFragment();
                while (dummy.childNodes.length) docFrag.appendChild(dummy.childNodes[0]);
                this.innerText = "";
                app_window_default().Element.prototype.appendChild.call(this, docFrag);
                return this.innerHTML;
            }
        });
        const app_getDescriptor = (priority, prop) => {
            let descriptor = {};
            for (let i = 0; i < priority.length; i++) {
                descriptor = Object.getOwnPropertyDescriptor(priority[i], prop);
                if (descriptor && descriptor.set && descriptor.get) break;
            }
            descriptor.enumerable = true;
            descriptor.configurable = true;
            return descriptor;
        };
        const app_getInnerHTMLDescriptor = tech => app_getDescriptor([ tech.el(), app_window_default().HTMLMediaElement.prototype, app_window_default().Element.prototype, app_innerHTMLDescriptorPolyfill ], "innerHTML");
        const app_firstSourceWatch = function(tech) {
            const el = tech.el();
            if (el.resetSourceWatch_) return;
            const old = {};
            const innerDescriptor = app_getInnerHTMLDescriptor(tech);
            const appendWrapper = appendFn => (...args) => {
                const retval = appendFn.apply(el, args);
                app_sourcesetLoad(tech);
                return retval;
            };
            [ "append", "appendChild", "insertAdjacentHTML" ].forEach((k => {
                if (!el[k]) return;
                old[k] = el[k];
                el[k] = appendWrapper(old[k]);
            }));
            Object.defineProperty(el, "innerHTML", app_merge$1(innerDescriptor, {
                set: appendWrapper(innerDescriptor.set)
            }));
            el.resetSourceWatch_ = () => {
                el.resetSourceWatch_ = null;
                Object.keys(old).forEach((k => {
                    el[k] = old[k];
                }));
                Object.defineProperty(el, "innerHTML", innerDescriptor);
            };
            tech.one("sourceset", el.resetSourceWatch_);
        };
        const app_srcDescriptorPolyfill = Object.defineProperty({}, "src", {
            get() {
                if (this.hasAttribute("src")) return app_getAbsoluteURL(app_window_default().Element.prototype.getAttribute.call(this, "src"));
                return "";
            },
            set(v) {
                app_window_default().Element.prototype.setAttribute.call(this, "src", v);
                return v;
            }
        });
        const app_getSrcDescriptor = tech => app_getDescriptor([ tech.el(), app_window_default().HTMLMediaElement.prototype, app_srcDescriptorPolyfill ], "src");
        const app_setupSourceset = function(tech) {
            if (!tech.featuresSourceset) return;
            const el = tech.el();
            if (el.resetSourceset_) return;
            const srcDescriptor = app_getSrcDescriptor(tech);
            const oldSetAttribute = el.setAttribute;
            const oldLoad = el.load;
            Object.defineProperty(el, "src", app_merge$1(srcDescriptor, {
                set: v => {
                    const retval = srcDescriptor.set.call(el, v);
                    tech.triggerSourceset(el.src);
                    return retval;
                }
            }));
            el.setAttribute = (n, v) => {
                const retval = oldSetAttribute.call(el, n, v);
                if (/src/i.test(n)) tech.triggerSourceset(el.src);
                return retval;
            };
            el.load = () => {
                const retval = oldLoad.call(el);
                if (!app_sourcesetLoad(tech)) {
                    tech.triggerSourceset("");
                    app_firstSourceWatch(tech);
                }
                return retval;
            };
            if (el.currentSrc) tech.triggerSourceset(el.currentSrc); else if (!app_sourcesetLoad(tech)) app_firstSourceWatch(tech);
            el.resetSourceset_ = () => {
                el.resetSourceset_ = null;
                el.load = oldLoad;
                el.setAttribute = oldSetAttribute;
                Object.defineProperty(el, "src", srcDescriptor);
                if (el.resetSourceWatch_) el.resetSourceWatch_();
            };
        };
        class app_Html5 extends app_Tech {
            constructor(options, ready) {
                super(options, ready);
                const source = options.source;
                let crossoriginTracks = false;
                this.featuresVideoFrameCallback = this.featuresVideoFrameCallback && this.el_.tagName === "VIDEO";
                if (source && (this.el_.currentSrc !== source.src || options.tag && options.tag.initNetworkState_ === 3)) this.setSource(source); else this.handleLateInit_(this.el_);
                if (options.enableSourceset) this.setupSourcesetHandling_();
                this.isScrubbing_ = false;
                if (this.el_.hasChildNodes()) {
                    const nodes = this.el_.childNodes;
                    let nodesLength = nodes.length;
                    const removeNodes = [];
                    while (nodesLength--) {
                        const node = nodes[nodesLength];
                        const nodeName = node.nodeName.toLowerCase();
                        if (nodeName === "track") if (!this.featuresNativeTextTracks) removeNodes.push(node); else {
                            this.remoteTextTrackEls().addTrackElement_(node);
                            this.remoteTextTracks().addTrack(node.track);
                            this.textTracks().addTrack(node.track);
                            if (!crossoriginTracks && !this.el_.hasAttribute("crossorigin") && app_isCrossOrigin(node.src)) crossoriginTracks = true;
                        }
                    }
                    for (let i = 0; i < removeNodes.length; i++) this.el_.removeChild(removeNodes[i]);
                }
                this.proxyNativeTracks_();
                if (this.featuresNativeTextTracks && crossoriginTracks) app_log$1.warn("Text Tracks are being loaded from another origin but the crossorigin attribute isn't used.\n" + "This may prevent text tracks from loading.");
                this.restoreMetadataTracksInIOSNativePlayer_();
                if ((app_TOUCH_ENABLED || app_IS_IPHONE) && options.nativeControlsForTouch === true) this.setControls(true);
                this.proxyWebkitFullscreen_();
                this.triggerReady();
            }
            dispose() {
                if (this.el_ && this.el_.resetSourceset_) this.el_.resetSourceset_();
                app_Html5.disposeMediaElement(this.el_);
                this.options_ = null;
                super.dispose();
            }
            setupSourcesetHandling_() {
                app_setupSourceset(this);
            }
            restoreMetadataTracksInIOSNativePlayer_() {
                const textTracks = this.textTracks();
                let metadataTracksPreFullscreenState;
                const takeMetadataTrackSnapshot = () => {
                    metadataTracksPreFullscreenState = [];
                    for (let i = 0; i < textTracks.length; i++) {
                        const track = textTracks[i];
                        if (track.kind === "metadata") metadataTracksPreFullscreenState.push({
                            track,
                            storedMode: track.mode
                        });
                    }
                };
                takeMetadataTrackSnapshot();
                textTracks.addEventListener("change", takeMetadataTrackSnapshot);
                this.on("dispose", (() => textTracks.removeEventListener("change", takeMetadataTrackSnapshot)));
                const restoreTrackMode = () => {
                    for (let i = 0; i < metadataTracksPreFullscreenState.length; i++) {
                        const storedTrack = metadataTracksPreFullscreenState[i];
                        if (storedTrack.track.mode === "disabled" && storedTrack.track.mode !== storedTrack.storedMode) storedTrack.track.mode = storedTrack.storedMode;
                    }
                    textTracks.removeEventListener("change", restoreTrackMode);
                };
                this.on("webkitbeginfullscreen", (() => {
                    textTracks.removeEventListener("change", takeMetadataTrackSnapshot);
                    textTracks.removeEventListener("change", restoreTrackMode);
                    textTracks.addEventListener("change", restoreTrackMode);
                }));
                this.on("webkitendfullscreen", (() => {
                    textTracks.removeEventListener("change", takeMetadataTrackSnapshot);
                    textTracks.addEventListener("change", takeMetadataTrackSnapshot);
                    textTracks.removeEventListener("change", restoreTrackMode);
                }));
            }
            overrideNative_(type, override) {
                if (override !== this[`featuresNative${type}Tracks`]) return;
                const lowerCaseType = type.toLowerCase();
                if (this[`${lowerCaseType}TracksListeners_`]) Object.keys(this[`${lowerCaseType}TracksListeners_`]).forEach((eventName => {
                    const elTracks = this.el()[`${lowerCaseType}Tracks`];
                    elTracks.removeEventListener(eventName, this[`${lowerCaseType}TracksListeners_`][eventName]);
                }));
                this[`featuresNative${type}Tracks`] = !override;
                this[`${lowerCaseType}TracksListeners_`] = null;
                this.proxyNativeTracksForType_(lowerCaseType);
            }
            overrideNativeAudioTracks(override) {
                this.overrideNative_("Audio", override);
            }
            overrideNativeVideoTracks(override) {
                this.overrideNative_("Video", override);
            }
            proxyNativeTracksForType_(name) {
                const props = app_NORMAL[name];
                const elTracks = this.el()[props.getterName];
                const techTracks = this[props.getterName]();
                if (!this[`featuresNative${props.capitalName}Tracks`] || !elTracks || !elTracks.addEventListener) return;
                const listeners = {
                    change: e => {
                        const event = {
                            type: "change",
                            target: techTracks,
                            currentTarget: techTracks,
                            srcElement: techTracks
                        };
                        techTracks.trigger(event);
                        if (name === "text") this[app_REMOTE.remoteText.getterName]().trigger(event);
                    },
                    addtrack(e) {
                        techTracks.addTrack(e.track);
                    },
                    removetrack(e) {
                        techTracks.removeTrack(e.track);
                    }
                };
                const removeOldTracks = function() {
                    const removeTracks = [];
                    for (let i = 0; i < techTracks.length; i++) {
                        let found = false;
                        for (let j = 0; j < elTracks.length; j++) if (elTracks[j] === techTracks[i]) {
                            found = true;
                            break;
                        }
                        if (!found) removeTracks.push(techTracks[i]);
                    }
                    while (removeTracks.length) techTracks.removeTrack(removeTracks.shift());
                };
                this[props.getterName + "Listeners_"] = listeners;
                Object.keys(listeners).forEach((eventName => {
                    const listener = listeners[eventName];
                    elTracks.addEventListener(eventName, listener);
                    this.on("dispose", (e => elTracks.removeEventListener(eventName, listener)));
                }));
                this.on("loadstart", removeOldTracks);
                this.on("dispose", (e => this.off("loadstart", removeOldTracks)));
            }
            proxyNativeTracks_() {
                app_NORMAL.names.forEach((name => {
                    this.proxyNativeTracksForType_(name);
                }));
            }
            createEl() {
                let el = this.options_.tag;
                if (!el || !(this.options_.playerElIngest || this.movingMediaElementInDOM)) {
                    if (el) {
                        const clone = el.cloneNode(true);
                        if (el.parentNode) el.parentNode.insertBefore(clone, el);
                        app_Html5.disposeMediaElement(el);
                        el = clone;
                    } else {
                        el = app_document_default().createElement("video");
                        const tagAttributes = this.options_.tag && app_getAttributes(this.options_.tag);
                        const attributes = app_merge$1({}, tagAttributes);
                        if (!app_TOUCH_ENABLED || this.options_.nativeControlsForTouch !== true) delete attributes.controls;
                        app_setAttributes(el, Object.assign(attributes, {
                            id: this.options_.techId,
                            class: "vjs-tech"
                        }));
                    }
                    el.playerId = this.options_.playerId;
                }
                if (typeof this.options_.preload !== "undefined") app_setAttribute(el, "preload", this.options_.preload);
                if (this.options_.disablePictureInPicture !== void 0) el.disablePictureInPicture = this.options_.disablePictureInPicture;
                const settingsAttrs = [ "loop", "muted", "playsinline", "autoplay" ];
                for (let i = 0; i < settingsAttrs.length; i++) {
                    const attr = settingsAttrs[i];
                    const value = this.options_[attr];
                    if (typeof value !== "undefined") {
                        if (value) app_setAttribute(el, attr, attr); else app_removeAttribute(el, attr);
                        el[attr] = value;
                    }
                }
                return el;
            }
            handleLateInit_(el) {
                if (el.networkState === 0 || el.networkState === 3) return;
                if (el.readyState === 0) {
                    let loadstartFired = false;
                    const setLoadstartFired = function() {
                        loadstartFired = true;
                    };
                    this.on("loadstart", setLoadstartFired);
                    const triggerLoadstart = function() {
                        if (!loadstartFired) this.trigger("loadstart");
                    };
                    this.on("loadedmetadata", triggerLoadstart);
                    this.ready((function() {
                        this.off("loadstart", setLoadstartFired);
                        this.off("loadedmetadata", triggerLoadstart);
                        if (!loadstartFired) this.trigger("loadstart");
                    }));
                    return;
                }
                const eventsToTrigger = [ "loadstart" ];
                eventsToTrigger.push("loadedmetadata");
                if (el.readyState >= 2) eventsToTrigger.push("loadeddata");
                if (el.readyState >= 3) eventsToTrigger.push("canplay");
                if (el.readyState >= 4) eventsToTrigger.push("canplaythrough");
                this.ready((function() {
                    eventsToTrigger.forEach((function(type) {
                        this.trigger(type);
                    }), this);
                }));
            }
            setScrubbing(isScrubbing) {
                this.isScrubbing_ = isScrubbing;
            }
            scrubbing() {
                return this.isScrubbing_;
            }
            setCurrentTime(seconds) {
                try {
                    if (this.isScrubbing_ && this.el_.fastSeek && app_IS_ANY_SAFARI) this.el_.fastSeek(seconds); else this.el_.currentTime = seconds;
                } catch (e) {
                    app_log$1(e, "Video is not ready. (Video.js)");
                }
            }
            duration() {
                if (this.el_.duration === 1 / 0 && app_IS_ANDROID && app_IS_CHROME && this.el_.currentTime === 0) {
                    const checkProgress = () => {
                        if (this.el_.currentTime > 0) {
                            if (this.el_.duration === 1 / 0) this.trigger("durationchange");
                            this.off("timeupdate", checkProgress);
                        }
                    };
                    this.on("timeupdate", checkProgress);
                    return NaN;
                }
                return this.el_.duration || NaN;
            }
            width() {
                return this.el_.offsetWidth;
            }
            height() {
                return this.el_.offsetHeight;
            }
            proxyWebkitFullscreen_() {
                if (!("webkitDisplayingFullscreen" in this.el_)) return;
                const endFn = function() {
                    this.trigger("fullscreenchange", {
                        isFullscreen: false
                    });
                    if (this.el_.controls && !this.options_.nativeControlsForTouch && this.controls()) this.el_.controls = false;
                };
                const beginFn = function() {
                    if ("webkitPresentationMode" in this.el_ && this.el_.webkitPresentationMode !== "picture-in-picture") {
                        this.one("webkitendfullscreen", endFn);
                        this.trigger("fullscreenchange", {
                            isFullscreen: true,
                            nativeIOSFullscreen: true
                        });
                    }
                };
                this.on("webkitbeginfullscreen", beginFn);
                this.on("dispose", (() => {
                    this.off("webkitbeginfullscreen", beginFn);
                    this.off("webkitendfullscreen", endFn);
                }));
            }
            supportsFullScreen() {
                return typeof this.el_.webkitEnterFullScreen === "function";
            }
            enterFullScreen() {
                const video = this.el_;
                if (video.paused && video.networkState <= video.HAVE_METADATA) {
                    app_silencePromise(this.el_.play());
                    this.setTimeout((function() {
                        video.pause();
                        try {
                            video.webkitEnterFullScreen();
                        } catch (e) {
                            this.trigger("fullscreenerror", e);
                        }
                    }), 0);
                } else try {
                    video.webkitEnterFullScreen();
                } catch (e) {
                    this.trigger("fullscreenerror", e);
                }
            }
            exitFullScreen() {
                if (!this.el_.webkitDisplayingFullscreen) {
                    this.trigger("fullscreenerror", new Error("The video is not fullscreen"));
                    return;
                }
                this.el_.webkitExitFullScreen();
            }
            requestPictureInPicture() {
                return this.el_.requestPictureInPicture();
            }
            requestVideoFrameCallback(cb) {
                if (this.featuresVideoFrameCallback && !this.el_.webkitKeys) return this.el_.requestVideoFrameCallback(cb);
                return super.requestVideoFrameCallback(cb);
            }
            cancelVideoFrameCallback(id) {
                if (this.featuresVideoFrameCallback && !this.el_.webkitKeys) this.el_.cancelVideoFrameCallback(id); else super.cancelVideoFrameCallback(id);
            }
            src(src) {
                if (src === void 0) return this.el_.src;
                this.setSrc(src);
            }
            addSourceElement(srcUrl, mimeType) {
                if (!srcUrl) {
                    app_log$1.error("Invalid source URL.");
                    return false;
                }
                const sourceAttributes = {
                    src: srcUrl
                };
                if (mimeType) sourceAttributes.type = mimeType;
                const sourceElement = app_createEl("source", {}, sourceAttributes);
                this.el_.appendChild(sourceElement);
                return true;
            }
            removeSourceElement(srcUrl) {
                if (!srcUrl) {
                    app_log$1.error("Source URL is required to remove the source element.");
                    return false;
                }
                const sourceElements = this.el_.querySelectorAll("source");
                for (const sourceElement of sourceElements) if (sourceElement.src === srcUrl) {
                    this.el_.removeChild(sourceElement);
                    return true;
                }
                app_log$1.warn(`No matching source element found with src: ${srcUrl}`);
                return false;
            }
            reset() {
                app_Html5.resetMediaElement(this.el_);
            }
            currentSrc() {
                if (this.currentSource_) return this.currentSource_.src;
                return this.el_.currentSrc;
            }
            setControls(val) {
                this.el_.controls = !!val;
            }
            addTextTrack(kind, label, language) {
                if (!this.featuresNativeTextTracks) return super.addTextTrack(kind, label, language);
                return this.el_.addTextTrack(kind, label, language);
            }
            createRemoteTextTrack(options) {
                if (!this.featuresNativeTextTracks) return super.createRemoteTextTrack(options);
                const htmlTrackElement = app_document_default().createElement("track");
                if (options.kind) htmlTrackElement.kind = options.kind;
                if (options.label) htmlTrackElement.label = options.label;
                if (options.language || options.srclang) htmlTrackElement.srclang = options.language || options.srclang;
                if (options.default) htmlTrackElement.default = options.default;
                if (options.id) htmlTrackElement.id = options.id;
                if (options.src) htmlTrackElement.src = options.src;
                return htmlTrackElement;
            }
            addRemoteTextTrack(options, manualCleanup) {
                const htmlTrackElement = super.addRemoteTextTrack(options, manualCleanup);
                if (this.featuresNativeTextTracks) this.el().appendChild(htmlTrackElement);
                return htmlTrackElement;
            }
            removeRemoteTextTrack(track) {
                super.removeRemoteTextTrack(track);
                if (this.featuresNativeTextTracks) {
                    const tracks = this.$$("track");
                    let i = tracks.length;
                    while (i--) if (track === tracks[i] || track === tracks[i].track) this.el().removeChild(tracks[i]);
                }
            }
            getVideoPlaybackQuality() {
                if (typeof this.el().getVideoPlaybackQuality === "function") return this.el().getVideoPlaybackQuality();
                const videoPlaybackQuality = {};
                if (typeof this.el().webkitDroppedFrameCount !== "undefined" && typeof this.el().webkitDecodedFrameCount !== "undefined") {
                    videoPlaybackQuality.droppedVideoFrames = this.el().webkitDroppedFrameCount;
                    videoPlaybackQuality.totalVideoFrames = this.el().webkitDecodedFrameCount;
                }
                if (app_window_default().performance) videoPlaybackQuality.creationTime = app_window_default().performance.now();
                return videoPlaybackQuality;
            }
        }
        app_defineLazyProperty(app_Html5, "TEST_VID", (function() {
            if (!app_isReal()) return;
            const video = app_document_default().createElement("video");
            const track = app_document_default().createElement("track");
            track.kind = "captions";
            track.srclang = "en";
            track.label = "English";
            video.appendChild(track);
            return video;
        }));
        app_Html5.isSupported = function() {
            try {
                app_Html5.TEST_VID.volume = .5;
            } catch (e) {
                return false;
            }
            return !!(app_Html5.TEST_VID && app_Html5.TEST_VID.canPlayType);
        };
        app_Html5.canPlayType = function(type) {
            return app_Html5.TEST_VID.canPlayType(type);
        };
        app_Html5.canPlaySource = function(srcObj, options) {
            return app_Html5.canPlayType(srcObj.type);
        };
        app_Html5.canControlVolume = function() {
            try {
                const volume = app_Html5.TEST_VID.volume;
                app_Html5.TEST_VID.volume = volume / 2 + .1;
                const canControl = volume !== app_Html5.TEST_VID.volume;
                if (canControl && app_IS_IOS) {
                    app_window_default().setTimeout((() => {
                        if (app_Html5 && app_Html5.prototype) app_Html5.prototype.featuresVolumeControl = volume !== app_Html5.TEST_VID.volume;
                    }));
                    return false;
                }
                return canControl;
            } catch (e) {
                return false;
            }
        };
        app_Html5.canMuteVolume = function() {
            try {
                const muted = app_Html5.TEST_VID.muted;
                app_Html5.TEST_VID.muted = !muted;
                if (app_Html5.TEST_VID.muted) app_setAttribute(app_Html5.TEST_VID, "muted", "muted"); else app_removeAttribute(app_Html5.TEST_VID, "muted", "muted");
                return muted !== app_Html5.TEST_VID.muted;
            } catch (e) {
                return false;
            }
        };
        app_Html5.canControlPlaybackRate = function() {
            if (app_IS_ANDROID && app_IS_CHROME && app_CHROME_VERSION < 58) return false;
            try {
                const playbackRate = app_Html5.TEST_VID.playbackRate;
                app_Html5.TEST_VID.playbackRate = playbackRate / 2 + .1;
                return playbackRate !== app_Html5.TEST_VID.playbackRate;
            } catch (e) {
                return false;
            }
        };
        app_Html5.canOverrideAttributes = function() {
            try {
                const noop = () => {};
                Object.defineProperty(app_document_default().createElement("video"), "src", {
                    get: noop,
                    set: noop
                });
                Object.defineProperty(app_document_default().createElement("audio"), "src", {
                    get: noop,
                    set: noop
                });
                Object.defineProperty(app_document_default().createElement("video"), "innerHTML", {
                    get: noop,
                    set: noop
                });
                Object.defineProperty(app_document_default().createElement("audio"), "innerHTML", {
                    get: noop,
                    set: noop
                });
            } catch (e) {
                return false;
            }
            return true;
        };
        app_Html5.supportsNativeTextTracks = function() {
            return app_IS_ANY_SAFARI || app_IS_IOS && app_IS_CHROME;
        };
        app_Html5.supportsNativeVideoTracks = function() {
            return !!(app_Html5.TEST_VID && app_Html5.TEST_VID.videoTracks);
        };
        app_Html5.supportsNativeAudioTracks = function() {
            return !!(app_Html5.TEST_VID && app_Html5.TEST_VID.audioTracks);
        };
        app_Html5.Events = [ "loadstart", "suspend", "abort", "error", "emptied", "stalled", "loadedmetadata", "loadeddata", "canplay", "canplaythrough", "playing", "waiting", "seeking", "seeked", "ended", "durationchange", "timeupdate", "progress", "play", "pause", "ratechange", "resize", "volumechange" ];
        [ [ "featuresMuteControl", "canMuteVolume" ], [ "featuresPlaybackRate", "canControlPlaybackRate" ], [ "featuresSourceset", "canOverrideAttributes" ], [ "featuresNativeTextTracks", "supportsNativeTextTracks" ], [ "featuresNativeVideoTracks", "supportsNativeVideoTracks" ], [ "featuresNativeAudioTracks", "supportsNativeAudioTracks" ] ].forEach((function([key, fn]) {
            app_defineLazyProperty(app_Html5.prototype, key, (() => app_Html5[fn]()), true);
        }));
        app_Html5.prototype.featuresVolumeControl = app_Html5.canControlVolume();
        app_Html5.prototype.movingMediaElementInDOM = !app_IS_IOS;
        app_Html5.prototype.featuresFullscreenResize = true;
        app_Html5.prototype.featuresProgressEvents = true;
        app_Html5.prototype.featuresTimeupdateEvents = true;
        app_Html5.prototype.featuresVideoFrameCallback = !!(app_Html5.TEST_VID && app_Html5.TEST_VID.requestVideoFrameCallback);
        app_Html5.disposeMediaElement = function(el) {
            if (!el) return;
            if (el.parentNode) el.parentNode.removeChild(el);
            while (el.hasChildNodes()) el.removeChild(el.firstChild);
            el.removeAttribute("src");
            if (typeof el.load === "function") (function() {
                try {
                    el.load();
                } catch (e) {}
            })();
        };
        app_Html5.resetMediaElement = function(el) {
            if (!el) return;
            const sources = el.querySelectorAll("source");
            let i = sources.length;
            while (i--) el.removeChild(sources[i]);
            el.removeAttribute("src");
            if (typeof el.load === "function") (function() {
                try {
                    el.load();
                } catch (e) {}
            })();
        };
        [ "muted", "defaultMuted", "autoplay", "controls", "loop", "playsinline" ].forEach((function(prop) {
            app_Html5.prototype[prop] = function() {
                return this.el_[prop] || this.el_.hasAttribute(prop);
            };
        }));
        [ "muted", "defaultMuted", "autoplay", "loop", "playsinline" ].forEach((function(prop) {
            app_Html5.prototype["set" + app_toTitleCase$1(prop)] = function(v) {
                this.el_[prop] = v;
                if (v) this.el_.setAttribute(prop, prop); else this.el_.removeAttribute(prop);
            };
        }));
        [ "paused", "currentTime", "buffered", "volume", "poster", "preload", "error", "seeking", "seekable", "ended", "playbackRate", "defaultPlaybackRate", "disablePictureInPicture", "played", "networkState", "readyState", "videoWidth", "videoHeight", "crossOrigin" ].forEach((function(prop) {
            app_Html5.prototype[prop] = function() {
                return this.el_[prop];
            };
        }));
        [ "volume", "src", "poster", "preload", "playbackRate", "defaultPlaybackRate", "disablePictureInPicture", "crossOrigin" ].forEach((function(prop) {
            app_Html5.prototype["set" + app_toTitleCase$1(prop)] = function(v) {
                this.el_[prop] = v;
            };
        }));
        [ "pause", "load", "play" ].forEach((function(prop) {
            app_Html5.prototype[prop] = function() {
                return this.el_[prop]();
            };
        }));
        app_Tech.withSourceHandlers(app_Html5);
        app_Html5.nativeSourceHandler = {};
        app_Html5.nativeSourceHandler.canPlayType = function(type) {
            try {
                return app_Html5.TEST_VID.canPlayType(type);
            } catch (e) {
                return "";
            }
        };
        app_Html5.nativeSourceHandler.canHandleSource = function(source, options) {
            if (source.type) return app_Html5.nativeSourceHandler.canPlayType(source.type); else if (source.src) {
                const ext = app_getFileExtension(source.src);
                return app_Html5.nativeSourceHandler.canPlayType(`video/${ext}`);
            }
            return "";
        };
        app_Html5.nativeSourceHandler.handleSource = function(source, tech, options) {
            tech.setSrc(source.src);
        };
        app_Html5.nativeSourceHandler.dispose = function() {};
        app_Html5.registerSourceHandler(app_Html5.nativeSourceHandler);
        app_Tech.registerTech("Html5", app_Html5);
        const app_TECH_EVENTS_RETRIGGER = [ "progress", "abort", "suspend", "emptied", "stalled", "loadedmetadata", "loadeddata", "timeupdate", "resize", "volumechange", "texttrackchange" ];
        const app_TECH_EVENTS_QUEUE = {
            canplay: "CanPlay",
            canplaythrough: "CanPlayThrough",
            playing: "Playing",
            seeked: "Seeked"
        };
        const app_BREAKPOINT_ORDER = [ "tiny", "xsmall", "small", "medium", "large", "xlarge", "huge" ];
        const app_BREAKPOINT_CLASSES = {};
        app_BREAKPOINT_ORDER.forEach((k => {
            const v = k.charAt(0) === "x" ? `x-${k.substring(1)}` : k;
            app_BREAKPOINT_CLASSES[k] = `vjs-layout-${v}`;
        }));
        const app_DEFAULT_BREAKPOINTS = {
            tiny: 210,
            xsmall: 320,
            small: 425,
            medium: 768,
            large: 1440,
            xlarge: 2560,
            huge: 1 / 0
        };
        class app_Player extends app_Component$1 {
            constructor(tag, options, ready) {
                tag.id = tag.id || options.id || `vjs_video_${app_newGUID()}`;
                options = Object.assign(app_Player.getTagSettings(tag), options);
                options.initChildren = false;
                options.createEl = false;
                options.evented = false;
                options.reportTouchActivity = false;
                if (!options.language) {
                    const closest = tag.closest("[lang]");
                    if (closest) options.language = closest.getAttribute("lang");
                }
                super(null, options, ready);
                this.boundDocumentFullscreenChange_ = e => this.documentFullscreenChange_(e);
                this.boundFullWindowOnEscKey_ = e => this.fullWindowOnEscKey(e);
                this.boundUpdateStyleEl_ = e => this.updateStyleEl_(e);
                this.boundApplyInitTime_ = e => this.applyInitTime_(e);
                this.boundUpdateCurrentBreakpoint_ = e => this.updateCurrentBreakpoint_(e);
                this.boundHandleTechClick_ = e => this.handleTechClick_(e);
                this.boundHandleTechDoubleClick_ = e => this.handleTechDoubleClick_(e);
                this.boundHandleTechTouchStart_ = e => this.handleTechTouchStart_(e);
                this.boundHandleTechTouchMove_ = e => this.handleTechTouchMove_(e);
                this.boundHandleTechTouchEnd_ = e => this.handleTechTouchEnd_(e);
                this.boundHandleTechTap_ = e => this.handleTechTap_(e);
                this.boundUpdatePlayerHeightOnAudioOnlyMode_ = e => this.updatePlayerHeightOnAudioOnlyMode_(e);
                this.isFullscreen_ = false;
                this.log = app_createLogger(this.id_);
                this.fsApi_ = app_FullscreenApi;
                this.isPosterFromTech_ = false;
                this.queuedCallbacks_ = [];
                this.isReady_ = false;
                this.hasStarted_ = false;
                this.userActive_ = false;
                this.debugEnabled_ = false;
                this.audioOnlyMode_ = false;
                this.audioPosterMode_ = false;
                this.audioOnlyCache_ = {
                    controlBarHeight: null,
                    playerHeight: null,
                    hiddenChildren: []
                };
                if (!this.options_ || !this.options_.techOrder || !this.options_.techOrder.length) throw new Error("No techOrder specified. Did you overwrite " + "videojs.options instead of just changing the " + "properties you want to override?");
                this.tag = tag;
                this.tagAttributes = tag && app_getAttributes(tag);
                this.language(this.options_.language);
                if (options.languages) {
                    const languagesToLower = {};
                    Object.getOwnPropertyNames(options.languages).forEach((function(name) {
                        languagesToLower[name.toLowerCase()] = options.languages[name];
                    }));
                    this.languages_ = languagesToLower;
                } else this.languages_ = app_Player.prototype.options_.languages;
                this.resetCache_();
                this.poster_ = options.poster || "";
                this.controls_ = !!options.controls;
                tag.controls = false;
                tag.removeAttribute("controls");
                this.changingSrc_ = false;
                this.playCallbacks_ = [];
                this.playTerminatedQueue_ = [];
                if (tag.hasAttribute("autoplay")) this.autoplay(true); else this.autoplay(this.options_.autoplay);
                if (options.plugins) Object.keys(options.plugins).forEach((name => {
                    if (typeof this[name] !== "function") throw new Error(`plugin "${name}" does not exist`);
                }));
                this.scrubbing_ = false;
                this.el_ = this.createEl();
                app_evented(this, {
                    eventBusKey: "el_"
                });
                if (this.fsApi_.requestFullscreen) {
                    app_on(app_document_default(), this.fsApi_.fullscreenchange, this.boundDocumentFullscreenChange_);
                    this.on(this.fsApi_.fullscreenchange, this.boundDocumentFullscreenChange_);
                }
                if (this.fluid_) this.on([ "playerreset", "resize" ], this.boundUpdateStyleEl_);
                const playerOptionsCopy = app_merge$1(this.options_);
                if (options.plugins) Object.keys(options.plugins).forEach((name => {
                    this[name](options.plugins[name]);
                }));
                if (options.debug) this.debug(true);
                this.options_.playerOptions = playerOptionsCopy;
                this.middleware_ = [];
                this.playbackRates(options.playbackRates);
                if (options.experimentalSvgIcons) {
                    const parser = new (app_window_default().DOMParser);
                    const parsedSVG = parser.parseFromString(app_icons, "image/svg+xml");
                    const errorNode = parsedSVG.querySelector("parsererror");
                    if (errorNode) {
                        app_log$1.warn("Failed to load SVG Icons. Falling back to Font Icons.");
                        this.options_.experimentalSvgIcons = null;
                    } else {
                        const sprite = parsedSVG.documentElement;
                        sprite.style.display = "none";
                        this.el_.appendChild(sprite);
                        this.addClass("vjs-svg-icons-enabled");
                    }
                }
                this.initChildren();
                this.isAudio(tag.nodeName.toLowerCase() === "audio");
                if (this.controls()) this.addClass("vjs-controls-enabled"); else this.addClass("vjs-controls-disabled");
                this.el_.setAttribute("role", "region");
                if (this.isAudio()) this.el_.setAttribute("aria-label", this.localize("Audio Player")); else this.el_.setAttribute("aria-label", this.localize("Video Player"));
                if (this.isAudio()) this.addClass("vjs-audio");
                if (options.spatialNavigation && options.spatialNavigation.enabled) {
                    this.spatialNavigation = new app_SpatialNavigation(this);
                    this.addClass("vjs-spatial-navigation-enabled");
                }
                if (app_TOUCH_ENABLED) this.addClass("vjs-touch-enabled");
                if (!app_IS_IOS) this.addClass("vjs-workinghover");
                app_Player.players[this.id_] = this;
                const majorVersion = app_version$6.split(".")[0];
                this.addClass(`vjs-v${majorVersion}`);
                this.userActive(true);
                this.reportUserActivity();
                this.one("play", (e => this.listenForUserActivity_(e)));
                this.on("keydown", (e => this.handleKeyDown(e)));
                this.on("languagechange", (e => this.handleLanguagechange(e)));
                this.breakpoints(this.options_.breakpoints);
                this.responsive(this.options_.responsive);
                this.on("ready", (() => {
                    this.audioPosterMode(this.options_.audioPosterMode);
                    this.audioOnlyMode(this.options_.audioOnlyMode);
                }));
            }
            dispose() {
                this.trigger("dispose");
                this.off("dispose");
                app_off(app_document_default(), this.fsApi_.fullscreenchange, this.boundDocumentFullscreenChange_);
                app_off(app_document_default(), "keydown", this.boundFullWindowOnEscKey_);
                if (this.styleEl_ && this.styleEl_.parentNode) {
                    this.styleEl_.parentNode.removeChild(this.styleEl_);
                    this.styleEl_ = null;
                }
                app_Player.players[this.id_] = null;
                if (this.tag && this.tag.player) this.tag.player = null;
                if (this.el_ && this.el_.player) this.el_.player = null;
                if (this.tech_) {
                    this.tech_.dispose();
                    this.isPosterFromTech_ = false;
                    this.poster_ = "";
                }
                if (this.playerElIngest_) this.playerElIngest_ = null;
                if (this.tag) this.tag = null;
                app_clearCacheForPlayer(this);
                app_ALL.names.forEach((name => {
                    const props = app_ALL[name];
                    const list = this[props.getterName]();
                    if (list && list.off) list.off();
                }));
                super.dispose({
                    restoreEl: this.options_.restoreEl
                });
            }
            createEl() {
                let tag = this.tag;
                let el;
                let playerElIngest = this.playerElIngest_ = tag.parentNode && tag.parentNode.hasAttribute && tag.parentNode.hasAttribute("data-vjs-player");
                const divEmbed = this.tag.tagName.toLowerCase() === "video-js";
                if (playerElIngest) el = this.el_ = tag.parentNode; else if (!divEmbed) el = this.el_ = super.createEl("div");
                const attrs = app_getAttributes(tag);
                if (divEmbed) {
                    el = this.el_ = tag;
                    tag = this.tag = app_document_default().createElement("video");
                    while (el.children.length) tag.appendChild(el.firstChild);
                    if (!app_hasClass(el, "video-js")) app_addClass(el, "video-js");
                    el.appendChild(tag);
                    playerElIngest = this.playerElIngest_ = el;
                    Object.keys(el).forEach((k => {
                        try {
                            tag[k] = el[k];
                        } catch (e) {}
                    }));
                }
                tag.setAttribute("tabindex", "-1");
                attrs.tabindex = "-1";
                if (app_IS_CHROME && app_IS_WINDOWS) {
                    tag.setAttribute("role", "application");
                    attrs.role = "application";
                }
                tag.removeAttribute("width");
                tag.removeAttribute("height");
                if ("width" in attrs) delete attrs.width;
                if ("height" in attrs) delete attrs.height;
                Object.getOwnPropertyNames(attrs).forEach((function(attr) {
                    if (!(divEmbed && attr === "class")) el.setAttribute(attr, attrs[attr]);
                    if (divEmbed) tag.setAttribute(attr, attrs[attr]);
                }));
                tag.playerId = tag.id;
                tag.id += "_html5_api";
                tag.className = "vjs-tech";
                tag.player = el.player = this;
                this.addClass("vjs-paused");
                const deviceClassNames = [ "IS_SMART_TV", "IS_TIZEN", "IS_WEBOS", "IS_ANDROID", "IS_IPAD", "IS_IPHONE", "IS_CHROMECAST_RECEIVER" ].filter((key => app_video_es_browser[key])).map((key => "vjs-device-" + key.substring(3).toLowerCase().replace(/\_/g, "-")));
                this.addClass(...deviceClassNames);
                if (app_window_default().VIDEOJS_NO_DYNAMIC_STYLE !== true) {
                    this.styleEl_ = app_createStyleElement("vjs-styles-dimensions");
                    const defaultsStyleEl = app_$(".vjs-styles-defaults");
                    const head = app_$("head");
                    head.insertBefore(this.styleEl_, defaultsStyleEl ? defaultsStyleEl.nextSibling : head.firstChild);
                }
                this.fill_ = false;
                this.fluid_ = false;
                this.width(this.options_.width);
                this.height(this.options_.height);
                this.fill(this.options_.fill);
                this.fluid(this.options_.fluid);
                this.aspectRatio(this.options_.aspectRatio);
                this.crossOrigin(this.options_.crossOrigin || this.options_.crossorigin);
                const links = tag.getElementsByTagName("a");
                for (let i = 0; i < links.length; i++) {
                    const linkEl = links.item(i);
                    app_addClass(linkEl, "vjs-hidden");
                    linkEl.setAttribute("hidden", "hidden");
                }
                tag.initNetworkState_ = tag.networkState;
                if (tag.parentNode && !playerElIngest) tag.parentNode.insertBefore(el, tag);
                app_prependTo(tag, el);
                this.children_.unshift(tag);
                this.el_.setAttribute("lang", this.language_);
                this.el_.setAttribute("translate", "no");
                this.el_ = el;
                return el;
            }
            crossOrigin(value) {
                if (typeof value === "undefined") return this.techGet_("crossOrigin");
                if (value !== null && value !== "anonymous" && value !== "use-credentials") {
                    app_log$1.warn(`crossOrigin must be null,  "anonymous" or "use-credentials", given "${value}"`);
                    return;
                }
                this.techCall_("setCrossOrigin", value);
                if (this.posterImage) this.posterImage.crossOrigin(value);
                return;
            }
            width(value) {
                return this.dimension("width", value);
            }
            height(value) {
                return this.dimension("height", value);
            }
            dimension(dimension, value) {
                const privDimension = dimension + "_";
                if (value === void 0) return this[privDimension] || 0;
                if (value === "" || value === "auto") {
                    this[privDimension] = void 0;
                    this.updateStyleEl_();
                    return;
                }
                const parsedVal = parseFloat(value);
                if (isNaN(parsedVal)) {
                    app_log$1.error(`Improper value "${value}" supplied for for ${dimension}`);
                    return;
                }
                this[privDimension] = parsedVal;
                this.updateStyleEl_();
            }
            fluid(bool) {
                if (bool === void 0) return !!this.fluid_;
                this.fluid_ = !!bool;
                if (app_isEvented(this)) this.off([ "playerreset", "resize" ], this.boundUpdateStyleEl_);
                if (bool) {
                    this.addClass("vjs-fluid");
                    this.fill(false);
                    app_addEventedCallback(this, (() => {
                        this.on([ "playerreset", "resize" ], this.boundUpdateStyleEl_);
                    }));
                } else this.removeClass("vjs-fluid");
                this.updateStyleEl_();
            }
            fill(bool) {
                if (bool === void 0) return !!this.fill_;
                this.fill_ = !!bool;
                if (bool) {
                    this.addClass("vjs-fill");
                    this.fluid(false);
                } else this.removeClass("vjs-fill");
            }
            aspectRatio(ratio) {
                if (ratio === void 0) return this.aspectRatio_;
                if (!/^\d+\:\d+$/.test(ratio)) throw new Error("Improper value supplied for aspect ratio. The format should be width:height, for example 16:9.");
                this.aspectRatio_ = ratio;
                this.fluid(true);
                this.updateStyleEl_();
            }
            updateStyleEl_() {
                if (app_window_default().VIDEOJS_NO_DYNAMIC_STYLE === true) {
                    const width = typeof this.width_ === "number" ? this.width_ : this.options_.width;
                    const height = typeof this.height_ === "number" ? this.height_ : this.options_.height;
                    const techEl = this.tech_ && this.tech_.el();
                    if (techEl) {
                        if (width >= 0) techEl.width = width;
                        if (height >= 0) techEl.height = height;
                    }
                    return;
                }
                let width;
                let height;
                let aspectRatio;
                let idClass;
                if (this.aspectRatio_ !== void 0 && this.aspectRatio_ !== "auto") aspectRatio = this.aspectRatio_; else if (this.videoWidth() > 0) aspectRatio = this.videoWidth() + ":" + this.videoHeight(); else aspectRatio = "16:9";
                const ratioParts = aspectRatio.split(":");
                const ratioMultiplier = ratioParts[1] / ratioParts[0];
                if (this.width_ !== void 0) width = this.width_; else if (this.height_ !== void 0) width = this.height_ / ratioMultiplier; else width = this.videoWidth() || 300;
                if (this.height_ !== void 0) height = this.height_; else height = width * ratioMultiplier;
                if (/^[^a-zA-Z]/.test(this.id())) idClass = "dimensions-" + this.id(); else idClass = this.id() + "-dimensions";
                this.addClass(idClass);
                app_setTextContent(this.styleEl_, `\n      .${idClass} {\n        width: ${width}px;\n        height: ${height}px;\n      }\n\n      .${idClass}.vjs-fluid:not(.vjs-audio-only-mode) {\n        padding-top: ${ratioMultiplier * 100}%;\n      }\n    `);
            }
            loadTech_(techName, source) {
                if (this.tech_) this.unloadTech_();
                const titleTechName = app_toTitleCase$1(techName);
                const camelTechName = techName.charAt(0).toLowerCase() + techName.slice(1);
                if (titleTechName !== "Html5" && this.tag) {
                    app_Tech.getTech("Html5").disposeMediaElement(this.tag);
                    this.tag.player = null;
                    this.tag = null;
                }
                this.techName_ = titleTechName;
                this.isReady_ = false;
                let autoplay = this.autoplay();
                if (typeof this.autoplay() === "string" || this.autoplay() === true && this.options_.normalizeAutoplay) autoplay = false;
                const techOptions = {
                    source,
                    autoplay,
                    nativeControlsForTouch: this.options_.nativeControlsForTouch,
                    playerId: this.id(),
                    techId: `${this.id()}_${camelTechName}_api`,
                    playsinline: this.options_.playsinline,
                    preload: this.options_.preload,
                    loop: this.options_.loop,
                    disablePictureInPicture: this.options_.disablePictureInPicture,
                    muted: this.options_.muted,
                    poster: this.poster(),
                    language: this.language(),
                    playerElIngest: this.playerElIngest_ || false,
                    "vtt.js": this.options_["vtt.js"],
                    canOverridePoster: !!this.options_.techCanOverridePoster,
                    enableSourceset: this.options_.enableSourceset
                };
                app_ALL.names.forEach((name => {
                    const props = app_ALL[name];
                    techOptions[props.getterName] = this[props.privateName];
                }));
                Object.assign(techOptions, this.options_[titleTechName]);
                Object.assign(techOptions, this.options_[camelTechName]);
                Object.assign(techOptions, this.options_[techName.toLowerCase()]);
                if (this.tag) techOptions.tag = this.tag;
                if (source && source.src === this.cache_.src && this.cache_.currentTime > 0) techOptions.startTime = this.cache_.currentTime;
                const TechClass = app_Tech.getTech(techName);
                if (!TechClass) throw new Error(`No Tech named '${titleTechName}' exists! '${titleTechName}' should be registered using videojs.registerTech()'`);
                this.tech_ = new TechClass(techOptions);
                this.tech_.ready(app_bind_(this, this.handleTechReady_), true);
                app_textTrackConverter.jsonToTextTracks(this.textTracksJson_ || [], this.tech_);
                app_TECH_EVENTS_RETRIGGER.forEach((event => {
                    this.on(this.tech_, event, (e => this[`handleTech${app_toTitleCase$1(event)}_`](e)));
                }));
                Object.keys(app_TECH_EVENTS_QUEUE).forEach((event => {
                    this.on(this.tech_, event, (eventObj => {
                        if (this.tech_.playbackRate() === 0 && this.tech_.seeking()) {
                            this.queuedCallbacks_.push({
                                callback: this[`handleTech${app_TECH_EVENTS_QUEUE[event]}_`].bind(this),
                                event: eventObj
                            });
                            return;
                        }
                        this[`handleTech${app_TECH_EVENTS_QUEUE[event]}_`](eventObj);
                    }));
                }));
                this.on(this.tech_, "loadstart", (e => this.handleTechLoadStart_(e)));
                this.on(this.tech_, "sourceset", (e => this.handleTechSourceset_(e)));
                this.on(this.tech_, "waiting", (e => this.handleTechWaiting_(e)));
                this.on(this.tech_, "ended", (e => this.handleTechEnded_(e)));
                this.on(this.tech_, "seeking", (e => this.handleTechSeeking_(e)));
                this.on(this.tech_, "play", (e => this.handleTechPlay_(e)));
                this.on(this.tech_, "pause", (e => this.handleTechPause_(e)));
                this.on(this.tech_, "durationchange", (e => this.handleTechDurationChange_(e)));
                this.on(this.tech_, "fullscreenchange", ((e, data) => this.handleTechFullscreenChange_(e, data)));
                this.on(this.tech_, "fullscreenerror", ((e, err) => this.handleTechFullscreenError_(e, err)));
                this.on(this.tech_, "enterpictureinpicture", (e => this.handleTechEnterPictureInPicture_(e)));
                this.on(this.tech_, "leavepictureinpicture", (e => this.handleTechLeavePictureInPicture_(e)));
                this.on(this.tech_, "error", (e => this.handleTechError_(e)));
                this.on(this.tech_, "posterchange", (e => this.handleTechPosterChange_(e)));
                this.on(this.tech_, "textdata", (e => this.handleTechTextData_(e)));
                this.on(this.tech_, "ratechange", (e => this.handleTechRateChange_(e)));
                this.on(this.tech_, "loadedmetadata", this.boundUpdateStyleEl_);
                this.usingNativeControls(this.techGet_("controls"));
                if (this.controls() && !this.usingNativeControls()) this.addTechControlsListeners_();
                if (this.tech_.el().parentNode !== this.el() && (titleTechName !== "Html5" || !this.tag)) app_prependTo(this.tech_.el(), this.el());
                if (this.tag) {
                    this.tag.player = null;
                    this.tag = null;
                }
            }
            unloadTech_() {
                app_ALL.names.forEach((name => {
                    const props = app_ALL[name];
                    this[props.privateName] = this[props.getterName]();
                }));
                this.textTracksJson_ = app_textTrackConverter.textTracksToJson(this.tech_);
                this.isReady_ = false;
                this.tech_.dispose();
                this.tech_ = false;
                if (this.isPosterFromTech_) {
                    this.poster_ = "";
                    this.trigger("posterchange");
                }
                this.isPosterFromTech_ = false;
            }
            tech(safety) {
                if (safety === void 0) app_log$1.warn("Using the tech directly can be dangerous. I hope you know what you're doing.\n" + "See https://github.com/videojs/video.js/issues/2617 for more info.\n");
                return this.tech_;
            }
            version() {
                return {
                    "video.js": app_version$6
                };
            }
            addTechControlsListeners_() {
                this.removeTechControlsListeners_();
                this.on(this.tech_, "click", this.boundHandleTechClick_);
                this.on(this.tech_, "dblclick", this.boundHandleTechDoubleClick_);
                this.on(this.tech_, "touchstart", this.boundHandleTechTouchStart_);
                this.on(this.tech_, "touchmove", this.boundHandleTechTouchMove_);
                this.on(this.tech_, "touchend", this.boundHandleTechTouchEnd_);
                this.on(this.tech_, "tap", this.boundHandleTechTap_);
            }
            removeTechControlsListeners_() {
                this.off(this.tech_, "tap", this.boundHandleTechTap_);
                this.off(this.tech_, "touchstart", this.boundHandleTechTouchStart_);
                this.off(this.tech_, "touchmove", this.boundHandleTechTouchMove_);
                this.off(this.tech_, "touchend", this.boundHandleTechTouchEnd_);
                this.off(this.tech_, "click", this.boundHandleTechClick_);
                this.off(this.tech_, "dblclick", this.boundHandleTechDoubleClick_);
            }
            handleTechReady_() {
                this.triggerReady();
                if (this.cache_.volume) this.techCall_("setVolume", this.cache_.volume);
                this.handleTechPosterChange_();
                this.handleTechDurationChange_();
            }
            handleTechLoadStart_() {
                this.removeClass("vjs-ended", "vjs-seeking");
                this.error(null);
                this.handleTechDurationChange_();
                if (!this.paused()) this.trigger("loadstart"); else {
                    this.hasStarted(false);
                    this.trigger("loadstart");
                }
                this.manualAutoplay_(this.autoplay() === true && this.options_.normalizeAutoplay ? "play" : this.autoplay());
            }
            manualAutoplay_(type) {
                if (!this.tech_ || typeof type !== "string") return;
                const resolveMuted = () => {
                    const previouslyMuted = this.muted();
                    this.muted(true);
                    const restoreMuted = () => {
                        this.muted(previouslyMuted);
                    };
                    this.playTerminatedQueue_.push(restoreMuted);
                    const mutedPromise = this.play();
                    if (!app_isPromise(mutedPromise)) return;
                    return mutedPromise.catch((err => {
                        restoreMuted();
                        throw new Error(`Rejection at manualAutoplay. Restoring muted value. ${err ? err : ""}`);
                    }));
                };
                let promise;
                if (type === "any" && !this.muted()) {
                    promise = this.play();
                    if (app_isPromise(promise)) promise = promise.catch(resolveMuted);
                } else if (type === "muted" && !this.muted()) promise = resolveMuted(); else promise = this.play();
                if (!app_isPromise(promise)) return;
                return promise.then((() => {
                    this.trigger({
                        type: "autoplay-success",
                        autoplay: type
                    });
                })).catch((() => {
                    this.trigger({
                        type: "autoplay-failure",
                        autoplay: type
                    });
                }));
            }
            updateSourceCaches_(srcObj = "") {
                let src = srcObj;
                let type = "";
                if (typeof src !== "string") {
                    src = srcObj.src;
                    type = srcObj.type;
                }
                this.cache_.source = this.cache_.source || {};
                this.cache_.sources = this.cache_.sources || [];
                if (src && !type) type = app_findMimetype(this, src);
                this.cache_.source = app_merge$1({}, srcObj, {
                    src,
                    type
                });
                const matchingSources = this.cache_.sources.filter((s => s.src && s.src === src));
                const sourceElSources = [];
                const sourceEls = this.$$("source");
                const matchingSourceEls = [];
                for (let i = 0; i < sourceEls.length; i++) {
                    const sourceObj = app_getAttributes(sourceEls[i]);
                    sourceElSources.push(sourceObj);
                    if (sourceObj.src && sourceObj.src === src) matchingSourceEls.push(sourceObj.src);
                }
                if (matchingSourceEls.length && !matchingSources.length) this.cache_.sources = sourceElSources; else if (!matchingSources.length) this.cache_.sources = [ this.cache_.source ];
                this.cache_.src = src;
            }
            handleTechSourceset_(event) {
                if (!this.changingSrc_) {
                    let updateSourceCaches = src => this.updateSourceCaches_(src);
                    const playerSrc = this.currentSource().src;
                    const eventSrc = event.src;
                    if (playerSrc && !/^blob:/.test(playerSrc) && /^blob:/.test(eventSrc)) if (!this.lastSource_ || this.lastSource_.tech !== eventSrc && this.lastSource_.player !== playerSrc) updateSourceCaches = () => {};
                    updateSourceCaches(eventSrc);
                    if (!event.src) this.tech_.any([ "sourceset", "loadstart" ], (e => {
                        if (e.type === "sourceset") return;
                        const techSrc = this.techGet_("currentSrc");
                        this.lastSource_.tech = techSrc;
                        this.updateSourceCaches_(techSrc);
                    }));
                }
                this.lastSource_ = {
                    player: this.currentSource().src,
                    tech: event.src
                };
                this.trigger({
                    src: event.src,
                    type: "sourceset"
                });
            }
            hasStarted(request) {
                if (request === void 0) return this.hasStarted_;
                if (request === this.hasStarted_) return;
                this.hasStarted_ = request;
                if (this.hasStarted_) this.addClass("vjs-has-started"); else this.removeClass("vjs-has-started");
            }
            handleTechPlay_() {
                this.removeClass("vjs-ended", "vjs-paused");
                this.addClass("vjs-playing");
                this.hasStarted(true);
                this.trigger("play");
            }
            handleTechRateChange_() {
                if (this.tech_.playbackRate() > 0 && this.cache_.lastPlaybackRate === 0) {
                    this.queuedCallbacks_.forEach((queued => queued.callback(queued.event)));
                    this.queuedCallbacks_ = [];
                }
                this.cache_.lastPlaybackRate = this.tech_.playbackRate();
                this.trigger("ratechange");
            }
            handleTechWaiting_() {
                this.addClass("vjs-waiting");
                this.trigger("waiting");
                const timeWhenWaiting = this.currentTime();
                const timeUpdateListener = () => {
                    if (timeWhenWaiting !== this.currentTime()) {
                        this.removeClass("vjs-waiting");
                        this.off("timeupdate", timeUpdateListener);
                    }
                };
                this.on("timeupdate", timeUpdateListener);
            }
            handleTechCanPlay_() {
                this.removeClass("vjs-waiting");
                this.trigger("canplay");
            }
            handleTechCanPlayThrough_() {
                this.removeClass("vjs-waiting");
                this.trigger("canplaythrough");
            }
            handleTechPlaying_() {
                this.removeClass("vjs-waiting");
                this.trigger("playing");
            }
            handleTechSeeking_() {
                this.addClass("vjs-seeking");
                this.trigger("seeking");
            }
            handleTechSeeked_() {
                this.removeClass("vjs-seeking", "vjs-ended");
                this.trigger("seeked");
            }
            handleTechPause_() {
                this.removeClass("vjs-playing");
                this.addClass("vjs-paused");
                this.trigger("pause");
            }
            handleTechEnded_() {
                this.addClass("vjs-ended");
                this.removeClass("vjs-waiting");
                if (this.options_.loop) {
                    this.currentTime(0);
                    this.play();
                } else if (!this.paused()) this.pause();
                this.trigger("ended");
            }
            handleTechDurationChange_() {
                this.duration(this.techGet_("duration"));
            }
            handleTechClick_(event) {
                if (!this.controls_) return;
                if (this.options_ === void 0 || this.options_.userActions === void 0 || this.options_.userActions.click === void 0 || this.options_.userActions.click !== false) if (this.options_ !== void 0 && this.options_.userActions !== void 0 && typeof this.options_.userActions.click === "function") this.options_.userActions.click.call(this, event); else if (this.paused()) app_silencePromise(this.play()); else this.pause();
            }
            handleTechDoubleClick_(event) {
                if (!this.controls_) return;
                const inAllowedEls = Array.prototype.some.call(this.$$(".vjs-control-bar, .vjs-modal-dialog"), (el => el.contains(event.target)));
                if (!inAllowedEls) if (this.options_ === void 0 || this.options_.userActions === void 0 || this.options_.userActions.doubleClick === void 0 || this.options_.userActions.doubleClick !== false) if (this.options_ !== void 0 && this.options_.userActions !== void 0 && typeof this.options_.userActions.doubleClick === "function") this.options_.userActions.doubleClick.call(this, event); else if (this.isInPictureInPicture() && !app_document_default().pictureInPictureElement) this.exitPictureInPicture(); else if (this.isFullscreen()) this.exitFullscreen(); else this.requestFullscreen();
            }
            handleTechTap_() {
                this.userActive(!this.userActive());
            }
            handleTechTouchStart_() {
                this.userWasActive = this.userActive();
            }
            handleTechTouchMove_() {
                if (this.userWasActive) this.reportUserActivity();
            }
            handleTechTouchEnd_(event) {
                if (event.cancelable) event.preventDefault();
            }
            toggleFullscreenClass_() {
                if (this.isFullscreen()) this.addClass("vjs-fullscreen"); else this.removeClass("vjs-fullscreen");
            }
            documentFullscreenChange_(e) {
                const targetPlayer = e.target.player;
                if (targetPlayer && targetPlayer !== this) return;
                const el = this.el();
                let isFs = app_document_default()[this.fsApi_.fullscreenElement] === el;
                if (!isFs && el.matches) isFs = el.matches(":" + this.fsApi_.fullscreen);
                this.isFullscreen(isFs);
            }
            handleTechFullscreenChange_(event, data) {
                if (data) {
                    if (data.nativeIOSFullscreen) {
                        this.addClass("vjs-ios-native-fs");
                        this.tech_.one("webkitendfullscreen", (() => {
                            this.removeClass("vjs-ios-native-fs");
                        }));
                    }
                    this.isFullscreen(data.isFullscreen);
                }
            }
            handleTechFullscreenError_(event, err) {
                this.trigger("fullscreenerror", err);
            }
            togglePictureInPictureClass_() {
                if (this.isInPictureInPicture()) this.addClass("vjs-picture-in-picture"); else this.removeClass("vjs-picture-in-picture");
            }
            handleTechEnterPictureInPicture_(event) {
                this.isInPictureInPicture(true);
            }
            handleTechLeavePictureInPicture_(event) {
                this.isInPictureInPicture(false);
            }
            handleTechError_() {
                const error = this.tech_.error();
                if (error) this.error(error);
            }
            handleTechTextData_() {
                let data = null;
                if (arguments.length > 1) data = arguments[1];
                this.trigger("textdata", data);
            }
            getCache() {
                return this.cache_;
            }
            resetCache_() {
                this.cache_ = {
                    currentTime: 0,
                    initTime: 0,
                    inactivityTimeout: this.options_.inactivityTimeout,
                    duration: NaN,
                    lastVolume: 1,
                    lastPlaybackRate: this.defaultPlaybackRate(),
                    media: null,
                    src: "",
                    source: {},
                    sources: [],
                    playbackRates: [],
                    volume: 1
                };
            }
            techCall_(method, arg) {
                this.ready((function() {
                    if (method in app_allowedSetters) return app_set(this.middleware_, this.tech_, method, arg); else if (method in app_allowedMediators) return app_mediate(this.middleware_, this.tech_, method, arg);
                    try {
                        if (this.tech_) this.tech_[method](arg);
                    } catch (e) {
                        app_log$1(e);
                        throw e;
                    }
                }), true);
            }
            techGet_(method) {
                if (!this.tech_ || !this.tech_.isReady_) return;
                if (method in app_allowedGetters) return app_get(this.middleware_, this.tech_, method); else if (method in app_allowedMediators) return app_mediate(this.middleware_, this.tech_, method);
                try {
                    return this.tech_[method]();
                } catch (e) {
                    if (this.tech_[method] === void 0) {
                        app_log$1(`Video.js: ${method} method not defined for ${this.techName_} playback technology.`, e);
                        throw e;
                    }
                    if (e.name === "TypeError") {
                        app_log$1(`Video.js: ${method} unavailable on ${this.techName_} playback technology element.`, e);
                        this.tech_.isReady_ = false;
                        throw e;
                    }
                    app_log$1(e);
                    throw e;
                }
            }
            play() {
                return new Promise((resolve => {
                    this.play_(resolve);
                }));
            }
            play_(callback = app_silencePromise) {
                this.playCallbacks_.push(callback);
                const isSrcReady = Boolean(!this.changingSrc_ && (this.src() || this.currentSrc()));
                const isSafariOrIOS = Boolean(app_IS_ANY_SAFARI || app_IS_IOS);
                if (this.waitToPlay_) {
                    this.off([ "ready", "loadstart" ], this.waitToPlay_);
                    this.waitToPlay_ = null;
                }
                if (!this.isReady_ || !isSrcReady) {
                    this.waitToPlay_ = e => {
                        this.play_();
                    };
                    this.one([ "ready", "loadstart" ], this.waitToPlay_);
                    if (!isSrcReady && isSafariOrIOS) this.load();
                    return;
                }
                const val = this.techGet_("play");
                const isNativeReplay = isSafariOrIOS && this.hasClass("vjs-ended");
                if (isNativeReplay) this.resetProgressBar_();
                if (val === null) this.runPlayTerminatedQueue_(); else this.runPlayCallbacks_(val);
            }
            runPlayTerminatedQueue_() {
                const queue = this.playTerminatedQueue_.slice(0);
                this.playTerminatedQueue_ = [];
                queue.forEach((function(q) {
                    q();
                }));
            }
            runPlayCallbacks_(val) {
                const callbacks = this.playCallbacks_.slice(0);
                this.playCallbacks_ = [];
                this.playTerminatedQueue_ = [];
                callbacks.forEach((function(cb) {
                    cb(val);
                }));
            }
            pause() {
                this.techCall_("pause");
            }
            paused() {
                return this.techGet_("paused") === false ? false : true;
            }
            played() {
                return this.techGet_("played") || app_createTimeRanges$1(0, 0);
            }
            scrubbing(isScrubbing) {
                if (typeof isScrubbing === "undefined") return this.scrubbing_;
                this.scrubbing_ = !!isScrubbing;
                this.techCall_("setScrubbing", this.scrubbing_);
                if (isScrubbing) this.addClass("vjs-scrubbing"); else this.removeClass("vjs-scrubbing");
            }
            currentTime(seconds) {
                if (seconds === void 0) {
                    this.cache_.currentTime = this.techGet_("currentTime") || 0;
                    return this.cache_.currentTime;
                }
                if (seconds < 0) seconds = 0;
                if (!this.isReady_ || this.changingSrc_ || !this.tech_ || !this.tech_.isReady_) {
                    this.cache_.initTime = seconds;
                    this.off("canplay", this.boundApplyInitTime_);
                    this.one("canplay", this.boundApplyInitTime_);
                    return;
                }
                this.techCall_("setCurrentTime", seconds);
                this.cache_.initTime = 0;
                if (isFinite(seconds)) this.cache_.currentTime = Number(seconds);
            }
            applyInitTime_() {
                this.currentTime(this.cache_.initTime);
            }
            duration(seconds) {
                if (seconds === void 0) return this.cache_.duration !== void 0 ? this.cache_.duration : NaN;
                seconds = parseFloat(seconds);
                if (seconds < 0) seconds = 1 / 0;
                if (seconds !== this.cache_.duration) {
                    this.cache_.duration = seconds;
                    if (seconds === 1 / 0) this.addClass("vjs-live"); else this.removeClass("vjs-live");
                    if (!isNaN(seconds)) this.trigger("durationchange");
                }
            }
            remainingTime() {
                return this.duration() - this.currentTime();
            }
            remainingTimeDisplay() {
                return Math.floor(this.duration()) - Math.floor(this.currentTime());
            }
            buffered() {
                let buffered = this.techGet_("buffered");
                if (!buffered || !buffered.length) buffered = app_createTimeRanges$1(0, 0);
                return buffered;
            }
            seekable() {
                let seekable = this.techGet_("seekable");
                if (!seekable || !seekable.length) seekable = app_createTimeRanges$1(0, 0);
                return seekable;
            }
            seeking() {
                return this.techGet_("seeking");
            }
            ended() {
                return this.techGet_("ended");
            }
            networkState() {
                return this.techGet_("networkState");
            }
            readyState() {
                return this.techGet_("readyState");
            }
            bufferedPercent() {
                return app_bufferedPercent(this.buffered(), this.duration());
            }
            bufferedEnd() {
                const buffered = this.buffered();
                const duration = this.duration();
                let end = buffered.end(buffered.length - 1);
                if (end > duration) end = duration;
                return end;
            }
            volume(percentAsDecimal) {
                let vol;
                if (percentAsDecimal !== void 0) {
                    vol = Math.max(0, Math.min(1, percentAsDecimal));
                    this.cache_.volume = vol;
                    this.techCall_("setVolume", vol);
                    if (vol > 0) this.lastVolume_(vol);
                    return;
                }
                vol = parseFloat(this.techGet_("volume"));
                return isNaN(vol) ? 1 : vol;
            }
            muted(muted) {
                if (muted !== void 0) {
                    this.techCall_("setMuted", muted);
                    return;
                }
                return this.techGet_("muted") || false;
            }
            defaultMuted(defaultMuted) {
                if (defaultMuted !== void 0) this.techCall_("setDefaultMuted", defaultMuted);
                return this.techGet_("defaultMuted") || false;
            }
            lastVolume_(percentAsDecimal) {
                if (percentAsDecimal !== void 0 && percentAsDecimal !== 0) {
                    this.cache_.lastVolume = percentAsDecimal;
                    return;
                }
                return this.cache_.lastVolume;
            }
            supportsFullScreen() {
                return this.techGet_("supportsFullScreen") || false;
            }
            isFullscreen(isFS) {
                if (isFS !== void 0) {
                    const oldValue = this.isFullscreen_;
                    this.isFullscreen_ = Boolean(isFS);
                    if (this.isFullscreen_ !== oldValue && this.fsApi_.prefixed) this.trigger("fullscreenchange");
                    this.toggleFullscreenClass_();
                    return;
                }
                return this.isFullscreen_;
            }
            requestFullscreen(fullscreenOptions) {
                if (this.isInPictureInPicture()) this.exitPictureInPicture();
                const self = this;
                return new Promise(((resolve, reject) => {
                    function offHandler() {
                        self.off("fullscreenerror", errorHandler);
                        self.off("fullscreenchange", changeHandler);
                    }
                    function changeHandler() {
                        offHandler();
                        resolve();
                    }
                    function errorHandler(e, err) {
                        offHandler();
                        reject(err);
                    }
                    self.one("fullscreenchange", changeHandler);
                    self.one("fullscreenerror", errorHandler);
                    const promise = self.requestFullscreenHelper_(fullscreenOptions);
                    if (promise) {
                        promise.then(offHandler, offHandler);
                        promise.then(resolve, reject);
                    }
                }));
            }
            requestFullscreenHelper_(fullscreenOptions) {
                let fsOptions;
                if (!this.fsApi_.prefixed) {
                    fsOptions = this.options_.fullscreen && this.options_.fullscreen.options || {};
                    if (fullscreenOptions !== void 0) fsOptions = fullscreenOptions;
                }
                if (this.fsApi_.requestFullscreen) {
                    const promise = this.el_[this.fsApi_.requestFullscreen](fsOptions);
                    if (promise) promise.then((() => this.isFullscreen(true)), (() => this.isFullscreen(false)));
                    return promise;
                } else if (this.tech_.supportsFullScreen() && !this.options_.preferFullWindow === true) this.techCall_("enterFullScreen"); else this.enterFullWindow();
            }
            exitFullscreen() {
                const self = this;
                return new Promise(((resolve, reject) => {
                    function offHandler() {
                        self.off("fullscreenerror", errorHandler);
                        self.off("fullscreenchange", changeHandler);
                    }
                    function changeHandler() {
                        offHandler();
                        resolve();
                    }
                    function errorHandler(e, err) {
                        offHandler();
                        reject(err);
                    }
                    self.one("fullscreenchange", changeHandler);
                    self.one("fullscreenerror", errorHandler);
                    const promise = self.exitFullscreenHelper_();
                    if (promise) {
                        promise.then(offHandler, offHandler);
                        promise.then(resolve, reject);
                    }
                }));
            }
            exitFullscreenHelper_() {
                if (this.fsApi_.requestFullscreen) {
                    const promise = app_document_default()[this.fsApi_.exitFullscreen]();
                    if (promise) app_silencePromise(promise.then((() => this.isFullscreen(false))));
                    return promise;
                } else if (this.tech_.supportsFullScreen() && !this.options_.preferFullWindow === true) this.techCall_("exitFullScreen"); else this.exitFullWindow();
            }
            enterFullWindow() {
                this.isFullscreen(true);
                this.isFullWindow = true;
                this.docOrigOverflow = app_document_default().documentElement.style.overflow;
                app_on(app_document_default(), "keydown", this.boundFullWindowOnEscKey_);
                app_document_default().documentElement.style.overflow = "hidden";
                app_addClass(app_document_default().body, "vjs-full-window");
                this.trigger("enterFullWindow");
            }
            fullWindowOnEscKey(event) {
                if (event.key === "Escape") if (this.isFullscreen() === true) if (!this.isFullWindow) this.exitFullscreen(); else this.exitFullWindow();
            }
            exitFullWindow() {
                this.isFullscreen(false);
                this.isFullWindow = false;
                app_off(app_document_default(), "keydown", this.boundFullWindowOnEscKey_);
                app_document_default().documentElement.style.overflow = this.docOrigOverflow;
                app_removeClass(app_document_default().body, "vjs-full-window");
                this.trigger("exitFullWindow");
            }
            disablePictureInPicture(value) {
                if (value === void 0) return this.techGet_("disablePictureInPicture");
                this.techCall_("setDisablePictureInPicture", value);
                this.options_.disablePictureInPicture = value;
                this.trigger("disablepictureinpicturechanged");
            }
            isInPictureInPicture(isPiP) {
                if (isPiP !== void 0) {
                    this.isInPictureInPicture_ = !!isPiP;
                    this.togglePictureInPictureClass_();
                    return;
                }
                return !!this.isInPictureInPicture_;
            }
            requestPictureInPicture() {
                if (this.options_.enableDocumentPictureInPicture && app_window_default().documentPictureInPicture) {
                    const pipContainer = app_document_default().createElement(this.el().tagName);
                    pipContainer.classList = this.el().classList;
                    pipContainer.classList.add("vjs-pip-container");
                    if (this.posterImage) pipContainer.appendChild(this.posterImage.el().cloneNode(true));
                    if (this.titleBar) pipContainer.appendChild(this.titleBar.el().cloneNode(true));
                    pipContainer.appendChild(app_createEl("p", {
                        className: "vjs-pip-text"
                    }, {}, this.localize("Playing in picture-in-picture")));
                    return app_window_default().documentPictureInPicture.requestWindow({
                        width: this.videoWidth(),
                        height: this.videoHeight()
                    }).then((pipWindow => {
                        app_copyStyleSheetsToWindow(pipWindow);
                        this.el_.parentNode.insertBefore(pipContainer, this.el_);
                        pipWindow.document.body.appendChild(this.el_);
                        pipWindow.document.body.classList.add("vjs-pip-window");
                        this.player_.isInPictureInPicture(true);
                        this.player_.trigger({
                            type: "enterpictureinpicture",
                            pipWindow
                        });
                        pipWindow.addEventListener("pagehide", (event => {
                            const pipVideo = event.target.querySelector(".video-js");
                            pipContainer.parentNode.replaceChild(pipVideo, pipContainer);
                            this.player_.isInPictureInPicture(false);
                            this.player_.trigger("leavepictureinpicture");
                        }));
                        return pipWindow;
                    }));
                }
                if ("pictureInPictureEnabled" in app_document_default() && this.disablePictureInPicture() === false) return this.techGet_("requestPictureInPicture");
                return Promise.reject("No PiP mode is available");
            }
            exitPictureInPicture() {
                if (app_window_default().documentPictureInPicture && app_window_default().documentPictureInPicture.window) {
                    app_window_default().documentPictureInPicture.window.close();
                    return Promise.resolve();
                }
                if ("pictureInPictureEnabled" in app_document_default()) return app_document_default().exitPictureInPicture();
            }
            handleKeyDown(event) {
                const {userActions} = this.options_;
                if (!userActions || !userActions.hotkeys) return;
                const excludeElement = el => {
                    const tagName = el.tagName.toLowerCase();
                    if (el.isContentEditable) return true;
                    const allowedInputTypes = [ "button", "checkbox", "hidden", "radio", "reset", "submit" ];
                    if (tagName === "input") return allowedInputTypes.indexOf(el.type) === -1;
                    const excludedTags = [ "textarea" ];
                    return excludedTags.indexOf(tagName) !== -1;
                };
                if (excludeElement(this.el_.ownerDocument.activeElement)) return;
                if (typeof userActions.hotkeys === "function") userActions.hotkeys.call(this, event); else this.handleHotkeys(event);
            }
            handleHotkeys(event) {
                const hotkeys = this.options_.userActions ? this.options_.userActions.hotkeys : {};
                const {fullscreenKey = keydownEvent => event.key.toLowerCase() === "f", muteKey = keydownEvent => event.key.toLowerCase() === "m", playPauseKey = keydownEvent => event.key.toLowerCase() === "k" || event.key.toLowerCase() === " "} = hotkeys;
                if (fullscreenKey.call(this, event)) {
                    event.preventDefault();
                    event.stopPropagation();
                    const FSToggle = app_Component$1.getComponent("FullscreenToggle");
                    if (app_document_default()[this.fsApi_.fullscreenEnabled] !== false) FSToggle.prototype.handleClick.call(this, event);
                } else if (muteKey.call(this, event)) {
                    event.preventDefault();
                    event.stopPropagation();
                    const MuteToggle = app_Component$1.getComponent("MuteToggle");
                    MuteToggle.prototype.handleClick.call(this, event);
                } else if (playPauseKey.call(this, event)) {
                    event.preventDefault();
                    event.stopPropagation();
                    const PlayToggle = app_Component$1.getComponent("PlayToggle");
                    PlayToggle.prototype.handleClick.call(this, event);
                }
            }
            canPlayType(type) {
                let can;
                for (let i = 0, j = this.options_.techOrder; i < j.length; i++) {
                    const techName = j[i];
                    let tech = app_Tech.getTech(techName);
                    if (!tech) tech = app_Component$1.getComponent(techName);
                    if (!tech) {
                        app_log$1.error(`The "${techName}" tech is undefined. Skipped browser support check for that tech.`);
                        continue;
                    }
                    if (tech.isSupported()) {
                        can = tech.canPlayType(type);
                        if (can) return can;
                    }
                }
                return "";
            }
            selectSource(sources) {
                const techs = this.options_.techOrder.map((techName => [ techName, app_Tech.getTech(techName) ])).filter((([techName, tech]) => {
                    if (tech) return tech.isSupported();
                    app_log$1.error(`The "${techName}" tech is undefined. Skipped browser support check for that tech.`);
                    return false;
                }));
                const findFirstPassingTechSourcePair = function(outerArray, innerArray, tester) {
                    let found;
                    outerArray.some((outerChoice => innerArray.some((innerChoice => {
                        found = tester(outerChoice, innerChoice);
                        if (found) return true;
                    }))));
                    return found;
                };
                let foundSourceAndTech;
                const flip = fn => (a, b) => fn(b, a);
                const finder = ([techName, tech], source) => {
                    if (tech.canPlaySource(source, this.options_[techName.toLowerCase()])) return {
                        source,
                        tech: techName
                    };
                };
                if (this.options_.sourceOrder) foundSourceAndTech = findFirstPassingTechSourcePair(sources, techs, flip(finder)); else foundSourceAndTech = findFirstPassingTechSourcePair(techs, sources, finder);
                return foundSourceAndTech || false;
            }
            handleSrc_(source, isRetry) {
                if (typeof source === "undefined") return this.cache_.src || "";
                if (this.resetRetryOnError_) this.resetRetryOnError_();
                const sources = app_filterSource(source);
                if (!sources.length) {
                    this.setTimeout((function() {
                        this.error({
                            code: 4,
                            message: this.options_.notSupportedMessage
                        });
                    }), 0);
                    return;
                }
                this.changingSrc_ = true;
                if (!isRetry) this.cache_.sources = sources;
                this.updateSourceCaches_(sources[0]);
                app_setSource(this, sources[0], ((middlewareSource, mws) => {
                    this.middleware_ = mws;
                    if (!isRetry) this.cache_.sources = sources;
                    this.updateSourceCaches_(middlewareSource);
                    const err = this.src_(middlewareSource);
                    if (err) {
                        if (sources.length > 1) return this.handleSrc_(sources.slice(1));
                        this.changingSrc_ = false;
                        this.setTimeout((function() {
                            this.error({
                                code: 4,
                                message: this.options_.notSupportedMessage
                            });
                        }), 0);
                        this.triggerReady();
                        return;
                    }
                    app_setTech(mws, this.tech_);
                }));
                if (sources.length > 1) {
                    const retry = () => {
                        this.error(null);
                        this.handleSrc_(sources.slice(1), true);
                    };
                    const stopListeningForErrors = () => {
                        this.off("error", retry);
                    };
                    this.one("error", retry);
                    this.one("playing", stopListeningForErrors);
                    this.resetRetryOnError_ = () => {
                        this.off("error", retry);
                        this.off("playing", stopListeningForErrors);
                    };
                }
            }
            src(source) {
                return this.handleSrc_(source, false);
            }
            src_(source) {
                const sourceTech = this.selectSource([ source ]);
                if (!sourceTech) return true;
                if (!app_titleCaseEquals(sourceTech.tech, this.techName_)) {
                    this.changingSrc_ = true;
                    this.loadTech_(sourceTech.tech, sourceTech.source);
                    this.tech_.ready((() => {
                        this.changingSrc_ = false;
                    }));
                    return false;
                }
                this.ready((function() {
                    if (this.tech_.constructor.prototype.hasOwnProperty("setSource")) this.techCall_("setSource", source); else this.techCall_("src", source.src);
                    this.changingSrc_ = false;
                }), true);
                return false;
            }
            addSourceElement(srcUrl, mimeType) {
                if (!this.tech_) return false;
                return this.tech_.addSourceElement(srcUrl, mimeType);
            }
            removeSourceElement(srcUrl) {
                if (!this.tech_) return false;
                return this.tech_.removeSourceElement(srcUrl);
            }
            load() {
                if (this.tech_ && this.tech_.vhs) {
                    this.src(this.currentSource());
                    return;
                }
                this.techCall_("load");
            }
            reset() {
                if (this.paused()) this.doReset_(); else {
                    const playPromise = this.play();
                    app_silencePromise(playPromise.then((() => this.doReset_())));
                }
            }
            doReset_() {
                if (this.tech_) this.tech_.clearTracks("text");
                this.removeClass("vjs-playing");
                this.addClass("vjs-paused");
                this.resetCache_();
                this.poster("");
                this.loadTech_(this.options_.techOrder[0], null);
                this.techCall_("reset");
                this.resetControlBarUI_();
                this.error(null);
                if (this.titleBar) this.titleBar.update({
                    title: void 0,
                    description: void 0
                });
                if (app_isEvented(this)) this.trigger("playerreset");
            }
            resetControlBarUI_() {
                this.resetProgressBar_();
                this.resetPlaybackRate_();
                this.resetVolumeBar_();
            }
            resetProgressBar_() {
                this.currentTime(0);
                const {currentTimeDisplay, durationDisplay, progressControl, remainingTimeDisplay} = this.controlBar || {};
                const {seekBar} = progressControl || {};
                if (currentTimeDisplay) currentTimeDisplay.updateContent();
                if (durationDisplay) durationDisplay.updateContent();
                if (remainingTimeDisplay) remainingTimeDisplay.updateContent();
                if (seekBar) {
                    seekBar.update();
                    if (seekBar.loadProgressBar) seekBar.loadProgressBar.update();
                }
            }
            resetPlaybackRate_() {
                this.playbackRate(this.defaultPlaybackRate());
                this.handleTechRateChange_();
            }
            resetVolumeBar_() {
                this.volume(1);
                this.trigger("volumechange");
            }
            currentSources() {
                const source = this.currentSource();
                const sources = [];
                if (Object.keys(source).length !== 0) sources.push(source);
                return this.cache_.sources || sources;
            }
            currentSource() {
                return this.cache_.source || {};
            }
            currentSrc() {
                return this.currentSource() && this.currentSource().src || "";
            }
            currentType() {
                return this.currentSource() && this.currentSource().type || "";
            }
            preload(value) {
                if (value !== void 0) {
                    this.techCall_("setPreload", value);
                    this.options_.preload = value;
                    return;
                }
                return this.techGet_("preload");
            }
            autoplay(value) {
                if (value === void 0) return this.options_.autoplay || false;
                let techAutoplay;
                if (typeof value === "string" && /(any|play|muted)/.test(value) || value === true && this.options_.normalizeAutoplay) {
                    this.options_.autoplay = value;
                    this.manualAutoplay_(typeof value === "string" ? value : "play");
                    techAutoplay = false;
                } else if (!value) this.options_.autoplay = false; else this.options_.autoplay = true;
                techAutoplay = typeof techAutoplay === "undefined" ? this.options_.autoplay : techAutoplay;
                if (this.tech_) this.techCall_("setAutoplay", techAutoplay);
            }
            playsinline(value) {
                if (value !== void 0) {
                    this.techCall_("setPlaysinline", value);
                    this.options_.playsinline = value;
                }
                return this.techGet_("playsinline");
            }
            loop(value) {
                if (value !== void 0) {
                    this.techCall_("setLoop", value);
                    this.options_.loop = value;
                    return;
                }
                return this.techGet_("loop");
            }
            poster(src) {
                if (src === void 0) return this.poster_;
                if (!src) src = "";
                if (src === this.poster_) return;
                this.poster_ = src;
                this.techCall_("setPoster", src);
                this.isPosterFromTech_ = false;
                this.trigger("posterchange");
            }
            handleTechPosterChange_() {
                if ((!this.poster_ || this.options_.techCanOverridePoster) && this.tech_ && this.tech_.poster) {
                    const newPoster = this.tech_.poster() || "";
                    if (newPoster !== this.poster_) {
                        this.poster_ = newPoster;
                        this.isPosterFromTech_ = true;
                        this.trigger("posterchange");
                    }
                }
            }
            controls(bool) {
                if (bool === void 0) return !!this.controls_;
                bool = !!bool;
                if (this.controls_ === bool) return;
                this.controls_ = bool;
                if (this.usingNativeControls()) this.techCall_("setControls", bool);
                if (this.controls_) {
                    this.removeClass("vjs-controls-disabled");
                    this.addClass("vjs-controls-enabled");
                    this.trigger("controlsenabled");
                    if (!this.usingNativeControls()) this.addTechControlsListeners_();
                } else {
                    this.removeClass("vjs-controls-enabled");
                    this.addClass("vjs-controls-disabled");
                    this.trigger("controlsdisabled");
                    if (!this.usingNativeControls()) this.removeTechControlsListeners_();
                }
            }
            usingNativeControls(bool) {
                if (bool === void 0) return !!this.usingNativeControls_;
                bool = !!bool;
                if (this.usingNativeControls_ === bool) return;
                this.usingNativeControls_ = bool;
                if (this.usingNativeControls_) {
                    this.addClass("vjs-using-native-controls");
                    this.trigger("usingnativecontrols");
                } else {
                    this.removeClass("vjs-using-native-controls");
                    this.trigger("usingcustomcontrols");
                }
            }
            error(err) {
                if (err === void 0) return this.error_ || null;
                app_hooks("beforeerror").forEach((hookFunction => {
                    const newErr = hookFunction(this, err);
                    if (!(app_video_es_isObject(newErr) && !Array.isArray(newErr) || typeof newErr === "string" || typeof newErr === "number" || newErr === null)) {
                        this.log.error("please return a value that MediaError expects in beforeerror hooks");
                        return;
                    }
                    err = newErr;
                }));
                if (this.options_.suppressNotSupportedError && err && err.code === 4) {
                    const triggerSuppressedError = function() {
                        this.error(err);
                    };
                    this.options_.suppressNotSupportedError = false;
                    this.any([ "click", "touchstart" ], triggerSuppressedError);
                    this.one("loadstart", (function() {
                        this.off([ "click", "touchstart" ], triggerSuppressedError);
                    }));
                    return;
                }
                if (err === null) {
                    this.error_ = null;
                    this.removeClass("vjs-error");
                    if (this.errorDisplay) this.errorDisplay.close();
                    return;
                }
                this.error_ = new app_MediaError(err);
                this.addClass("vjs-error");
                app_log$1.error(`(CODE:${this.error_.code} ${app_MediaError.errorTypes[this.error_.code]})`, this.error_.message, this.error_);
                this.trigger("error");
                app_hooks("error").forEach((hookFunction => hookFunction(this, this.error_)));
                return;
            }
            reportUserActivity(event) {
                this.userActivity_ = true;
            }
            userActive(bool) {
                if (bool === void 0) return this.userActive_;
                bool = !!bool;
                if (bool === this.userActive_) return;
                this.userActive_ = bool;
                if (this.userActive_) {
                    this.userActivity_ = true;
                    this.removeClass("vjs-user-inactive");
                    this.addClass("vjs-user-active");
                    this.trigger("useractive");
                    return;
                }
                if (this.tech_) this.tech_.one("mousemove", (function(e) {
                    e.stopPropagation();
                    e.preventDefault();
                }));
                this.userActivity_ = false;
                this.removeClass("vjs-user-active");
                this.addClass("vjs-user-inactive");
                this.trigger("userinactive");
            }
            listenForUserActivity_() {
                let mouseInProgress;
                let lastMoveX;
                let lastMoveY;
                const handleActivity = app_bind_(this, this.reportUserActivity);
                const handleMouseMove = function(e) {
                    if (e.screenX !== lastMoveX || e.screenY !== lastMoveY) {
                        lastMoveX = e.screenX;
                        lastMoveY = e.screenY;
                        handleActivity();
                    }
                };
                const handleMouseDown = function() {
                    handleActivity();
                    this.clearInterval(mouseInProgress);
                    mouseInProgress = this.setInterval(handleActivity, 250);
                };
                const handleMouseUpAndMouseLeave = function(event) {
                    handleActivity();
                    this.clearInterval(mouseInProgress);
                };
                this.on("mousedown", handleMouseDown);
                this.on("mousemove", handleMouseMove);
                this.on("mouseup", handleMouseUpAndMouseLeave);
                this.on("mouseleave", handleMouseUpAndMouseLeave);
                const controlBar = this.getChild("controlBar");
                if (controlBar && !app_IS_IOS && !app_IS_ANDROID) {
                    controlBar.on("mouseenter", (function(event) {
                        if (this.player().options_.inactivityTimeout !== 0) this.player().cache_.inactivityTimeout = this.player().options_.inactivityTimeout;
                        this.player().options_.inactivityTimeout = 0;
                    }));
                    controlBar.on("mouseleave", (function(event) {
                        this.player().options_.inactivityTimeout = this.player().cache_.inactivityTimeout;
                    }));
                }
                this.on("keydown", handleActivity);
                this.on("keyup", handleActivity);
                let inactivityTimeout;
                const activityCheck = function() {
                    if (!this.userActivity_) return;
                    this.userActivity_ = false;
                    this.userActive(true);
                    this.clearTimeout(inactivityTimeout);
                    const timeout = this.options_.inactivityTimeout;
                    if (timeout <= 0) return;
                    inactivityTimeout = this.setTimeout((function() {
                        if (!this.userActivity_) this.userActive(false);
                    }), timeout);
                };
                this.setInterval(activityCheck, 250);
            }
            playbackRate(rate) {
                if (rate !== void 0) {
                    this.techCall_("setPlaybackRate", rate);
                    return;
                }
                if (this.tech_ && this.tech_.featuresPlaybackRate) return this.cache_.lastPlaybackRate || this.techGet_("playbackRate");
                return 1;
            }
            defaultPlaybackRate(rate) {
                if (rate !== void 0) return this.techCall_("setDefaultPlaybackRate", rate);
                if (this.tech_ && this.tech_.featuresPlaybackRate) return this.techGet_("defaultPlaybackRate");
                return 1;
            }
            isAudio(bool) {
                if (bool !== void 0) {
                    this.isAudio_ = !!bool;
                    return;
                }
                return !!this.isAudio_;
            }
            updatePlayerHeightOnAudioOnlyMode_() {
                const controlBar = this.getChild("ControlBar");
                if (!controlBar || this.audioOnlyCache_.controlBarHeight === controlBar.currentHeight()) return;
                this.audioOnlyCache_.controlBarHeight = controlBar.currentHeight();
                this.height(this.audioOnlyCache_.controlBarHeight);
            }
            enableAudioOnlyUI_() {
                this.addClass("vjs-audio-only-mode");
                const playerChildren = this.children();
                const controlBar = this.getChild("ControlBar");
                const controlBarHeight = controlBar && controlBar.currentHeight();
                playerChildren.forEach((child => {
                    if (child === controlBar) return;
                    if (child.el_ && !child.hasClass("vjs-hidden")) {
                        child.hide();
                        this.audioOnlyCache_.hiddenChildren.push(child);
                    }
                }));
                this.audioOnlyCache_.playerHeight = this.currentHeight();
                this.audioOnlyCache_.controlBarHeight = controlBarHeight;
                this.on("playerresize", this.boundUpdatePlayerHeightOnAudioOnlyMode_);
                this.height(controlBarHeight);
                this.trigger("audioonlymodechange");
            }
            disableAudioOnlyUI_() {
                this.removeClass("vjs-audio-only-mode");
                this.off("playerresize", this.boundUpdatePlayerHeightOnAudioOnlyMode_);
                this.audioOnlyCache_.hiddenChildren.forEach((child => child.show()));
                this.height(this.audioOnlyCache_.playerHeight);
                this.trigger("audioonlymodechange");
            }
            audioOnlyMode(value) {
                if (typeof value !== "boolean" || value === this.audioOnlyMode_) return this.audioOnlyMode_;
                this.audioOnlyMode_ = value;
                if (value) {
                    const exitPromises = [];
                    if (this.isInPictureInPicture()) exitPromises.push(this.exitPictureInPicture());
                    if (this.isFullscreen()) exitPromises.push(this.exitFullscreen());
                    if (this.audioPosterMode()) exitPromises.push(this.audioPosterMode(false));
                    return Promise.all(exitPromises).then((() => this.enableAudioOnlyUI_()));
                }
                return Promise.resolve().then((() => this.disableAudioOnlyUI_()));
            }
            enablePosterModeUI_() {
                const tech = this.tech_ && this.tech_;
                tech.hide();
                this.addClass("vjs-audio-poster-mode");
                this.trigger("audiopostermodechange");
            }
            disablePosterModeUI_() {
                const tech = this.tech_ && this.tech_;
                tech.show();
                this.removeClass("vjs-audio-poster-mode");
                this.trigger("audiopostermodechange");
            }
            audioPosterMode(value) {
                if (typeof value !== "boolean" || value === this.audioPosterMode_) return this.audioPosterMode_;
                this.audioPosterMode_ = value;
                if (value) {
                    if (this.audioOnlyMode()) {
                        const audioOnlyModePromise = this.audioOnlyMode(false);
                        return audioOnlyModePromise.then((() => {
                            this.enablePosterModeUI_();
                        }));
                    }
                    return Promise.resolve().then((() => {
                        this.enablePosterModeUI_();
                    }));
                }
                return Promise.resolve().then((() => {
                    this.disablePosterModeUI_();
                }));
            }
            addTextTrack(kind, label, language) {
                if (this.tech_) return this.tech_.addTextTrack(kind, label, language);
            }
            addRemoteTextTrack(options, manualCleanup) {
                if (this.tech_) return this.tech_.addRemoteTextTrack(options, manualCleanup);
            }
            removeRemoteTextTrack(obj = {}) {
                let {track} = obj;
                if (!track) track = obj;
                if (this.tech_) return this.tech_.removeRemoteTextTrack(track);
            }
            getVideoPlaybackQuality() {
                return this.techGet_("getVideoPlaybackQuality");
            }
            videoWidth() {
                return this.tech_ && this.tech_.videoWidth && this.tech_.videoWidth() || 0;
            }
            videoHeight() {
                return this.tech_ && this.tech_.videoHeight && this.tech_.videoHeight() || 0;
            }
            language(code) {
                if (code === void 0) return this.language_;
                if (this.language_ !== String(code).toLowerCase()) {
                    this.language_ = String(code).toLowerCase();
                    if (app_isEvented(this)) this.trigger("languagechange");
                }
            }
            languages() {
                return app_merge$1(app_Player.prototype.options_.languages, this.languages_);
            }
            toJSON() {
                const options = app_merge$1(this.options_);
                const tracks = options.tracks;
                options.tracks = [];
                for (let i = 0; i < tracks.length; i++) {
                    let track = tracks[i];
                    track = app_merge$1(track);
                    track.player = void 0;
                    options.tracks[i] = track;
                }
                return options;
            }
            createModal(content, options) {
                options = options || {};
                options.content = content || "";
                const modal = new app_ModalDialog(this, options);
                this.addChild(modal);
                modal.on("dispose", (() => {
                    this.removeChild(modal);
                }));
                modal.open();
                return modal;
            }
            updateCurrentBreakpoint_() {
                if (!this.responsive()) return;
                const currentBreakpoint = this.currentBreakpoint();
                const currentWidth = this.currentWidth();
                for (let i = 0; i < app_BREAKPOINT_ORDER.length; i++) {
                    const candidateBreakpoint = app_BREAKPOINT_ORDER[i];
                    const maxWidth = this.breakpoints_[candidateBreakpoint];
                    if (currentWidth <= maxWidth) {
                        if (currentBreakpoint === candidateBreakpoint) return;
                        if (currentBreakpoint) this.removeClass(app_BREAKPOINT_CLASSES[currentBreakpoint]);
                        this.addClass(app_BREAKPOINT_CLASSES[candidateBreakpoint]);
                        this.breakpoint_ = candidateBreakpoint;
                        break;
                    }
                }
            }
            removeCurrentBreakpoint_() {
                const className = this.currentBreakpointClass();
                this.breakpoint_ = "";
                if (className) this.removeClass(className);
            }
            breakpoints(breakpoints) {
                if (breakpoints === void 0) return Object.assign(this.breakpoints_);
                this.breakpoint_ = "";
                this.breakpoints_ = Object.assign({}, app_DEFAULT_BREAKPOINTS, breakpoints);
                this.updateCurrentBreakpoint_();
                return Object.assign(this.breakpoints_);
            }
            responsive(value) {
                if (value === void 0) return this.responsive_;
                value = Boolean(value);
                const current = this.responsive_;
                if (value === current) return;
                this.responsive_ = value;
                if (value) {
                    this.on("playerresize", this.boundUpdateCurrentBreakpoint_);
                    this.updateCurrentBreakpoint_();
                } else {
                    this.off("playerresize", this.boundUpdateCurrentBreakpoint_);
                    this.removeCurrentBreakpoint_();
                }
                return value;
            }
            currentBreakpoint() {
                return this.breakpoint_;
            }
            currentBreakpointClass() {
                return app_BREAKPOINT_CLASSES[this.breakpoint_] || "";
            }
            loadMedia(media, ready) {
                if (!media || typeof media !== "object") return;
                const crossOrigin = this.crossOrigin();
                this.reset();
                this.cache_.media = app_merge$1(media);
                const {artist, artwork, description, poster, src, textTracks, title} = this.cache_.media;
                if (!artwork && poster) this.cache_.media.artwork = [ {
                    src: poster,
                    type: app_getMimetype(poster)
                } ];
                if (crossOrigin) this.crossOrigin(crossOrigin);
                if (src) this.src(src);
                if (poster) this.poster(poster);
                if (Array.isArray(textTracks)) textTracks.forEach((tt => this.addRemoteTextTrack(tt, false)));
                if (this.titleBar) this.titleBar.update({
                    title,
                    description: description || artist || ""
                });
                this.ready(ready);
            }
            getMedia() {
                if (!this.cache_.media) {
                    const poster = this.poster();
                    const src = this.currentSources();
                    const textTracks = Array.prototype.map.call(this.remoteTextTracks(), (tt => ({
                        kind: tt.kind,
                        label: tt.label,
                        language: tt.language,
                        src: tt.src
                    })));
                    const media = {
                        src,
                        textTracks
                    };
                    if (poster) {
                        media.poster = poster;
                        media.artwork = [ {
                            src: media.poster,
                            type: app_getMimetype(media.poster)
                        } ];
                    }
                    return media;
                }
                return app_merge$1(this.cache_.media);
            }
            static getTagSettings(tag) {
                const baseOptions = {
                    sources: [],
                    tracks: []
                };
                const tagOptions = app_getAttributes(tag);
                const dataSetup = tagOptions["data-setup"];
                if (app_hasClass(tag, "vjs-fill")) tagOptions.fill = true;
                if (app_hasClass(tag, "vjs-fluid")) tagOptions.fluid = true;
                if (dataSetup !== null) try {
                    Object.assign(tagOptions, JSON.parse(dataSetup || "{}"));
                } catch (e) {
                    app_log$1.error("data-setup", e);
                }
                Object.assign(baseOptions, tagOptions);
                if (tag.hasChildNodes()) {
                    const children = tag.childNodes;
                    for (let i = 0, j = children.length; i < j; i++) {
                        const child = children[i];
                        const childName = child.nodeName.toLowerCase();
                        if (childName === "source") baseOptions.sources.push(app_getAttributes(child)); else if (childName === "track") baseOptions.tracks.push(app_getAttributes(child));
                    }
                }
                return baseOptions;
            }
            debug(enabled) {
                if (enabled === void 0) return this.debugEnabled_;
                if (enabled) {
                    this.trigger("debugon");
                    this.previousLogLevel_ = this.log.level;
                    this.log.level("debug");
                    this.debugEnabled_ = true;
                } else {
                    this.trigger("debugoff");
                    this.log.level(this.previousLogLevel_);
                    this.previousLogLevel_ = void 0;
                    this.debugEnabled_ = false;
                }
            }
            playbackRates(newRates) {
                if (newRates === void 0) return this.cache_.playbackRates;
                if (!Array.isArray(newRates)) return;
                if (!newRates.every((rate => typeof rate === "number"))) return;
                this.cache_.playbackRates = newRates;
                this.trigger("playbackrateschange");
            }
        }
        app_ALL.names.forEach((function(name) {
            const props = app_ALL[name];
            app_Player.prototype[props.getterName] = function() {
                if (this.tech_) return this.tech_[props.getterName]();
                this[props.privateName] = this[props.privateName] || new props.ListClass;
                return this[props.privateName];
            };
        }));
        app_Player.prototype.crossorigin = app_Player.prototype.crossOrigin;
        app_Player.players = {};
        const app_video_es_navigator = app_window_default().navigator;
        app_Player.prototype.options_ = {
            techOrder: app_Tech.defaultTechOrder_,
            html5: {},
            enableSourceset: true,
            inactivityTimeout: 2e3,
            playbackRates: [],
            liveui: false,
            children: [ "mediaLoader", "posterImage", "titleBar", "textTrackDisplay", "loadingSpinner", "bigPlayButton", "liveTracker", "controlBar", "errorDisplay", "textTrackSettings", "resizeManager" ],
            language: app_video_es_navigator && (app_video_es_navigator.languages && app_video_es_navigator.languages[0] || app_video_es_navigator.userLanguage || app_video_es_navigator.language) || "en",
            languages: {},
            notSupportedMessage: "No compatible source was found for this media.",
            normalizeAutoplay: false,
            fullscreen: {
                options: {
                    navigationUI: "hide"
                }
            },
            breakpoints: {},
            responsive: false,
            audioOnlyMode: false,
            audioPosterMode: false,
            spatialNavigation: {
                enabled: false,
                horizontalSeek: false
            },
            enableSmoothSeeking: false,
            disableSeekWhileScrubbingOnMobile: false
        };
        app_TECH_EVENTS_RETRIGGER.forEach((function(event) {
            app_Player.prototype[`handleTech${app_toTitleCase$1(event)}_`] = function() {
                return this.trigger(event);
            };
        }));
        app_Component$1.registerComponent("Player", app_Player);
        const app_BASE_PLUGIN_NAME = "plugin";
        const app_PLUGIN_CACHE_KEY = "activePlugins_";
        const app_pluginStorage = {};
        const app_pluginExists = name => app_pluginStorage.hasOwnProperty(name);
        const app_getPlugin = name => app_pluginExists(name) ? app_pluginStorage[name] : void 0;
        const app_markPluginAsActive = (player, name) => {
            player[app_PLUGIN_CACHE_KEY] = player[app_PLUGIN_CACHE_KEY] || {};
            player[app_PLUGIN_CACHE_KEY][name] = true;
        };
        const app_triggerSetupEvent = (player, hash, before) => {
            const eventName = (before ? "before" : "") + "pluginsetup";
            player.trigger(eventName, hash);
            player.trigger(eventName + ":" + hash.name, hash);
        };
        const app_createBasicPlugin = function(name, plugin) {
            const basicPluginWrapper = function() {
                app_triggerSetupEvent(this, {
                    name,
                    plugin,
                    instance: null
                }, true);
                const instance = plugin.apply(this, arguments);
                app_markPluginAsActive(this, name);
                app_triggerSetupEvent(this, {
                    name,
                    plugin,
                    instance
                });
                return instance;
            };
            Object.keys(plugin).forEach((function(prop) {
                basicPluginWrapper[prop] = plugin[prop];
            }));
            return basicPluginWrapper;
        };
        const app_createPluginFactory = (name, PluginSubClass) => {
            PluginSubClass.prototype.name = name;
            return function(...args) {
                app_triggerSetupEvent(this, {
                    name,
                    plugin: PluginSubClass,
                    instance: null
                }, true);
                const instance = new PluginSubClass(...[ this, ...args ]);
                this[name] = () => instance;
                app_triggerSetupEvent(this, instance.getEventHash());
                return instance;
            };
        };
        class app_Plugin {
            constructor(player) {
                if (this.constructor === app_Plugin) throw new Error("Plugin must be sub-classed; not directly instantiated.");
                this.player = player;
                if (!this.log) this.log = this.player.log.createLogger(this.name);
                app_evented(this);
                delete this.trigger;
                app_stateful(this, this.constructor.defaultState);
                app_markPluginAsActive(player, this.name);
                this.dispose = this.dispose.bind(this);
                player.on("dispose", this.dispose);
            }
            version() {
                return this.constructor.VERSION;
            }
            getEventHash(hash = {}) {
                hash.name = this.name;
                hash.plugin = this.constructor;
                hash.instance = this;
                return hash;
            }
            trigger(event, hash = {}) {
                return app_trigger(this.eventBusEl_, event, this.getEventHash(hash));
            }
            handleStateChanged(e) {}
            dispose() {
                const {name, player} = this;
                this.trigger("dispose");
                this.off();
                player.off("dispose", this.dispose);
                player[app_PLUGIN_CACHE_KEY][name] = false;
                this.player = this.state = null;
                player[name] = app_createPluginFactory(name, app_pluginStorage[name]);
            }
            static isBasic(plugin) {
                const p = typeof plugin === "string" ? app_getPlugin(plugin) : plugin;
                return typeof p === "function" && !app_Plugin.prototype.isPrototypeOf(p.prototype);
            }
            static registerPlugin(name, plugin) {
                if (typeof name !== "string") throw new Error(`Illegal plugin name, "${name}", must be a string, was ${typeof name}.`);
                if (app_pluginExists(name)) app_log$1.warn(`A plugin named "${name}" already exists. You may want to avoid re-registering plugins!`); else if (app_Player.prototype.hasOwnProperty(name)) throw new Error(`Illegal plugin name, "${name}", cannot share a name with an existing player method!`);
                if (typeof plugin !== "function") throw new Error(`Illegal plugin for "${name}", must be a function, was ${typeof plugin}.`);
                app_pluginStorage[name] = plugin;
                if (name !== app_BASE_PLUGIN_NAME) if (app_Plugin.isBasic(plugin)) app_Player.prototype[name] = app_createBasicPlugin(name, plugin); else app_Player.prototype[name] = app_createPluginFactory(name, plugin);
                return plugin;
            }
            static deregisterPlugin(name) {
                if (name === app_BASE_PLUGIN_NAME) throw new Error("Cannot de-register base plugin.");
                if (app_pluginExists(name)) {
                    delete app_pluginStorage[name];
                    delete app_Player.prototype[name];
                }
            }
            static getPlugins(names = Object.keys(app_pluginStorage)) {
                let result;
                names.forEach((name => {
                    const plugin = app_getPlugin(name);
                    if (plugin) {
                        result = result || {};
                        result[name] = plugin;
                    }
                }));
                return result;
            }
            static getPluginVersion(name) {
                const plugin = app_getPlugin(name);
                return plugin && plugin.VERSION || "";
            }
        }
        app_Plugin.getPlugin = app_getPlugin;
        app_Plugin.BASE_PLUGIN_NAME = app_BASE_PLUGIN_NAME;
        app_Plugin.registerPlugin(app_BASE_PLUGIN_NAME, app_Plugin);
        app_Player.prototype.usingPlugin = function(name) {
            return !!this[app_PLUGIN_CACHE_KEY] && this[app_PLUGIN_CACHE_KEY][name] === true;
        };
        app_Player.prototype.hasPlugin = function(name) {
            return !!app_pluginExists(name);
        };
        function app_deprecate(message, fn) {
            let warned = false;
            return function(...args) {
                if (!warned) app_log$1.warn(message);
                warned = true;
                return fn.apply(this, args);
            };
        }
        function app_deprecateForMajor(major, oldName, newName, fn) {
            return app_deprecate(`${oldName} is deprecated and will be removed in ${major}.0; please use ${newName} instead.`, fn);
        }
        var app_VjsErrors = {
            NetworkBadStatus: "networkbadstatus",
            NetworkRequestFailed: "networkrequestfailed",
            NetworkRequestAborted: "networkrequestaborted",
            NetworkRequestTimeout: "networkrequesttimeout",
            NetworkBodyParserFailed: "networkbodyparserfailed",
            StreamingHlsPlaylistParserError: "streaminghlsplaylistparsererror",
            StreamingDashManifestParserError: "streamingdashmanifestparsererror",
            StreamingContentSteeringParserError: "streamingcontentsteeringparsererror",
            StreamingVttParserError: "streamingvttparsererror",
            StreamingFailedToSelectNextSegment: "streamingfailedtoselectnextsegment",
            StreamingFailedToDecryptSegment: "streamingfailedtodecryptsegment",
            StreamingFailedToTransmuxSegment: "streamingfailedtotransmuxsegment",
            StreamingFailedToAppendSegment: "streamingfailedtoappendsegment",
            StreamingCodecsChangeError: "streamingcodecschangeerror"
        };
        const app_normalizeId = id => id.indexOf("#") === 0 ? id.slice(1) : id;
        function app_videojs(id, options, ready) {
            let player = app_videojs.getPlayer(id);
            if (player) {
                if (options) app_log$1.warn(`Player "${id}" is already initialised. Options will not be applied.`);
                if (ready) player.ready(ready);
                return player;
            }
            const el = typeof id === "string" ? app_$("#" + app_normalizeId(id)) : id;
            if (!app_isEl(el)) throw new TypeError("The element or ID supplied is not valid. (videojs)");
            const inShadowDom = "getRootNode" in el ? el.getRootNode() instanceof app_window_default().ShadowRoot : false;
            const rootNode = inShadowDom ? el.getRootNode() : el.ownerDocument.body;
            if (!el.ownerDocument.defaultView || !rootNode.contains(el)) app_log$1.warn("The element supplied is not included in the DOM");
            options = options || {};
            if (options.restoreEl === true) options.restoreEl = (el.parentNode && el.parentNode.hasAttribute && el.parentNode.hasAttribute("data-vjs-player") ? el.parentNode : el).cloneNode(true);
            app_hooks("beforesetup").forEach((hookFunction => {
                const opts = hookFunction(el, app_merge$1(options));
                if (!app_video_es_isObject(opts) || Array.isArray(opts)) {
                    app_log$1.error("please return an object in beforesetup hooks");
                    return;
                }
                options = app_merge$1(options, opts);
            }));
            const PlayerComponent = app_Component$1.getComponent("Player");
            player = new PlayerComponent(el, options, ready);
            app_hooks("setup").forEach((hookFunction => hookFunction(player)));
            return player;
        }
        app_videojs.hooks_ = app_hooks_;
        app_videojs.hooks = app_hooks;
        app_videojs.hook = app_hook;
        app_videojs.hookOnce = app_hookOnce;
        app_videojs.removeHook = app_removeHook;
        if (app_window_default().VIDEOJS_NO_DYNAMIC_STYLE !== true && app_isReal()) {
            let style = app_$(".vjs-styles-defaults");
            if (!style) {
                style = app_createStyleElement("vjs-styles-defaults");
                const head = app_$("head");
                if (head) head.insertBefore(style, head.firstChild);
                app_setTextContent(style, `\n      .video-js {\n        width: 300px;\n        height: 150px;\n      }\n\n      .vjs-fluid:not(.vjs-audio-only-mode) {\n        padding-top: 56.25%\n      }\n    `);
            }
        }
        app_autoSetupTimeout(1, app_videojs);
        app_videojs.VERSION = app_version$6;
        app_videojs.options = app_Player.prototype.options_;
        app_videojs.getPlayers = () => app_Player.players;
        app_videojs.getPlayer = id => {
            const players = app_Player.players;
            let tag;
            if (typeof id === "string") {
                const nId = app_normalizeId(id);
                const player = players[nId];
                if (player) return player;
                tag = app_$("#" + nId);
            } else tag = id;
            if (app_isEl(tag)) {
                const {player, playerId} = tag;
                if (player || players[playerId]) return player || players[playerId];
            }
        };
        app_videojs.getAllPlayers = () => Object.keys(app_Player.players).map((k => app_Player.players[k])).filter(Boolean);
        app_videojs.players = app_Player.players;
        app_videojs.getComponent = app_Component$1.getComponent;
        app_videojs.registerComponent = (name, comp) => {
            if (app_Tech.isTech(comp)) app_log$1.warn(`The ${name} tech was registered as a component. It should instead be registered using videojs.registerTech(name, tech)`);
            return app_Component$1.registerComponent.call(app_Component$1, name, comp);
        };
        app_videojs.getTech = app_Tech.getTech;
        app_videojs.registerTech = app_Tech.registerTech;
        app_videojs.use = app_use;
        Object.defineProperty(app_videojs, "middleware", {
            value: {},
            writeable: false,
            enumerable: true
        });
        Object.defineProperty(app_videojs.middleware, "TERMINATOR", {
            value: app_TERMINATOR,
            writeable: false,
            enumerable: true
        });
        app_videojs.browser = app_video_es_browser;
        app_videojs.obj = app_Obj;
        app_videojs.mergeOptions = app_deprecateForMajor(9, "videojs.mergeOptions", "videojs.obj.merge", app_merge$1);
        app_videojs.defineLazyProperty = app_deprecateForMajor(9, "videojs.defineLazyProperty", "videojs.obj.defineLazyProperty", app_defineLazyProperty);
        app_videojs.bind = app_deprecateForMajor(9, "videojs.bind", "native Function.prototype.bind", app_bind_);
        app_videojs.registerPlugin = app_Plugin.registerPlugin;
        app_videojs.deregisterPlugin = app_Plugin.deregisterPlugin;
        app_videojs.plugin = (name, plugin) => {
            app_log$1.warn("videojs.plugin() is deprecated; use videojs.registerPlugin() instead");
            return app_Plugin.registerPlugin(name, plugin);
        };
        app_videojs.getPlugins = app_Plugin.getPlugins;
        app_videojs.getPlugin = app_Plugin.getPlugin;
        app_videojs.getPluginVersion = app_Plugin.getPluginVersion;
        app_videojs.addLanguage = function(code, data) {
            code = ("" + code).toLowerCase();
            app_videojs.options.languages = app_merge$1(app_videojs.options.languages, {
                [code]: data
            });
            return app_videojs.options.languages[code];
        };
        app_videojs.log = app_log$1;
        app_videojs.createLogger = app_createLogger;
        app_videojs.time = app_Time;
        app_videojs.createTimeRange = app_deprecateForMajor(9, "videojs.createTimeRange", "videojs.time.createTimeRanges", app_createTimeRanges$1);
        app_videojs.createTimeRanges = app_deprecateForMajor(9, "videojs.createTimeRanges", "videojs.time.createTimeRanges", app_createTimeRanges$1);
        app_videojs.formatTime = app_deprecateForMajor(9, "videojs.formatTime", "videojs.time.formatTime", app_formatTime);
        app_videojs.setFormatTime = app_deprecateForMajor(9, "videojs.setFormatTime", "videojs.time.setFormatTime", app_setFormatTime);
        app_videojs.resetFormatTime = app_deprecateForMajor(9, "videojs.resetFormatTime", "videojs.time.resetFormatTime", app_resetFormatTime);
        app_videojs.parseUrl = app_deprecateForMajor(9, "videojs.parseUrl", "videojs.url.parseUrl", app_parseUrl);
        app_videojs.isCrossOrigin = app_deprecateForMajor(9, "videojs.isCrossOrigin", "videojs.url.isCrossOrigin", app_isCrossOrigin);
        app_videojs.EventTarget = app_EventTarget$2;
        app_videojs.any = app_any;
        app_videojs.on = app_on;
        app_videojs.one = app_one;
        app_videojs.off = app_off;
        app_videojs.trigger = app_trigger;
        app_videojs.xhr = app_lib_default();
        app_videojs.TextTrack = app_TextTrack;
        app_videojs.AudioTrack = app_AudioTrack;
        app_videojs.VideoTrack = app_VideoTrack;
        [ "isEl", "isTextNode", "createEl", "hasClass", "addClass", "removeClass", "toggleClass", "setAttributes", "getAttributes", "emptyEl", "appendContent", "insertContent" ].forEach((k => {
            app_videojs[k] = function() {
                app_log$1.warn(`videojs.${k}() is deprecated; use videojs.dom.${k}() instead`);
                return app_Dom[k].apply(null, arguments);
            };
        }));
        app_videojs.computedStyle = app_deprecateForMajor(9, "videojs.computedStyle", "videojs.dom.computedStyle", app_computedStyle);
        app_videojs.dom = app_Dom;
        app_videojs.fn = app_Fn;
        app_videojs.num = app_Num;
        app_videojs.str = app_Str;
        app_videojs.url = app_Url;
        app_videojs.Error = app_VjsErrors;
        /*! @name videojs-contrib-quality-levels @version 4.1.0 @license Apache-2.0 */        class app_QualityLevel {
            constructor(representation) {
                let level = this;
                level.id = representation.id;
                level.label = level.id;
                level.width = representation.width;
                level.height = representation.height;
                level.bitrate = representation.bandwidth;
                level.frameRate = representation.frameRate;
                level.enabled_ = representation.enabled;
                Object.defineProperty(level, "enabled", {
                    get() {
                        return level.enabled_();
                    },
                    set(enable) {
                        level.enabled_(enable);
                    }
                });
                return level;
            }
        }
        class app_QualityLevelList extends app_videojs.EventTarget {
            constructor() {
                super();
                let list = this;
                list.levels_ = [];
                list.selectedIndex_ = -1;
                Object.defineProperty(list, "selectedIndex", {
                    get() {
                        return list.selectedIndex_;
                    }
                });
                Object.defineProperty(list, "length", {
                    get() {
                        return list.levels_.length;
                    }
                });
                list[Symbol.iterator] = () => list.levels_.values();
                return list;
            }
            addQualityLevel(representation) {
                let qualityLevel = this.getQualityLevelById(representation.id);
                if (qualityLevel) return qualityLevel;
                const index = this.levels_.length;
                qualityLevel = new app_QualityLevel(representation);
                if (!("" + index in this)) Object.defineProperty(this, index, {
                    get() {
                        return this.levels_[index];
                    }
                });
                this.levels_.push(qualityLevel);
                this.trigger({
                    qualityLevel,
                    type: "addqualitylevel"
                });
                return qualityLevel;
            }
            removeQualityLevel(qualityLevel) {
                let removed = null;
                for (let i = 0, l = this.length; i < l; i++) if (this[i] === qualityLevel) {
                    removed = this.levels_.splice(i, 1)[0];
                    if (this.selectedIndex_ === i) this.selectedIndex_ = -1; else if (this.selectedIndex_ > i) this.selectedIndex_--;
                    break;
                }
                if (removed) this.trigger({
                    qualityLevel,
                    type: "removequalitylevel"
                });
                return removed;
            }
            getQualityLevelById(id) {
                for (let i = 0, l = this.length; i < l; i++) {
                    const level = this[i];
                    if (level.id === id) return level;
                }
                return null;
            }
            dispose() {
                this.selectedIndex_ = -1;
                this.levels_.length = 0;
            }
        }
        app_QualityLevelList.prototype.allowedEvents_ = {
            change: "change",
            addqualitylevel: "addqualitylevel",
            removequalitylevel: "removequalitylevel"
        };
        for (const event in app_QualityLevelList.prototype.allowedEvents_) app_QualityLevelList.prototype["on" + event] = null;
        var app_version$5 = "4.1.0";
        const app_initPlugin$1 = function(player, options) {
            const originalPluginFn = player.qualityLevels;
            const qualityLevelList = new app_QualityLevelList;
            const disposeHandler = function() {
                qualityLevelList.dispose();
                player.qualityLevels = originalPluginFn;
                player.off("dispose", disposeHandler);
            };
            player.on("dispose", disposeHandler);
            player.qualityLevels = () => qualityLevelList;
            player.qualityLevels.VERSION = app_version$5;
            return qualityLevelList;
        };
        const app_qualityLevels = function(options) {
            return app_initPlugin$1(this, app_videojs.obj.merge({}, options));
        };
        app_videojs.registerPlugin("qualityLevels", app_qualityLevels);
        app_qualityLevels.VERSION = app_version$5;
        /*! @name @videojs/http-streaming @version 3.16.2 @license Apache-2.0 */        const app_video_es_resolveUrl = app_resolve_url;
        const app_resolveManifestRedirect = (url, req) => {
            if (req && req.responseURL && url !== req.responseURL) return req.responseURL;
            return url;
        };
        const app_logger = source => {
            if (app_videojs.log.debug) return app_videojs.log.debug.bind(app_videojs, "VHS:", `${source} >`);
            return function() {};
        };
        function app_video_es_merge(...args) {
            const context = app_videojs.obj || app_videojs;
            const fn = context.merge || context.mergeOptions;
            return fn.apply(context, args);
        }
        function app_createTimeRanges(...args) {
            const context = app_videojs.time || app_videojs;
            const fn = context.createTimeRanges || context.createTimeRanges;
            return fn.apply(context, args);
        }
        function app_bufferedRangesToString(buffered) {
            if (buffered.length === 0) return "Buffered Ranges are empty";
            let bufferedRangesStr = "Buffered Ranges: \n";
            for (let i = 0; i < buffered.length; i++) {
                const start = buffered.start(i);
                const end = buffered.end(i);
                bufferedRangesStr += `${start} --\x3e ${end}. Duration (${end - start})\n`;
            }
            return bufferedRangesStr;
        }
        const app_TIME_FUDGE_FACTOR = 1 / 30;
        const app_SAFE_TIME_DELTA = app_TIME_FUDGE_FACTOR * 3;
        const app_filterRanges = function(timeRanges, predicate) {
            const results = [];
            let i;
            if (timeRanges && timeRanges.length) for (i = 0; i < timeRanges.length; i++) if (predicate(timeRanges.start(i), timeRanges.end(i))) results.push([ timeRanges.start(i), timeRanges.end(i) ]);
            return app_createTimeRanges(results);
        };
        const app_findRange = function(buffered, time) {
            return app_filterRanges(buffered, (function(start, end) {
                return start - app_SAFE_TIME_DELTA <= time && end + app_SAFE_TIME_DELTA >= time;
            }));
        };
        const app_findNextRange = function(timeRanges, time) {
            return app_filterRanges(timeRanges, (function(start) {
                return start - app_TIME_FUDGE_FACTOR >= time;
            }));
        };
        const app_findGaps = function(buffered) {
            if (buffered.length < 2) return app_createTimeRanges();
            const ranges = [];
            for (let i = 1; i < buffered.length; i++) {
                const start = buffered.end(i - 1);
                const end = buffered.start(i);
                ranges.push([ start, end ]);
            }
            return app_createTimeRanges(ranges);
        };
        const app_bufferIntersection = function(bufferA, bufferB) {
            let start = null;
            let end = null;
            let arity = 0;
            const extents = [];
            const ranges = [];
            if (!bufferA || !bufferA.length || !bufferB || !bufferB.length) return app_createTimeRanges();
            let count = bufferA.length;
            while (count--) {
                extents.push({
                    time: bufferA.start(count),
                    type: "start"
                });
                extents.push({
                    time: bufferA.end(count),
                    type: "end"
                });
            }
            count = bufferB.length;
            while (count--) {
                extents.push({
                    time: bufferB.start(count),
                    type: "start"
                });
                extents.push({
                    time: bufferB.end(count),
                    type: "end"
                });
            }
            extents.sort((function(a, b) {
                return a.time - b.time;
            }));
            for (count = 0; count < extents.length; count++) {
                if (extents[count].type === "start") {
                    arity++;
                    if (arity === 2) start = extents[count].time;
                } else if (extents[count].type === "end") {
                    arity--;
                    if (arity === 1) end = extents[count].time;
                }
                if (start !== null && end !== null) {
                    ranges.push([ start, end ]);
                    start = null;
                    end = null;
                }
            }
            return app_createTimeRanges(ranges);
        };
        const app_printableRange = range => {
            const strArr = [];
            if (!range || !range.length) return "";
            for (let i = 0; i < range.length; i++) strArr.push(range.start(i) + " => " + range.end(i));
            return strArr.join(", ");
        };
        const app_timeUntilRebuffer = function(buffered, currentTime, playbackRate = 1) {
            const bufferedEnd = buffered.length ? buffered.end(buffered.length - 1) : 0;
            return (bufferedEnd - currentTime) / playbackRate;
        };
        const app_timeRangesToArray = timeRanges => {
            const timeRangesList = [];
            for (let i = 0; i < timeRanges.length; i++) timeRangesList.push({
                start: timeRanges.start(i),
                end: timeRanges.end(i)
            });
            return timeRangesList;
        };
        const app_isRangeDifferent = function(a, b) {
            if (a === b) return false;
            if (!a && b || !b && a) return true;
            if (a.length !== b.length) return true;
            for (let i = 0; i < a.length; i++) if (a.start(i) !== b.start(i) || a.end(i) !== b.end(i)) return true;
            return false;
        };
        const app_lastBufferedEnd = function(a) {
            if (!a || !a.length || !a.end) return;
            return a.end(a.length - 1);
        };
        const app_timeAheadOf = function(range, startTime) {
            let time = 0;
            if (!range || !range.length) return time;
            for (let i = 0; i < range.length; i++) {
                const start = range.start(i);
                const end = range.end(i);
                if (startTime > end) continue;
                if (startTime > start && startTime <= end) {
                    time += end - startTime;
                    continue;
                }
                time += end - start;
            }
            return time;
        };
        const app_segmentDurationWithParts = (playlist, segment) => {
            if (!segment.preload) return segment.duration;
            let result = 0;
            (segment.parts || []).forEach((function(p) {
                result += p.duration;
            }));
            (segment.preloadHints || []).forEach((function(p) {
                if (p.type === "PART") result += playlist.partTargetDuration;
            }));
            return result;
        };
        const app_getPartsAndSegments = playlist => (playlist.segments || []).reduce(((acc, segment, si) => {
            if (segment.parts) segment.parts.forEach((function(part, pi) {
                acc.push({
                    duration: part.duration,
                    segmentIndex: si,
                    partIndex: pi,
                    part,
                    segment
                });
            })); else acc.push({
                duration: segment.duration,
                segmentIndex: si,
                partIndex: null,
                segment,
                part: null
            });
            return acc;
        }), []);
        const app_getLastParts = media => {
            const lastSegment = media.segments && media.segments.length && media.segments[media.segments.length - 1];
            return lastSegment && lastSegment.parts || [];
        };
        const app_getKnownPartCount = ({preloadSegment}) => {
            if (!preloadSegment) return;
            const {parts, preloadHints} = preloadSegment;
            let partCount = (preloadHints || []).reduce(((count, hint) => count + (hint.type === "PART" ? 1 : 0)), 0);
            partCount += parts && parts.length ? parts.length : 0;
            return partCount;
        };
        const app_liveEdgeDelay = (main, media) => {
            if (media.endList) return 0;
            if (main && main.suggestedPresentationDelay) return main.suggestedPresentationDelay;
            const hasParts = app_getLastParts(media).length > 0;
            if (hasParts && media.serverControl && media.serverControl.partHoldBack) return media.serverControl.partHoldBack; else if (hasParts && media.partTargetDuration) return media.partTargetDuration * 3; else if (media.serverControl && media.serverControl.holdBack) return media.serverControl.holdBack; else if (media.targetDuration) return media.targetDuration * 3;
            return 0;
        };
        const app_backwardDuration = function(playlist, endSequence) {
            let result = 0;
            let i = endSequence - playlist.mediaSequence;
            let segment = playlist.segments[i];
            if (segment) {
                if (typeof segment.start !== "undefined") return {
                    result: segment.start,
                    precise: true
                };
                if (typeof segment.end !== "undefined") return {
                    result: segment.end - segment.duration,
                    precise: true
                };
            }
            while (i--) {
                segment = playlist.segments[i];
                if (typeof segment.end !== "undefined") return {
                    result: result + segment.end,
                    precise: true
                };
                result += app_segmentDurationWithParts(playlist, segment);
                if (typeof segment.start !== "undefined") return {
                    result: result + segment.start,
                    precise: true
                };
            }
            return {
                result,
                precise: false
            };
        };
        const app_forwardDuration = function(playlist, endSequence) {
            let result = 0;
            let segment;
            let i = endSequence - playlist.mediaSequence;
            for (;i < playlist.segments.length; i++) {
                segment = playlist.segments[i];
                if (typeof segment.start !== "undefined") return {
                    result: segment.start - result,
                    precise: true
                };
                result += app_segmentDurationWithParts(playlist, segment);
                if (typeof segment.end !== "undefined") return {
                    result: segment.end - result,
                    precise: true
                };
            }
            return {
                result: -1,
                precise: false
            };
        };
        const app_intervalDuration = function(playlist, endSequence, expired) {
            if (typeof endSequence === "undefined") endSequence = playlist.mediaSequence + playlist.segments.length;
            if (endSequence < playlist.mediaSequence) return 0;
            const backward = app_backwardDuration(playlist, endSequence);
            if (backward.precise) return backward.result;
            const forward = app_forwardDuration(playlist, endSequence);
            if (forward.precise) return forward.result;
            return backward.result + expired;
        };
        const app_duration = function(playlist, endSequence, expired) {
            if (!playlist) return 0;
            if (typeof expired !== "number") expired = 0;
            if (typeof endSequence === "undefined") {
                if (playlist.totalDuration) return playlist.totalDuration;
                if (!playlist.endList) return app_window_default()[1 / 0];
            }
            return app_intervalDuration(playlist, endSequence, expired);
        };
        const app_sumDurations = function({defaultDuration, durationList, startIndex, endIndex}) {
            let durations = 0;
            if (startIndex > endIndex) [startIndex, endIndex] = [ endIndex, startIndex ];
            if (startIndex < 0) {
                for (let i = startIndex; i < Math.min(0, endIndex); i++) durations += defaultDuration;
                startIndex = 0;
            }
            for (let i = startIndex; i < endIndex; i++) durations += durationList[i].duration;
            return durations;
        };
        const app_playlistEnd = function(playlist, expired, useSafeLiveEnd, liveEdgePadding) {
            if (!playlist || !playlist.segments) return null;
            if (playlist.endList) return app_duration(playlist);
            if (expired === null) return null;
            expired = expired || 0;
            let lastSegmentEndTime = app_intervalDuration(playlist, playlist.mediaSequence + playlist.segments.length, expired);
            if (useSafeLiveEnd) {
                liveEdgePadding = typeof liveEdgePadding === "number" ? liveEdgePadding : app_liveEdgeDelay(null, playlist);
                lastSegmentEndTime -= liveEdgePadding;
            }
            return Math.max(0, lastSegmentEndTime);
        };
        const app_seekable = function(playlist, expired, liveEdgePadding) {
            const useSafeLiveEnd = true;
            const seekableStart = expired || 0;
            let seekableEnd = app_playlistEnd(playlist, expired, useSafeLiveEnd, liveEdgePadding);
            if (seekableEnd === null) return app_createTimeRanges();
            if (seekableEnd < seekableStart) seekableEnd = seekableStart;
            return app_createTimeRanges(seekableStart, seekableEnd);
        };
        const app_getMediaInfoForTime = function({playlist, currentTime, startingSegmentIndex, startingPartIndex, startTime, exactManifestTimings}) {
            let time = currentTime - startTime;
            const partsAndSegments = app_getPartsAndSegments(playlist);
            let startIndex = 0;
            for (let i = 0; i < partsAndSegments.length; i++) {
                const partAndSegment = partsAndSegments[i];
                if (startingSegmentIndex !== partAndSegment.segmentIndex) continue;
                if (typeof startingPartIndex === "number" && typeof partAndSegment.partIndex === "number" && startingPartIndex !== partAndSegment.partIndex) continue;
                startIndex = i;
                break;
            }
            if (time < 0) {
                if (startIndex > 0) for (let i = startIndex - 1; i >= 0; i--) {
                    const partAndSegment = partsAndSegments[i];
                    time += partAndSegment.duration;
                    if (exactManifestTimings) {
                        if (time < 0) continue;
                    } else if (time + app_TIME_FUDGE_FACTOR <= 0) continue;
                    return {
                        partIndex: partAndSegment.partIndex,
                        segmentIndex: partAndSegment.segmentIndex,
                        startTime: startTime - app_sumDurations({
                            defaultDuration: playlist.targetDuration,
                            durationList: partsAndSegments,
                            startIndex,
                            endIndex: i
                        })
                    };
                }
                return {
                    partIndex: partsAndSegments[0] && partsAndSegments[0].partIndex || null,
                    segmentIndex: partsAndSegments[0] && partsAndSegments[0].segmentIndex || 0,
                    startTime: currentTime
                };
            }
            if (startIndex < 0) {
                for (let i = startIndex; i < 0; i++) {
                    time -= playlist.targetDuration;
                    if (time < 0) return {
                        partIndex: partsAndSegments[0] && partsAndSegments[0].partIndex || null,
                        segmentIndex: partsAndSegments[0] && partsAndSegments[0].segmentIndex || 0,
                        startTime: currentTime
                    };
                }
                startIndex = 0;
            }
            for (let i = startIndex; i < partsAndSegments.length; i++) {
                const partAndSegment = partsAndSegments[i];
                time -= partAndSegment.duration;
                const canUseFudgeFactor = partAndSegment.duration > app_TIME_FUDGE_FACTOR;
                const isExactlyAtTheEnd = time === 0;
                const isExtremelyCloseToTheEnd = canUseFudgeFactor && time + app_TIME_FUDGE_FACTOR >= 0;
                if (isExactlyAtTheEnd || isExtremelyCloseToTheEnd) if (i !== partsAndSegments.length - 1) continue;
                if (exactManifestTimings) {
                    if (time > 0) continue;
                } else if (time - app_TIME_FUDGE_FACTOR >= 0) continue;
                return {
                    partIndex: partAndSegment.partIndex,
                    segmentIndex: partAndSegment.segmentIndex,
                    startTime: startTime + app_sumDurations({
                        defaultDuration: playlist.targetDuration,
                        durationList: partsAndSegments,
                        startIndex,
                        endIndex: i
                    })
                };
            }
            return {
                segmentIndex: partsAndSegments[partsAndSegments.length - 1].segmentIndex,
                partIndex: partsAndSegments[partsAndSegments.length - 1].partIndex,
                startTime: currentTime
            };
        };
        const app_isExcluded = function(playlist) {
            return playlist.excludeUntil && playlist.excludeUntil > Date.now();
        };
        const app_isIncompatible = function(playlist) {
            return playlist.excludeUntil && playlist.excludeUntil === 1 / 0;
        };
        const app_isEnabled = function(playlist) {
            const excluded = app_isExcluded(playlist);
            return !playlist.disabled && !excluded;
        };
        const app_isDisabled = function(playlist) {
            return playlist.disabled;
        };
        const app_isAes = function(media) {
            for (let i = 0; i < media.segments.length; i++) if (media.segments[i].key) return true;
            return false;
        };
        const app_hasAttribute = function(attr, playlist) {
            return playlist.attributes && playlist.attributes[attr];
        };
        const app_estimateSegmentRequestTime = function(segmentDuration, bandwidth, playlist, bytesReceived = 0) {
            if (!app_hasAttribute("BANDWIDTH", playlist)) return NaN;
            const size = segmentDuration * playlist.attributes.BANDWIDTH;
            return (size - bytesReceived * 8) / bandwidth;
        };
        const app_isLowestEnabledRendition = (main, media) => {
            if (main.playlists.length === 1) return true;
            const currentBandwidth = media.attributes.BANDWIDTH || Number.MAX_VALUE;
            return main.playlists.filter((playlist => {
                if (!app_isEnabled(playlist)) return false;
                return (playlist.attributes.BANDWIDTH || 0) < currentBandwidth;
            })).length === 0;
        };
        const app_playlistMatch = (a, b) => {
            if (!a && !b || !a && b || a && !b) return false;
            if (a === b) return true;
            if (a.id && b.id && a.id === b.id) return true;
            if (a.resolvedUri && b.resolvedUri && a.resolvedUri === b.resolvedUri) return true;
            if (a.uri && b.uri && a.uri === b.uri) return true;
            return false;
        };
        const app_someAudioVariant = function(main, callback) {
            const AUDIO = main && main.mediaGroups && main.mediaGroups.AUDIO || {};
            let found = false;
            for (const groupName in AUDIO) {
                for (const label in AUDIO[groupName]) {
                    found = callback(AUDIO[groupName][label]);
                    if (found) break;
                }
                if (found) break;
            }
            return !!found;
        };
        const app_isAudioOnly = main => {
            if (!main || !main.playlists || !main.playlists.length) {
                const found = app_someAudioVariant(main, (variant => variant.playlists && variant.playlists.length || variant.uri));
                return found;
            }
            for (let i = 0; i < main.playlists.length; i++) {
                const playlist = main.playlists[i];
                const CODECS = playlist.attributes && playlist.attributes.CODECS;
                if (CODECS && CODECS.split(",").every((c => app_isAudioCodec(c)))) continue;
                const found = app_someAudioVariant(main, (variant => app_playlistMatch(playlist, variant)));
                if (found) continue;
                return false;
            }
            return true;
        };
        var app_Playlist = {
            liveEdgeDelay: app_liveEdgeDelay,
            duration: app_duration,
            seekable: app_seekable,
            getMediaInfoForTime: app_getMediaInfoForTime,
            isEnabled: app_isEnabled,
            isDisabled: app_isDisabled,
            isExcluded: app_isExcluded,
            isIncompatible: app_isIncompatible,
            playlistEnd: app_playlistEnd,
            isAes: app_isAes,
            hasAttribute: app_hasAttribute,
            estimateSegmentRequestTime: app_estimateSegmentRequestTime,
            isLowestEnabledRendition: app_isLowestEnabledRendition,
            isAudioOnly: app_isAudioOnly,
            playlistMatch: app_playlistMatch,
            segmentDurationWithParts: app_segmentDurationWithParts
        };
        const {log: app_log} = app_videojs;
        const app_createPlaylistID = (index, uri) => `${index}-${uri}`;
        const app_groupID = (type, group, label) => `placeholder-uri-${type}-${group}-${label}`;
        const app_parseManifest = ({onwarn, oninfo, manifestString, customTagParsers = [], customTagMappers = [], llhls}) => {
            const parser = new app_Parser;
            if (onwarn) parser.on("warn", onwarn);
            if (oninfo) parser.on("info", oninfo);
            customTagParsers.forEach((customParser => parser.addParser(customParser)));
            customTagMappers.forEach((mapper => parser.addTagMapper(mapper)));
            parser.push(manifestString);
            parser.end();
            const manifest = parser.manifest;
            if (!llhls) {
                [ "preloadSegment", "skip", "serverControl", "renditionReports", "partInf", "partTargetDuration" ].forEach((function(k) {
                    if (manifest.hasOwnProperty(k)) delete manifest[k];
                }));
                if (manifest.segments) manifest.segments.forEach((function(segment) {
                    [ "parts", "preloadHints" ].forEach((function(k) {
                        if (segment.hasOwnProperty(k)) delete segment[k];
                    }));
                }));
            }
            if (!manifest.targetDuration) {
                let targetDuration = 10;
                if (manifest.segments && manifest.segments.length) targetDuration = manifest.segments.reduce(((acc, s) => Math.max(acc, s.duration)), 0);
                if (onwarn) onwarn({
                    message: `manifest has no targetDuration defaulting to ${targetDuration}`
                });
                manifest.targetDuration = targetDuration;
            }
            const parts = app_getLastParts(manifest);
            if (parts.length && !manifest.partTargetDuration) {
                const partTargetDuration = parts.reduce(((acc, p) => Math.max(acc, p.duration)), 0);
                if (onwarn) {
                    onwarn({
                        message: `manifest has no partTargetDuration defaulting to ${partTargetDuration}`
                    });
                    app_log.error("LL-HLS manifest has parts but lacks required #EXT-X-PART-INF:PART-TARGET value. See https://datatracker.ietf.org/doc/html/draft-pantos-hls-rfc8216bis-09#section-4.4.3.7. Playback is not guaranteed.");
                }
                manifest.partTargetDuration = partTargetDuration;
            }
            return manifest;
        };
        const app_video_es_forEachMediaGroup = (main, callback) => {
            if (!main.mediaGroups) return;
            [ "AUDIO", "SUBTITLES" ].forEach((mediaType => {
                if (!main.mediaGroups[mediaType]) return;
                for (const groupKey in main.mediaGroups[mediaType]) for (const labelKey in main.mediaGroups[mediaType][groupKey]) {
                    const mediaProperties = main.mediaGroups[mediaType][groupKey][labelKey];
                    callback(mediaProperties, mediaType, groupKey, labelKey);
                }
            }));
        };
        const app_setupMediaPlaylist = ({playlist, uri, id}) => {
            playlist.id = id;
            playlist.playlistErrors_ = 0;
            if (uri) playlist.uri = uri;
            playlist.attributes = playlist.attributes || {};
        };
        const app_setupMediaPlaylists = main => {
            let i = main.playlists.length;
            while (i--) {
                const playlist = main.playlists[i];
                app_setupMediaPlaylist({
                    playlist,
                    id: app_createPlaylistID(i, playlist.uri)
                });
                playlist.resolvedUri = app_video_es_resolveUrl(main.uri, playlist.uri);
                main.playlists[playlist.id] = playlist;
                main.playlists[playlist.uri] = playlist;
                if (!playlist.attributes.BANDWIDTH) app_log.warn("Invalid playlist STREAM-INF detected. Missing BANDWIDTH attribute.");
            }
        };
        const app_resolveMediaGroupUris = main => {
            app_video_es_forEachMediaGroup(main, (properties => {
                if (properties.uri) properties.resolvedUri = app_video_es_resolveUrl(main.uri, properties.uri);
            }));
        };
        const app_mainForMedia = (media, uri) => {
            const id = app_createPlaylistID(0, uri);
            const main = {
                mediaGroups: {
                    AUDIO: {},
                    VIDEO: {},
                    "CLOSED-CAPTIONS": {},
                    SUBTITLES: {}
                },
                uri: app_window_default().location.href,
                resolvedUri: app_window_default().location.href,
                playlists: [ {
                    uri,
                    id,
                    resolvedUri: uri,
                    attributes: {}
                } ]
            };
            main.playlists[id] = main.playlists[0];
            main.playlists[uri] = main.playlists[0];
            return main;
        };
        const app_addPropertiesToMain = (main, uri, createGroupID = app_groupID) => {
            main.uri = uri;
            for (let i = 0; i < main.playlists.length; i++) if (!main.playlists[i].uri) {
                const phonyUri = `placeholder-uri-${i}`;
                main.playlists[i].uri = phonyUri;
            }
            const audioOnlyMain = app_isAudioOnly(main);
            app_video_es_forEachMediaGroup(main, ((properties, mediaType, groupKey, labelKey) => {
                if (!properties.playlists || !properties.playlists.length) {
                    if (audioOnlyMain && mediaType === "AUDIO" && !properties.uri) for (let i = 0; i < main.playlists.length; i++) {
                        const p = main.playlists[i];
                        if (p.attributes && p.attributes.AUDIO && p.attributes.AUDIO === groupKey) return;
                    }
                    properties.playlists = [ app_extends({}, properties) ];
                }
                properties.playlists.forEach((function(p, i) {
                    const groupId = createGroupID(mediaType, groupKey, labelKey, p);
                    const id = app_createPlaylistID(i, groupId);
                    if (p.uri) p.resolvedUri = p.resolvedUri || app_video_es_resolveUrl(main.uri, p.uri); else {
                        p.uri = i === 0 ? groupId : id;
                        p.resolvedUri = p.uri;
                    }
                    p.id = p.id || id;
                    p.attributes = p.attributes || {};
                    main.playlists[p.id] = p;
                    main.playlists[p.uri] = p;
                }));
            }));
            app_setupMediaPlaylists(main);
            app_resolveMediaGroupUris(main);
        };
        class app_DateRangesStorage {
            constructor() {
                this.offset_ = null;
                this.pendingDateRanges_ = new Map;
                this.processedDateRanges_ = new Map;
            }
            setOffset(segments = []) {
                if (this.offset_ !== null) return;
                if (!segments.length) return;
                const [firstSegment] = segments;
                if (firstSegment.programDateTime === void 0) return;
                this.offset_ = firstSegment.programDateTime / 1e3;
            }
            setPendingDateRanges(dateRanges = []) {
                if (!dateRanges.length) return;
                const [dateRange] = dateRanges;
                const startTime = dateRange.startDate.getTime();
                this.trimProcessedDateRanges_(startTime);
                this.pendingDateRanges_ = dateRanges.reduce(((map, pendingDateRange) => {
                    map.set(pendingDateRange.id, pendingDateRange);
                    return map;
                }), new Map);
            }
            processDateRange(dateRange) {
                this.pendingDateRanges_.delete(dateRange.id);
                this.processedDateRanges_.set(dateRange.id, dateRange);
            }
            getDateRangesToProcess() {
                if (this.offset_ === null) return [];
                const dateRangeClasses = {};
                const dateRangesToProcess = [];
                this.pendingDateRanges_.forEach(((dateRange, id) => {
                    if (this.processedDateRanges_.has(id)) return;
                    dateRange.startTime = dateRange.startDate.getTime() / 1e3 - this.offset_;
                    dateRange.processDateRange = () => this.processDateRange(dateRange);
                    dateRangesToProcess.push(dateRange);
                    if (!dateRange.class) return;
                    if (dateRangeClasses[dateRange.class]) {
                        const length = dateRangeClasses[dateRange.class].push(dateRange);
                        dateRange.classListIndex = length - 1;
                    } else {
                        dateRangeClasses[dateRange.class] = [ dateRange ];
                        dateRange.classListIndex = 0;
                    }
                }));
                for (const dateRange of dateRangesToProcess) {
                    const classList = dateRangeClasses[dateRange.class] || [];
                    if (dateRange.endDate) dateRange.endTime = dateRange.endDate.getTime() / 1e3 - this.offset_; else if (dateRange.endOnNext && classList[dateRange.classListIndex + 1]) dateRange.endTime = classList[dateRange.classListIndex + 1].startTime; else if (dateRange.duration) dateRange.endTime = dateRange.startTime + dateRange.duration; else if (dateRange.plannedDuration) dateRange.endTime = dateRange.startTime + dateRange.plannedDuration; else dateRange.endTime = dateRange.startTime;
                }
                return dateRangesToProcess;
            }
            trimProcessedDateRanges_(startTime) {
                const copy = new Map(this.processedDateRanges_);
                copy.forEach(((dateRange, id) => {
                    if (dateRange.startDate.getTime() < startTime) this.processedDateRanges_.delete(id);
                }));
            }
        }
        const app_QUOTA_EXCEEDED_ERR = 22;
        const app_getStreamingNetworkErrorMetadata = ({requestType, request, error, parseFailure}) => {
            const isBadStatus = request.status < 200 || request.status > 299;
            const isFailure = request.status >= 400 && request.status <= 499;
            const errorMetadata = {
                uri: request.uri,
                requestType
            };
            const isBadStatusOrParseFailure = isBadStatus && !isFailure || parseFailure;
            if (error && isFailure) {
                errorMetadata.error = app_extends({}, error);
                errorMetadata.errorType = app_videojs.Error.NetworkRequestFailed;
            } else if (request.aborted) errorMetadata.errorType = app_videojs.Error.NetworkRequestAborted; else if (request.timedout) errorMetadata.erroType = app_videojs.Error.NetworkRequestTimeout; else if (isBadStatusOrParseFailure) {
                const errorType = parseFailure ? app_videojs.Error.NetworkBodyParserFailed : app_videojs.Error.NetworkBadStatus;
                errorMetadata.errorType = errorType;
                errorMetadata.status = request.status;
                errorMetadata.headers = request.headers;
            }
            return errorMetadata;
        };
        const {EventTarget: app_EventTarget$1} = app_videojs;
        const app_addLLHLSQueryDirectives = (uri, media) => {
            if (media.endList || !media.serverControl) return uri;
            const parameters = {};
            if (media.serverControl.canBlockReload) {
                const {preloadSegment} = media;
                let nextMSN = media.mediaSequence + media.segments.length;
                if (preloadSegment) {
                    const parts = preloadSegment.parts || [];
                    const nextPart = app_getKnownPartCount(media) - 1;
                    if (nextPart > -1 && nextPart !== parts.length - 1) parameters._HLS_part = nextPart;
                    if (nextPart > -1 || parts.length) nextMSN--;
                }
                parameters._HLS_msn = nextMSN;
            }
            if (media.serverControl && media.serverControl.canSkipUntil) parameters._HLS_skip = media.serverControl.canSkipDateranges ? "v2" : "YES";
            if (Object.keys(parameters).length) {
                const parsedUri = new (app_window_default().URL)(uri);
                [ "_HLS_skip", "_HLS_msn", "_HLS_part" ].forEach((function(name) {
                    if (!parameters.hasOwnProperty(name)) return;
                    parsedUri.searchParams.set(name, parameters[name]);
                }));
                uri = parsedUri.toString();
            }
            return uri;
        };
        const app_updateSegment = (a, b) => {
            if (!a) return b;
            const result = app_video_es_merge(a, b);
            if (a.preloadHints && !b.preloadHints) delete result.preloadHints;
            if (a.parts && !b.parts) delete result.parts; else if (a.parts && b.parts) for (let i = 0; i < b.parts.length; i++) if (a.parts && a.parts[i]) result.parts[i] = app_video_es_merge(a.parts[i], b.parts[i]);
            if (!a.skipped && b.skipped) result.skipped = false;
            if (a.preload && !b.preload) result.preload = false;
            return result;
        };
        const app_updateSegments = (original, update, offset) => {
            const oldSegments = original.slice();
            const newSegments = update.slice();
            offset = offset || 0;
            const result = [];
            let currentMap;
            for (let newIndex = 0; newIndex < newSegments.length; newIndex++) {
                const oldSegment = oldSegments[newIndex + offset];
                const newSegment = newSegments[newIndex];
                if (oldSegment) {
                    currentMap = oldSegment.map || currentMap;
                    result.push(app_updateSegment(oldSegment, newSegment));
                } else {
                    if (currentMap && !newSegment.map) newSegment.map = currentMap;
                    result.push(newSegment);
                }
            }
            return result;
        };
        const app_resolveSegmentUris = (segment, baseUri) => {
            if (!segment.resolvedUri && segment.uri) segment.resolvedUri = app_video_es_resolveUrl(baseUri, segment.uri);
            if (segment.key && !segment.key.resolvedUri) segment.key.resolvedUri = app_video_es_resolveUrl(baseUri, segment.key.uri);
            if (segment.map && !segment.map.resolvedUri) segment.map.resolvedUri = app_video_es_resolveUrl(baseUri, segment.map.uri);
            if (segment.map && segment.map.key && !segment.map.key.resolvedUri) segment.map.key.resolvedUri = app_video_es_resolveUrl(baseUri, segment.map.key.uri);
            if (segment.parts && segment.parts.length) segment.parts.forEach((p => {
                if (p.resolvedUri) return;
                p.resolvedUri = app_video_es_resolveUrl(baseUri, p.uri);
            }));
            if (segment.preloadHints && segment.preloadHints.length) segment.preloadHints.forEach((p => {
                if (p.resolvedUri) return;
                p.resolvedUri = app_video_es_resolveUrl(baseUri, p.uri);
            }));
        };
        const app_getAllSegments = function(media) {
            const segments = media.segments || [];
            const preloadSegment = media.preloadSegment;
            if (preloadSegment && preloadSegment.parts && preloadSegment.parts.length) {
                if (preloadSegment.preloadHints) for (let i = 0; i < preloadSegment.preloadHints.length; i++) if (preloadSegment.preloadHints[i].type === "MAP") return segments;
                preloadSegment.duration = media.targetDuration;
                preloadSegment.preload = true;
                segments.push(preloadSegment);
            }
            return segments;
        };
        const app_isPlaylistUnchanged = (a, b) => a === b || a.segments && b.segments && a.segments.length === b.segments.length && a.endList === b.endList && a.mediaSequence === b.mediaSequence && a.preloadSegment === b.preloadSegment;
        const app_updateMain$1 = (main, newMedia, unchangedCheck = app_isPlaylistUnchanged) => {
            const result = app_video_es_merge(main, {});
            const oldMedia = result.playlists[newMedia.id];
            if (!oldMedia) return null;
            if (unchangedCheck(oldMedia, newMedia)) return null;
            newMedia.segments = app_getAllSegments(newMedia);
            const mergedPlaylist = app_video_es_merge(oldMedia, newMedia);
            if (mergedPlaylist.preloadSegment && !newMedia.preloadSegment) delete mergedPlaylist.preloadSegment;
            if (oldMedia.segments) {
                if (newMedia.skip) {
                    newMedia.segments = newMedia.segments || [];
                    for (let i = 0; i < newMedia.skip.skippedSegments; i++) newMedia.segments.unshift({
                        skipped: true
                    });
                }
                mergedPlaylist.segments = app_updateSegments(oldMedia.segments, newMedia.segments, newMedia.mediaSequence - oldMedia.mediaSequence);
            }
            mergedPlaylist.segments.forEach((segment => {
                app_resolveSegmentUris(segment, mergedPlaylist.resolvedUri);
            }));
            for (let i = 0; i < result.playlists.length; i++) if (result.playlists[i].id === newMedia.id) result.playlists[i] = mergedPlaylist;
            result.playlists[newMedia.id] = mergedPlaylist;
            result.playlists[newMedia.uri] = mergedPlaylist;
            app_video_es_forEachMediaGroup(main, ((properties, mediaType, groupKey, labelKey) => {
                if (!properties.playlists) return;
                for (let i = 0; i < properties.playlists.length; i++) if (newMedia.id === properties.playlists[i].id) properties.playlists[i] = mergedPlaylist;
            }));
            return result;
        };
        const app_refreshDelay = (media, update) => {
            const segments = media.segments || [];
            const lastSegment = segments[segments.length - 1];
            const lastPart = lastSegment && lastSegment.parts && lastSegment.parts[lastSegment.parts.length - 1];
            const lastDuration = lastPart && lastPart.duration || lastSegment && lastSegment.duration;
            if (update && lastDuration) return lastDuration * 1e3;
            return (media.partTargetDuration || media.targetDuration || 10) * 500;
        };
        const app_playlistMetadataPayload = (playlists, type, isLive) => {
            if (!playlists) return;
            const renditions = [];
            playlists.forEach((playlist => {
                if (!playlist.attributes) return;
                const {BANDWIDTH, RESOLUTION, CODECS} = playlist.attributes;
                renditions.push({
                    id: playlist.id,
                    bandwidth: BANDWIDTH,
                    resolution: RESOLUTION,
                    codecs: CODECS
                });
            }));
            return {
                type,
                isLive,
                renditions
            };
        };
        class app_PlaylistLoader extends app_EventTarget$1 {
            constructor(src, vhs, options = {}) {
                super();
                if (!src) throw new Error("A non-empty playlist URL or object is required");
                this.logger_ = app_logger("PlaylistLoader");
                const {withCredentials = false} = options;
                this.src = src;
                this.vhs_ = vhs;
                this.withCredentials = withCredentials;
                this.addDateRangesToTextTrack_ = options.addDateRangesToTextTrack;
                const vhsOptions = vhs.options_;
                this.customTagParsers = vhsOptions && vhsOptions.customTagParsers || [];
                this.customTagMappers = vhsOptions && vhsOptions.customTagMappers || [];
                this.llhls = vhsOptions && vhsOptions.llhls;
                this.dateRangesStorage_ = new app_DateRangesStorage;
                this.state = "HAVE_NOTHING";
                this.handleMediaupdatetimeout_ = this.handleMediaupdatetimeout_.bind(this);
                this.on("mediaupdatetimeout", this.handleMediaupdatetimeout_);
                this.on("loadedplaylist", this.handleLoadedPlaylist_.bind(this));
            }
            handleLoadedPlaylist_() {
                const mediaPlaylist = this.media();
                if (!mediaPlaylist) return;
                this.dateRangesStorage_.setOffset(mediaPlaylist.segments);
                this.dateRangesStorage_.setPendingDateRanges(mediaPlaylist.dateRanges);
                const availableDateRanges = this.dateRangesStorage_.getDateRangesToProcess();
                if (!availableDateRanges.length || !this.addDateRangesToTextTrack_) return;
                this.addDateRangesToTextTrack_(availableDateRanges);
            }
            handleMediaupdatetimeout_() {
                if (this.state !== "HAVE_METADATA") return;
                const media = this.media();
                let uri = app_video_es_resolveUrl(this.main.uri, media.uri);
                if (this.llhls) uri = app_addLLHLSQueryDirectives(uri, media);
                this.state = "HAVE_CURRENT_METADATA";
                this.request = this.vhs_.xhr({
                    uri,
                    withCredentials: this.withCredentials,
                    requestType: "hls-playlist"
                }, ((error, req) => {
                    if (!this.request) return;
                    if (error) return this.playlistRequestError(this.request, this.media(), "HAVE_METADATA");
                    this.haveMetadata({
                        playlistString: this.request.responseText,
                        url: this.media().uri,
                        id: this.media().id
                    });
                }));
            }
            playlistRequestError(xhr, playlist, startingState) {
                const {uri, id} = playlist;
                this.request = null;
                if (startingState) this.state = startingState;
                this.error = {
                    playlist: this.main.playlists[id],
                    status: xhr.status,
                    message: `HLS playlist request error at URL: ${uri}.`,
                    responseText: xhr.responseText,
                    code: xhr.status >= 500 ? 4 : 2,
                    metadata: app_getStreamingNetworkErrorMetadata({
                        requestType: xhr.requestType,
                        request: xhr,
                        error: xhr.error
                    })
                };
                this.trigger("error");
            }
            parseManifest_({url, manifestString}) {
                try {
                    return app_parseManifest({
                        onwarn: ({message}) => this.logger_(`m3u8-parser warn for ${url}: ${message}`),
                        oninfo: ({message}) => this.logger_(`m3u8-parser info for ${url}: ${message}`),
                        manifestString,
                        customTagParsers: this.customTagParsers,
                        customTagMappers: this.customTagMappers,
                        llhls: this.llhls
                    });
                } catch (error) {
                    this.error = error;
                    this.error.metadata = {
                        errorType: app_videojs.Error.StreamingHlsPlaylistParserError,
                        error
                    };
                }
            }
            haveMetadata({playlistString, playlistObject, url, id}) {
                this.request = null;
                this.state = "HAVE_METADATA";
                const metadata = {
                    playlistInfo: {
                        type: "media",
                        uri: url
                    }
                };
                this.trigger({
                    type: "playlistparsestart",
                    metadata
                });
                const playlist = playlistObject || this.parseManifest_({
                    url,
                    manifestString: playlistString
                });
                playlist.lastRequest = Date.now();
                app_setupMediaPlaylist({
                    playlist,
                    uri: url,
                    id
                });
                const update = app_updateMain$1(this.main, playlist);
                this.targetDuration = playlist.partTargetDuration || playlist.targetDuration;
                this.pendingMedia_ = null;
                if (update) {
                    this.main = update;
                    this.media_ = this.main.playlists[id];
                } else this.trigger("playlistunchanged");
                this.updateMediaUpdateTimeout_(app_refreshDelay(this.media(), !!update));
                metadata.parsedPlaylist = app_playlistMetadataPayload(this.main.playlists, metadata.playlistInfo.type, !this.media_.endList);
                this.trigger({
                    type: "playlistparsecomplete",
                    metadata
                });
                this.trigger("loadedplaylist");
            }
            dispose() {
                this.trigger("dispose");
                this.stopRequest();
                app_window_default().clearTimeout(this.mediaUpdateTimeout);
                app_window_default().clearTimeout(this.finalRenditionTimeout);
                this.dateRangesStorage_ = new app_DateRangesStorage;
                this.off();
            }
            stopRequest() {
                if (this.request) {
                    const oldRequest = this.request;
                    this.request = null;
                    oldRequest.onreadystatechange = null;
                    oldRequest.abort();
                }
            }
            media(playlist, shouldDelay) {
                if (!playlist) return this.media_;
                if (this.state === "HAVE_NOTHING") throw new Error("Cannot switch media playlist from " + this.state);
                if (typeof playlist === "string") {
                    if (!this.main.playlists[playlist]) throw new Error("Unknown playlist URI: " + playlist);
                    playlist = this.main.playlists[playlist];
                }
                app_window_default().clearTimeout(this.finalRenditionTimeout);
                if (shouldDelay) {
                    const delay = (playlist.partTargetDuration || playlist.targetDuration) / 2 * 1e3 || 5 * 1e3;
                    this.finalRenditionTimeout = app_window_default().setTimeout(this.media.bind(this, playlist, false), delay);
                    return;
                }
                const startingState = this.state;
                const mediaChange = !this.media_ || playlist.id !== this.media_.id;
                const mainPlaylistRef = this.main.playlists[playlist.id];
                if (mainPlaylistRef && mainPlaylistRef.endList || playlist.endList && playlist.segments.length) {
                    if (this.request) {
                        this.request.onreadystatechange = null;
                        this.request.abort();
                        this.request = null;
                    }
                    this.state = "HAVE_METADATA";
                    this.media_ = playlist;
                    if (mediaChange) {
                        this.trigger("mediachanging");
                        if (startingState === "HAVE_MAIN_MANIFEST") this.trigger("loadedmetadata"); else this.trigger("mediachange");
                    }
                    return;
                }
                this.updateMediaUpdateTimeout_(app_refreshDelay(playlist, true));
                if (!mediaChange) return;
                this.state = "SWITCHING_MEDIA";
                if (this.request) {
                    if (playlist.resolvedUri === this.request.url) return;
                    this.request.onreadystatechange = null;
                    this.request.abort();
                    this.request = null;
                }
                if (this.media_) this.trigger("mediachanging");
                this.pendingMedia_ = playlist;
                const metadata = {
                    playlistInfo: {
                        type: "media",
                        uri: playlist.uri
                    }
                };
                this.trigger({
                    type: "playlistrequeststart",
                    metadata
                });
                this.request = this.vhs_.xhr({
                    uri: playlist.resolvedUri,
                    withCredentials: this.withCredentials,
                    requestType: "hls-playlist"
                }, ((error, req) => {
                    if (!this.request) return;
                    playlist.lastRequest = Date.now();
                    playlist.resolvedUri = app_resolveManifestRedirect(playlist.resolvedUri, req);
                    if (error) return this.playlistRequestError(this.request, playlist, startingState);
                    this.trigger({
                        type: "playlistrequestcomplete",
                        metadata
                    });
                    this.haveMetadata({
                        playlistString: req.responseText,
                        url: playlist.uri,
                        id: playlist.id
                    });
                    if (startingState === "HAVE_MAIN_MANIFEST") this.trigger("loadedmetadata"); else this.trigger("mediachange");
                }));
            }
            pause() {
                if (this.mediaUpdateTimeout) {
                    app_window_default().clearTimeout(this.mediaUpdateTimeout);
                    this.mediaUpdateTimeout = null;
                }
                this.stopRequest();
                if (this.state === "HAVE_NOTHING") this.started = false;
                if (this.state === "SWITCHING_MEDIA") if (this.media_) this.state = "HAVE_METADATA"; else this.state = "HAVE_MAIN_MANIFEST"; else if (this.state === "HAVE_CURRENT_METADATA") this.state = "HAVE_METADATA";
            }
            load(shouldDelay) {
                if (this.mediaUpdateTimeout) {
                    app_window_default().clearTimeout(this.mediaUpdateTimeout);
                    this.mediaUpdateTimeout = null;
                }
                const media = this.media();
                if (shouldDelay) {
                    const delay = media ? (media.partTargetDuration || media.targetDuration) / 2 * 1e3 : 5 * 1e3;
                    this.mediaUpdateTimeout = app_window_default().setTimeout((() => {
                        this.mediaUpdateTimeout = null;
                        this.load();
                    }), delay);
                    return;
                }
                if (!this.started) {
                    this.start();
                    return;
                }
                if (media && !media.endList) this.trigger("mediaupdatetimeout"); else this.trigger("loadedplaylist");
            }
            updateMediaUpdateTimeout_(delay) {
                if (this.mediaUpdateTimeout) {
                    app_window_default().clearTimeout(this.mediaUpdateTimeout);
                    this.mediaUpdateTimeout = null;
                }
                if (!this.media() || this.media().endList) return;
                this.mediaUpdateTimeout = app_window_default().setTimeout((() => {
                    this.mediaUpdateTimeout = null;
                    this.trigger("mediaupdatetimeout");
                    this.updateMediaUpdateTimeout_(delay);
                }), delay);
            }
            start() {
                this.started = true;
                if (typeof this.src === "object") {
                    if (!this.src.uri) this.src.uri = app_window_default().location.href;
                    this.src.resolvedUri = this.src.uri;
                    setTimeout((() => {
                        this.setupInitialPlaylist(this.src);
                    }), 0);
                    return;
                }
                const metadata = {
                    playlistInfo: {
                        type: "multivariant",
                        uri: this.src
                    }
                };
                this.trigger({
                    type: "playlistrequeststart",
                    metadata
                });
                this.request = this.vhs_.xhr({
                    uri: this.src,
                    withCredentials: this.withCredentials,
                    requestType: "hls-playlist"
                }, ((error, req) => {
                    if (!this.request) return;
                    this.request = null;
                    if (error) {
                        this.error = {
                            status: req.status,
                            message: `HLS playlist request error at URL: ${this.src}.`,
                            responseText: req.responseText,
                            code: 2,
                            metadata: app_getStreamingNetworkErrorMetadata({
                                requestType: req.requestType,
                                request: req,
                                error
                            })
                        };
                        if (this.state === "HAVE_NOTHING") this.started = false;
                        return this.trigger("error");
                    }
                    this.trigger({
                        type: "playlistrequestcomplete",
                        metadata
                    });
                    this.src = app_resolveManifestRedirect(this.src, req);
                    this.trigger({
                        type: "playlistparsestart",
                        metadata
                    });
                    const manifest = this.parseManifest_({
                        manifestString: req.responseText,
                        url: this.src
                    });
                    metadata.parsedPlaylist = app_playlistMetadataPayload(manifest.playlists, metadata.playlistInfo.type, false);
                    this.trigger({
                        type: "playlistparsecomplete",
                        metadata
                    });
                    this.setupInitialPlaylist(manifest);
                }));
            }
            srcUri() {
                return typeof this.src === "string" ? this.src : this.src.uri;
            }
            setupInitialPlaylist(manifest) {
                this.state = "HAVE_MAIN_MANIFEST";
                if (manifest.playlists) {
                    this.main = manifest;
                    app_addPropertiesToMain(this.main, this.srcUri());
                    manifest.playlists.forEach((playlist => {
                        playlist.segments = app_getAllSegments(playlist);
                        playlist.segments.forEach((segment => {
                            app_resolveSegmentUris(segment, playlist.resolvedUri);
                        }));
                    }));
                    this.trigger("loadedplaylist");
                    if (!this.request) this.media(this.main.playlists[0]);
                    return;
                }
                const uri = this.srcUri() || app_window_default().location.href;
                this.main = app_mainForMedia(manifest, uri);
                this.haveMetadata({
                    playlistObject: manifest,
                    url: uri,
                    id: this.main.playlists[0].id
                });
                this.trigger("loadedmetadata");
            }
            updateOrDeleteClone(clone, isUpdate) {
                const main = this.main;
                const pathway = clone.ID;
                let i = main.playlists.length;
                while (i--) {
                    const p = main.playlists[i];
                    if (p.attributes["PATHWAY-ID"] === pathway) {
                        const oldPlaylistUri = p.resolvedUri;
                        const oldPlaylistId = p.id;
                        if (isUpdate) {
                            const newPlaylistUri = this.createCloneURI_(p.resolvedUri, clone);
                            const newPlaylistId = app_createPlaylistID(pathway, newPlaylistUri);
                            const attributes = this.createCloneAttributes_(pathway, p.attributes);
                            const updatedPlaylist = this.createClonePlaylist_(p, newPlaylistId, clone, attributes);
                            main.playlists[i] = updatedPlaylist;
                            main.playlists[newPlaylistId] = updatedPlaylist;
                            main.playlists[newPlaylistUri] = updatedPlaylist;
                        } else main.playlists.splice(i, 1);
                        delete main.playlists[oldPlaylistId];
                        delete main.playlists[oldPlaylistUri];
                    }
                }
                this.updateOrDeleteCloneMedia(clone, isUpdate);
            }
            updateOrDeleteCloneMedia(clone, isUpdate) {
                const main = this.main;
                const id = clone.ID;
                [ "AUDIO", "SUBTITLES", "CLOSED-CAPTIONS" ].forEach((mediaType => {
                    if (!main.mediaGroups[mediaType] || !main.mediaGroups[mediaType][id]) return;
                    for (const groupKey in main.mediaGroups[mediaType]) if (groupKey === id) {
                        for (const labelKey in main.mediaGroups[mediaType][groupKey]) {
                            const oldMedia = main.mediaGroups[mediaType][groupKey][labelKey];
                            oldMedia.playlists.forEach(((p, i) => {
                                const oldMediaPlaylist = main.playlists[p.id];
                                const oldPlaylistId = oldMediaPlaylist.id;
                                const oldPlaylistUri = oldMediaPlaylist.resolvedUri;
                                delete main.playlists[oldPlaylistId];
                                delete main.playlists[oldPlaylistUri];
                            }));
                        }
                        delete main.mediaGroups[mediaType][groupKey];
                    }
                }));
                if (isUpdate) this.createClonedMediaGroups_(clone);
            }
            addClonePathway(clone, basePlaylist = {}) {
                const main = this.main;
                const index = main.playlists.length;
                const uri = this.createCloneURI_(basePlaylist.resolvedUri, clone);
                const playlistId = app_createPlaylistID(clone.ID, uri);
                const attributes = this.createCloneAttributes_(clone.ID, basePlaylist.attributes);
                const playlist = this.createClonePlaylist_(basePlaylist, playlistId, clone, attributes);
                main.playlists[index] = playlist;
                main.playlists[playlistId] = playlist;
                main.playlists[uri] = playlist;
                this.createClonedMediaGroups_(clone);
            }
            createClonedMediaGroups_(clone) {
                const id = clone.ID;
                const baseID = clone["BASE-ID"];
                const main = this.main;
                [ "AUDIO", "SUBTITLES", "CLOSED-CAPTIONS" ].forEach((mediaType => {
                    if (!main.mediaGroups[mediaType] || main.mediaGroups[mediaType][id]) return;
                    for (const groupKey in main.mediaGroups[mediaType]) {
                        if (groupKey === baseID) main.mediaGroups[mediaType][id] = {}; else continue;
                        for (const labelKey in main.mediaGroups[mediaType][groupKey]) {
                            const oldMedia = main.mediaGroups[mediaType][groupKey][labelKey];
                            main.mediaGroups[mediaType][id][labelKey] = app_extends({}, oldMedia);
                            const newMedia = main.mediaGroups[mediaType][id][labelKey];
                            const newUri = this.createCloneURI_(oldMedia.resolvedUri, clone);
                            newMedia.resolvedUri = newUri;
                            newMedia.uri = newUri;
                            newMedia.playlists = [];
                            oldMedia.playlists.forEach(((p, i) => {
                                const oldMediaPlaylist = main.playlists[p.id];
                                const group = app_groupID(mediaType, id, labelKey);
                                const newPlaylistID = app_createPlaylistID(id, group);
                                if (oldMediaPlaylist && !main.playlists[newPlaylistID]) {
                                    const newMediaPlaylist = this.createClonePlaylist_(oldMediaPlaylist, newPlaylistID, clone);
                                    const newPlaylistUri = newMediaPlaylist.resolvedUri;
                                    main.playlists[newPlaylistID] = newMediaPlaylist;
                                    main.playlists[newPlaylistUri] = newMediaPlaylist;
                                }
                                newMedia.playlists[i] = this.createClonePlaylist_(p, newPlaylistID, clone);
                            }));
                        }
                    }
                }));
            }
            createClonePlaylist_(basePlaylist, id, clone, attributes) {
                const uri = this.createCloneURI_(basePlaylist.resolvedUri, clone);
                const newProps = {
                    resolvedUri: uri,
                    uri,
                    id
                };
                if (basePlaylist.segments) newProps.segments = [];
                if (attributes) newProps.attributes = attributes;
                return app_video_es_merge(basePlaylist, newProps);
            }
            createCloneURI_(baseURI, clone) {
                const uri = new URL(baseURI);
                uri.hostname = clone["URI-REPLACEMENT"].HOST;
                const params = clone["URI-REPLACEMENT"].PARAMS;
                for (const key of Object.keys(params)) uri.searchParams.set(key, params[key]);
                return uri.href;
            }
            createCloneAttributes_(id, oldAttributes) {
                const attributes = {
                    ["PATHWAY-ID"]: id
                };
                [ "AUDIO", "SUBTITLES", "CLOSED-CAPTIONS" ].forEach((mediaType => {
                    if (oldAttributes[mediaType]) attributes[mediaType] = id;
                }));
                return attributes;
            }
            getKeyIdSet(playlist) {
                if (playlist.contentProtection) {
                    const keyIds = new Set;
                    for (const keysystem in playlist.contentProtection) {
                        const keyId = playlist.contentProtection[keysystem].attributes.keyId;
                        if (keyId) keyIds.add(keyId.toLowerCase());
                    }
                    return keyIds;
                }
            }
        }
        const app_callbackWrapper = function(request, error, response, callback) {
            const reqResponse = request.responseType === "arraybuffer" ? request.response : request.responseText;
            if (!error && reqResponse) {
                request.responseTime = Date.now();
                request.roundTripTime = request.responseTime - request.requestTime;
                request.bytesReceived = reqResponse.byteLength || reqResponse.length;
                if (!request.bandwidth) request.bandwidth = Math.floor(request.bytesReceived / request.roundTripTime * 8 * 1e3);
            }
            if (response.headers) request.responseHeaders = response.headers;
            if (error && error.code === "ETIMEDOUT") request.timedout = true;
            if (!error && !request.aborted && response.statusCode !== 200 && response.statusCode !== 206 && response.statusCode !== 0) error = new Error("XHR Failed with a response of: " + (request && (reqResponse || request.responseText)));
            callback(error, request);
        };
        const app_callAllRequestHooks = (requestSet, options) => {
            if (!requestSet || !requestSet.size) return;
            let newOptions = options;
            requestSet.forEach((requestCallback => {
                newOptions = requestCallback(newOptions);
            }));
            return newOptions;
        };
        const app_callAllResponseHooks = (responseSet, request, error, response) => {
            if (!responseSet || !responseSet.size) return;
            responseSet.forEach((responseCallback => {
                responseCallback(request, error, response);
            }));
        };
        const app_xhrFactory = function() {
            const xhr = function XhrFunction(options, callback) {
                options = app_video_es_merge({
                    timeout: 45e3
                }, options);
                const beforeRequest = XhrFunction.beforeRequest || app_videojs.Vhs.xhr.beforeRequest;
                const _requestCallbackSet = XhrFunction._requestCallbackSet || app_videojs.Vhs.xhr._requestCallbackSet || new Set;
                const _responseCallbackSet = XhrFunction._responseCallbackSet || app_videojs.Vhs.xhr._responseCallbackSet;
                if (beforeRequest && typeof beforeRequest === "function") {
                    app_videojs.log.warn("beforeRequest is deprecated, use onRequest instead.");
                    _requestCallbackSet.add(beforeRequest);
                }
                const xhrMethod = app_videojs.Vhs.xhr.original === true ? app_videojs.xhr : app_videojs.Vhs.xhr;
                const beforeRequestOptions = app_callAllRequestHooks(_requestCallbackSet, options);
                _requestCallbackSet.delete(beforeRequest);
                const request = xhrMethod(beforeRequestOptions || options, (function(error, response) {
                    app_callAllResponseHooks(_responseCallbackSet, request, error, response);
                    return app_callbackWrapper(request, error, response, callback);
                }));
                const originalAbort = request.abort;
                request.abort = function() {
                    request.aborted = true;
                    return originalAbort.apply(request, arguments);
                };
                request.uri = options.uri;
                request.requestType = options.requestType;
                request.requestTime = Date.now();
                return request;
            };
            xhr.original = true;
            return xhr;
        };
        const app_byterangeStr = function(byterange) {
            let byterangeEnd;
            const byterangeStart = byterange.offset;
            if (typeof byterange.offset === "bigint" || typeof byterange.length === "bigint") byterangeEnd = app_window_default().BigInt(byterange.offset) + app_window_default().BigInt(byterange.length) - app_window_default().BigInt(1); else byterangeEnd = byterange.offset + byterange.length - 1;
            return "bytes=" + byterangeStart + "-" + byterangeEnd;
        };
        const app_segmentXhrHeaders = function(segment) {
            const headers = {};
            if (segment.byterange) headers.Range = app_byterangeStr(segment.byterange);
            return headers;
        };
        const app_textRange = function(range, i) {
            return range.start(i) + "-" + range.end(i);
        };
        const app_formatHexString = function(e, i) {
            const value = e.toString(16);
            return "00".substring(0, 2 - value.length) + value + (i % 2 ? " " : "");
        };
        const app_formatAsciiString = function(e) {
            if (e >= 32 && e < 126) return String.fromCharCode(e);
            return ".";
        };
        const app_createTransferableMessage = function(message) {
            const transferable = {};
            Object.keys(message).forEach((key => {
                const value = message[key];
                if (app_isArrayBufferView(value)) transferable[key] = {
                    bytes: value.buffer,
                    byteOffset: value.byteOffset,
                    byteLength: value.byteLength
                }; else transferable[key] = value;
            }));
            return transferable;
        };
        const app_initSegmentId = function(initSegment) {
            const byterange = initSegment.byterange || {
                length: 1 / 0,
                offset: 0
            };
            return [ byterange.length, byterange.offset, initSegment.resolvedUri ].join(",");
        };
        const app_segmentKeyId = function(key) {
            return key.resolvedUri;
        };
        const app_hexDump = data => {
            const bytes = Array.prototype.slice.call(data);
            const step = 16;
            let result = "";
            let hex;
            let ascii;
            for (let j = 0; j < bytes.length / step; j++) {
                hex = bytes.slice(j * step, j * step + step).map(app_formatHexString).join("");
                ascii = bytes.slice(j * step, j * step + step).map(app_formatAsciiString).join("");
                result += hex + " " + ascii + "\n";
            }
            return result;
        };
        const app_tagDump = ({bytes}) => app_hexDump(bytes);
        const app_textRanges = ranges => {
            let result = "";
            let i;
            for (i = 0; i < ranges.length; i++) result += app_textRange(ranges, i) + " ";
            return result;
        };
        var app_utils = Object.freeze({
            __proto__: null,
            createTransferableMessage: app_createTransferableMessage,
            initSegmentId: app_initSegmentId,
            segmentKeyId: app_segmentKeyId,
            hexDump: app_hexDump,
            tagDump: app_tagDump,
            textRanges: app_textRanges
        });
        const app_SEGMENT_END_FUDGE_PERCENT = .25;
        const app_playerTimeToProgramTime = (playerTime, segment) => {
            if (!segment.dateTimeObject) return null;
            const transmuxerPrependedSeconds = segment.videoTimingInfo.transmuxerPrependedSeconds;
            const transmuxedStart = segment.videoTimingInfo.transmuxedPresentationStart;
            const startOfSegment = transmuxedStart + transmuxerPrependedSeconds;
            const offsetFromSegmentStart = playerTime - startOfSegment;
            return new Date(segment.dateTimeObject.getTime() + offsetFromSegmentStart * 1e3);
        };
        const app_originalSegmentVideoDuration = videoTimingInfo => videoTimingInfo.transmuxedPresentationEnd - videoTimingInfo.transmuxedPresentationStart - videoTimingInfo.transmuxerPrependedSeconds;
        const app_findSegmentForProgramTime = (programTime, playlist) => {
            let dateTimeObject;
            try {
                dateTimeObject = new Date(programTime);
            } catch (e) {
                return null;
            }
            if (!playlist || !playlist.segments || playlist.segments.length === 0) return null;
            let segment = playlist.segments[0];
            if (dateTimeObject < new Date(segment.dateTimeObject)) return null;
            for (let i = 0; i < playlist.segments.length - 1; i++) {
                segment = playlist.segments[i];
                const nextSegmentStart = new Date(playlist.segments[i + 1].dateTimeObject);
                if (dateTimeObject < nextSegmentStart) break;
            }
            const lastSegment = playlist.segments[playlist.segments.length - 1];
            const lastSegmentStart = lastSegment.dateTimeObject;
            const lastSegmentDuration = lastSegment.videoTimingInfo ? app_originalSegmentVideoDuration(lastSegment.videoTimingInfo) : lastSegment.duration + lastSegment.duration * app_SEGMENT_END_FUDGE_PERCENT;
            const lastSegmentEnd = new Date(lastSegmentStart.getTime() + lastSegmentDuration * 1e3);
            if (dateTimeObject > lastSegmentEnd) return null;
            if (dateTimeObject > new Date(lastSegmentStart)) segment = lastSegment;
            return {
                segment,
                estimatedStart: segment.videoTimingInfo ? segment.videoTimingInfo.transmuxedPresentationStart : app_Playlist.duration(playlist, playlist.mediaSequence + playlist.segments.indexOf(segment)),
                type: segment.videoTimingInfo ? "accurate" : "estimate"
            };
        };
        const app_findSegmentForPlayerTime = (time, playlist) => {
            if (!playlist || !playlist.segments || playlist.segments.length === 0) return null;
            let segmentEnd = 0;
            let segment;
            for (let i = 0; i < playlist.segments.length; i++) {
                segment = playlist.segments[i];
                segmentEnd = segment.videoTimingInfo ? segment.videoTimingInfo.transmuxedPresentationEnd : segmentEnd + segment.duration;
                if (time <= segmentEnd) break;
            }
            const lastSegment = playlist.segments[playlist.segments.length - 1];
            if (lastSegment.videoTimingInfo && lastSegment.videoTimingInfo.transmuxedPresentationEnd < time) return null;
            if (time > segmentEnd) {
                if (time > segmentEnd + lastSegment.duration * app_SEGMENT_END_FUDGE_PERCENT) return null;
                segment = lastSegment;
            }
            return {
                segment,
                estimatedStart: segment.videoTimingInfo ? segment.videoTimingInfo.transmuxedPresentationStart : segmentEnd - segment.duration,
                type: segment.videoTimingInfo ? "accurate" : "estimate"
            };
        };
        const app_getOffsetFromTimestamp = (comparisonTimeStamp, programTime) => {
            let segmentDateTime;
            let programDateTime;
            try {
                segmentDateTime = new Date(comparisonTimeStamp);
                programDateTime = new Date(programTime);
            } catch (e) {}
            const segmentTimeEpoch = segmentDateTime.getTime();
            const programTimeEpoch = programDateTime.getTime();
            return (programTimeEpoch - segmentTimeEpoch) / 1e3;
        };
        const app_verifyProgramDateTimeTags = playlist => {
            if (!playlist.segments || playlist.segments.length === 0) return false;
            for (let i = 0; i < playlist.segments.length; i++) {
                const segment = playlist.segments[i];
                if (!segment.dateTimeObject) return false;
            }
            return true;
        };
        const app_getProgramTime = ({playlist, time = void 0, callback}) => {
            if (!callback) throw new Error("getProgramTime: callback must be provided");
            if (!playlist || time === void 0) return callback({
                message: "getProgramTime: playlist and time must be provided"
            });
            const matchedSegment = app_findSegmentForPlayerTime(time, playlist);
            if (!matchedSegment) return callback({
                message: "valid programTime was not found"
            });
            if (matchedSegment.type === "estimate") return callback({
                message: "Accurate programTime could not be determined." + " Please seek to e.seekTime and try again",
                seekTime: matchedSegment.estimatedStart
            });
            const programTimeObject = {
                mediaSeconds: time
            };
            const programTime = app_playerTimeToProgramTime(time, matchedSegment.segment);
            if (programTime) programTimeObject.programDateTime = programTime.toISOString();
            return callback(null, programTimeObject);
        };
        const app_seekToProgramTime = ({programTime, playlist, retryCount = 2, seekTo, pauseAfterSeek = true, tech, callback}) => {
            if (!callback) throw new Error("seekToProgramTime: callback must be provided");
            if (typeof programTime === "undefined" || !playlist || !seekTo) return callback({
                message: "seekToProgramTime: programTime, seekTo and playlist must be provided"
            });
            if (!playlist.endList && !tech.hasStarted_) return callback({
                message: "player must be playing a live stream to start buffering"
            });
            if (!app_verifyProgramDateTimeTags(playlist)) return callback({
                message: "programDateTime tags must be provided in the manifest " + playlist.resolvedUri
            });
            const matchedSegment = app_findSegmentForProgramTime(programTime, playlist);
            if (!matchedSegment) return callback({
                message: `${programTime} was not found in the stream`
            });
            const segment = matchedSegment.segment;
            const mediaOffset = app_getOffsetFromTimestamp(segment.dateTimeObject, programTime);
            if (matchedSegment.type === "estimate") {
                if (retryCount === 0) return callback({
                    message: `${programTime} is not buffered yet. Try again`
                });
                seekTo(matchedSegment.estimatedStart + mediaOffset);
                tech.one("seeked", (() => {
                    app_seekToProgramTime({
                        programTime,
                        playlist,
                        retryCount: retryCount - 1,
                        seekTo,
                        pauseAfterSeek,
                        tech,
                        callback
                    });
                }));
                return;
            }
            const seekToTime = segment.start + mediaOffset;
            const seekedCallback = () => callback(null, tech.currentTime());
            tech.one("seeked", seekedCallback);
            if (pauseAfterSeek) tech.pause();
            seekTo(seekToTime);
        };
        const app_callbackOnCompleted = (request, cb) => {
            if (request.readyState === 4) return cb();
            return;
        };
        const app_containerRequest = (uri, xhr, cb, requestType) => {
            let bytes = [];
            let id3Offset;
            let finished = false;
            const endRequestAndCallback = function(err, req, type, _bytes) {
                req.abort();
                finished = true;
                return cb(err, req, type, _bytes);
            };
            const progressListener = function(error, request) {
                if (finished) return;
                if (error) {
                    error.metadata = app_getStreamingNetworkErrorMetadata({
                        requestType,
                        request,
                        error
                    });
                    return endRequestAndCallback(error, request, "", bytes);
                }
                const newPart = request.responseText.substring(bytes && bytes.byteLength || 0, request.responseText.length);
                bytes = app_concatTypedArrays(bytes, app_stringToBytes(newPart, true));
                id3Offset = id3Offset || app_getId3Offset(bytes);
                if (bytes.length < 10 || id3Offset && bytes.length < id3Offset + 2) return app_callbackOnCompleted(request, (() => endRequestAndCallback(error, request, "", bytes)));
                const type = app_detectContainerForBytes(bytes);
                if (type === "ts" && bytes.length < 188) return app_callbackOnCompleted(request, (() => endRequestAndCallback(error, request, "", bytes)));
                if (!type && bytes.length < 376) return app_callbackOnCompleted(request, (() => endRequestAndCallback(error, request, "", bytes)));
                return endRequestAndCallback(null, request, type, bytes);
            };
            const options = {
                uri,
                beforeSend(request) {
                    request.overrideMimeType("text/plain; charset=x-user-defined");
                    request.addEventListener("progress", (function({total, loaded}) {
                        return app_callbackWrapper(request, null, {
                            statusCode: request.status
                        }, progressListener);
                    }));
                }
            };
            const request = xhr(options, (function(error, response) {
                return app_callbackWrapper(request, error, response, progressListener);
            }));
            return request;
        };
        const {EventTarget: app_EventTarget} = app_videojs;
        const app_dashPlaylistUnchanged = function(a, b) {
            if (!app_isPlaylistUnchanged(a, b)) return false;
            if (a.sidx && b.sidx && (a.sidx.offset !== b.sidx.offset || a.sidx.length !== b.sidx.length)) return false; else if (!a.sidx && b.sidx || a.sidx && !b.sidx) return false;
            if (a.segments && !b.segments || !a.segments && b.segments) return false;
            if (!a.segments && !b.segments) return true;
            for (let i = 0; i < a.segments.length; i++) {
                const aSegment = a.segments[i];
                const bSegment = b.segments[i];
                if (aSegment.uri !== bSegment.uri) return false;
                if (!aSegment.byterange && !bSegment.byterange) continue;
                const aByterange = aSegment.byterange;
                const bByterange = bSegment.byterange;
                if (aByterange && !bByterange || !aByterange && bByterange) return false;
                if (aByterange.offset !== bByterange.offset || aByterange.length !== bByterange.length) return false;
            }
            return true;
        };
        const app_dashGroupId = (type, group, label, playlist) => {
            const playlistId = playlist.attributes.NAME || label;
            return `placeholder-uri-${type}-${group}-${playlistId}`;
        };
        const app_parseMainXml = ({mainXml, srcUrl, clientOffset, sidxMapping, previousManifest}) => {
            const manifest = app_parse(mainXml, {
                manifestUri: srcUrl,
                clientOffset,
                sidxMapping,
                previousManifest
            });
            app_addPropertiesToMain(manifest, srcUrl, app_dashGroupId);
            return manifest;
        };
        const app_removeOldMediaGroupLabels = (update, newMain) => {
            app_video_es_forEachMediaGroup(update, ((properties, type, group, label) => {
                if (!newMain.mediaGroups[type][group] || !(label in newMain.mediaGroups[type][group])) delete update.mediaGroups[type][group][label];
            }));
        };
        const app_updateMain = (oldMain, newMain, sidxMapping) => {
            let noChanges = true;
            let update = app_video_es_merge(oldMain, {
                duration: newMain.duration,
                minimumUpdatePeriod: newMain.minimumUpdatePeriod,
                timelineStarts: newMain.timelineStarts
            });
            for (let i = 0; i < newMain.playlists.length; i++) {
                const playlist = newMain.playlists[i];
                if (playlist.sidx) {
                    const sidxKey = app_generateSidxKey(playlist.sidx);
                    if (sidxMapping && sidxMapping[sidxKey] && sidxMapping[sidxKey].sidx) app_addSidxSegmentsToPlaylist$1(playlist, sidxMapping[sidxKey].sidx, playlist.sidx.resolvedUri);
                }
                const playlistUpdate = app_updateMain$1(update, playlist, app_dashPlaylistUnchanged);
                if (playlistUpdate) {
                    update = playlistUpdate;
                    noChanges = false;
                }
            }
            app_video_es_forEachMediaGroup(newMain, ((properties, type, group, label) => {
                if (properties.playlists && properties.playlists.length) {
                    const id = properties.playlists[0].id;
                    const playlistUpdate = app_updateMain$1(update, properties.playlists[0], app_dashPlaylistUnchanged);
                    if (playlistUpdate) {
                        update = playlistUpdate;
                        if (!(label in update.mediaGroups[type][group])) update.mediaGroups[type][group][label] = properties;
                        update.mediaGroups[type][group][label].playlists[0] = update.playlists[id];
                        noChanges = false;
                    }
                }
            }));
            app_removeOldMediaGroupLabels(update, newMain);
            if (newMain.minimumUpdatePeriod !== oldMain.minimumUpdatePeriod) noChanges = false;
            if (noChanges) return null;
            return update;
        };
        const app_equivalentSidx = (a, b) => {
            const neitherMap = Boolean(!a.map && !b.map);
            const equivalentMap = neitherMap || Boolean(a.map && b.map && a.map.byterange.offset === b.map.byterange.offset && a.map.byterange.length === b.map.byterange.length);
            return equivalentMap && a.uri === b.uri && a.byterange.offset === b.byterange.offset && a.byterange.length === b.byterange.length;
        };
        const app_compareSidxEntry = (playlists, oldSidxMapping) => {
            const newSidxMapping = {};
            for (const id in playlists) {
                const playlist = playlists[id];
                const currentSidxInfo = playlist.sidx;
                if (currentSidxInfo) {
                    const key = app_generateSidxKey(currentSidxInfo);
                    if (!oldSidxMapping[key]) break;
                    const savedSidxInfo = oldSidxMapping[key].sidxInfo;
                    if (app_equivalentSidx(savedSidxInfo, currentSidxInfo)) newSidxMapping[key] = oldSidxMapping[key];
                }
            }
            return newSidxMapping;
        };
        const app_filterChangedSidxMappings = (main, oldSidxMapping) => {
            const videoSidx = app_compareSidxEntry(main.playlists, oldSidxMapping);
            let mediaGroupSidx = videoSidx;
            app_video_es_forEachMediaGroup(main, ((properties, mediaType, groupKey, labelKey) => {
                if (properties.playlists && properties.playlists.length) {
                    const playlists = properties.playlists;
                    mediaGroupSidx = app_video_es_merge(mediaGroupSidx, app_compareSidxEntry(playlists, oldSidxMapping));
                }
            }));
            return mediaGroupSidx;
        };
        class app_DashPlaylistLoader extends app_EventTarget {
            constructor(srcUrlOrPlaylist, vhs, options = {}, mainPlaylistLoader) {
                super();
                this.isPaused_ = true;
                this.mainPlaylistLoader_ = mainPlaylistLoader || this;
                if (!mainPlaylistLoader) this.isMain_ = true;
                const {withCredentials = false} = options;
                this.vhs_ = vhs;
                this.withCredentials = withCredentials;
                this.addMetadataToTextTrack = options.addMetadataToTextTrack;
                if (!srcUrlOrPlaylist) throw new Error("A non-empty playlist URL or object is required");
                this.on("minimumUpdatePeriod", (() => {
                    this.refreshXml_();
                }));
                this.on("mediaupdatetimeout", (() => {
                    this.refreshMedia_(this.media().id);
                }));
                this.state = "HAVE_NOTHING";
                this.loadedPlaylists_ = {};
                this.logger_ = app_logger("DashPlaylistLoader");
                if (this.isMain_) {
                    this.mainPlaylistLoader_.srcUrl = srcUrlOrPlaylist;
                    this.mainPlaylistLoader_.sidxMapping_ = {};
                } else this.childPlaylist_ = srcUrlOrPlaylist;
            }
            get isPaused() {
                return this.isPaused_;
            }
            requestErrored_(err, request, startingState) {
                if (!this.request) return true;
                this.request = null;
                if (err) {
                    this.error = typeof err === "object" && !(err instanceof Error) ? err : {
                        status: request.status,
                        message: "DASH request error at URL: " + request.uri,
                        response: request.response,
                        code: 2,
                        metadata: err.metadata
                    };
                    if (startingState) this.state = startingState;
                    this.trigger("error");
                    return true;
                }
            }
            addSidxSegments_(playlist, startingState, cb) {
                const sidxKey = playlist.sidx && app_generateSidxKey(playlist.sidx);
                if (!playlist.sidx || !sidxKey || this.mainPlaylistLoader_.sidxMapping_[sidxKey]) {
                    app_window_default().clearTimeout(this.mediaRequest_);
                    this.mediaRequest_ = app_window_default().setTimeout((() => cb(false)), 0);
                    return;
                }
                const uri = app_resolveManifestRedirect(playlist.sidx.resolvedUri);
                const fin = (err, request) => {
                    if (this.requestErrored_(err, request, startingState)) return;
                    const sidxMapping = this.mainPlaylistLoader_.sidxMapping_;
                    const {requestType} = request;
                    let sidx;
                    try {
                        sidx = app_parse_sidx_default()(app_byte_helpers_toUint8(request.response).subarray(8));
                    } catch (e) {
                        e.metadata = app_getStreamingNetworkErrorMetadata({
                            requestType,
                            request,
                            parseFailure: true
                        });
                        this.requestErrored_(e, request, startingState);
                        return;
                    }
                    sidxMapping[sidxKey] = {
                        sidxInfo: playlist.sidx,
                        sidx
                    };
                    app_addSidxSegmentsToPlaylist$1(playlist, sidx, playlist.sidx.resolvedUri);
                    return cb(true);
                };
                const REQUEST_TYPE = "dash-sidx";
                this.request = app_containerRequest(uri, this.vhs_.xhr, ((err, request, container, bytes) => {
                    if (err) return fin(err, request);
                    if (!container || container !== "mp4") {
                        const sidxContainer = container || "unknown";
                        return fin({
                            status: request.status,
                            message: `Unsupported ${sidxContainer} container type for sidx segment at URL: ${uri}`,
                            response: "",
                            playlist,
                            internal: true,
                            playlistExclusionDuration: 1 / 0,
                            code: 2
                        }, request);
                    }
                    const {offset, length} = playlist.sidx.byterange;
                    if (bytes.length >= length + offset) return fin(err, {
                        response: bytes.subarray(offset, offset + length),
                        status: request.status,
                        uri: request.uri
                    });
                    this.request = this.vhs_.xhr({
                        uri,
                        responseType: "arraybuffer",
                        requestType: "dash-sidx",
                        headers: app_segmentXhrHeaders({
                            byterange: playlist.sidx.byterange
                        })
                    }, fin);
                }), REQUEST_TYPE);
            }
            dispose() {
                this.isPaused_ = true;
                this.trigger("dispose");
                this.stopRequest();
                this.loadedPlaylists_ = {};
                app_window_default().clearTimeout(this.minimumUpdatePeriodTimeout_);
                app_window_default().clearTimeout(this.mediaRequest_);
                app_window_default().clearTimeout(this.mediaUpdateTimeout);
                this.mediaUpdateTimeout = null;
                this.mediaRequest_ = null;
                this.minimumUpdatePeriodTimeout_ = null;
                if (this.mainPlaylistLoader_.createMupOnMedia_) {
                    this.off("loadedmetadata", this.mainPlaylistLoader_.createMupOnMedia_);
                    this.mainPlaylistLoader_.createMupOnMedia_ = null;
                }
                this.off();
            }
            hasPendingRequest() {
                return this.request || this.mediaRequest_;
            }
            stopRequest() {
                if (this.request) {
                    const oldRequest = this.request;
                    this.request = null;
                    oldRequest.onreadystatechange = null;
                    oldRequest.abort();
                }
            }
            media(playlist) {
                if (!playlist) return this.media_;
                if (this.state === "HAVE_NOTHING") throw new Error("Cannot switch media playlist from " + this.state);
                const startingState = this.state;
                if (typeof playlist === "string") {
                    if (!this.mainPlaylistLoader_.main.playlists[playlist]) throw new Error("Unknown playlist URI: " + playlist);
                    playlist = this.mainPlaylistLoader_.main.playlists[playlist];
                }
                const mediaChange = !this.media_ || playlist.id !== this.media_.id;
                if (mediaChange && this.loadedPlaylists_[playlist.id] && this.loadedPlaylists_[playlist.id].endList) {
                    this.state = "HAVE_METADATA";
                    this.media_ = playlist;
                    if (mediaChange) {
                        this.trigger("mediachanging");
                        this.trigger("mediachange");
                    }
                    return;
                }
                if (!mediaChange) return;
                if (this.media_) this.trigger("mediachanging");
                this.addSidxSegments_(playlist, startingState, (sidxChanged => {
                    this.haveMetadata({
                        startingState,
                        playlist
                    });
                }));
            }
            haveMetadata({startingState, playlist}) {
                this.state = "HAVE_METADATA";
                this.loadedPlaylists_[playlist.id] = playlist;
                app_window_default().clearTimeout(this.mediaRequest_);
                this.mediaRequest_ = null;
                this.refreshMedia_(playlist.id);
                if (startingState === "HAVE_MAIN_MANIFEST") this.trigger("loadedmetadata"); else this.trigger("mediachange");
            }
            pause() {
                this.isPaused_ = true;
                if (this.mainPlaylistLoader_.createMupOnMedia_) {
                    this.off("loadedmetadata", this.mainPlaylistLoader_.createMupOnMedia_);
                    this.mainPlaylistLoader_.createMupOnMedia_ = null;
                }
                this.stopRequest();
                app_window_default().clearTimeout(this.mediaUpdateTimeout);
                this.mediaUpdateTimeout = null;
                if (this.isMain_) {
                    app_window_default().clearTimeout(this.mainPlaylistLoader_.minimumUpdatePeriodTimeout_);
                    this.mainPlaylistLoader_.minimumUpdatePeriodTimeout_ = null;
                }
                if (this.state === "HAVE_NOTHING") this.started = false;
            }
            load(isFinalRendition) {
                this.isPaused_ = false;
                app_window_default().clearTimeout(this.mediaUpdateTimeout);
                this.mediaUpdateTimeout = null;
                const media = this.media();
                if (isFinalRendition) {
                    const delay = media ? media.targetDuration / 2 * 1e3 : 5 * 1e3;
                    this.mediaUpdateTimeout = app_window_default().setTimeout((() => this.load()), delay);
                    return;
                }
                if (!this.started) {
                    this.start();
                    return;
                }
                if (media && !media.endList) {
                    if (this.isMain_ && !this.minimumUpdatePeriodTimeout_) {
                        this.trigger("minimumUpdatePeriod");
                        this.updateMinimumUpdatePeriodTimeout_();
                    }
                    this.trigger("mediaupdatetimeout");
                } else this.trigger("loadedplaylist");
            }
            start() {
                this.started = true;
                if (!this.isMain_) {
                    app_window_default().clearTimeout(this.mediaRequest_);
                    this.mediaRequest_ = app_window_default().setTimeout((() => this.haveMain_()), 0);
                    return;
                }
                this.requestMain_(((req, mainChanged) => {
                    this.haveMain_();
                    if (!this.hasPendingRequest() && !this.media_) this.media(this.mainPlaylistLoader_.main.playlists[0]);
                }));
            }
            requestMain_(cb) {
                const metadata = {
                    manifestInfo: {
                        uri: this.mainPlaylistLoader_.srcUrl
                    }
                };
                this.trigger({
                    type: "manifestrequeststart",
                    metadata
                });
                this.request = this.vhs_.xhr({
                    uri: this.mainPlaylistLoader_.srcUrl,
                    withCredentials: this.withCredentials,
                    requestType: "dash-manifest"
                }, ((error, req) => {
                    if (error) {
                        const {requestType} = req;
                        error.metadata = app_getStreamingNetworkErrorMetadata({
                            requestType,
                            request: req,
                            error
                        });
                    }
                    if (this.requestErrored_(error, req)) {
                        if (this.state === "HAVE_NOTHING") this.started = false;
                        return;
                    }
                    this.trigger({
                        type: "manifestrequestcomplete",
                        metadata
                    });
                    const mainChanged = req.responseText !== this.mainPlaylistLoader_.mainXml_;
                    this.mainPlaylistLoader_.mainXml_ = req.responseText;
                    if (req.responseHeaders && req.responseHeaders.date) this.mainLoaded_ = Date.parse(req.responseHeaders.date); else this.mainLoaded_ = Date.now();
                    this.mainPlaylistLoader_.srcUrl = app_resolveManifestRedirect(this.mainPlaylistLoader_.srcUrl, req);
                    if (mainChanged) {
                        this.handleMain_();
                        this.syncClientServerClock_((() => cb(req, mainChanged)));
                        return;
                    }
                    return cb(req, mainChanged);
                }));
            }
            syncClientServerClock_(done) {
                const utcTiming = app_parseUTCTiming(this.mainPlaylistLoader_.mainXml_);
                if (utcTiming === null) {
                    this.mainPlaylistLoader_.clientOffset_ = this.mainLoaded_ - Date.now();
                    return done();
                }
                if (utcTiming.method === "DIRECT") {
                    this.mainPlaylistLoader_.clientOffset_ = utcTiming.value - Date.now();
                    return done();
                }
                this.request = this.vhs_.xhr({
                    uri: app_video_es_resolveUrl(this.mainPlaylistLoader_.srcUrl, utcTiming.value),
                    method: utcTiming.method,
                    withCredentials: this.withCredentials,
                    requestType: "dash-clock-sync"
                }, ((error, req) => {
                    if (!this.request) return;
                    if (error) {
                        const {requestType} = req;
                        this.error.metadata = app_getStreamingNetworkErrorMetadata({
                            requestType,
                            request: req,
                            error
                        });
                        this.mainPlaylistLoader_.clientOffset_ = this.mainLoaded_ - Date.now();
                        return done();
                    }
                    let serverTime;
                    if (utcTiming.method === "HEAD") if (!req.responseHeaders || !req.responseHeaders.date) serverTime = this.mainLoaded_; else serverTime = Date.parse(req.responseHeaders.date); else serverTime = Date.parse(req.responseText);
                    this.mainPlaylistLoader_.clientOffset_ = serverTime - Date.now();
                    done();
                }));
            }
            haveMain_() {
                this.state = "HAVE_MAIN_MANIFEST";
                if (this.isMain_) this.trigger("loadedplaylist"); else if (!this.media_) this.media(this.childPlaylist_);
            }
            handleMain_() {
                app_window_default().clearTimeout(this.mediaRequest_);
                this.mediaRequest_ = null;
                const oldMain = this.mainPlaylistLoader_.main;
                const metadata = {
                    manifestInfo: {
                        uri: this.mainPlaylistLoader_.srcUrl
                    }
                };
                this.trigger({
                    type: "manifestparsestart",
                    metadata
                });
                let newMain;
                try {
                    newMain = app_parseMainXml({
                        mainXml: this.mainPlaylistLoader_.mainXml_,
                        srcUrl: this.mainPlaylistLoader_.srcUrl,
                        clientOffset: this.mainPlaylistLoader_.clientOffset_,
                        sidxMapping: this.mainPlaylistLoader_.sidxMapping_,
                        previousManifest: oldMain
                    });
                } catch (error) {
                    this.error = error;
                    this.error.metadata = {
                        errorType: app_videojs.Error.StreamingDashManifestParserError,
                        error
                    };
                    this.trigger("error");
                }
                if (oldMain) newMain = app_updateMain(oldMain, newMain, this.mainPlaylistLoader_.sidxMapping_);
                this.mainPlaylistLoader_.main = newMain ? newMain : oldMain;
                const location = this.mainPlaylistLoader_.main.locations && this.mainPlaylistLoader_.main.locations[0];
                if (location && location !== this.mainPlaylistLoader_.srcUrl) this.mainPlaylistLoader_.srcUrl = location;
                if (!oldMain || newMain && newMain.minimumUpdatePeriod !== oldMain.minimumUpdatePeriod) this.updateMinimumUpdatePeriodTimeout_();
                this.addEventStreamToMetadataTrack_(newMain);
                if (newMain) {
                    const {duration, endList} = newMain;
                    const renditions = [];
                    newMain.playlists.forEach((playlist => {
                        renditions.push({
                            id: playlist.id,
                            bandwidth: playlist.attributes.BANDWIDTH,
                            resolution: playlist.attributes.RESOLUTION,
                            codecs: playlist.attributes.CODECS
                        });
                    }));
                    const parsedManifest = {
                        duration,
                        isLive: !endList,
                        renditions
                    };
                    metadata.parsedManifest = parsedManifest;
                    this.trigger({
                        type: "manifestparsecomplete",
                        metadata
                    });
                }
                return Boolean(newMain);
            }
            updateMinimumUpdatePeriodTimeout_() {
                const mpl = this.mainPlaylistLoader_;
                if (mpl.createMupOnMedia_) {
                    mpl.off("loadedmetadata", mpl.createMupOnMedia_);
                    mpl.createMupOnMedia_ = null;
                }
                if (mpl.minimumUpdatePeriodTimeout_) {
                    app_window_default().clearTimeout(mpl.minimumUpdatePeriodTimeout_);
                    mpl.minimumUpdatePeriodTimeout_ = null;
                }
                let mup = mpl.main && mpl.main.minimumUpdatePeriod;
                if (mup === 0) if (mpl.media()) mup = mpl.media().targetDuration * 1e3; else {
                    mpl.createMupOnMedia_ = mpl.updateMinimumUpdatePeriodTimeout_;
                    mpl.one("loadedmetadata", mpl.createMupOnMedia_);
                }
                if (typeof mup !== "number" || mup <= 0) {
                    if (mup < 0) this.logger_(`found invalid minimumUpdatePeriod of ${mup}, not setting a timeout`);
                    return;
                }
                this.createMUPTimeout_(mup);
            }
            createMUPTimeout_(mup) {
                const mpl = this.mainPlaylistLoader_;
                mpl.minimumUpdatePeriodTimeout_ = app_window_default().setTimeout((() => {
                    mpl.minimumUpdatePeriodTimeout_ = null;
                    mpl.trigger("minimumUpdatePeriod");
                    mpl.createMUPTimeout_(mup);
                }), mup);
            }
            refreshXml_() {
                this.requestMain_(((req, mainChanged) => {
                    if (!mainChanged) return;
                    if (this.media_) this.media_ = this.mainPlaylistLoader_.main.playlists[this.media_.id];
                    this.mainPlaylistLoader_.sidxMapping_ = app_filterChangedSidxMappings(this.mainPlaylistLoader_.main, this.mainPlaylistLoader_.sidxMapping_);
                    this.addSidxSegments_(this.media(), this.state, (sidxChanged => {
                        this.refreshMedia_(this.media().id);
                    }));
                }));
            }
            refreshMedia_(mediaID) {
                if (!mediaID) throw new Error("refreshMedia_ must take a media id");
                if (this.media_ && this.isMain_) this.handleMain_();
                const playlists = this.mainPlaylistLoader_.main.playlists;
                const mediaChanged = !this.media_ || this.media_ !== playlists[mediaID];
                if (mediaChanged) this.media_ = playlists[mediaID]; else this.trigger("playlistunchanged");
                if (!this.mediaUpdateTimeout) {
                    const createMediaUpdateTimeout = () => {
                        if (this.media().endList) return;
                        this.mediaUpdateTimeout = app_window_default().setTimeout((() => {
                            this.trigger("mediaupdatetimeout");
                            createMediaUpdateTimeout();
                        }), app_refreshDelay(this.media(), Boolean(mediaChanged)));
                    };
                    createMediaUpdateTimeout();
                }
                this.trigger("loadedplaylist");
            }
            addEventStreamToMetadataTrack_(newMain) {
                if (newMain && this.mainPlaylistLoader_.main.eventStream) {
                    const metadataArray = this.mainPlaylistLoader_.main.eventStream.map((eventStreamNode => ({
                        cueTime: eventStreamNode.start,
                        frames: [ {
                            data: eventStreamNode.messageData
                        } ]
                    })));
                    this.addMetadataToTextTrack("EventStream", metadataArray, this.mainPlaylistLoader_.main.duration);
                }
            }
            getKeyIdSet(playlist) {
                if (playlist.contentProtection) {
                    const keyIds = new Set;
                    for (const keysystem in playlist.contentProtection) {
                        const defaultKID = playlist.contentProtection[keysystem].attributes["cenc:default_KID"];
                        if (defaultKID) keyIds.add(defaultKID.replace(/-/g, "").toLowerCase());
                    }
                    return keyIds;
                }
            }
        }
        var app_Config = {
            GOAL_BUFFER_LENGTH: 30,
            MAX_GOAL_BUFFER_LENGTH: 60,
            BACK_BUFFER_LENGTH: 30,
            GOAL_BUFFER_LENGTH_RATE: 1,
            INITIAL_BANDWIDTH: 4194304,
            BANDWIDTH_VARIANCE: 1.2,
            BUFFER_LOW_WATER_LINE: 0,
            MAX_BUFFER_LOW_WATER_LINE: 30,
            EXPERIMENTAL_MAX_BUFFER_LOW_WATER_LINE: 16,
            BUFFER_LOW_WATER_LINE_RATE: 1,
            BUFFER_HIGH_WATER_LINE: 30
        };
        const app_stringToArrayBuffer = string => {
            const view = new Uint8Array(new ArrayBuffer(string.length));
            for (let i = 0; i < string.length; i++) view[i] = string.charCodeAt(i);
            return view.buffer;
        };
        const app_browserWorkerPolyFill = function(workerObj) {
            workerObj.on = workerObj.addEventListener;
            workerObj.off = workerObj.removeEventListener;
            return workerObj;
        };
        const app_createObjectURL = function(str) {
            try {
                return URL.createObjectURL(new Blob([ str ], {
                    type: "application/javascript"
                }));
            } catch (e) {
                const blob = new BlobBuilder;
                blob.append(str);
                return URL.createObjectURL(blob.getBlob());
            }
        };
        const app_factory = function(code) {
            return function() {
                const objectUrl = app_createObjectURL(code);
                const worker = app_browserWorkerPolyFill(new Worker(objectUrl));
                worker.objURL = objectUrl;
                const terminate = worker.terminate;
                worker.on = worker.addEventListener;
                worker.off = worker.removeEventListener;
                worker.terminate = function() {
                    URL.revokeObjectURL(objectUrl);
                    return terminate.call(this);
                };
                return worker;
            };
        };
        const app_transform = function(code) {
            return `var browserWorkerPolyFill = ${app_browserWorkerPolyFill.toString()};\n` + "browserWorkerPolyFill(self);\n" + code;
        };
        const app_getWorkerString = function(fn) {
            return fn.toString().replace(/^function.+?{/, "").slice(0, -1);
        };
        const app_workerCode$1 = app_transform(app_getWorkerString((function() {
            var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof __webpack_require__.g !== "undefined" ? __webpack_require__.g : typeof self !== "undefined" ? self : {};
            var Stream$8 = function() {
                this.init = function() {
                    var listeners = {};
                    this.on = function(type, listener) {
                        if (!listeners[type]) listeners[type] = [];
                        listeners[type] = listeners[type].concat(listener);
                    };
                    this.off = function(type, listener) {
                        var index;
                        if (!listeners[type]) return false;
                        index = listeners[type].indexOf(listener);
                        listeners[type] = listeners[type].slice();
                        listeners[type].splice(index, 1);
                        return index > -1;
                    };
                    this.trigger = function(type) {
                        var callbacks, i, length, args;
                        callbacks = listeners[type];
                        if (!callbacks) return;
                        if (arguments.length === 2) {
                            length = callbacks.length;
                            for (i = 0; i < length; ++i) callbacks[i].call(this, arguments[1]);
                        } else {
                            args = [];
                            i = arguments.length;
                            for (i = 1; i < arguments.length; ++i) args.push(arguments[i]);
                            length = callbacks.length;
                            for (i = 0; i < length; ++i) callbacks[i].apply(this, args);
                        }
                    };
                    this.dispose = function() {
                        listeners = {};
                    };
                };
            };
            Stream$8.prototype.pipe = function(destination) {
                this.on("data", (function(data) {
                    destination.push(data);
                }));
                this.on("done", (function(flushSource) {
                    destination.flush(flushSource);
                }));
                this.on("partialdone", (function(flushSource) {
                    destination.partialFlush(flushSource);
                }));
                this.on("endedtimeline", (function(flushSource) {
                    destination.endTimeline(flushSource);
                }));
                this.on("reset", (function(flushSource) {
                    destination.reset(flushSource);
                }));
                return destination;
            };
            Stream$8.prototype.push = function(data) {
                this.trigger("data", data);
            };
            Stream$8.prototype.flush = function(flushSource) {
                this.trigger("done", flushSource);
            };
            Stream$8.prototype.partialFlush = function(flushSource) {
                this.trigger("partialdone", flushSource);
            };
            Stream$8.prototype.endTimeline = function(flushSource) {
                this.trigger("endedtimeline", flushSource);
            };
            Stream$8.prototype.reset = function(flushSource) {
                this.trigger("reset", flushSource);
            };
            var stream = Stream$8;
            var MAX_UINT32$1 = Math.pow(2, 32);
            var getUint64$5 = function(uint8) {
                var dv = new DataView(uint8.buffer, uint8.byteOffset, uint8.byteLength);
                var value;
                if (dv.getBigUint64) {
                    value = dv.getBigUint64(0);
                    if (value < Number.MAX_SAFE_INTEGER) return Number(value);
                    return value;
                }
                return dv.getUint32(0) * MAX_UINT32$1 + dv.getUint32(4);
            };
            var numbers = {
                getUint64: getUint64$5,
                MAX_UINT32: MAX_UINT32$1
            };
            var MAX_UINT32 = numbers.MAX_UINT32;
            var box, dinf, esds, ftyp, mdat, mfhd, minf, moof, moov, mvex, mvhd, trak, tkhd, mdia, mdhd, hdlr, sdtp, stbl, stsd, traf, trex, trun$1, types, MAJOR_BRAND, MINOR_VERSION, AVC1_BRAND, VIDEO_HDLR, AUDIO_HDLR, HDLR_TYPES, VMHD, SMHD, DREF, STCO, STSC, STSZ, STTS;
            (function() {
                var i;
                types = {
                    avc1: [],
                    avcC: [],
                    btrt: [],
                    dinf: [],
                    dref: [],
                    esds: [],
                    ftyp: [],
                    hdlr: [],
                    mdat: [],
                    mdhd: [],
                    mdia: [],
                    mfhd: [],
                    minf: [],
                    moof: [],
                    moov: [],
                    mp4a: [],
                    mvex: [],
                    mvhd: [],
                    pasp: [],
                    sdtp: [],
                    smhd: [],
                    stbl: [],
                    stco: [],
                    stsc: [],
                    stsd: [],
                    stsz: [],
                    stts: [],
                    styp: [],
                    tfdt: [],
                    tfhd: [],
                    traf: [],
                    trak: [],
                    trun: [],
                    trex: [],
                    tkhd: [],
                    vmhd: []
                };
                if (typeof Uint8Array === "undefined") return;
                for (i in types) if (types.hasOwnProperty(i)) types[i] = [ i.charCodeAt(0), i.charCodeAt(1), i.charCodeAt(2), i.charCodeAt(3) ];
                MAJOR_BRAND = new Uint8Array([ "i".charCodeAt(0), "s".charCodeAt(0), "o".charCodeAt(0), "m".charCodeAt(0) ]);
                AVC1_BRAND = new Uint8Array([ "a".charCodeAt(0), "v".charCodeAt(0), "c".charCodeAt(0), "1".charCodeAt(0) ]);
                MINOR_VERSION = new Uint8Array([ 0, 0, 0, 1 ]);
                VIDEO_HDLR = new Uint8Array([ 0, 0, 0, 0, 0, 0, 0, 0, 118, 105, 100, 101, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86, 105, 100, 101, 111, 72, 97, 110, 100, 108, 101, 114, 0 ]);
                AUDIO_HDLR = new Uint8Array([ 0, 0, 0, 0, 0, 0, 0, 0, 115, 111, 117, 110, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83, 111, 117, 110, 100, 72, 97, 110, 100, 108, 101, 114, 0 ]);
                HDLR_TYPES = {
                    video: VIDEO_HDLR,
                    audio: AUDIO_HDLR
                };
                DREF = new Uint8Array([ 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 12, 117, 114, 108, 32, 0, 0, 0, 1 ]);
                SMHD = new Uint8Array([ 0, 0, 0, 0, 0, 0, 0, 0 ]);
                STCO = new Uint8Array([ 0, 0, 0, 0, 0, 0, 0, 0 ]);
                STSC = STCO;
                STSZ = new Uint8Array([ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ]);
                STTS = STCO;
                VMHD = new Uint8Array([ 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 ]);
            })();
            box = function(type) {
                var i, result, view, payload = [], size = 0;
                for (i = 1; i < arguments.length; i++) payload.push(arguments[i]);
                i = payload.length;
                while (i--) size += payload[i].byteLength;
                result = new Uint8Array(size + 8);
                view = new DataView(result.buffer, result.byteOffset, result.byteLength);
                view.setUint32(0, result.byteLength);
                result.set(type, 4);
                for (i = 0, size = 8; i < payload.length; i++) {
                    result.set(payload[i], size);
                    size += payload[i].byteLength;
                }
                return result;
            };
            dinf = function() {
                return box(types.dinf, box(types.dref, DREF));
            };
            esds = function(track) {
                return box(types.esds, new Uint8Array([ 0, 0, 0, 0, 3, 25, 0, 0, 0, 4, 17, 64, 21, 0, 6, 0, 0, 0, 218, 192, 0, 0, 218, 192, 5, 2, track.audioobjecttype << 3 | track.samplingfrequencyindex >>> 1, track.samplingfrequencyindex << 7 | track.channelcount << 3, 6, 1, 2 ]));
            };
            ftyp = function() {
                return box(types.ftyp, MAJOR_BRAND, MINOR_VERSION, MAJOR_BRAND, AVC1_BRAND);
            };
            hdlr = function(type) {
                return box(types.hdlr, HDLR_TYPES[type]);
            };
            mdat = function(data) {
                return box(types.mdat, data);
            };
            mdhd = function(track) {
                var result = new Uint8Array([ 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 3, 0, 1, 95, 144, track.duration >>> 24 & 255, track.duration >>> 16 & 255, track.duration >>> 8 & 255, track.duration & 255, 85, 196, 0, 0 ]);
                if (track.samplerate) {
                    result[12] = track.samplerate >>> 24 & 255;
                    result[13] = track.samplerate >>> 16 & 255;
                    result[14] = track.samplerate >>> 8 & 255;
                    result[15] = track.samplerate & 255;
                }
                return box(types.mdhd, result);
            };
            mdia = function(track) {
                return box(types.mdia, mdhd(track), hdlr(track.type), minf(track));
            };
            mfhd = function(sequenceNumber) {
                return box(types.mfhd, new Uint8Array([ 0, 0, 0, 0, (sequenceNumber & 4278190080) >> 24, (sequenceNumber & 16711680) >> 16, (sequenceNumber & 65280) >> 8, sequenceNumber & 255 ]));
            };
            minf = function(track) {
                return box(types.minf, track.type === "video" ? box(types.vmhd, VMHD) : box(types.smhd, SMHD), dinf(), stbl(track));
            };
            moof = function(sequenceNumber, tracks) {
                var trackFragments = [], i = tracks.length;
                while (i--) trackFragments[i] = traf(tracks[i]);
                return box.apply(null, [ types.moof, mfhd(sequenceNumber) ].concat(trackFragments));
            };
            moov = function(tracks) {
                var i = tracks.length, boxes = [];
                while (i--) boxes[i] = trak(tracks[i]);
                return box.apply(null, [ types.moov, mvhd(4294967295) ].concat(boxes).concat(mvex(tracks)));
            };
            mvex = function(tracks) {
                var i = tracks.length, boxes = [];
                while (i--) boxes[i] = trex(tracks[i]);
                return box.apply(null, [ types.mvex ].concat(boxes));
            };
            mvhd = function(duration) {
                var bytes = new Uint8Array([ 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 1, 95, 144, (duration & 4278190080) >> 24, (duration & 16711680) >> 16, (duration & 65280) >> 8, duration & 255, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255 ]);
                return box(types.mvhd, bytes);
            };
            sdtp = function(track) {
                var flags, i, samples = track.samples || [], bytes = new Uint8Array(4 + samples.length);
                for (i = 0; i < samples.length; i++) {
                    flags = samples[i].flags;
                    bytes[i + 4] = flags.dependsOn << 4 | flags.isDependedOn << 2 | flags.hasRedundancy;
                }
                return box(types.sdtp, bytes);
            };
            stbl = function(track) {
                return box(types.stbl, stsd(track), box(types.stts, STTS), box(types.stsc, STSC), box(types.stsz, STSZ), box(types.stco, STCO));
            };
            (function() {
                var videoSample, audioSample;
                stsd = function(track) {
                    return box(types.stsd, new Uint8Array([ 0, 0, 0, 0, 0, 0, 0, 1 ]), track.type === "video" ? videoSample(track) : audioSample(track));
                };
                videoSample = function(track) {
                    var i, avc1Box, sps = track.sps || [], pps = track.pps || [], sequenceParameterSets = [], pictureParameterSets = [];
                    for (i = 0; i < sps.length; i++) {
                        sequenceParameterSets.push((sps[i].byteLength & 65280) >>> 8);
                        sequenceParameterSets.push(sps[i].byteLength & 255);
                        sequenceParameterSets = sequenceParameterSets.concat(Array.prototype.slice.call(sps[i]));
                    }
                    for (i = 0; i < pps.length; i++) {
                        pictureParameterSets.push((pps[i].byteLength & 65280) >>> 8);
                        pictureParameterSets.push(pps[i].byteLength & 255);
                        pictureParameterSets = pictureParameterSets.concat(Array.prototype.slice.call(pps[i]));
                    }
                    avc1Box = [ types.avc1, new Uint8Array([ 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (track.width & 65280) >> 8, track.width & 255, (track.height & 65280) >> 8, track.height & 255, 0, 72, 0, 0, 0, 72, 0, 0, 0, 0, 0, 0, 0, 1, 19, 118, 105, 100, 101, 111, 106, 115, 45, 99, 111, 110, 116, 114, 105, 98, 45, 104, 108, 115, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 17, 17 ]), box(types.avcC, new Uint8Array([ 1, track.profileIdc, track.profileCompatibility, track.levelIdc, 255 ].concat([ sps.length ], sequenceParameterSets, [ pps.length ], pictureParameterSets))), box(types.btrt, new Uint8Array([ 0, 28, 156, 128, 0, 45, 198, 192, 0, 45, 198, 192 ])) ];
                    if (track.sarRatio) {
                        var hSpacing = track.sarRatio[0], vSpacing = track.sarRatio[1];
                        avc1Box.push(box(types.pasp, new Uint8Array([ (hSpacing & 4278190080) >> 24, (hSpacing & 16711680) >> 16, (hSpacing & 65280) >> 8, hSpacing & 255, (vSpacing & 4278190080) >> 24, (vSpacing & 16711680) >> 16, (vSpacing & 65280) >> 8, vSpacing & 255 ])));
                    }
                    return box.apply(null, avc1Box);
                };
                audioSample = function(track) {
                    return box(types.mp4a, new Uint8Array([ 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, (track.channelcount & 65280) >> 8, track.channelcount & 255, (track.samplesize & 65280) >> 8, track.samplesize & 255, 0, 0, 0, 0, (track.samplerate & 65280) >> 8, track.samplerate & 255, 0, 0 ]), esds(track));
                };
            })();
            tkhd = function(track) {
                var result = new Uint8Array([ 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, (track.id & 4278190080) >> 24, (track.id & 16711680) >> 16, (track.id & 65280) >> 8, track.id & 255, 0, 0, 0, 0, (track.duration & 4278190080) >> 24, (track.duration & 16711680) >> 16, (track.duration & 65280) >> 8, track.duration & 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, (track.width & 65280) >> 8, track.width & 255, 0, 0, (track.height & 65280) >> 8, track.height & 255, 0, 0 ]);
                return box(types.tkhd, result);
            };
            traf = function(track) {
                var trackFragmentHeader, trackFragmentDecodeTime, trackFragmentRun, sampleDependencyTable, dataOffset, upperWordBaseMediaDecodeTime, lowerWordBaseMediaDecodeTime;
                trackFragmentHeader = box(types.tfhd, new Uint8Array([ 0, 0, 0, 58, (track.id & 4278190080) >> 24, (track.id & 16711680) >> 16, (track.id & 65280) >> 8, track.id & 255, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ]));
                upperWordBaseMediaDecodeTime = Math.floor(track.baseMediaDecodeTime / MAX_UINT32);
                lowerWordBaseMediaDecodeTime = Math.floor(track.baseMediaDecodeTime % MAX_UINT32);
                trackFragmentDecodeTime = box(types.tfdt, new Uint8Array([ 1, 0, 0, 0, upperWordBaseMediaDecodeTime >>> 24 & 255, upperWordBaseMediaDecodeTime >>> 16 & 255, upperWordBaseMediaDecodeTime >>> 8 & 255, upperWordBaseMediaDecodeTime & 255, lowerWordBaseMediaDecodeTime >>> 24 & 255, lowerWordBaseMediaDecodeTime >>> 16 & 255, lowerWordBaseMediaDecodeTime >>> 8 & 255, lowerWordBaseMediaDecodeTime & 255 ]));
                dataOffset = 32 + 20 + 8 + 16 + 8 + 8;
                if (track.type === "audio") {
                    trackFragmentRun = trun$1(track, dataOffset);
                    return box(types.traf, trackFragmentHeader, trackFragmentDecodeTime, trackFragmentRun);
                }
                sampleDependencyTable = sdtp(track);
                trackFragmentRun = trun$1(track, sampleDependencyTable.length + dataOffset);
                return box(types.traf, trackFragmentHeader, trackFragmentDecodeTime, trackFragmentRun, sampleDependencyTable);
            };
            trak = function(track) {
                track.duration = track.duration || 4294967295;
                return box(types.trak, tkhd(track), mdia(track));
            };
            trex = function(track) {
                var result = new Uint8Array([ 0, 0, 0, 0, (track.id & 4278190080) >> 24, (track.id & 16711680) >> 16, (track.id & 65280) >> 8, track.id & 255, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1 ]);
                if (track.type !== "video") result[result.length - 1] = 0;
                return box(types.trex, result);
            };
            (function() {
                var audioTrun, videoTrun, trunHeader;
                trunHeader = function(samples, offset) {
                    var durationPresent = 0, sizePresent = 0, flagsPresent = 0, compositionTimeOffset = 0;
                    if (samples.length) {
                        if (samples[0].duration !== void 0) durationPresent = 1;
                        if (samples[0].size !== void 0) sizePresent = 2;
                        if (samples[0].flags !== void 0) flagsPresent = 4;
                        if (samples[0].compositionTimeOffset !== void 0) compositionTimeOffset = 8;
                    }
                    return [ 0, 0, durationPresent | sizePresent | flagsPresent | compositionTimeOffset, 1, (samples.length & 4278190080) >>> 24, (samples.length & 16711680) >>> 16, (samples.length & 65280) >>> 8, samples.length & 255, (offset & 4278190080) >>> 24, (offset & 16711680) >>> 16, (offset & 65280) >>> 8, offset & 255 ];
                };
                videoTrun = function(track, offset) {
                    var bytesOffest, bytes, header, samples, sample, i;
                    samples = track.samples || [];
                    offset += 8 + 12 + 16 * samples.length;
                    header = trunHeader(samples, offset);
                    bytes = new Uint8Array(header.length + samples.length * 16);
                    bytes.set(header);
                    bytesOffest = header.length;
                    for (i = 0; i < samples.length; i++) {
                        sample = samples[i];
                        bytes[bytesOffest++] = (sample.duration & 4278190080) >>> 24;
                        bytes[bytesOffest++] = (sample.duration & 16711680) >>> 16;
                        bytes[bytesOffest++] = (sample.duration & 65280) >>> 8;
                        bytes[bytesOffest++] = sample.duration & 255;
                        bytes[bytesOffest++] = (sample.size & 4278190080) >>> 24;
                        bytes[bytesOffest++] = (sample.size & 16711680) >>> 16;
                        bytes[bytesOffest++] = (sample.size & 65280) >>> 8;
                        bytes[bytesOffest++] = sample.size & 255;
                        bytes[bytesOffest++] = sample.flags.isLeading << 2 | sample.flags.dependsOn;
                        bytes[bytesOffest++] = sample.flags.isDependedOn << 6 | sample.flags.hasRedundancy << 4 | sample.flags.paddingValue << 1 | sample.flags.isNonSyncSample;
                        bytes[bytesOffest++] = sample.flags.degradationPriority & 240 << 8;
                        bytes[bytesOffest++] = sample.flags.degradationPriority & 15;
                        bytes[bytesOffest++] = (sample.compositionTimeOffset & 4278190080) >>> 24;
                        bytes[bytesOffest++] = (sample.compositionTimeOffset & 16711680) >>> 16;
                        bytes[bytesOffest++] = (sample.compositionTimeOffset & 65280) >>> 8;
                        bytes[bytesOffest++] = sample.compositionTimeOffset & 255;
                    }
                    return box(types.trun, bytes);
                };
                audioTrun = function(track, offset) {
                    var bytes, bytesOffest, header, samples, sample, i;
                    samples = track.samples || [];
                    offset += 8 + 12 + 8 * samples.length;
                    header = trunHeader(samples, offset);
                    bytes = new Uint8Array(header.length + samples.length * 8);
                    bytes.set(header);
                    bytesOffest = header.length;
                    for (i = 0; i < samples.length; i++) {
                        sample = samples[i];
                        bytes[bytesOffest++] = (sample.duration & 4278190080) >>> 24;
                        bytes[bytesOffest++] = (sample.duration & 16711680) >>> 16;
                        bytes[bytesOffest++] = (sample.duration & 65280) >>> 8;
                        bytes[bytesOffest++] = sample.duration & 255;
                        bytes[bytesOffest++] = (sample.size & 4278190080) >>> 24;
                        bytes[bytesOffest++] = (sample.size & 16711680) >>> 16;
                        bytes[bytesOffest++] = (sample.size & 65280) >>> 8;
                        bytes[bytesOffest++] = sample.size & 255;
                    }
                    return box(types.trun, bytes);
                };
                trun$1 = function(track, offset) {
                    if (track.type === "audio") return audioTrun(track, offset);
                    return videoTrun(track, offset);
                };
            })();
            var mp4Generator = {
                ftyp,
                mdat,
                moof,
                moov,
                initSegment: function(tracks) {
                    var result, fileType = ftyp(), movie = moov(tracks);
                    result = new Uint8Array(fileType.byteLength + movie.byteLength);
                    result.set(fileType);
                    result.set(movie, fileType.byteLength);
                    return result;
                }
            };
            var groupNalsIntoFrames = function(nalUnits) {
                var i, currentNal, currentFrame = [], frames = [];
                frames.byteLength = 0;
                frames.nalCount = 0;
                frames.duration = 0;
                currentFrame.byteLength = 0;
                for (i = 0; i < nalUnits.length; i++) {
                    currentNal = nalUnits[i];
                    if (currentNal.nalUnitType === "access_unit_delimiter_rbsp") {
                        if (currentFrame.length) {
                            currentFrame.duration = currentNal.dts - currentFrame.dts;
                            frames.byteLength += currentFrame.byteLength;
                            frames.nalCount += currentFrame.length;
                            frames.duration += currentFrame.duration;
                            frames.push(currentFrame);
                        }
                        currentFrame = [ currentNal ];
                        currentFrame.byteLength = currentNal.data.byteLength;
                        currentFrame.pts = currentNal.pts;
                        currentFrame.dts = currentNal.dts;
                    } else {
                        if (currentNal.nalUnitType === "slice_layer_without_partitioning_rbsp_idr") currentFrame.keyFrame = true;
                        currentFrame.duration = currentNal.dts - currentFrame.dts;
                        currentFrame.byteLength += currentNal.data.byteLength;
                        currentFrame.push(currentNal);
                    }
                }
                if (frames.length && (!currentFrame.duration || currentFrame.duration <= 0)) currentFrame.duration = frames[frames.length - 1].duration;
                frames.byteLength += currentFrame.byteLength;
                frames.nalCount += currentFrame.length;
                frames.duration += currentFrame.duration;
                frames.push(currentFrame);
                return frames;
            };
            var groupFramesIntoGops = function(frames) {
                var i, currentFrame, currentGop = [], gops = [];
                currentGop.byteLength = 0;
                currentGop.nalCount = 0;
                currentGop.duration = 0;
                currentGop.pts = frames[0].pts;
                currentGop.dts = frames[0].dts;
                gops.byteLength = 0;
                gops.nalCount = 0;
                gops.duration = 0;
                gops.pts = frames[0].pts;
                gops.dts = frames[0].dts;
                for (i = 0; i < frames.length; i++) {
                    currentFrame = frames[i];
                    if (currentFrame.keyFrame) {
                        if (currentGop.length) {
                            gops.push(currentGop);
                            gops.byteLength += currentGop.byteLength;
                            gops.nalCount += currentGop.nalCount;
                            gops.duration += currentGop.duration;
                        }
                        currentGop = [ currentFrame ];
                        currentGop.nalCount = currentFrame.length;
                        currentGop.byteLength = currentFrame.byteLength;
                        currentGop.pts = currentFrame.pts;
                        currentGop.dts = currentFrame.dts;
                        currentGop.duration = currentFrame.duration;
                    } else {
                        currentGop.duration += currentFrame.duration;
                        currentGop.nalCount += currentFrame.length;
                        currentGop.byteLength += currentFrame.byteLength;
                        currentGop.push(currentFrame);
                    }
                }
                if (gops.length && currentGop.duration <= 0) currentGop.duration = gops[gops.length - 1].duration;
                gops.byteLength += currentGop.byteLength;
                gops.nalCount += currentGop.nalCount;
                gops.duration += currentGop.duration;
                gops.push(currentGop);
                return gops;
            };
            var extendFirstKeyFrame = function(gops) {
                var currentGop;
                if (!gops[0][0].keyFrame && gops.length > 1) {
                    currentGop = gops.shift();
                    gops.byteLength -= currentGop.byteLength;
                    gops.nalCount -= currentGop.nalCount;
                    gops[0][0].dts = currentGop.dts;
                    gops[0][0].pts = currentGop.pts;
                    gops[0][0].duration += currentGop.duration;
                }
                return gops;
            };
            var createDefaultSample = function() {
                return {
                    size: 0,
                    flags: {
                        isLeading: 0,
                        dependsOn: 1,
                        isDependedOn: 0,
                        hasRedundancy: 0,
                        degradationPriority: 0,
                        isNonSyncSample: 1
                    }
                };
            };
            var sampleForFrame = function(frame, dataOffset) {
                var sample = createDefaultSample();
                sample.dataOffset = dataOffset;
                sample.compositionTimeOffset = frame.pts - frame.dts;
                sample.duration = frame.duration;
                sample.size = 4 * frame.length;
                sample.size += frame.byteLength;
                if (frame.keyFrame) {
                    sample.flags.dependsOn = 2;
                    sample.flags.isNonSyncSample = 0;
                }
                return sample;
            };
            var generateSampleTable$1 = function(gops, baseDataOffset) {
                var h, i, sample, currentGop, currentFrame, dataOffset = baseDataOffset || 0, samples = [];
                for (h = 0; h < gops.length; h++) {
                    currentGop = gops[h];
                    for (i = 0; i < currentGop.length; i++) {
                        currentFrame = currentGop[i];
                        sample = sampleForFrame(currentFrame, dataOffset);
                        dataOffset += sample.size;
                        samples.push(sample);
                    }
                }
                return samples;
            };
            var concatenateNalData = function(gops) {
                var h, i, j, currentGop, currentFrame, currentNal, dataOffset = 0, nalsByteLength = gops.byteLength, numberOfNals = gops.nalCount, totalByteLength = nalsByteLength + 4 * numberOfNals, data = new Uint8Array(totalByteLength), view = new DataView(data.buffer);
                for (h = 0; h < gops.length; h++) {
                    currentGop = gops[h];
                    for (i = 0; i < currentGop.length; i++) {
                        currentFrame = currentGop[i];
                        for (j = 0; j < currentFrame.length; j++) {
                            currentNal = currentFrame[j];
                            view.setUint32(dataOffset, currentNal.data.byteLength);
                            dataOffset += 4;
                            data.set(currentNal.data, dataOffset);
                            dataOffset += currentNal.data.byteLength;
                        }
                    }
                }
                return data;
            };
            var generateSampleTableForFrame = function(frame, baseDataOffset) {
                var sample, dataOffset = baseDataOffset || 0, samples = [];
                sample = sampleForFrame(frame, dataOffset);
                samples.push(sample);
                return samples;
            };
            var concatenateNalDataForFrame = function(frame) {
                var i, currentNal, dataOffset = 0, nalsByteLength = frame.byteLength, numberOfNals = frame.length, totalByteLength = nalsByteLength + 4 * numberOfNals, data = new Uint8Array(totalByteLength), view = new DataView(data.buffer);
                for (i = 0; i < frame.length; i++) {
                    currentNal = frame[i];
                    view.setUint32(dataOffset, currentNal.data.byteLength);
                    dataOffset += 4;
                    data.set(currentNal.data, dataOffset);
                    dataOffset += currentNal.data.byteLength;
                }
                return data;
            };
            var frameUtils$1 = {
                groupNalsIntoFrames,
                groupFramesIntoGops,
                extendFirstKeyFrame,
                generateSampleTable: generateSampleTable$1,
                concatenateNalData,
                generateSampleTableForFrame,
                concatenateNalDataForFrame
            };
            var highPrefix = [ 33, 16, 5, 32, 164, 27 ];
            var lowPrefix = [ 33, 65, 108, 84, 1, 2, 4, 8, 168, 2, 4, 8, 17, 191, 252 ];
            var zeroFill = function(count) {
                var a = [];
                while (count--) a.push(0);
                return a;
            };
            var makeTable = function(metaTable) {
                return Object.keys(metaTable).reduce((function(obj, key) {
                    obj[key] = new Uint8Array(metaTable[key].reduce((function(arr, part) {
                        return arr.concat(part);
                    }), []));
                    return obj;
                }), {});
            };
            var silence;
            var silence_1 = function() {
                if (!silence) {
                    var coneOfSilence = {
                        96e3: [ highPrefix, [ 227, 64 ], zeroFill(154), [ 56 ] ],
                        88200: [ highPrefix, [ 231 ], zeroFill(170), [ 56 ] ],
                        64e3: [ highPrefix, [ 248, 192 ], zeroFill(240), [ 56 ] ],
                        48e3: [ highPrefix, [ 255, 192 ], zeroFill(268), [ 55, 148, 128 ], zeroFill(54), [ 112 ] ],
                        44100: [ highPrefix, [ 255, 192 ], zeroFill(268), [ 55, 163, 128 ], zeroFill(84), [ 112 ] ],
                        32e3: [ highPrefix, [ 255, 192 ], zeroFill(268), [ 55, 234 ], zeroFill(226), [ 112 ] ],
                        24e3: [ highPrefix, [ 255, 192 ], zeroFill(268), [ 55, 255, 128 ], zeroFill(268), [ 111, 112 ], zeroFill(126), [ 224 ] ],
                        16e3: [ highPrefix, [ 255, 192 ], zeroFill(268), [ 55, 255, 128 ], zeroFill(268), [ 111, 255 ], zeroFill(269), [ 223, 108 ], zeroFill(195), [ 1, 192 ] ],
                        12e3: [ lowPrefix, zeroFill(268), [ 3, 127, 248 ], zeroFill(268), [ 6, 255, 240 ], zeroFill(268), [ 13, 255, 224 ], zeroFill(268), [ 27, 253, 128 ], zeroFill(259), [ 56 ] ],
                        11025: [ lowPrefix, zeroFill(268), [ 3, 127, 248 ], zeroFill(268), [ 6, 255, 240 ], zeroFill(268), [ 13, 255, 224 ], zeroFill(268), [ 27, 255, 192 ], zeroFill(268), [ 55, 175, 128 ], zeroFill(108), [ 112 ] ],
                        8e3: [ lowPrefix, zeroFill(268), [ 3, 121, 16 ], zeroFill(47), [ 7 ] ]
                    };
                    silence = makeTable(coneOfSilence);
                }
                return silence;
            };
            var secondsToVideoTs, secondsToAudioTs, videoTsToSeconds, audioTsToSeconds, audioTsToVideoTs, videoTsToAudioTs, metadataTsToSeconds, ONE_SECOND_IN_TS$4 = 9e4;
            secondsToVideoTs = function(seconds) {
                return seconds * ONE_SECOND_IN_TS$4;
            };
            secondsToAudioTs = function(seconds, sampleRate) {
                return seconds * sampleRate;
            };
            videoTsToSeconds = function(timestamp) {
                return timestamp / ONE_SECOND_IN_TS$4;
            };
            audioTsToSeconds = function(timestamp, sampleRate) {
                return timestamp / sampleRate;
            };
            audioTsToVideoTs = function(timestamp, sampleRate) {
                return secondsToVideoTs(audioTsToSeconds(timestamp, sampleRate));
            };
            videoTsToAudioTs = function(timestamp, sampleRate) {
                return secondsToAudioTs(videoTsToSeconds(timestamp), sampleRate);
            };
            metadataTsToSeconds = function(timestamp, timelineStartPts, keepOriginalTimestamps) {
                return videoTsToSeconds(keepOriginalTimestamps ? timestamp : timestamp - timelineStartPts);
            };
            var clock$2 = {
                ONE_SECOND_IN_TS: ONE_SECOND_IN_TS$4,
                secondsToVideoTs,
                secondsToAudioTs,
                videoTsToSeconds,
                audioTsToSeconds,
                audioTsToVideoTs,
                videoTsToAudioTs,
                metadataTsToSeconds
            };
            var coneOfSilence = silence_1;
            var clock$1 = clock$2;
            var sumFrameByteLengths = function(array) {
                var i, currentObj, sum = 0;
                for (i = 0; i < array.length; i++) {
                    currentObj = array[i];
                    sum += currentObj.data.byteLength;
                }
                return sum;
            };
            var prefixWithSilence = function(track, frames, audioAppendStartTs, videoBaseMediaDecodeTime) {
                var baseMediaDecodeTimeTs, silentFrame, i, firstFrame, frameDuration = 0, audioGapDuration = 0, audioFillFrameCount = 0, audioFillDuration = 0;
                if (!frames.length) return;
                baseMediaDecodeTimeTs = clock$1.audioTsToVideoTs(track.baseMediaDecodeTime, track.samplerate);
                frameDuration = Math.ceil(clock$1.ONE_SECOND_IN_TS / (track.samplerate / 1024));
                if (audioAppendStartTs && videoBaseMediaDecodeTime) {
                    audioGapDuration = baseMediaDecodeTimeTs - Math.max(audioAppendStartTs, videoBaseMediaDecodeTime);
                    audioFillFrameCount = Math.floor(audioGapDuration / frameDuration);
                    audioFillDuration = audioFillFrameCount * frameDuration;
                }
                if (audioFillFrameCount < 1 || audioFillDuration > clock$1.ONE_SECOND_IN_TS / 2) return;
                silentFrame = coneOfSilence()[track.samplerate];
                if (!silentFrame) silentFrame = frames[0].data;
                for (i = 0; i < audioFillFrameCount; i++) {
                    firstFrame = frames[0];
                    frames.splice(0, 0, {
                        data: silentFrame,
                        dts: firstFrame.dts - frameDuration,
                        pts: firstFrame.pts - frameDuration
                    });
                }
                track.baseMediaDecodeTime -= Math.floor(clock$1.videoTsToAudioTs(audioFillDuration, track.samplerate));
                return audioFillDuration;
            };
            var trimAdtsFramesByEarliestDts = function(adtsFrames, track, earliestAllowedDts) {
                if (track.minSegmentDts >= earliestAllowedDts) return adtsFrames;
                track.minSegmentDts = 1 / 0;
                return adtsFrames.filter((function(currentFrame) {
                    if (currentFrame.dts >= earliestAllowedDts) {
                        track.minSegmentDts = Math.min(track.minSegmentDts, currentFrame.dts);
                        track.minSegmentPts = track.minSegmentDts;
                        return true;
                    }
                    return false;
                }));
            };
            var generateSampleTable = function(frames) {
                var i, currentFrame, samples = [];
                for (i = 0; i < frames.length; i++) {
                    currentFrame = frames[i];
                    samples.push({
                        size: currentFrame.data.byteLength,
                        duration: 1024
                    });
                }
                return samples;
            };
            var concatenateFrameData = function(frames) {
                var i, currentFrame, dataOffset = 0, data = new Uint8Array(sumFrameByteLengths(frames));
                for (i = 0; i < frames.length; i++) {
                    currentFrame = frames[i];
                    data.set(currentFrame.data, dataOffset);
                    dataOffset += currentFrame.data.byteLength;
                }
                return data;
            };
            var audioFrameUtils$1 = {
                prefixWithSilence,
                trimAdtsFramesByEarliestDts,
                generateSampleTable,
                concatenateFrameData
            };
            var ONE_SECOND_IN_TS$3 = clock$2.ONE_SECOND_IN_TS;
            var collectDtsInfo = function(track, data) {
                if (typeof data.pts === "number") {
                    if (track.timelineStartInfo.pts === void 0) track.timelineStartInfo.pts = data.pts;
                    if (track.minSegmentPts === void 0) track.minSegmentPts = data.pts; else track.minSegmentPts = Math.min(track.minSegmentPts, data.pts);
                    if (track.maxSegmentPts === void 0) track.maxSegmentPts = data.pts; else track.maxSegmentPts = Math.max(track.maxSegmentPts, data.pts);
                }
                if (typeof data.dts === "number") {
                    if (track.timelineStartInfo.dts === void 0) track.timelineStartInfo.dts = data.dts;
                    if (track.minSegmentDts === void 0) track.minSegmentDts = data.dts; else track.minSegmentDts = Math.min(track.minSegmentDts, data.dts);
                    if (track.maxSegmentDts === void 0) track.maxSegmentDts = data.dts; else track.maxSegmentDts = Math.max(track.maxSegmentDts, data.dts);
                }
            };
            var clearDtsInfo = function(track) {
                delete track.minSegmentDts;
                delete track.maxSegmentDts;
                delete track.minSegmentPts;
                delete track.maxSegmentPts;
            };
            var calculateTrackBaseMediaDecodeTime = function(track, keepOriginalTimestamps) {
                var baseMediaDecodeTime, scale, minSegmentDts = track.minSegmentDts;
                if (!keepOriginalTimestamps) minSegmentDts -= track.timelineStartInfo.dts;
                baseMediaDecodeTime = track.timelineStartInfo.baseMediaDecodeTime;
                baseMediaDecodeTime += minSegmentDts;
                baseMediaDecodeTime = Math.max(0, baseMediaDecodeTime);
                if (track.type === "audio") {
                    scale = track.samplerate / ONE_SECOND_IN_TS$3;
                    baseMediaDecodeTime *= scale;
                    baseMediaDecodeTime = Math.floor(baseMediaDecodeTime);
                }
                return baseMediaDecodeTime;
            };
            var trackDecodeInfo$1 = {
                clearDtsInfo,
                calculateTrackBaseMediaDecodeTime,
                collectDtsInfo
            };
            var USER_DATA_REGISTERED_ITU_T_T35 = 4, RBSP_TRAILING_BITS = 128;
            var parseSei = function(bytes) {
                var i = 0, result = {
                    payloadType: -1,
                    payloadSize: 0
                }, payloadType = 0, payloadSize = 0;
                while (i < bytes.byteLength) {
                    if (bytes[i] === RBSP_TRAILING_BITS) break;
                    while (bytes[i] === 255) {
                        payloadType += 255;
                        i++;
                    }
                    payloadType += bytes[i++];
                    while (bytes[i] === 255) {
                        payloadSize += 255;
                        i++;
                    }
                    payloadSize += bytes[i++];
                    if (!result.payload && payloadType === USER_DATA_REGISTERED_ITU_T_T35) {
                        var userIdentifier = String.fromCharCode(bytes[i + 3], bytes[i + 4], bytes[i + 5], bytes[i + 6]);
                        if (userIdentifier === "GA94") {
                            result.payloadType = payloadType;
                            result.payloadSize = payloadSize;
                            result.payload = bytes.subarray(i, i + payloadSize);
                            break;
                        } else result.payload = void 0;
                    }
                    i += payloadSize;
                    payloadType = 0;
                    payloadSize = 0;
                }
                return result;
            };
            var parseUserData = function(sei) {
                if (sei.payload[0] !== 181) return null;
                if ((sei.payload[1] << 8 | sei.payload[2]) !== 49) return null;
                if (String.fromCharCode(sei.payload[3], sei.payload[4], sei.payload[5], sei.payload[6]) !== "GA94") return null;
                if (sei.payload[7] !== 3) return null;
                return sei.payload.subarray(8, sei.payload.length - 1);
            };
            var parseCaptionPackets = function(pts, userData) {
                var i, count, offset, data, results = [];
                if (!(userData[0] & 64)) return results;
                count = userData[0] & 31;
                for (i = 0; i < count; i++) {
                    offset = i * 3;
                    data = {
                        type: userData[offset + 2] & 3,
                        pts
                    };
                    if (userData[offset + 2] & 4) {
                        data.ccData = userData[offset + 3] << 8 | userData[offset + 4];
                        results.push(data);
                    }
                }
                return results;
            };
            var discardEmulationPreventionBytes$1 = function(data) {
                var newLength, newData, length = data.byteLength, emulationPreventionBytesPositions = [], i = 1;
                while (i < length - 2) if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 3) {
                    emulationPreventionBytesPositions.push(i + 2);
                    i += 2;
                } else i++;
                if (emulationPreventionBytesPositions.length === 0) return data;
                newLength = length - emulationPreventionBytesPositions.length;
                newData = new Uint8Array(newLength);
                var sourceIndex = 0;
                for (i = 0; i < newLength; sourceIndex++, i++) {
                    if (sourceIndex === emulationPreventionBytesPositions[0]) {
                        sourceIndex++;
                        emulationPreventionBytesPositions.shift();
                    }
                    newData[i] = data[sourceIndex];
                }
                return newData;
            };
            var captionPacketParser = {
                parseSei,
                parseUserData,
                parseCaptionPackets,
                discardEmulationPreventionBytes: discardEmulationPreventionBytes$1,
                USER_DATA_REGISTERED_ITU_T_T35
            };
            var Stream$7 = stream;
            var cea708Parser = captionPacketParser;
            var CaptionStream$2 = function(options) {
                options = options || {};
                CaptionStream$2.prototype.init.call(this);
                this.parse708captions_ = typeof options.parse708captions === "boolean" ? options.parse708captions : true;
                this.captionPackets_ = [];
                this.ccStreams_ = [ new Cea608Stream(0, 0), new Cea608Stream(0, 1), new Cea608Stream(1, 0), new Cea608Stream(1, 1) ];
                if (this.parse708captions_) this.cc708Stream_ = new Cea708Stream({
                    captionServices: options.captionServices
                });
                this.reset();
                this.ccStreams_.forEach((function(cc) {
                    cc.on("data", this.trigger.bind(this, "data"));
                    cc.on("partialdone", this.trigger.bind(this, "partialdone"));
                    cc.on("done", this.trigger.bind(this, "done"));
                }), this);
                if (this.parse708captions_) {
                    this.cc708Stream_.on("data", this.trigger.bind(this, "data"));
                    this.cc708Stream_.on("partialdone", this.trigger.bind(this, "partialdone"));
                    this.cc708Stream_.on("done", this.trigger.bind(this, "done"));
                }
            };
            CaptionStream$2.prototype = new Stream$7;
            CaptionStream$2.prototype.push = function(event) {
                var sei, userData, newCaptionPackets;
                if (event.nalUnitType !== "sei_rbsp") return;
                sei = cea708Parser.parseSei(event.escapedRBSP);
                if (!sei.payload) return;
                if (sei.payloadType !== cea708Parser.USER_DATA_REGISTERED_ITU_T_T35) return;
                userData = cea708Parser.parseUserData(sei);
                if (!userData) return;
                if (event.dts < this.latestDts_) {
                    this.ignoreNextEqualDts_ = true;
                    return;
                } else if (event.dts === this.latestDts_ && this.ignoreNextEqualDts_) {
                    this.numSameDts_--;
                    if (!this.numSameDts_) this.ignoreNextEqualDts_ = false;
                    return;
                }
                newCaptionPackets = cea708Parser.parseCaptionPackets(event.pts, userData);
                this.captionPackets_ = this.captionPackets_.concat(newCaptionPackets);
                if (this.latestDts_ !== event.dts) this.numSameDts_ = 0;
                this.numSameDts_++;
                this.latestDts_ = event.dts;
            };
            CaptionStream$2.prototype.flushCCStreams = function(flushType) {
                this.ccStreams_.forEach((function(cc) {
                    return flushType === "flush" ? cc.flush() : cc.partialFlush();
                }), this);
            };
            CaptionStream$2.prototype.flushStream = function(flushType) {
                if (!this.captionPackets_.length) {
                    this.flushCCStreams(flushType);
                    return;
                }
                this.captionPackets_.forEach((function(elem, idx) {
                    elem.presortIndex = idx;
                }));
                this.captionPackets_.sort((function(a, b) {
                    if (a.pts === b.pts) return a.presortIndex - b.presortIndex;
                    return a.pts - b.pts;
                }));
                this.captionPackets_.forEach((function(packet) {
                    if (packet.type < 2) this.dispatchCea608Packet(packet); else this.dispatchCea708Packet(packet);
                }), this);
                this.captionPackets_.length = 0;
                this.flushCCStreams(flushType);
            };
            CaptionStream$2.prototype.flush = function() {
                return this.flushStream("flush");
            };
            CaptionStream$2.prototype.partialFlush = function() {
                return this.flushStream("partialFlush");
            };
            CaptionStream$2.prototype.reset = function() {
                this.latestDts_ = null;
                this.ignoreNextEqualDts_ = false;
                this.numSameDts_ = 0;
                this.activeCea608Channel_ = [ null, null ];
                this.ccStreams_.forEach((function(ccStream) {
                    ccStream.reset();
                }));
            };
            CaptionStream$2.prototype.dispatchCea608Packet = function(packet) {
                if (this.setsTextOrXDSActive(packet)) this.activeCea608Channel_[packet.type] = null; else if (this.setsChannel1Active(packet)) this.activeCea608Channel_[packet.type] = 0; else if (this.setsChannel2Active(packet)) this.activeCea608Channel_[packet.type] = 1;
                if (this.activeCea608Channel_[packet.type] === null) return;
                this.ccStreams_[(packet.type << 1) + this.activeCea608Channel_[packet.type]].push(packet);
            };
            CaptionStream$2.prototype.setsChannel1Active = function(packet) {
                return (packet.ccData & 30720) === 4096;
            };
            CaptionStream$2.prototype.setsChannel2Active = function(packet) {
                return (packet.ccData & 30720) === 6144;
            };
            CaptionStream$2.prototype.setsTextOrXDSActive = function(packet) {
                return (packet.ccData & 28928) === 256 || (packet.ccData & 30974) === 4138 || (packet.ccData & 30974) === 6186;
            };
            CaptionStream$2.prototype.dispatchCea708Packet = function(packet) {
                if (this.parse708captions_) this.cc708Stream_.push(packet);
            };
            var CHARACTER_TRANSLATION_708 = {
                127: 9834,
                4128: 32,
                4129: 160,
                4133: 8230,
                4138: 352,
                4140: 338,
                4144: 9608,
                4145: 8216,
                4146: 8217,
                4147: 8220,
                4148: 8221,
                4149: 8226,
                4153: 8482,
                4154: 353,
                4156: 339,
                4157: 8480,
                4159: 376,
                4214: 8539,
                4215: 8540,
                4216: 8541,
                4217: 8542,
                4218: 9168,
                4219: 9124,
                4220: 9123,
                4221: 9135,
                4222: 9126,
                4223: 9121,
                4256: 12600
            };
            var get708CharFromCode = function(code) {
                var newCode = CHARACTER_TRANSLATION_708[code] || code;
                if (code & 4096 && code === newCode) return "";
                return String.fromCharCode(newCode);
            };
            var within708TextBlock = function(b) {
                return 32 <= b && b <= 127 || 160 <= b && b <= 255;
            };
            var Cea708Window = function(windowNum) {
                this.windowNum = windowNum;
                this.reset();
            };
            Cea708Window.prototype.reset = function() {
                this.clearText();
                this.pendingNewLine = false;
                this.winAttr = {};
                this.penAttr = {};
                this.penLoc = {};
                this.penColor = {};
                this.visible = 0;
                this.rowLock = 0;
                this.columnLock = 0;
                this.priority = 0;
                this.relativePositioning = 0;
                this.anchorVertical = 0;
                this.anchorHorizontal = 0;
                this.anchorPoint = 0;
                this.rowCount = 1;
                this.virtualRowCount = this.rowCount + 1;
                this.columnCount = 41;
                this.windowStyle = 0;
                this.penStyle = 0;
            };
            Cea708Window.prototype.getText = function() {
                return this.rows.join("\n");
            };
            Cea708Window.prototype.clearText = function() {
                this.rows = [ "" ];
                this.rowIdx = 0;
            };
            Cea708Window.prototype.newLine = function(pts) {
                if (this.rows.length >= this.virtualRowCount && typeof this.beforeRowOverflow === "function") this.beforeRowOverflow(pts);
                if (this.rows.length > 0) {
                    this.rows.push("");
                    this.rowIdx++;
                }
                while (this.rows.length > this.virtualRowCount) {
                    this.rows.shift();
                    this.rowIdx--;
                }
            };
            Cea708Window.prototype.isEmpty = function() {
                if (this.rows.length === 0) return true; else if (this.rows.length === 1) return this.rows[0] === "";
                return false;
            };
            Cea708Window.prototype.addText = function(text) {
                this.rows[this.rowIdx] += text;
            };
            Cea708Window.prototype.backspace = function() {
                if (!this.isEmpty()) {
                    var row = this.rows[this.rowIdx];
                    this.rows[this.rowIdx] = row.substr(0, row.length - 1);
                }
            };
            var Cea708Service = function(serviceNum, encoding, stream) {
                this.serviceNum = serviceNum;
                this.text = "";
                this.currentWindow = new Cea708Window(-1);
                this.windows = [];
                this.stream = stream;
                if (typeof encoding === "string") this.createTextDecoder(encoding);
            };
            Cea708Service.prototype.init = function(pts, beforeRowOverflow) {
                this.startPts = pts;
                for (var win = 0; win < 8; win++) {
                    this.windows[win] = new Cea708Window(win);
                    if (typeof beforeRowOverflow === "function") this.windows[win].beforeRowOverflow = beforeRowOverflow;
                }
            };
            Cea708Service.prototype.setCurrentWindow = function(windowNum) {
                this.currentWindow = this.windows[windowNum];
            };
            Cea708Service.prototype.createTextDecoder = function(encoding) {
                if (typeof TextDecoder === "undefined") this.stream.trigger("log", {
                    level: "warn",
                    message: "The `encoding` option is unsupported without TextDecoder support"
                }); else try {
                    this.textDecoder_ = new TextDecoder(encoding);
                } catch (error) {
                    this.stream.trigger("log", {
                        level: "warn",
                        message: "TextDecoder could not be created with " + encoding + " encoding. " + error
                    });
                }
            };
            var Cea708Stream = function(options) {
                options = options || {};
                Cea708Stream.prototype.init.call(this);
                var self = this;
                var captionServices = options.captionServices || {};
                var captionServiceEncodings = {};
                var serviceProps;
                Object.keys(captionServices).forEach((serviceName => {
                    serviceProps = captionServices[serviceName];
                    if (/^SERVICE/.test(serviceName)) captionServiceEncodings[serviceName] = serviceProps.encoding;
                }));
                this.serviceEncodings = captionServiceEncodings;
                this.current708Packet = null;
                this.services = {};
                this.push = function(packet) {
                    if (packet.type === 3) {
                        self.new708Packet();
                        self.add708Bytes(packet);
                    } else {
                        if (self.current708Packet === null) self.new708Packet();
                        self.add708Bytes(packet);
                    }
                };
            };
            Cea708Stream.prototype = new Stream$7;
            Cea708Stream.prototype.new708Packet = function() {
                if (this.current708Packet !== null) this.push708Packet();
                this.current708Packet = {
                    data: [],
                    ptsVals: []
                };
            };
            Cea708Stream.prototype.add708Bytes = function(packet) {
                var data = packet.ccData;
                var byte0 = data >>> 8;
                var byte1 = data & 255;
                this.current708Packet.ptsVals.push(packet.pts);
                this.current708Packet.data.push(byte0);
                this.current708Packet.data.push(byte1);
            };
            Cea708Stream.prototype.push708Packet = function() {
                var packet708 = this.current708Packet;
                var packetData = packet708.data;
                var serviceNum = null;
                var blockSize = null;
                var i = 0;
                var b = packetData[i++];
                packet708.seq = b >> 6;
                packet708.sizeCode = b & 63;
                for (;i < packetData.length; i++) {
                    b = packetData[i++];
                    serviceNum = b >> 5;
                    blockSize = b & 31;
                    if (serviceNum === 7 && blockSize > 0) {
                        b = packetData[i++];
                        serviceNum = b;
                    }
                    this.pushServiceBlock(serviceNum, i, blockSize);
                    if (blockSize > 0) i += blockSize - 1;
                }
            };
            Cea708Stream.prototype.pushServiceBlock = function(serviceNum, start, size) {
                var b;
                var i = start;
                var packetData = this.current708Packet.data;
                var service = this.services[serviceNum];
                if (!service) service = this.initService(serviceNum, i);
                for (;i < start + size && i < packetData.length; i++) {
                    b = packetData[i];
                    if (within708TextBlock(b)) i = this.handleText(i, service); else if (b === 24) i = this.multiByteCharacter(i, service); else if (b === 16) i = this.extendedCommands(i, service); else if (128 <= b && b <= 135) i = this.setCurrentWindow(i, service); else if (152 <= b && b <= 159) i = this.defineWindow(i, service); else if (b === 136) i = this.clearWindows(i, service); else if (b === 140) i = this.deleteWindows(i, service); else if (b === 137) i = this.displayWindows(i, service); else if (b === 138) i = this.hideWindows(i, service); else if (b === 139) i = this.toggleWindows(i, service); else if (b === 151) i = this.setWindowAttributes(i, service); else if (b === 144) i = this.setPenAttributes(i, service); else if (b === 145) i = this.setPenColor(i, service); else if (b === 146) i = this.setPenLocation(i, service); else if (b === 143) service = this.reset(i, service); else if (b === 8) service.currentWindow.backspace(); else if (b === 12) service.currentWindow.clearText(); else if (b === 13) service.currentWindow.pendingNewLine = true; else if (b === 14) service.currentWindow.clearText(); else if (b === 141) i++;
                }
            };
            Cea708Stream.prototype.extendedCommands = function(i, service) {
                var packetData = this.current708Packet.data;
                var b = packetData[++i];
                if (within708TextBlock(b)) i = this.handleText(i, service, {
                    isExtended: true
                });
                return i;
            };
            Cea708Stream.prototype.getPts = function(byteIndex) {
                return this.current708Packet.ptsVals[Math.floor(byteIndex / 2)];
            };
            Cea708Stream.prototype.initService = function(serviceNum, i) {
                var serviceName = "SERVICE" + serviceNum;
                var self = this;
                var encoding;
                if (serviceName in this.serviceEncodings) encoding = this.serviceEncodings[serviceName];
                this.services[serviceNum] = new Cea708Service(serviceNum, encoding, self);
                this.services[serviceNum].init(this.getPts(i), (function(pts) {
                    self.flushDisplayed(pts, self.services[serviceNum]);
                }));
                return this.services[serviceNum];
            };
            Cea708Stream.prototype.handleText = function(i, service, options) {
                var isExtended = options && options.isExtended;
                var isMultiByte = options && options.isMultiByte;
                var packetData = this.current708Packet.data;
                var extended = isExtended ? 4096 : 0;
                var currentByte = packetData[i];
                var nextByte = packetData[i + 1];
                var win = service.currentWindow;
                var char;
                var charCodeArray;
                function toHexString(byteArray) {
                    return byteArray.map((byte => ("0" + (byte & 255).toString(16)).slice(-2))).join("");
                }
                if (isMultiByte) {
                    charCodeArray = [ currentByte, nextByte ];
                    i++;
                } else charCodeArray = [ currentByte ];
                if (service.textDecoder_ && !isExtended) char = service.textDecoder_.decode(new Uint8Array(charCodeArray)); else if (isMultiByte) {
                    const unicode = toHexString(charCodeArray);
                    char = String.fromCharCode(parseInt(unicode, 16));
                } else char = get708CharFromCode(extended | currentByte);
                if (win.pendingNewLine && !win.isEmpty()) win.newLine(this.getPts(i));
                win.pendingNewLine = false;
                win.addText(char);
                return i;
            };
            Cea708Stream.prototype.multiByteCharacter = function(i, service) {
                var packetData = this.current708Packet.data;
                var firstByte = packetData[i + 1];
                var secondByte = packetData[i + 2];
                if (within708TextBlock(firstByte) && within708TextBlock(secondByte)) i = this.handleText(++i, service, {
                    isMultiByte: true
                });
                return i;
            };
            Cea708Stream.prototype.setCurrentWindow = function(i, service) {
                var packetData = this.current708Packet.data;
                var b = packetData[i];
                var windowNum = b & 7;
                service.setCurrentWindow(windowNum);
                return i;
            };
            Cea708Stream.prototype.defineWindow = function(i, service) {
                var packetData = this.current708Packet.data;
                var b = packetData[i];
                var windowNum = b & 7;
                service.setCurrentWindow(windowNum);
                var win = service.currentWindow;
                b = packetData[++i];
                win.visible = (b & 32) >> 5;
                win.rowLock = (b & 16) >> 4;
                win.columnLock = (b & 8) >> 3;
                win.priority = b & 7;
                b = packetData[++i];
                win.relativePositioning = (b & 128) >> 7;
                win.anchorVertical = b & 127;
                b = packetData[++i];
                win.anchorHorizontal = b;
                b = packetData[++i];
                win.anchorPoint = (b & 240) >> 4;
                win.rowCount = b & 15;
                b = packetData[++i];
                win.columnCount = b & 63;
                b = packetData[++i];
                win.windowStyle = (b & 56) >> 3;
                win.penStyle = b & 7;
                win.virtualRowCount = win.rowCount + 1;
                return i;
            };
            Cea708Stream.prototype.setWindowAttributes = function(i, service) {
                var packetData = this.current708Packet.data;
                var b = packetData[i];
                var winAttr = service.currentWindow.winAttr;
                b = packetData[++i];
                winAttr.fillOpacity = (b & 192) >> 6;
                winAttr.fillRed = (b & 48) >> 4;
                winAttr.fillGreen = (b & 12) >> 2;
                winAttr.fillBlue = b & 3;
                b = packetData[++i];
                winAttr.borderType = (b & 192) >> 6;
                winAttr.borderRed = (b & 48) >> 4;
                winAttr.borderGreen = (b & 12) >> 2;
                winAttr.borderBlue = b & 3;
                b = packetData[++i];
                winAttr.borderType += (b & 128) >> 5;
                winAttr.wordWrap = (b & 64) >> 6;
                winAttr.printDirection = (b & 48) >> 4;
                winAttr.scrollDirection = (b & 12) >> 2;
                winAttr.justify = b & 3;
                b = packetData[++i];
                winAttr.effectSpeed = (b & 240) >> 4;
                winAttr.effectDirection = (b & 12) >> 2;
                winAttr.displayEffect = b & 3;
                return i;
            };
            Cea708Stream.prototype.flushDisplayed = function(pts, service) {
                var displayedText = [];
                for (var winId = 0; winId < 8; winId++) if (service.windows[winId].visible && !service.windows[winId].isEmpty()) displayedText.push(service.windows[winId].getText());
                service.endPts = pts;
                service.text = displayedText.join("\n\n");
                this.pushCaption(service);
                service.startPts = pts;
            };
            Cea708Stream.prototype.pushCaption = function(service) {
                if (service.text !== "") {
                    this.trigger("data", {
                        startPts: service.startPts,
                        endPts: service.endPts,
                        text: service.text,
                        stream: "cc708_" + service.serviceNum
                    });
                    service.text = "";
                    service.startPts = service.endPts;
                }
            };
            Cea708Stream.prototype.displayWindows = function(i, service) {
                var packetData = this.current708Packet.data;
                var b = packetData[++i];
                var pts = this.getPts(i);
                this.flushDisplayed(pts, service);
                for (var winId = 0; winId < 8; winId++) if (b & 1 << winId) service.windows[winId].visible = 1;
                return i;
            };
            Cea708Stream.prototype.hideWindows = function(i, service) {
                var packetData = this.current708Packet.data;
                var b = packetData[++i];
                var pts = this.getPts(i);
                this.flushDisplayed(pts, service);
                for (var winId = 0; winId < 8; winId++) if (b & 1 << winId) service.windows[winId].visible = 0;
                return i;
            };
            Cea708Stream.prototype.toggleWindows = function(i, service) {
                var packetData = this.current708Packet.data;
                var b = packetData[++i];
                var pts = this.getPts(i);
                this.flushDisplayed(pts, service);
                for (var winId = 0; winId < 8; winId++) if (b & 1 << winId) service.windows[winId].visible ^= 1;
                return i;
            };
            Cea708Stream.prototype.clearWindows = function(i, service) {
                var packetData = this.current708Packet.data;
                var b = packetData[++i];
                var pts = this.getPts(i);
                this.flushDisplayed(pts, service);
                for (var winId = 0; winId < 8; winId++) if (b & 1 << winId) service.windows[winId].clearText();
                return i;
            };
            Cea708Stream.prototype.deleteWindows = function(i, service) {
                var packetData = this.current708Packet.data;
                var b = packetData[++i];
                var pts = this.getPts(i);
                this.flushDisplayed(pts, service);
                for (var winId = 0; winId < 8; winId++) if (b & 1 << winId) service.windows[winId].reset();
                return i;
            };
            Cea708Stream.prototype.setPenAttributes = function(i, service) {
                var packetData = this.current708Packet.data;
                var b = packetData[i];
                var penAttr = service.currentWindow.penAttr;
                b = packetData[++i];
                penAttr.textTag = (b & 240) >> 4;
                penAttr.offset = (b & 12) >> 2;
                penAttr.penSize = b & 3;
                b = packetData[++i];
                penAttr.italics = (b & 128) >> 7;
                penAttr.underline = (b & 64) >> 6;
                penAttr.edgeType = (b & 56) >> 3;
                penAttr.fontStyle = b & 7;
                return i;
            };
            Cea708Stream.prototype.setPenColor = function(i, service) {
                var packetData = this.current708Packet.data;
                var b = packetData[i];
                var penColor = service.currentWindow.penColor;
                b = packetData[++i];
                penColor.fgOpacity = (b & 192) >> 6;
                penColor.fgRed = (b & 48) >> 4;
                penColor.fgGreen = (b & 12) >> 2;
                penColor.fgBlue = b & 3;
                b = packetData[++i];
                penColor.bgOpacity = (b & 192) >> 6;
                penColor.bgRed = (b & 48) >> 4;
                penColor.bgGreen = (b & 12) >> 2;
                penColor.bgBlue = b & 3;
                b = packetData[++i];
                penColor.edgeRed = (b & 48) >> 4;
                penColor.edgeGreen = (b & 12) >> 2;
                penColor.edgeBlue = b & 3;
                return i;
            };
            Cea708Stream.prototype.setPenLocation = function(i, service) {
                var packetData = this.current708Packet.data;
                var b = packetData[i];
                var penLoc = service.currentWindow.penLoc;
                service.currentWindow.pendingNewLine = true;
                b = packetData[++i];
                penLoc.row = b & 15;
                b = packetData[++i];
                penLoc.column = b & 63;
                return i;
            };
            Cea708Stream.prototype.reset = function(i, service) {
                var pts = this.getPts(i);
                this.flushDisplayed(pts, service);
                return this.initService(service.serviceNum, i);
            };
            var CHARACTER_TRANSLATION = {
                42: 225,
                92: 233,
                94: 237,
                95: 243,
                96: 250,
                123: 231,
                124: 247,
                125: 209,
                126: 241,
                127: 9608,
                304: 174,
                305: 176,
                306: 189,
                307: 191,
                308: 8482,
                309: 162,
                310: 163,
                311: 9834,
                312: 224,
                313: 160,
                314: 232,
                315: 226,
                316: 234,
                317: 238,
                318: 244,
                319: 251,
                544: 193,
                545: 201,
                546: 211,
                547: 218,
                548: 220,
                549: 252,
                550: 8216,
                551: 161,
                552: 42,
                553: 39,
                554: 8212,
                555: 169,
                556: 8480,
                557: 8226,
                558: 8220,
                559: 8221,
                560: 192,
                561: 194,
                562: 199,
                563: 200,
                564: 202,
                565: 203,
                566: 235,
                567: 206,
                568: 207,
                569: 239,
                570: 212,
                571: 217,
                572: 249,
                573: 219,
                574: 171,
                575: 187,
                800: 195,
                801: 227,
                802: 205,
                803: 204,
                804: 236,
                805: 210,
                806: 242,
                807: 213,
                808: 245,
                809: 123,
                810: 125,
                811: 92,
                812: 94,
                813: 95,
                814: 124,
                815: 126,
                816: 196,
                817: 228,
                818: 214,
                819: 246,
                820: 223,
                821: 165,
                822: 164,
                823: 9474,
                824: 197,
                825: 229,
                826: 216,
                827: 248,
                828: 9484,
                829: 9488,
                830: 9492,
                831: 9496
            };
            var getCharFromCode = function(code) {
                if (code === null) return "";
                code = CHARACTER_TRANSLATION[code] || code;
                return String.fromCharCode(code);
            };
            var BOTTOM_ROW = 14;
            var ROWS = [ 4352, 4384, 4608, 4640, 5376, 5408, 5632, 5664, 5888, 5920, 4096, 4864, 4896, 5120, 5152 ];
            var createDisplayBuffer = function() {
                var result = [], i = BOTTOM_ROW + 1;
                while (i--) result.push({
                    text: "",
                    indent: 0,
                    offset: 0
                });
                return result;
            };
            var Cea608Stream = function(field, dataChannel) {
                Cea608Stream.prototype.init.call(this);
                this.field_ = field || 0;
                this.dataChannel_ = dataChannel || 0;
                this.name_ = "CC" + ((this.field_ << 1 | this.dataChannel_) + 1);
                this.setConstants();
                this.reset();
                this.push = function(packet) {
                    var data, swap, char0, char1, text;
                    data = packet.ccData & 32639;
                    if (data === this.lastControlCode_) {
                        this.lastControlCode_ = null;
                        return;
                    }
                    if ((data & 61440) === 4096) this.lastControlCode_ = data; else if (data !== this.PADDING_) this.lastControlCode_ = null;
                    char0 = data >>> 8;
                    char1 = data & 255;
                    if (data === this.PADDING_) return; else if (data === this.RESUME_CAPTION_LOADING_) this.mode_ = "popOn"; else if (data === this.END_OF_CAPTION_) {
                        this.mode_ = "popOn";
                        this.clearFormatting(packet.pts);
                        this.flushDisplayed(packet.pts);
                        swap = this.displayed_;
                        this.displayed_ = this.nonDisplayed_;
                        this.nonDisplayed_ = swap;
                        this.startPts_ = packet.pts;
                    } else if (data === this.ROLL_UP_2_ROWS_) {
                        this.rollUpRows_ = 2;
                        this.setRollUp(packet.pts);
                    } else if (data === this.ROLL_UP_3_ROWS_) {
                        this.rollUpRows_ = 3;
                        this.setRollUp(packet.pts);
                    } else if (data === this.ROLL_UP_4_ROWS_) {
                        this.rollUpRows_ = 4;
                        this.setRollUp(packet.pts);
                    } else if (data === this.CARRIAGE_RETURN_) {
                        this.clearFormatting(packet.pts);
                        this.flushDisplayed(packet.pts);
                        this.shiftRowsUp_();
                        this.startPts_ = packet.pts;
                    } else if (data === this.BACKSPACE_) if (this.mode_ === "popOn") this.nonDisplayed_[this.row_].text = this.nonDisplayed_[this.row_].text.slice(0, -1); else this.displayed_[this.row_].text = this.displayed_[this.row_].text.slice(0, -1); else if (data === this.ERASE_DISPLAYED_MEMORY_) {
                        this.flushDisplayed(packet.pts);
                        this.displayed_ = createDisplayBuffer();
                    } else if (data === this.ERASE_NON_DISPLAYED_MEMORY_) this.nonDisplayed_ = createDisplayBuffer(); else if (data === this.RESUME_DIRECT_CAPTIONING_) {
                        if (this.mode_ !== "paintOn") {
                            this.flushDisplayed(packet.pts);
                            this.displayed_ = createDisplayBuffer();
                        }
                        this.mode_ = "paintOn";
                        this.startPts_ = packet.pts;
                    } else if (this.isSpecialCharacter(char0, char1)) {
                        char0 = (char0 & 3) << 8;
                        text = getCharFromCode(char0 | char1);
                        this[this.mode_](packet.pts, text);
                        this.column_++;
                    } else if (this.isExtCharacter(char0, char1)) {
                        if (this.mode_ === "popOn") this.nonDisplayed_[this.row_].text = this.nonDisplayed_[this.row_].text.slice(0, -1); else this.displayed_[this.row_].text = this.displayed_[this.row_].text.slice(0, -1);
                        char0 = (char0 & 3) << 8;
                        text = getCharFromCode(char0 | char1);
                        this[this.mode_](packet.pts, text);
                        this.column_++;
                    } else if (this.isMidRowCode(char0, char1)) {
                        this.clearFormatting(packet.pts);
                        this[this.mode_](packet.pts, " ");
                        this.column_++;
                        if ((char1 & 14) === 14) this.addFormatting(packet.pts, [ "i" ]);
                        if ((char1 & 1) === 1) this.addFormatting(packet.pts, [ "u" ]);
                    } else if (this.isOffsetControlCode(char0, char1)) {
                        const offset = char1 & 3;
                        this.nonDisplayed_[this.row_].offset = offset;
                        this.column_ += offset;
                    } else if (this.isPAC(char0, char1)) {
                        var row = ROWS.indexOf(data & 7968);
                        if (this.mode_ === "rollUp") {
                            if (row - this.rollUpRows_ + 1 < 0) row = this.rollUpRows_ - 1;
                            this.setRollUp(packet.pts, row);
                        }
                        if (row !== this.row_ && row >= 0 && row <= 14) {
                            this.clearFormatting(packet.pts);
                            this.row_ = row;
                        }
                        if (char1 & 1 && this.formatting_.indexOf("u") === -1) this.addFormatting(packet.pts, [ "u" ]);
                        if ((data & 16) === 16) {
                            const indentations = (data & 14) >> 1;
                            this.column_ = indentations * 4;
                            this.nonDisplayed_[this.row_].indent += indentations;
                        }
                        if (this.isColorPAC(char1)) if ((char1 & 14) === 14) this.addFormatting(packet.pts, [ "i" ]);
                    } else if (this.isNormalChar(char0)) {
                        if (char1 === 0) char1 = null;
                        text = getCharFromCode(char0);
                        text += getCharFromCode(char1);
                        this[this.mode_](packet.pts, text);
                        this.column_ += text.length;
                    }
                };
            };
            Cea608Stream.prototype = new Stream$7;
            Cea608Stream.prototype.flushDisplayed = function(pts) {
                const logWarning = index => {
                    this.trigger("log", {
                        level: "warn",
                        message: "Skipping a malformed 608 caption at index " + index + "."
                    });
                };
                const content = [];
                this.displayed_.forEach(((row, i) => {
                    if (row && row.text && row.text.length) {
                        try {
                            row.text = row.text.trim();
                        } catch (e) {
                            logWarning(i);
                        }
                        if (row.text.length) content.push({
                            text: row.text,
                            line: i + 1,
                            position: 10 + Math.min(70, row.indent * 10) + row.offset * 2.5
                        });
                    } else if (row === void 0 || row === null) logWarning(i);
                }));
                if (content.length) this.trigger("data", {
                    startPts: this.startPts_,
                    endPts: pts,
                    content,
                    stream: this.name_
                });
            };
            Cea608Stream.prototype.reset = function() {
                this.mode_ = "popOn";
                this.topRow_ = 0;
                this.startPts_ = 0;
                this.displayed_ = createDisplayBuffer();
                this.nonDisplayed_ = createDisplayBuffer();
                this.lastControlCode_ = null;
                this.column_ = 0;
                this.row_ = BOTTOM_ROW;
                this.rollUpRows_ = 2;
                this.formatting_ = [];
            };
            Cea608Stream.prototype.setConstants = function() {
                if (this.dataChannel_ === 0) {
                    this.BASE_ = 16;
                    this.EXT_ = 17;
                    this.CONTROL_ = (20 | this.field_) << 8;
                    this.OFFSET_ = 23;
                } else if (this.dataChannel_ === 1) {
                    this.BASE_ = 24;
                    this.EXT_ = 25;
                    this.CONTROL_ = (28 | this.field_) << 8;
                    this.OFFSET_ = 31;
                }
                this.PADDING_ = 0;
                this.RESUME_CAPTION_LOADING_ = this.CONTROL_ | 32;
                this.END_OF_CAPTION_ = this.CONTROL_ | 47;
                this.ROLL_UP_2_ROWS_ = this.CONTROL_ | 37;
                this.ROLL_UP_3_ROWS_ = this.CONTROL_ | 38;
                this.ROLL_UP_4_ROWS_ = this.CONTROL_ | 39;
                this.CARRIAGE_RETURN_ = this.CONTROL_ | 45;
                this.RESUME_DIRECT_CAPTIONING_ = this.CONTROL_ | 41;
                this.BACKSPACE_ = this.CONTROL_ | 33;
                this.ERASE_DISPLAYED_MEMORY_ = this.CONTROL_ | 44;
                this.ERASE_NON_DISPLAYED_MEMORY_ = this.CONTROL_ | 46;
            };
            Cea608Stream.prototype.isSpecialCharacter = function(char0, char1) {
                return char0 === this.EXT_ && char1 >= 48 && char1 <= 63;
            };
            Cea608Stream.prototype.isExtCharacter = function(char0, char1) {
                return (char0 === this.EXT_ + 1 || char0 === this.EXT_ + 2) && char1 >= 32 && char1 <= 63;
            };
            Cea608Stream.prototype.isMidRowCode = function(char0, char1) {
                return char0 === this.EXT_ && char1 >= 32 && char1 <= 47;
            };
            Cea608Stream.prototype.isOffsetControlCode = function(char0, char1) {
                return char0 === this.OFFSET_ && char1 >= 33 && char1 <= 35;
            };
            Cea608Stream.prototype.isPAC = function(char0, char1) {
                return char0 >= this.BASE_ && char0 < this.BASE_ + 8 && char1 >= 64 && char1 <= 127;
            };
            Cea608Stream.prototype.isColorPAC = function(char1) {
                return char1 >= 64 && char1 <= 79 || char1 >= 96 && char1 <= 127;
            };
            Cea608Stream.prototype.isNormalChar = function(char) {
                return char >= 32 && char <= 127;
            };
            Cea608Stream.prototype.setRollUp = function(pts, newBaseRow) {
                if (this.mode_ !== "rollUp") {
                    this.row_ = BOTTOM_ROW;
                    this.mode_ = "rollUp";
                    this.flushDisplayed(pts);
                    this.nonDisplayed_ = createDisplayBuffer();
                    this.displayed_ = createDisplayBuffer();
                }
                if (newBaseRow !== void 0 && newBaseRow !== this.row_) for (var i = 0; i < this.rollUpRows_; i++) {
                    this.displayed_[newBaseRow - i] = this.displayed_[this.row_ - i];
                    this.displayed_[this.row_ - i] = {
                        text: "",
                        indent: 0,
                        offset: 0
                    };
                }
                if (newBaseRow === void 0) newBaseRow = this.row_;
                this.topRow_ = newBaseRow - this.rollUpRows_ + 1;
            };
            Cea608Stream.prototype.addFormatting = function(pts, format) {
                this.formatting_ = this.formatting_.concat(format);
                var text = format.reduce((function(text, format) {
                    return text + "<" + format + ">";
                }), "");
                this[this.mode_](pts, text);
            };
            Cea608Stream.prototype.clearFormatting = function(pts) {
                if (!this.formatting_.length) return;
                var text = this.formatting_.reverse().reduce((function(text, format) {
                    return text + "</" + format + ">";
                }), "");
                this.formatting_ = [];
                this[this.mode_](pts, text);
            };
            Cea608Stream.prototype.popOn = function(pts, text) {
                var baseRow = this.nonDisplayed_[this.row_].text;
                baseRow += text;
                this.nonDisplayed_[this.row_].text = baseRow;
            };
            Cea608Stream.prototype.rollUp = function(pts, text) {
                var baseRow = this.displayed_[this.row_].text;
                baseRow += text;
                this.displayed_[this.row_].text = baseRow;
            };
            Cea608Stream.prototype.shiftRowsUp_ = function() {
                var i;
                for (i = 0; i < this.topRow_; i++) this.displayed_[i] = {
                    text: "",
                    indent: 0,
                    offset: 0
                };
                for (i = this.row_ + 1; i < BOTTOM_ROW + 1; i++) this.displayed_[i] = {
                    text: "",
                    indent: 0,
                    offset: 0
                };
                for (i = this.topRow_; i < this.row_; i++) this.displayed_[i] = this.displayed_[i + 1];
                this.displayed_[this.row_] = {
                    text: "",
                    indent: 0,
                    offset: 0
                };
            };
            Cea608Stream.prototype.paintOn = function(pts, text) {
                var baseRow = this.displayed_[this.row_].text;
                baseRow += text;
                this.displayed_[this.row_].text = baseRow;
            };
            var captionStream = {
                CaptionStream: CaptionStream$2,
                Cea608Stream,
                Cea708Stream
            };
            var streamTypes = {
                H264_STREAM_TYPE: 27,
                ADTS_STREAM_TYPE: 15,
                METADATA_STREAM_TYPE: 21
            };
            var Stream$6 = stream;
            var MAX_TS = 8589934592;
            var RO_THRESH = 4294967296;
            var TYPE_SHARED = "shared";
            var handleRollover$1 = function(value, reference) {
                var direction = 1;
                if (value > reference) direction = -1;
                while (Math.abs(reference - value) > RO_THRESH) value += direction * MAX_TS;
                return value;
            };
            var TimestampRolloverStream$1 = function(type) {
                var lastDTS, referenceDTS;
                TimestampRolloverStream$1.prototype.init.call(this);
                this.type_ = type || TYPE_SHARED;
                this.push = function(data) {
                    if (data.type === "metadata") {
                        this.trigger("data", data);
                        return;
                    }
                    if (this.type_ !== TYPE_SHARED && data.type !== this.type_) return;
                    if (referenceDTS === void 0) referenceDTS = data.dts;
                    data.dts = handleRollover$1(data.dts, referenceDTS);
                    data.pts = handleRollover$1(data.pts, referenceDTS);
                    lastDTS = data.dts;
                    this.trigger("data", data);
                };
                this.flush = function() {
                    referenceDTS = lastDTS;
                    this.trigger("done");
                };
                this.endTimeline = function() {
                    this.flush();
                    this.trigger("endedtimeline");
                };
                this.discontinuity = function() {
                    referenceDTS = void 0;
                    lastDTS = void 0;
                };
                this.reset = function() {
                    this.discontinuity();
                    this.trigger("reset");
                };
            };
            TimestampRolloverStream$1.prototype = new Stream$6;
            var timestampRolloverStream = {
                TimestampRolloverStream: TimestampRolloverStream$1,
                handleRollover: handleRollover$1
            };
            var typedArrayIndexOf$1 = (typedArray, element, fromIndex) => {
                if (!typedArray) return -1;
                var currentIndex = fromIndex;
                for (;currentIndex < typedArray.length; currentIndex++) if (typedArray[currentIndex] === element) return currentIndex;
                return -1;
            };
            var typedArray = {
                typedArrayIndexOf: typedArrayIndexOf$1
            };
            var typedArrayIndexOf = typedArray.typedArrayIndexOf, textEncodingDescriptionByte = {
                Iso88591: 0,
                Utf16: 1,
                Utf16be: 2,
                Utf8: 3
            }, percentEncode$1 = function(bytes, start, end) {
                var i, result = "";
                for (i = start; i < end; i++) result += "%" + ("00" + bytes[i].toString(16)).slice(-2);
                return result;
            }, parseUtf8 = function(bytes, start, end) {
                return decodeURIComponent(percentEncode$1(bytes, start, end));
            }, parseIso88591$1 = function(bytes, start, end) {
                return unescape(percentEncode$1(bytes, start, end));
            }, parseSyncSafeInteger$1 = function(data) {
                return data[0] << 21 | data[1] << 14 | data[2] << 7 | data[3];
            }, frameParsers = {
                APIC: function(frame) {
                    var mimeTypeEndIndex, descriptionEndIndex, i = 1, LINK_MIME_TYPE = "--\x3e";
                    if (frame.data[0] !== textEncodingDescriptionByte.Utf8) return;
                    mimeTypeEndIndex = typedArrayIndexOf(frame.data, 0, i);
                    if (mimeTypeEndIndex < 0) return;
                    frame.mimeType = parseIso88591$1(frame.data, i, mimeTypeEndIndex);
                    i = mimeTypeEndIndex + 1;
                    frame.pictureType = frame.data[i];
                    i++;
                    descriptionEndIndex = typedArrayIndexOf(frame.data, 0, i);
                    if (descriptionEndIndex < 0) return;
                    frame.description = parseUtf8(frame.data, i, descriptionEndIndex);
                    i = descriptionEndIndex + 1;
                    if (frame.mimeType === LINK_MIME_TYPE) frame.url = parseIso88591$1(frame.data, i, frame.data.length); else frame.pictureData = frame.data.subarray(i, frame.data.length);
                },
                "T*": function(frame) {
                    if (frame.data[0] !== textEncodingDescriptionByte.Utf8) return;
                    frame.value = parseUtf8(frame.data, 1, frame.data.length).replace(/\0*$/, "");
                    frame.values = frame.value.split("\0");
                },
                TXXX: function(frame) {
                    var descriptionEndIndex;
                    if (frame.data[0] !== textEncodingDescriptionByte.Utf8) return;
                    descriptionEndIndex = typedArrayIndexOf(frame.data, 0, 1);
                    if (descriptionEndIndex === -1) return;
                    frame.description = parseUtf8(frame.data, 1, descriptionEndIndex);
                    frame.value = parseUtf8(frame.data, descriptionEndIndex + 1, frame.data.length).replace(/\0*$/, "");
                    frame.data = frame.value;
                },
                "W*": function(frame) {
                    frame.url = parseIso88591$1(frame.data, 0, frame.data.length).replace(/\0.*$/, "");
                },
                WXXX: function(frame) {
                    var descriptionEndIndex;
                    if (frame.data[0] !== textEncodingDescriptionByte.Utf8) return;
                    descriptionEndIndex = typedArrayIndexOf(frame.data, 0, 1);
                    if (descriptionEndIndex === -1) return;
                    frame.description = parseUtf8(frame.data, 1, descriptionEndIndex);
                    frame.url = parseIso88591$1(frame.data, descriptionEndIndex + 1, frame.data.length).replace(/\0.*$/, "");
                },
                PRIV: function(frame) {
                    var i;
                    for (i = 0; i < frame.data.length; i++) if (frame.data[i] === 0) {
                        frame.owner = parseIso88591$1(frame.data, 0, i);
                        break;
                    }
                    frame.privateData = frame.data.subarray(i + 1);
                    frame.data = frame.privateData;
                }
            };
            var parseId3Frames$1 = function(data) {
                var frameSize, frameHeader, frameStart = 10, tagSize = 0, frames = [];
                if (data.length < 10 || data[0] !== "I".charCodeAt(0) || data[1] !== "D".charCodeAt(0) || data[2] !== "3".charCodeAt(0)) return;
                tagSize = parseSyncSafeInteger$1(data.subarray(6, 10));
                tagSize += 10;
                var hasExtendedHeader = data[5] & 64;
                if (hasExtendedHeader) {
                    frameStart += 4;
                    frameStart += parseSyncSafeInteger$1(data.subarray(10, 14));
                    tagSize -= parseSyncSafeInteger$1(data.subarray(16, 20));
                }
                do {
                    frameSize = parseSyncSafeInteger$1(data.subarray(frameStart + 4, frameStart + 8));
                    if (frameSize < 1) break;
                    frameHeader = String.fromCharCode(data[frameStart], data[frameStart + 1], data[frameStart + 2], data[frameStart + 3]);
                    var frame = {
                        id: frameHeader,
                        data: data.subarray(frameStart + 10, frameStart + frameSize + 10)
                    };
                    frame.key = frame.id;
                    if (frameParsers[frame.id]) frameParsers[frame.id](frame); else if (frame.id[0] === "T") frameParsers["T*"](frame); else if (frame.id[0] === "W") frameParsers["W*"](frame);
                    frames.push(frame);
                    frameStart += 10;
                    frameStart += frameSize;
                } while (frameStart < tagSize);
                return frames;
            };
            var parseId3 = {
                parseId3Frames: parseId3Frames$1,
                parseSyncSafeInteger: parseSyncSafeInteger$1,
                frameParsers
            };
            var MetadataStream, Stream$5 = stream, StreamTypes$3 = streamTypes, id3 = parseId3;
            MetadataStream = function(options) {
                var i, settings = {
                    descriptor: options && options.descriptor
                }, tagSize = 0, buffer = [], bufferSize = 0;
                MetadataStream.prototype.init.call(this);
                this.dispatchType = StreamTypes$3.METADATA_STREAM_TYPE.toString(16);
                if (settings.descriptor) for (i = 0; i < settings.descriptor.length; i++) this.dispatchType += ("00" + settings.descriptor[i].toString(16)).slice(-2);
                this.push = function(chunk) {
                    var tag, frameStart, frameSize, frame, i, frameHeader;
                    if (chunk.type !== "timed-metadata") return;
                    if (chunk.dataAlignmentIndicator) {
                        bufferSize = 0;
                        buffer.length = 0;
                    }
                    if (buffer.length === 0 && (chunk.data.length < 10 || chunk.data[0] !== "I".charCodeAt(0) || chunk.data[1] !== "D".charCodeAt(0) || chunk.data[2] !== "3".charCodeAt(0))) {
                        this.trigger("log", {
                            level: "warn",
                            message: "Skipping unrecognized metadata packet"
                        });
                        return;
                    }
                    buffer.push(chunk);
                    bufferSize += chunk.data.byteLength;
                    if (buffer.length === 1) {
                        tagSize = id3.parseSyncSafeInteger(chunk.data.subarray(6, 10));
                        tagSize += 10;
                    }
                    if (bufferSize < tagSize) return;
                    tag = {
                        data: new Uint8Array(tagSize),
                        frames: [],
                        pts: buffer[0].pts,
                        dts: buffer[0].dts
                    };
                    for (i = 0; i < tagSize; ) {
                        tag.data.set(buffer[0].data.subarray(0, tagSize - i), i);
                        i += buffer[0].data.byteLength;
                        bufferSize -= buffer[0].data.byteLength;
                        buffer.shift();
                    }
                    frameStart = 10;
                    if (tag.data[5] & 64) {
                        frameStart += 4;
                        frameStart += id3.parseSyncSafeInteger(tag.data.subarray(10, 14));
                        tagSize -= id3.parseSyncSafeInteger(tag.data.subarray(16, 20));
                    }
                    do {
                        frameSize = id3.parseSyncSafeInteger(tag.data.subarray(frameStart + 4, frameStart + 8));
                        if (frameSize < 1) {
                            this.trigger("log", {
                                level: "warn",
                                message: "Malformed ID3 frame encountered. Skipping remaining metadata parsing."
                            });
                            break;
                        }
                        frameHeader = String.fromCharCode(tag.data[frameStart], tag.data[frameStart + 1], tag.data[frameStart + 2], tag.data[frameStart + 3]);
                        frame = {
                            id: frameHeader,
                            data: tag.data.subarray(frameStart + 10, frameStart + frameSize + 10)
                        };
                        frame.key = frame.id;
                        if (id3.frameParsers[frame.id]) id3.frameParsers[frame.id](frame); else if (frame.id[0] === "T") id3.frameParsers["T*"](frame); else if (frame.id[0] === "W") id3.frameParsers["W*"](frame);
                        if (frame.owner === "com.apple.streaming.transportStreamTimestamp") {
                            var d = frame.data, size = (d[3] & 1) << 30 | d[4] << 22 | d[5] << 14 | d[6] << 6 | d[7] >>> 2;
                            size *= 4;
                            size += d[7] & 3;
                            frame.timeStamp = size;
                            if (tag.pts === void 0 && tag.dts === void 0) {
                                tag.pts = frame.timeStamp;
                                tag.dts = frame.timeStamp;
                            }
                            this.trigger("timestamp", frame);
                        }
                        tag.frames.push(frame);
                        frameStart += 10;
                        frameStart += frameSize;
                    } while (frameStart < tagSize);
                    this.trigger("data", tag);
                };
            };
            MetadataStream.prototype = new Stream$5;
            var metadataStream = MetadataStream;
            var Stream$4 = stream, CaptionStream$1 = captionStream, StreamTypes$2 = streamTypes, TimestampRolloverStream = timestampRolloverStream.TimestampRolloverStream;
            var TransportPacketStream, TransportParseStream, ElementaryStream;
            var MP2T_PACKET_LENGTH$1 = 188, SYNC_BYTE$1 = 71;
            TransportPacketStream = function() {
                var buffer = new Uint8Array(MP2T_PACKET_LENGTH$1), bytesInBuffer = 0;
                TransportPacketStream.prototype.init.call(this);
                this.push = function(bytes) {
                    var everything, startIndex = 0, endIndex = MP2T_PACKET_LENGTH$1;
                    if (bytesInBuffer) {
                        everything = new Uint8Array(bytes.byteLength + bytesInBuffer);
                        everything.set(buffer.subarray(0, bytesInBuffer));
                        everything.set(bytes, bytesInBuffer);
                        bytesInBuffer = 0;
                    } else everything = bytes;
                    while (endIndex < everything.byteLength) {
                        if (everything[startIndex] === SYNC_BYTE$1 && everything[endIndex] === SYNC_BYTE$1) {
                            this.trigger("data", everything.subarray(startIndex, endIndex));
                            startIndex += MP2T_PACKET_LENGTH$1;
                            endIndex += MP2T_PACKET_LENGTH$1;
                            continue;
                        }
                        startIndex++;
                        endIndex++;
                    }
                    if (startIndex < everything.byteLength) {
                        buffer.set(everything.subarray(startIndex), 0);
                        bytesInBuffer = everything.byteLength - startIndex;
                    }
                };
                this.flush = function() {
                    if (bytesInBuffer === MP2T_PACKET_LENGTH$1 && buffer[0] === SYNC_BYTE$1) {
                        this.trigger("data", buffer);
                        bytesInBuffer = 0;
                    }
                    this.trigger("done");
                };
                this.endTimeline = function() {
                    this.flush();
                    this.trigger("endedtimeline");
                };
                this.reset = function() {
                    bytesInBuffer = 0;
                    this.trigger("reset");
                };
            };
            TransportPacketStream.prototype = new Stream$4;
            TransportParseStream = function() {
                var parsePsi, parsePat, parsePmt, self;
                TransportParseStream.prototype.init.call(this);
                self = this;
                this.packetsWaitingForPmt = [];
                this.programMapTable = void 0;
                parsePsi = function(payload, psi) {
                    var offset = 0;
                    if (psi.payloadUnitStartIndicator) offset += payload[offset] + 1;
                    if (psi.type === "pat") parsePat(payload.subarray(offset), psi); else parsePmt(payload.subarray(offset), psi);
                };
                parsePat = function(payload, pat) {
                    pat.section_number = payload[7];
                    pat.last_section_number = payload[8];
                    self.pmtPid = (payload[10] & 31) << 8 | payload[11];
                    pat.pmtPid = self.pmtPid;
                };
                parsePmt = function(payload, pmt) {
                    var sectionLength, tableEnd, programInfoLength, offset;
                    if (!(payload[5] & 1)) return;
                    self.programMapTable = {
                        video: null,
                        audio: null,
                        "timed-metadata": {}
                    };
                    sectionLength = (payload[1] & 15) << 8 | payload[2];
                    tableEnd = 3 + sectionLength - 4;
                    programInfoLength = (payload[10] & 15) << 8 | payload[11];
                    offset = 12 + programInfoLength;
                    while (offset < tableEnd) {
                        var streamType = payload[offset];
                        var pid = (payload[offset + 1] & 31) << 8 | payload[offset + 2];
                        if (streamType === StreamTypes$2.H264_STREAM_TYPE && self.programMapTable.video === null) self.programMapTable.video = pid; else if (streamType === StreamTypes$2.ADTS_STREAM_TYPE && self.programMapTable.audio === null) self.programMapTable.audio = pid; else if (streamType === StreamTypes$2.METADATA_STREAM_TYPE) self.programMapTable["timed-metadata"][pid] = streamType;
                        offset += ((payload[offset + 3] & 15) << 8 | payload[offset + 4]) + 5;
                    }
                    pmt.programMapTable = self.programMapTable;
                };
                this.push = function(packet) {
                    var result = {}, offset = 4;
                    result.payloadUnitStartIndicator = !!(packet[1] & 64);
                    result.pid = packet[1] & 31;
                    result.pid <<= 8;
                    result.pid |= packet[2];
                    if ((packet[3] & 48) >>> 4 > 1) offset += packet[offset] + 1;
                    if (result.pid === 0) {
                        result.type = "pat";
                        parsePsi(packet.subarray(offset), result);
                        this.trigger("data", result);
                    } else if (result.pid === this.pmtPid) {
                        result.type = "pmt";
                        parsePsi(packet.subarray(offset), result);
                        this.trigger("data", result);
                        while (this.packetsWaitingForPmt.length) this.processPes_.apply(this, this.packetsWaitingForPmt.shift());
                    } else if (this.programMapTable === void 0) this.packetsWaitingForPmt.push([ packet, offset, result ]); else this.processPes_(packet, offset, result);
                };
                this.processPes_ = function(packet, offset, result) {
                    if (result.pid === this.programMapTable.video) result.streamType = StreamTypes$2.H264_STREAM_TYPE; else if (result.pid === this.programMapTable.audio) result.streamType = StreamTypes$2.ADTS_STREAM_TYPE; else result.streamType = this.programMapTable["timed-metadata"][result.pid];
                    result.type = "pes";
                    result.data = packet.subarray(offset);
                    this.trigger("data", result);
                };
            };
            TransportParseStream.prototype = new Stream$4;
            TransportParseStream.STREAM_TYPES = {
                h264: 27,
                adts: 15
            };
            ElementaryStream = function() {
                var programMapTable, self = this, segmentHadPmt = false, video = {
                    data: [],
                    size: 0
                }, audio = {
                    data: [],
                    size: 0
                }, timedMetadata = {
                    data: [],
                    size: 0
                }, parsePes = function(payload, pes) {
                    var ptsDtsFlags;
                    const startPrefix = payload[0] << 16 | payload[1] << 8 | payload[2];
                    pes.data = new Uint8Array;
                    if (startPrefix !== 1) return;
                    pes.packetLength = 6 + (payload[4] << 8 | payload[5]);
                    pes.dataAlignmentIndicator = (payload[6] & 4) !== 0;
                    ptsDtsFlags = payload[7];
                    if (ptsDtsFlags & 192) {
                        pes.pts = (payload[9] & 14) << 27 | (payload[10] & 255) << 20 | (payload[11] & 254) << 12 | (payload[12] & 255) << 5 | (payload[13] & 254) >>> 3;
                        pes.pts *= 4;
                        pes.pts += (payload[13] & 6) >>> 1;
                        pes.dts = pes.pts;
                        if (ptsDtsFlags & 64) {
                            pes.dts = (payload[14] & 14) << 27 | (payload[15] & 255) << 20 | (payload[16] & 254) << 12 | (payload[17] & 255) << 5 | (payload[18] & 254) >>> 3;
                            pes.dts *= 4;
                            pes.dts += (payload[18] & 6) >>> 1;
                        }
                    }
                    pes.data = payload.subarray(9 + payload[8]);
                }, flushStream = function(stream, type, forceFlush) {
                    var fragment, packetData = new Uint8Array(stream.size), event = {
                        type
                    }, i = 0, offset = 0, packetFlushable = false;
                    if (!stream.data.length || stream.size < 9) return;
                    event.trackId = stream.data[0].pid;
                    for (i = 0; i < stream.data.length; i++) {
                        fragment = stream.data[i];
                        packetData.set(fragment.data, offset);
                        offset += fragment.data.byteLength;
                    }
                    parsePes(packetData, event);
                    packetFlushable = type === "video" || event.packetLength <= stream.size;
                    if (forceFlush || packetFlushable) {
                        stream.size = 0;
                        stream.data.length = 0;
                    }
                    if (packetFlushable) self.trigger("data", event);
                };
                ElementaryStream.prototype.init.call(this);
                this.push = function(data) {
                    ({
                        pat: function() {},
                        pes: function() {
                            var stream, streamType;
                            switch (data.streamType) {
                              case StreamTypes$2.H264_STREAM_TYPE:
                                stream = video;
                                streamType = "video";
                                break;

                              case StreamTypes$2.ADTS_STREAM_TYPE:
                                stream = audio;
                                streamType = "audio";
                                break;

                              case StreamTypes$2.METADATA_STREAM_TYPE:
                                stream = timedMetadata;
                                streamType = "timed-metadata";
                                break;

                              default:
                                return;
                            }
                            if (data.payloadUnitStartIndicator) flushStream(stream, streamType, true);
                            stream.data.push(data);
                            stream.size += data.data.byteLength;
                        },
                        pmt: function() {
                            var event = {
                                type: "metadata",
                                tracks: []
                            };
                            programMapTable = data.programMapTable;
                            if (programMapTable.video !== null) event.tracks.push({
                                timelineStartInfo: {
                                    baseMediaDecodeTime: 0
                                },
                                id: +programMapTable.video,
                                codec: "avc",
                                type: "video"
                            });
                            if (programMapTable.audio !== null) event.tracks.push({
                                timelineStartInfo: {
                                    baseMediaDecodeTime: 0
                                },
                                id: +programMapTable.audio,
                                codec: "adts",
                                type: "audio"
                            });
                            segmentHadPmt = true;
                            self.trigger("data", event);
                        }
                    })[data.type]();
                };
                this.reset = function() {
                    video.size = 0;
                    video.data.length = 0;
                    audio.size = 0;
                    audio.data.length = 0;
                    this.trigger("reset");
                };
                this.flushStreams_ = function() {
                    flushStream(video, "video");
                    flushStream(audio, "audio");
                    flushStream(timedMetadata, "timed-metadata");
                };
                this.flush = function() {
                    if (!segmentHadPmt && programMapTable) {
                        var pmt = {
                            type: "metadata",
                            tracks: []
                        };
                        if (programMapTable.video !== null) pmt.tracks.push({
                            timelineStartInfo: {
                                baseMediaDecodeTime: 0
                            },
                            id: +programMapTable.video,
                            codec: "avc",
                            type: "video"
                        });
                        if (programMapTable.audio !== null) pmt.tracks.push({
                            timelineStartInfo: {
                                baseMediaDecodeTime: 0
                            },
                            id: +programMapTable.audio,
                            codec: "adts",
                            type: "audio"
                        });
                        self.trigger("data", pmt);
                    }
                    segmentHadPmt = false;
                    this.flushStreams_();
                    this.trigger("done");
                };
            };
            ElementaryStream.prototype = new Stream$4;
            var m2ts$1 = {
                PAT_PID: 0,
                MP2T_PACKET_LENGTH: MP2T_PACKET_LENGTH$1,
                TransportPacketStream,
                TransportParseStream,
                ElementaryStream,
                TimestampRolloverStream,
                CaptionStream: CaptionStream$1.CaptionStream,
                Cea608Stream: CaptionStream$1.Cea608Stream,
                Cea708Stream: CaptionStream$1.Cea708Stream,
                MetadataStream: metadataStream
            };
            for (var type in StreamTypes$2) if (StreamTypes$2.hasOwnProperty(type)) m2ts$1[type] = StreamTypes$2[type];
            var m2ts_1 = m2ts$1;
            var Stream$3 = stream;
            var ONE_SECOND_IN_TS$2 = clock$2.ONE_SECOND_IN_TS;
            var AdtsStream$1;
            var ADTS_SAMPLING_FREQUENCIES$1 = [ 96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350 ];
            AdtsStream$1 = function(handlePartialSegments) {
                var buffer, frameNum = 0;
                AdtsStream$1.prototype.init.call(this);
                this.skipWarn_ = function(start, end) {
                    this.trigger("log", {
                        level: "warn",
                        message: `adts skiping bytes ${start} to ${end} in frame ${frameNum} outside syncword`
                    });
                };
                this.push = function(packet) {
                    var frameLength, protectionSkipBytes, oldBuffer, sampleCount, adtsFrameDuration, i = 0;
                    if (!handlePartialSegments) frameNum = 0;
                    if (packet.type !== "audio") return;
                    if (buffer && buffer.length) {
                        oldBuffer = buffer;
                        buffer = new Uint8Array(oldBuffer.byteLength + packet.data.byteLength);
                        buffer.set(oldBuffer);
                        buffer.set(packet.data, oldBuffer.byteLength);
                    } else buffer = packet.data;
                    var skip;
                    while (i + 7 < buffer.length) {
                        if (buffer[i] !== 255 || (buffer[i + 1] & 246) !== 240) {
                            if (typeof skip !== "number") skip = i;
                            i++;
                            continue;
                        }
                        if (typeof skip === "number") {
                            this.skipWarn_(skip, i);
                            skip = null;
                        }
                        protectionSkipBytes = (~buffer[i + 1] & 1) * 2;
                        frameLength = (buffer[i + 3] & 3) << 11 | buffer[i + 4] << 3 | (buffer[i + 5] & 224) >> 5;
                        sampleCount = ((buffer[i + 6] & 3) + 1) * 1024;
                        adtsFrameDuration = sampleCount * ONE_SECOND_IN_TS$2 / ADTS_SAMPLING_FREQUENCIES$1[(buffer[i + 2] & 60) >>> 2];
                        if (buffer.byteLength - i < frameLength) break;
                        this.trigger("data", {
                            pts: packet.pts + frameNum * adtsFrameDuration,
                            dts: packet.dts + frameNum * adtsFrameDuration,
                            sampleCount,
                            audioobjecttype: (buffer[i + 2] >>> 6 & 3) + 1,
                            channelcount: (buffer[i + 2] & 1) << 2 | (buffer[i + 3] & 192) >>> 6,
                            samplerate: ADTS_SAMPLING_FREQUENCIES$1[(buffer[i + 2] & 60) >>> 2],
                            samplingfrequencyindex: (buffer[i + 2] & 60) >>> 2,
                            samplesize: 16,
                            data: buffer.subarray(i + 7 + protectionSkipBytes, i + frameLength)
                        });
                        frameNum++;
                        i += frameLength;
                    }
                    if (typeof skip === "number") {
                        this.skipWarn_(skip, i);
                        skip = null;
                    }
                    buffer = buffer.subarray(i);
                };
                this.flush = function() {
                    frameNum = 0;
                    this.trigger("done");
                };
                this.reset = function() {
                    buffer = void 0;
                    this.trigger("reset");
                };
                this.endTimeline = function() {
                    buffer = void 0;
                    this.trigger("endedtimeline");
                };
            };
            AdtsStream$1.prototype = new Stream$3;
            var adts = AdtsStream$1;
            var ExpGolomb$1;
            ExpGolomb$1 = function(workingData) {
                var workingBytesAvailable = workingData.byteLength, workingWord = 0, workingBitsAvailable = 0;
                this.length = function() {
                    return 8 * workingBytesAvailable;
                };
                this.bitsAvailable = function() {
                    return 8 * workingBytesAvailable + workingBitsAvailable;
                };
                this.loadWord = function() {
                    var position = workingData.byteLength - workingBytesAvailable, workingBytes = new Uint8Array(4), availableBytes = Math.min(4, workingBytesAvailable);
                    if (availableBytes === 0) throw new Error("no bytes available");
                    workingBytes.set(workingData.subarray(position, position + availableBytes));
                    workingWord = new DataView(workingBytes.buffer).getUint32(0);
                    workingBitsAvailable = availableBytes * 8;
                    workingBytesAvailable -= availableBytes;
                };
                this.skipBits = function(count) {
                    var skipBytes;
                    if (workingBitsAvailable > count) {
                        workingWord <<= count;
                        workingBitsAvailable -= count;
                    } else {
                        count -= workingBitsAvailable;
                        skipBytes = Math.floor(count / 8);
                        count -= skipBytes * 8;
                        workingBytesAvailable -= skipBytes;
                        this.loadWord();
                        workingWord <<= count;
                        workingBitsAvailable -= count;
                    }
                };
                this.readBits = function(size) {
                    var bits = Math.min(workingBitsAvailable, size), valu = workingWord >>> 32 - bits;
                    workingBitsAvailable -= bits;
                    if (workingBitsAvailable > 0) workingWord <<= bits; else if (workingBytesAvailable > 0) this.loadWord();
                    bits = size - bits;
                    if (bits > 0) return valu << bits | this.readBits(bits);
                    return valu;
                };
                this.skipLeadingZeros = function() {
                    var leadingZeroCount;
                    for (leadingZeroCount = 0; leadingZeroCount < workingBitsAvailable; ++leadingZeroCount) if ((workingWord & 2147483648 >>> leadingZeroCount) !== 0) {
                        workingWord <<= leadingZeroCount;
                        workingBitsAvailable -= leadingZeroCount;
                        return leadingZeroCount;
                    }
                    this.loadWord();
                    return leadingZeroCount + this.skipLeadingZeros();
                };
                this.skipUnsignedExpGolomb = function() {
                    this.skipBits(1 + this.skipLeadingZeros());
                };
                this.skipExpGolomb = function() {
                    this.skipBits(1 + this.skipLeadingZeros());
                };
                this.readUnsignedExpGolomb = function() {
                    var clz = this.skipLeadingZeros();
                    return this.readBits(clz + 1) - 1;
                };
                this.readExpGolomb = function() {
                    var valu = this.readUnsignedExpGolomb();
                    if (1 & valu) return 1 + valu >>> 1;
                    return -1 * (valu >>> 1);
                };
                this.readBoolean = function() {
                    return this.readBits(1) === 1;
                };
                this.readUnsignedByte = function() {
                    return this.readBits(8);
                };
                this.loadWord();
            };
            var expGolomb = ExpGolomb$1;
            var Stream$2 = stream;
            var ExpGolomb = expGolomb;
            var H264Stream$1, NalByteStream;
            var PROFILES_WITH_OPTIONAL_SPS_DATA;
            NalByteStream = function() {
                var i, buffer, syncPoint = 0;
                NalByteStream.prototype.init.call(this);
                this.push = function(data) {
                    var swapBuffer;
                    if (!buffer) buffer = data.data; else {
                        swapBuffer = new Uint8Array(buffer.byteLength + data.data.byteLength);
                        swapBuffer.set(buffer);
                        swapBuffer.set(data.data, buffer.byteLength);
                        buffer = swapBuffer;
                    }
                    var len = buffer.byteLength;
                    for (;syncPoint < len - 3; syncPoint++) if (buffer[syncPoint + 2] === 1) {
                        i = syncPoint + 5;
                        break;
                    }
                    while (i < len) switch (buffer[i]) {
                      case 0:
                        if (buffer[i - 1] !== 0) {
                            i += 2;
                            break;
                        } else if (buffer[i - 2] !== 0) {
                            i++;
                            break;
                        }
                        if (syncPoint + 3 !== i - 2) this.trigger("data", buffer.subarray(syncPoint + 3, i - 2));
                        do {
                            i++;
                        } while (buffer[i] !== 1 && i < len);
                        syncPoint = i - 2;
                        i += 3;
                        break;

                      case 1:
                        if (buffer[i - 1] !== 0 || buffer[i - 2] !== 0) {
                            i += 3;
                            break;
                        }
                        this.trigger("data", buffer.subarray(syncPoint + 3, i - 2));
                        syncPoint = i - 2;
                        i += 3;
                        break;

                      default:
                        i += 3;
                        break;
                    }
                    buffer = buffer.subarray(syncPoint);
                    i -= syncPoint;
                    syncPoint = 0;
                };
                this.reset = function() {
                    buffer = null;
                    syncPoint = 0;
                    this.trigger("reset");
                };
                this.flush = function() {
                    if (buffer && buffer.byteLength > 3) this.trigger("data", buffer.subarray(syncPoint + 3));
                    buffer = null;
                    syncPoint = 0;
                    this.trigger("done");
                };
                this.endTimeline = function() {
                    this.flush();
                    this.trigger("endedtimeline");
                };
            };
            NalByteStream.prototype = new Stream$2;
            PROFILES_WITH_OPTIONAL_SPS_DATA = {
                100: true,
                110: true,
                122: true,
                244: true,
                44: true,
                83: true,
                86: true,
                118: true,
                128: true,
                138: true,
                139: true,
                134: true
            };
            H264Stream$1 = function() {
                var self, trackId, currentPts, currentDts, discardEmulationPreventionBytes, readSequenceParameterSet, skipScalingList, nalByteStream = new NalByteStream;
                H264Stream$1.prototype.init.call(this);
                self = this;
                this.push = function(packet) {
                    if (packet.type !== "video") return;
                    trackId = packet.trackId;
                    currentPts = packet.pts;
                    currentDts = packet.dts;
                    nalByteStream.push(packet);
                };
                nalByteStream.on("data", (function(data) {
                    var event = {
                        trackId,
                        pts: currentPts,
                        dts: currentDts,
                        data,
                        nalUnitTypeCode: data[0] & 31
                    };
                    switch (event.nalUnitTypeCode) {
                      case 5:
                        event.nalUnitType = "slice_layer_without_partitioning_rbsp_idr";
                        break;

                      case 6:
                        event.nalUnitType = "sei_rbsp";
                        event.escapedRBSP = discardEmulationPreventionBytes(data.subarray(1));
                        break;

                      case 7:
                        event.nalUnitType = "seq_parameter_set_rbsp";
                        event.escapedRBSP = discardEmulationPreventionBytes(data.subarray(1));
                        event.config = readSequenceParameterSet(event.escapedRBSP);
                        break;

                      case 8:
                        event.nalUnitType = "pic_parameter_set_rbsp";
                        break;

                      case 9:
                        event.nalUnitType = "access_unit_delimiter_rbsp";
                        break;
                    }
                    self.trigger("data", event);
                }));
                nalByteStream.on("done", (function() {
                    self.trigger("done");
                }));
                nalByteStream.on("partialdone", (function() {
                    self.trigger("partialdone");
                }));
                nalByteStream.on("reset", (function() {
                    self.trigger("reset");
                }));
                nalByteStream.on("endedtimeline", (function() {
                    self.trigger("endedtimeline");
                }));
                this.flush = function() {
                    nalByteStream.flush();
                };
                this.partialFlush = function() {
                    nalByteStream.partialFlush();
                };
                this.reset = function() {
                    nalByteStream.reset();
                };
                this.endTimeline = function() {
                    nalByteStream.endTimeline();
                };
                skipScalingList = function(count, expGolombDecoder) {
                    var j, deltaScale, lastScale = 8, nextScale = 8;
                    for (j = 0; j < count; j++) {
                        if (nextScale !== 0) {
                            deltaScale = expGolombDecoder.readExpGolomb();
                            nextScale = (lastScale + deltaScale + 256) % 256;
                        }
                        lastScale = nextScale === 0 ? lastScale : nextScale;
                    }
                };
                discardEmulationPreventionBytes = function(data) {
                    var newLength, newData, length = data.byteLength, emulationPreventionBytesPositions = [], i = 1;
                    while (i < length - 2) if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 3) {
                        emulationPreventionBytesPositions.push(i + 2);
                        i += 2;
                    } else i++;
                    if (emulationPreventionBytesPositions.length === 0) return data;
                    newLength = length - emulationPreventionBytesPositions.length;
                    newData = new Uint8Array(newLength);
                    var sourceIndex = 0;
                    for (i = 0; i < newLength; sourceIndex++, i++) {
                        if (sourceIndex === emulationPreventionBytesPositions[0]) {
                            sourceIndex++;
                            emulationPreventionBytesPositions.shift();
                        }
                        newData[i] = data[sourceIndex];
                    }
                    return newData;
                };
                readSequenceParameterSet = function(data) {
                    var expGolombDecoder, profileIdc, levelIdc, profileCompatibility, chromaFormatIdc, picOrderCntType, numRefFramesInPicOrderCntCycle, picWidthInMbsMinus1, picHeightInMapUnitsMinus1, frameMbsOnlyFlag, scalingListCount, aspectRatioIdc, i, frameCropLeftOffset = 0, frameCropRightOffset = 0, frameCropTopOffset = 0, frameCropBottomOffset = 0, sarRatio = [ 1, 1 ];
                    expGolombDecoder = new ExpGolomb(data);
                    profileIdc = expGolombDecoder.readUnsignedByte();
                    profileCompatibility = expGolombDecoder.readUnsignedByte();
                    levelIdc = expGolombDecoder.readUnsignedByte();
                    expGolombDecoder.skipUnsignedExpGolomb();
                    if (PROFILES_WITH_OPTIONAL_SPS_DATA[profileIdc]) {
                        chromaFormatIdc = expGolombDecoder.readUnsignedExpGolomb();
                        if (chromaFormatIdc === 3) expGolombDecoder.skipBits(1);
                        expGolombDecoder.skipUnsignedExpGolomb();
                        expGolombDecoder.skipUnsignedExpGolomb();
                        expGolombDecoder.skipBits(1);
                        if (expGolombDecoder.readBoolean()) {
                            scalingListCount = chromaFormatIdc !== 3 ? 8 : 12;
                            for (i = 0; i < scalingListCount; i++) if (expGolombDecoder.readBoolean()) if (i < 6) skipScalingList(16, expGolombDecoder); else skipScalingList(64, expGolombDecoder);
                        }
                    }
                    expGolombDecoder.skipUnsignedExpGolomb();
                    picOrderCntType = expGolombDecoder.readUnsignedExpGolomb();
                    if (picOrderCntType === 0) expGolombDecoder.readUnsignedExpGolomb(); else if (picOrderCntType === 1) {
                        expGolombDecoder.skipBits(1);
                        expGolombDecoder.skipExpGolomb();
                        expGolombDecoder.skipExpGolomb();
                        numRefFramesInPicOrderCntCycle = expGolombDecoder.readUnsignedExpGolomb();
                        for (i = 0; i < numRefFramesInPicOrderCntCycle; i++) expGolombDecoder.skipExpGolomb();
                    }
                    expGolombDecoder.skipUnsignedExpGolomb();
                    expGolombDecoder.skipBits(1);
                    picWidthInMbsMinus1 = expGolombDecoder.readUnsignedExpGolomb();
                    picHeightInMapUnitsMinus1 = expGolombDecoder.readUnsignedExpGolomb();
                    frameMbsOnlyFlag = expGolombDecoder.readBits(1);
                    if (frameMbsOnlyFlag === 0) expGolombDecoder.skipBits(1);
                    expGolombDecoder.skipBits(1);
                    if (expGolombDecoder.readBoolean()) {
                        frameCropLeftOffset = expGolombDecoder.readUnsignedExpGolomb();
                        frameCropRightOffset = expGolombDecoder.readUnsignedExpGolomb();
                        frameCropTopOffset = expGolombDecoder.readUnsignedExpGolomb();
                        frameCropBottomOffset = expGolombDecoder.readUnsignedExpGolomb();
                    }
                    if (expGolombDecoder.readBoolean()) if (expGolombDecoder.readBoolean()) {
                        aspectRatioIdc = expGolombDecoder.readUnsignedByte();
                        switch (aspectRatioIdc) {
                          case 1:
                            sarRatio = [ 1, 1 ];
                            break;

                          case 2:
                            sarRatio = [ 12, 11 ];
                            break;

                          case 3:
                            sarRatio = [ 10, 11 ];
                            break;

                          case 4:
                            sarRatio = [ 16, 11 ];
                            break;

                          case 5:
                            sarRatio = [ 40, 33 ];
                            break;

                          case 6:
                            sarRatio = [ 24, 11 ];
                            break;

                          case 7:
                            sarRatio = [ 20, 11 ];
                            break;

                          case 8:
                            sarRatio = [ 32, 11 ];
                            break;

                          case 9:
                            sarRatio = [ 80, 33 ];
                            break;

                          case 10:
                            sarRatio = [ 18, 11 ];
                            break;

                          case 11:
                            sarRatio = [ 15, 11 ];
                            break;

                          case 12:
                            sarRatio = [ 64, 33 ];
                            break;

                          case 13:
                            sarRatio = [ 160, 99 ];
                            break;

                          case 14:
                            sarRatio = [ 4, 3 ];
                            break;

                          case 15:
                            sarRatio = [ 3, 2 ];
                            break;

                          case 16:
                            sarRatio = [ 2, 1 ];
                            break;

                          case 255:
                            sarRatio = [ expGolombDecoder.readUnsignedByte() << 8 | expGolombDecoder.readUnsignedByte(), expGolombDecoder.readUnsignedByte() << 8 | expGolombDecoder.readUnsignedByte() ];
                            break;
                        }
                        if (sarRatio) sarRatio[0] / sarRatio[1];
                    }
                    return {
                        profileIdc,
                        levelIdc,
                        profileCompatibility,
                        width: (picWidthInMbsMinus1 + 1) * 16 - frameCropLeftOffset * 2 - frameCropRightOffset * 2,
                        height: (2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16 - frameCropTopOffset * 2 - frameCropBottomOffset * 2,
                        sarRatio
                    };
                };
            };
            H264Stream$1.prototype = new Stream$2;
            var h264 = {
                H264Stream: H264Stream$1,
                NalByteStream
            };
            var ADTS_SAMPLING_FREQUENCIES = [ 96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350 ];
            var parseId3TagSize = function(header, byteIndex) {
                var returnSize = header[byteIndex + 6] << 21 | header[byteIndex + 7] << 14 | header[byteIndex + 8] << 7 | header[byteIndex + 9], flags = header[byteIndex + 5], footerPresent = (flags & 16) >> 4;
                returnSize = returnSize >= 0 ? returnSize : 0;
                if (footerPresent) return returnSize + 20;
                return returnSize + 10;
            };
            var getId3Offset = function(data, offset) {
                if (data.length - offset < 10 || data[offset] !== "I".charCodeAt(0) || data[offset + 1] !== "D".charCodeAt(0) || data[offset + 2] !== "3".charCodeAt(0)) return offset;
                offset += parseId3TagSize(data, offset);
                return getId3Offset(data, offset);
            };
            var isLikelyAacData$1 = function(data) {
                var offset = getId3Offset(data, 0);
                return data.length >= offset + 2 && (data[offset] & 255) === 255 && (data[offset + 1] & 240) === 240 && (data[offset + 1] & 22) === 16;
            };
            var parseSyncSafeInteger = function(data) {
                return data[0] << 21 | data[1] << 14 | data[2] << 7 | data[3];
            };
            var percentEncode = function(bytes, start, end) {
                var i, result = "";
                for (i = start; i < end; i++) result += "%" + ("00" + bytes[i].toString(16)).slice(-2);
                return result;
            };
            var parseIso88591 = function(bytes, start, end) {
                return unescape(percentEncode(bytes, start, end));
            };
            var parseAdtsSize = function(header, byteIndex) {
                var lowThree = (header[byteIndex + 5] & 224) >> 5, middle = header[byteIndex + 4] << 3, highTwo = header[byteIndex + 3] & 3 << 11;
                return highTwo | middle | lowThree;
            };
            var parseType$5 = function(header, byteIndex) {
                if (header[byteIndex] === "I".charCodeAt(0) && header[byteIndex + 1] === "D".charCodeAt(0) && header[byteIndex + 2] === "3".charCodeAt(0)) return "timed-metadata"; else if (header[byteIndex] & 255 === 255 && (header[byteIndex + 1] & 240) === 240) return "audio";
                return null;
            };
            var parseSampleRate = function(packet) {
                var i = 0;
                while (i + 5 < packet.length) {
                    if (packet[i] !== 255 || (packet[i + 1] & 246) !== 240) {
                        i++;
                        continue;
                    }
                    return ADTS_SAMPLING_FREQUENCIES[(packet[i + 2] & 60) >>> 2];
                }
                return null;
            };
            var parseAacTimestamp = function(packet) {
                var frameStart, frameSize, frame, frameHeader;
                frameStart = 10;
                if (packet[5] & 64) {
                    frameStart += 4;
                    frameStart += parseSyncSafeInteger(packet.subarray(10, 14));
                }
                do {
                    frameSize = parseSyncSafeInteger(packet.subarray(frameStart + 4, frameStart + 8));
                    if (frameSize < 1) return null;
                    frameHeader = String.fromCharCode(packet[frameStart], packet[frameStart + 1], packet[frameStart + 2], packet[frameStart + 3]);
                    if (frameHeader === "PRIV") {
                        frame = packet.subarray(frameStart + 10, frameStart + frameSize + 10);
                        for (var i = 0; i < frame.byteLength; i++) if (frame[i] === 0) {
                            var owner = parseIso88591(frame, 0, i);
                            if (owner === "com.apple.streaming.transportStreamTimestamp") {
                                var d = frame.subarray(i + 1);
                                var size = (d[3] & 1) << 30 | d[4] << 22 | d[5] << 14 | d[6] << 6 | d[7] >>> 2;
                                size *= 4;
                                size += d[7] & 3;
                                return size;
                            }
                            break;
                        }
                    }
                    frameStart += 10;
                    frameStart += frameSize;
                } while (frameStart < packet.byteLength);
                return null;
            };
            var utils = {
                isLikelyAacData: isLikelyAacData$1,
                parseId3TagSize,
                parseAdtsSize,
                parseType: parseType$5,
                parseSampleRate,
                parseAacTimestamp
            };
            var Stream$1 = stream;
            var aacUtils = utils;
            var AacStream$1;
            AacStream$1 = function() {
                var everything = new Uint8Array, timeStamp = 0;
                AacStream$1.prototype.init.call(this);
                this.setTimestamp = function(timestamp) {
                    timeStamp = timestamp;
                };
                this.push = function(bytes) {
                    var bytesLeft, chunk, packet, tempLength, frameSize = 0, byteIndex = 0;
                    if (everything.length) {
                        tempLength = everything.length;
                        everything = new Uint8Array(bytes.byteLength + tempLength);
                        everything.set(everything.subarray(0, tempLength));
                        everything.set(bytes, tempLength);
                    } else everything = bytes;
                    while (everything.length - byteIndex >= 3) {
                        if (everything[byteIndex] === "I".charCodeAt(0) && everything[byteIndex + 1] === "D".charCodeAt(0) && everything[byteIndex + 2] === "3".charCodeAt(0)) {
                            if (everything.length - byteIndex < 10) break;
                            frameSize = aacUtils.parseId3TagSize(everything, byteIndex);
                            if (byteIndex + frameSize > everything.length) break;
                            chunk = {
                                type: "timed-metadata",
                                data: everything.subarray(byteIndex, byteIndex + frameSize)
                            };
                            this.trigger("data", chunk);
                            byteIndex += frameSize;
                            continue;
                        } else if ((everything[byteIndex] & 255) === 255 && (everything[byteIndex + 1] & 240) === 240) {
                            if (everything.length - byteIndex < 7) break;
                            frameSize = aacUtils.parseAdtsSize(everything, byteIndex);
                            if (byteIndex + frameSize > everything.length) break;
                            packet = {
                                type: "audio",
                                data: everything.subarray(byteIndex, byteIndex + frameSize),
                                pts: timeStamp,
                                dts: timeStamp
                            };
                            this.trigger("data", packet);
                            byteIndex += frameSize;
                            continue;
                        }
                        byteIndex++;
                    }
                    bytesLeft = everything.length - byteIndex;
                    if (bytesLeft > 0) everything = everything.subarray(byteIndex); else everything = new Uint8Array;
                };
                this.reset = function() {
                    everything = new Uint8Array;
                    this.trigger("reset");
                };
                this.endTimeline = function() {
                    everything = new Uint8Array;
                    this.trigger("endedtimeline");
                };
            };
            AacStream$1.prototype = new Stream$1;
            var aac = AacStream$1;
            var AUDIO_PROPERTIES$1 = [ "audioobjecttype", "channelcount", "samplerate", "samplingfrequencyindex", "samplesize" ];
            var audioProperties = AUDIO_PROPERTIES$1;
            var VIDEO_PROPERTIES$1 = [ "width", "height", "profileIdc", "levelIdc", "profileCompatibility", "sarRatio" ];
            var videoProperties = VIDEO_PROPERTIES$1;
            var Stream = stream;
            var mp4 = mp4Generator;
            var frameUtils = frameUtils$1;
            var audioFrameUtils = audioFrameUtils$1;
            var trackDecodeInfo = trackDecodeInfo$1;
            var m2ts = m2ts_1;
            var clock = clock$2;
            var AdtsStream = adts;
            var H264Stream = h264.H264Stream;
            var AacStream = aac;
            var isLikelyAacData = utils.isLikelyAacData;
            var ONE_SECOND_IN_TS$1 = clock$2.ONE_SECOND_IN_TS;
            var AUDIO_PROPERTIES = audioProperties;
            var VIDEO_PROPERTIES = videoProperties;
            var VideoSegmentStream, AudioSegmentStream, Transmuxer, CoalesceStream;
            var retriggerForStream = function(key, event) {
                event.stream = key;
                this.trigger("log", event);
            };
            var addPipelineLogRetriggers = function(transmuxer, pipeline) {
                var keys = Object.keys(pipeline);
                for (var i = 0; i < keys.length; i++) {
                    var key = keys[i];
                    if (key === "headOfPipeline" || !pipeline[key].on) continue;
                    pipeline[key].on("log", retriggerForStream.bind(transmuxer, key));
                }
            };
            var arrayEquals = function(a, b) {
                var i;
                if (a.length !== b.length) return false;
                for (i = 0; i < a.length; i++) if (a[i] !== b[i]) return false;
                return true;
            };
            var generateSegmentTimingInfo = function(baseMediaDecodeTime, startDts, startPts, endDts, endPts, prependedContentDuration) {
                var ptsOffsetFromDts = startPts - startDts, decodeDuration = endDts - startDts, presentationDuration = endPts - startPts;
                return {
                    start: {
                        dts: baseMediaDecodeTime,
                        pts: baseMediaDecodeTime + ptsOffsetFromDts
                    },
                    end: {
                        dts: baseMediaDecodeTime + decodeDuration,
                        pts: baseMediaDecodeTime + presentationDuration
                    },
                    prependedContentDuration,
                    baseMediaDecodeTime
                };
            };
            AudioSegmentStream = function(track, options) {
                var sequenceNumber, adtsFrames = [], earliestAllowedDts = 0, audioAppendStartTs = 0, videoBaseMediaDecodeTime = 1 / 0;
                options = options || {};
                sequenceNumber = options.firstSequenceNumber || 0;
                AudioSegmentStream.prototype.init.call(this);
                this.push = function(data) {
                    trackDecodeInfo.collectDtsInfo(track, data);
                    if (track) AUDIO_PROPERTIES.forEach((function(prop) {
                        track[prop] = data[prop];
                    }));
                    adtsFrames.push(data);
                };
                this.setEarliestDts = function(earliestDts) {
                    earliestAllowedDts = earliestDts;
                };
                this.setVideoBaseMediaDecodeTime = function(baseMediaDecodeTime) {
                    videoBaseMediaDecodeTime = baseMediaDecodeTime;
                };
                this.setAudioAppendStart = function(timestamp) {
                    audioAppendStartTs = timestamp;
                };
                this.flush = function() {
                    var frames, moof, mdat, boxes, frameDuration, segmentDuration, videoClockCyclesOfSilencePrefixed;
                    if (adtsFrames.length === 0) {
                        this.trigger("done", "AudioSegmentStream");
                        return;
                    }
                    frames = audioFrameUtils.trimAdtsFramesByEarliestDts(adtsFrames, track, earliestAllowedDts);
                    track.baseMediaDecodeTime = trackDecodeInfo.calculateTrackBaseMediaDecodeTime(track, options.keepOriginalTimestamps);
                    videoClockCyclesOfSilencePrefixed = audioFrameUtils.prefixWithSilence(track, frames, audioAppendStartTs, videoBaseMediaDecodeTime);
                    track.samples = audioFrameUtils.generateSampleTable(frames);
                    mdat = mp4.mdat(audioFrameUtils.concatenateFrameData(frames));
                    adtsFrames = [];
                    moof = mp4.moof(sequenceNumber, [ track ]);
                    boxes = new Uint8Array(moof.byteLength + mdat.byteLength);
                    sequenceNumber++;
                    boxes.set(moof);
                    boxes.set(mdat, moof.byteLength);
                    trackDecodeInfo.clearDtsInfo(track);
                    frameDuration = Math.ceil(ONE_SECOND_IN_TS$1 * 1024 / track.samplerate);
                    if (frames.length) {
                        segmentDuration = frames.length * frameDuration;
                        this.trigger("segmentTimingInfo", generateSegmentTimingInfo(clock.audioTsToVideoTs(track.baseMediaDecodeTime, track.samplerate), frames[0].dts, frames[0].pts, frames[0].dts + segmentDuration, frames[0].pts + segmentDuration, videoClockCyclesOfSilencePrefixed || 0));
                        this.trigger("timingInfo", {
                            start: frames[0].pts,
                            end: frames[0].pts + segmentDuration
                        });
                    }
                    this.trigger("data", {
                        track,
                        boxes
                    });
                    this.trigger("done", "AudioSegmentStream");
                };
                this.reset = function() {
                    trackDecodeInfo.clearDtsInfo(track);
                    adtsFrames = [];
                    this.trigger("reset");
                };
            };
            AudioSegmentStream.prototype = new Stream;
            VideoSegmentStream = function(track, options) {
                var sequenceNumber, config, pps, nalUnits = [], gopsToAlignWith = [];
                options = options || {};
                sequenceNumber = options.firstSequenceNumber || 0;
                VideoSegmentStream.prototype.init.call(this);
                delete track.minPTS;
                this.gopCache_ = [];
                this.push = function(nalUnit) {
                    trackDecodeInfo.collectDtsInfo(track, nalUnit);
                    if (nalUnit.nalUnitType === "seq_parameter_set_rbsp" && !config) {
                        config = nalUnit.config;
                        track.sps = [ nalUnit.data ];
                        VIDEO_PROPERTIES.forEach((function(prop) {
                            track[prop] = config[prop];
                        }), this);
                    }
                    if (nalUnit.nalUnitType === "pic_parameter_set_rbsp" && !pps) {
                        pps = nalUnit.data;
                        track.pps = [ nalUnit.data ];
                    }
                    nalUnits.push(nalUnit);
                };
                this.flush = function() {
                    var frames, gopForFusion, gops, moof, mdat, boxes, firstGop, lastGop, prependedContentDuration = 0;
                    while (nalUnits.length) {
                        if (nalUnits[0].nalUnitType === "access_unit_delimiter_rbsp") break;
                        nalUnits.shift();
                    }
                    if (nalUnits.length === 0) {
                        this.resetStream_();
                        this.trigger("done", "VideoSegmentStream");
                        return;
                    }
                    frames = frameUtils.groupNalsIntoFrames(nalUnits);
                    gops = frameUtils.groupFramesIntoGops(frames);
                    if (!gops[0][0].keyFrame) {
                        gopForFusion = this.getGopForFusion_(nalUnits[0], track);
                        if (gopForFusion) {
                            prependedContentDuration = gopForFusion.duration;
                            gops.unshift(gopForFusion);
                            gops.byteLength += gopForFusion.byteLength;
                            gops.nalCount += gopForFusion.nalCount;
                            gops.pts = gopForFusion.pts;
                            gops.dts = gopForFusion.dts;
                            gops.duration += gopForFusion.duration;
                        } else gops = frameUtils.extendFirstKeyFrame(gops);
                    }
                    if (gopsToAlignWith.length) {
                        var alignedGops;
                        if (options.alignGopsAtEnd) alignedGops = this.alignGopsAtEnd_(gops); else alignedGops = this.alignGopsAtStart_(gops);
                        if (!alignedGops) {
                            this.gopCache_.unshift({
                                gop: gops.pop(),
                                pps: track.pps,
                                sps: track.sps
                            });
                            this.gopCache_.length = Math.min(6, this.gopCache_.length);
                            nalUnits = [];
                            this.resetStream_();
                            this.trigger("done", "VideoSegmentStream");
                            return;
                        }
                        trackDecodeInfo.clearDtsInfo(track);
                        gops = alignedGops;
                    }
                    trackDecodeInfo.collectDtsInfo(track, gops);
                    track.samples = frameUtils.generateSampleTable(gops);
                    mdat = mp4.mdat(frameUtils.concatenateNalData(gops));
                    track.baseMediaDecodeTime = trackDecodeInfo.calculateTrackBaseMediaDecodeTime(track, options.keepOriginalTimestamps);
                    this.trigger("processedGopsInfo", gops.map((function(gop) {
                        return {
                            pts: gop.pts,
                            dts: gop.dts,
                            byteLength: gop.byteLength
                        };
                    })));
                    firstGop = gops[0];
                    lastGop = gops[gops.length - 1];
                    this.trigger("segmentTimingInfo", generateSegmentTimingInfo(track.baseMediaDecodeTime, firstGop.dts, firstGop.pts, lastGop.dts + lastGop.duration, lastGop.pts + lastGop.duration, prependedContentDuration));
                    this.trigger("timingInfo", {
                        start: gops[0].pts,
                        end: gops[gops.length - 1].pts + gops[gops.length - 1].duration
                    });
                    this.gopCache_.unshift({
                        gop: gops.pop(),
                        pps: track.pps,
                        sps: track.sps
                    });
                    this.gopCache_.length = Math.min(6, this.gopCache_.length);
                    nalUnits = [];
                    this.trigger("baseMediaDecodeTime", track.baseMediaDecodeTime);
                    this.trigger("timelineStartInfo", track.timelineStartInfo);
                    moof = mp4.moof(sequenceNumber, [ track ]);
                    boxes = new Uint8Array(moof.byteLength + mdat.byteLength);
                    sequenceNumber++;
                    boxes.set(moof);
                    boxes.set(mdat, moof.byteLength);
                    this.trigger("data", {
                        track,
                        boxes
                    });
                    this.resetStream_();
                    this.trigger("done", "VideoSegmentStream");
                };
                this.reset = function() {
                    this.resetStream_();
                    nalUnits = [];
                    this.gopCache_.length = 0;
                    gopsToAlignWith.length = 0;
                    this.trigger("reset");
                };
                this.resetStream_ = function() {
                    trackDecodeInfo.clearDtsInfo(track);
                    config = void 0;
                    pps = void 0;
                };
                this.getGopForFusion_ = function(nalUnit) {
                    var dtsDistance, nearestGopObj, currentGop, currentGopObj, i, halfSecond = 45e3, allowableOverlap = 1e4, nearestDistance = 1 / 0;
                    for (i = 0; i < this.gopCache_.length; i++) {
                        currentGopObj = this.gopCache_[i];
                        currentGop = currentGopObj.gop;
                        if (!(track.pps && arrayEquals(track.pps[0], currentGopObj.pps[0])) || !(track.sps && arrayEquals(track.sps[0], currentGopObj.sps[0]))) continue;
                        if (currentGop.dts < track.timelineStartInfo.dts) continue;
                        dtsDistance = nalUnit.dts - currentGop.dts - currentGop.duration;
                        if (dtsDistance >= -allowableOverlap && dtsDistance <= halfSecond) if (!nearestGopObj || nearestDistance > dtsDistance) {
                            nearestGopObj = currentGopObj;
                            nearestDistance = dtsDistance;
                        }
                    }
                    if (nearestGopObj) return nearestGopObj.gop;
                    return null;
                };
                this.alignGopsAtStart_ = function(gops) {
                    var alignIndex, gopIndex, align, gop, byteLength, nalCount, duration, alignedGops;
                    byteLength = gops.byteLength;
                    nalCount = gops.nalCount;
                    duration = gops.duration;
                    alignIndex = gopIndex = 0;
                    while (alignIndex < gopsToAlignWith.length && gopIndex < gops.length) {
                        align = gopsToAlignWith[alignIndex];
                        gop = gops[gopIndex];
                        if (align.pts === gop.pts) break;
                        if (gop.pts > align.pts) {
                            alignIndex++;
                            continue;
                        }
                        gopIndex++;
                        byteLength -= gop.byteLength;
                        nalCount -= gop.nalCount;
                        duration -= gop.duration;
                    }
                    if (gopIndex === 0) return gops;
                    if (gopIndex === gops.length) return null;
                    alignedGops = gops.slice(gopIndex);
                    alignedGops.byteLength = byteLength;
                    alignedGops.duration = duration;
                    alignedGops.nalCount = nalCount;
                    alignedGops.pts = alignedGops[0].pts;
                    alignedGops.dts = alignedGops[0].dts;
                    return alignedGops;
                };
                this.alignGopsAtEnd_ = function(gops) {
                    var alignIndex, gopIndex, align, gop, alignEndIndex, matchFound;
                    alignIndex = gopsToAlignWith.length - 1;
                    gopIndex = gops.length - 1;
                    alignEndIndex = null;
                    matchFound = false;
                    while (alignIndex >= 0 && gopIndex >= 0) {
                        align = gopsToAlignWith[alignIndex];
                        gop = gops[gopIndex];
                        if (align.pts === gop.pts) {
                            matchFound = true;
                            break;
                        }
                        if (align.pts > gop.pts) {
                            alignIndex--;
                            continue;
                        }
                        if (alignIndex === gopsToAlignWith.length - 1) alignEndIndex = gopIndex;
                        gopIndex--;
                    }
                    if (!matchFound && alignEndIndex === null) return null;
                    var trimIndex;
                    if (matchFound) trimIndex = gopIndex; else trimIndex = alignEndIndex;
                    if (trimIndex === 0) return gops;
                    var alignedGops = gops.slice(trimIndex);
                    var metadata = alignedGops.reduce((function(total, gop) {
                        total.byteLength += gop.byteLength;
                        total.duration += gop.duration;
                        total.nalCount += gop.nalCount;
                        return total;
                    }), {
                        byteLength: 0,
                        duration: 0,
                        nalCount: 0
                    });
                    alignedGops.byteLength = metadata.byteLength;
                    alignedGops.duration = metadata.duration;
                    alignedGops.nalCount = metadata.nalCount;
                    alignedGops.pts = alignedGops[0].pts;
                    alignedGops.dts = alignedGops[0].dts;
                    return alignedGops;
                };
                this.alignGopsWith = function(newGopsToAlignWith) {
                    gopsToAlignWith = newGopsToAlignWith;
                };
            };
            VideoSegmentStream.prototype = new Stream;
            CoalesceStream = function(options, metadataStream) {
                this.numberOfTracks = 0;
                this.metadataStream = metadataStream;
                options = options || {};
                if (typeof options.remux !== "undefined") this.remuxTracks = !!options.remux; else this.remuxTracks = true;
                if (typeof options.keepOriginalTimestamps === "boolean") this.keepOriginalTimestamps = options.keepOriginalTimestamps; else this.keepOriginalTimestamps = false;
                this.pendingTracks = [];
                this.videoTrack = null;
                this.pendingBoxes = [];
                this.pendingCaptions = [];
                this.pendingMetadata = [];
                this.pendingBytes = 0;
                this.emittedTracks = 0;
                CoalesceStream.prototype.init.call(this);
                this.push = function(output) {
                    if (output.content || output.text) return this.pendingCaptions.push(output);
                    if (output.frames) return this.pendingMetadata.push(output);
                    this.pendingTracks.push(output.track);
                    this.pendingBytes += output.boxes.byteLength;
                    if (output.track.type === "video") {
                        this.videoTrack = output.track;
                        this.pendingBoxes.push(output.boxes);
                    }
                    if (output.track.type === "audio") {
                        this.audioTrack = output.track;
                        this.pendingBoxes.unshift(output.boxes);
                    }
                };
            };
            CoalesceStream.prototype = new Stream;
            CoalesceStream.prototype.flush = function(flushSource) {
                var caption, id3, initSegment, i, offset = 0, event = {
                    captions: [],
                    captionStreams: {},
                    metadata: [],
                    info: {}
                }, timelineStartPts = 0;
                if (this.pendingTracks.length < this.numberOfTracks) if (flushSource !== "VideoSegmentStream" && flushSource !== "AudioSegmentStream") return; else if (this.remuxTracks) return; else if (this.pendingTracks.length === 0) {
                    this.emittedTracks++;
                    if (this.emittedTracks >= this.numberOfTracks) {
                        this.trigger("done");
                        this.emittedTracks = 0;
                    }
                    return;
                }
                if (this.videoTrack) {
                    timelineStartPts = this.videoTrack.timelineStartInfo.pts;
                    VIDEO_PROPERTIES.forEach((function(prop) {
                        event.info[prop] = this.videoTrack[prop];
                    }), this);
                } else if (this.audioTrack) {
                    timelineStartPts = this.audioTrack.timelineStartInfo.pts;
                    AUDIO_PROPERTIES.forEach((function(prop) {
                        event.info[prop] = this.audioTrack[prop];
                    }), this);
                }
                if (this.videoTrack || this.audioTrack) {
                    if (this.pendingTracks.length === 1) event.type = this.pendingTracks[0].type; else event.type = "combined";
                    this.emittedTracks += this.pendingTracks.length;
                    initSegment = mp4.initSegment(this.pendingTracks);
                    event.initSegment = new Uint8Array(initSegment.byteLength);
                    event.initSegment.set(initSegment);
                    event.data = new Uint8Array(this.pendingBytes);
                    for (i = 0; i < this.pendingBoxes.length; i++) {
                        event.data.set(this.pendingBoxes[i], offset);
                        offset += this.pendingBoxes[i].byteLength;
                    }
                    for (i = 0; i < this.pendingCaptions.length; i++) {
                        caption = this.pendingCaptions[i];
                        caption.startTime = clock.metadataTsToSeconds(caption.startPts, timelineStartPts, this.keepOriginalTimestamps);
                        caption.endTime = clock.metadataTsToSeconds(caption.endPts, timelineStartPts, this.keepOriginalTimestamps);
                        event.captionStreams[caption.stream] = true;
                        event.captions.push(caption);
                    }
                    for (i = 0; i < this.pendingMetadata.length; i++) {
                        id3 = this.pendingMetadata[i];
                        id3.cueTime = clock.metadataTsToSeconds(id3.pts, timelineStartPts, this.keepOriginalTimestamps);
                        event.metadata.push(id3);
                    }
                    event.metadata.dispatchType = this.metadataStream.dispatchType;
                    this.pendingTracks.length = 0;
                    this.videoTrack = null;
                    this.pendingBoxes.length = 0;
                    this.pendingCaptions.length = 0;
                    this.pendingBytes = 0;
                    this.pendingMetadata.length = 0;
                    this.trigger("data", event);
                    for (i = 0; i < event.captions.length; i++) {
                        caption = event.captions[i];
                        this.trigger("caption", caption);
                    }
                    for (i = 0; i < event.metadata.length; i++) {
                        id3 = event.metadata[i];
                        this.trigger("id3Frame", id3);
                    }
                }
                if (this.emittedTracks >= this.numberOfTracks) {
                    this.trigger("done");
                    this.emittedTracks = 0;
                }
            };
            CoalesceStream.prototype.setRemux = function(val) {
                this.remuxTracks = val;
            };
            Transmuxer = function(options) {
                var videoTrack, audioTrack, self = this, hasFlushed = true;
                Transmuxer.prototype.init.call(this);
                options = options || {};
                this.baseMediaDecodeTime = options.baseMediaDecodeTime || 0;
                this.transmuxPipeline_ = {};
                this.setupAacPipeline = function() {
                    var pipeline = {};
                    this.transmuxPipeline_ = pipeline;
                    pipeline.type = "aac";
                    pipeline.metadataStream = new m2ts.MetadataStream;
                    pipeline.aacStream = new AacStream;
                    pipeline.audioTimestampRolloverStream = new m2ts.TimestampRolloverStream("audio");
                    pipeline.timedMetadataTimestampRolloverStream = new m2ts.TimestampRolloverStream("timed-metadata");
                    pipeline.adtsStream = new AdtsStream;
                    pipeline.coalesceStream = new CoalesceStream(options, pipeline.metadataStream);
                    pipeline.headOfPipeline = pipeline.aacStream;
                    pipeline.aacStream.pipe(pipeline.audioTimestampRolloverStream).pipe(pipeline.adtsStream);
                    pipeline.aacStream.pipe(pipeline.timedMetadataTimestampRolloverStream).pipe(pipeline.metadataStream).pipe(pipeline.coalesceStream);
                    pipeline.metadataStream.on("timestamp", (function(frame) {
                        pipeline.aacStream.setTimestamp(frame.timeStamp);
                    }));
                    pipeline.aacStream.on("data", (function(data) {
                        if (data.type !== "timed-metadata" && data.type !== "audio" || pipeline.audioSegmentStream) return;
                        audioTrack = audioTrack || {
                            timelineStartInfo: {
                                baseMediaDecodeTime: self.baseMediaDecodeTime
                            },
                            codec: "adts",
                            type: "audio"
                        };
                        pipeline.coalesceStream.numberOfTracks++;
                        pipeline.audioSegmentStream = new AudioSegmentStream(audioTrack, options);
                        pipeline.audioSegmentStream.on("log", self.getLogTrigger_("audioSegmentStream"));
                        pipeline.audioSegmentStream.on("timingInfo", self.trigger.bind(self, "audioTimingInfo"));
                        pipeline.adtsStream.pipe(pipeline.audioSegmentStream).pipe(pipeline.coalesceStream);
                        self.trigger("trackinfo", {
                            hasAudio: !!audioTrack,
                            hasVideo: !!videoTrack
                        });
                    }));
                    pipeline.coalesceStream.on("data", this.trigger.bind(this, "data"));
                    pipeline.coalesceStream.on("done", this.trigger.bind(this, "done"));
                    addPipelineLogRetriggers(this, pipeline);
                };
                this.setupTsPipeline = function() {
                    var pipeline = {};
                    this.transmuxPipeline_ = pipeline;
                    pipeline.type = "ts";
                    pipeline.metadataStream = new m2ts.MetadataStream;
                    pipeline.packetStream = new m2ts.TransportPacketStream;
                    pipeline.parseStream = new m2ts.TransportParseStream;
                    pipeline.elementaryStream = new m2ts.ElementaryStream;
                    pipeline.timestampRolloverStream = new m2ts.TimestampRolloverStream;
                    pipeline.adtsStream = new AdtsStream;
                    pipeline.h264Stream = new H264Stream;
                    pipeline.captionStream = new m2ts.CaptionStream(options);
                    pipeline.coalesceStream = new CoalesceStream(options, pipeline.metadataStream);
                    pipeline.headOfPipeline = pipeline.packetStream;
                    pipeline.packetStream.pipe(pipeline.parseStream).pipe(pipeline.elementaryStream).pipe(pipeline.timestampRolloverStream);
                    pipeline.timestampRolloverStream.pipe(pipeline.h264Stream);
                    pipeline.timestampRolloverStream.pipe(pipeline.adtsStream);
                    pipeline.timestampRolloverStream.pipe(pipeline.metadataStream).pipe(pipeline.coalesceStream);
                    pipeline.h264Stream.pipe(pipeline.captionStream).pipe(pipeline.coalesceStream);
                    pipeline.elementaryStream.on("data", (function(data) {
                        var i;
                        if (data.type === "metadata") {
                            i = data.tracks.length;
                            while (i--) if (!videoTrack && data.tracks[i].type === "video") {
                                videoTrack = data.tracks[i];
                                videoTrack.timelineStartInfo.baseMediaDecodeTime = self.baseMediaDecodeTime;
                            } else if (!audioTrack && data.tracks[i].type === "audio") {
                                audioTrack = data.tracks[i];
                                audioTrack.timelineStartInfo.baseMediaDecodeTime = self.baseMediaDecodeTime;
                            }
                            if (videoTrack && !pipeline.videoSegmentStream) {
                                pipeline.coalesceStream.numberOfTracks++;
                                pipeline.videoSegmentStream = new VideoSegmentStream(videoTrack, options);
                                pipeline.videoSegmentStream.on("log", self.getLogTrigger_("videoSegmentStream"));
                                pipeline.videoSegmentStream.on("timelineStartInfo", (function(timelineStartInfo) {
                                    if (audioTrack && !options.keepOriginalTimestamps) {
                                        audioTrack.timelineStartInfo = timelineStartInfo;
                                        pipeline.audioSegmentStream.setEarliestDts(timelineStartInfo.dts - self.baseMediaDecodeTime);
                                    }
                                }));
                                pipeline.videoSegmentStream.on("processedGopsInfo", self.trigger.bind(self, "gopInfo"));
                                pipeline.videoSegmentStream.on("segmentTimingInfo", self.trigger.bind(self, "videoSegmentTimingInfo"));
                                pipeline.videoSegmentStream.on("baseMediaDecodeTime", (function(baseMediaDecodeTime) {
                                    if (audioTrack) pipeline.audioSegmentStream.setVideoBaseMediaDecodeTime(baseMediaDecodeTime);
                                }));
                                pipeline.videoSegmentStream.on("timingInfo", self.trigger.bind(self, "videoTimingInfo"));
                                pipeline.h264Stream.pipe(pipeline.videoSegmentStream).pipe(pipeline.coalesceStream);
                            }
                            if (audioTrack && !pipeline.audioSegmentStream) {
                                pipeline.coalesceStream.numberOfTracks++;
                                pipeline.audioSegmentStream = new AudioSegmentStream(audioTrack, options);
                                pipeline.audioSegmentStream.on("log", self.getLogTrigger_("audioSegmentStream"));
                                pipeline.audioSegmentStream.on("timingInfo", self.trigger.bind(self, "audioTimingInfo"));
                                pipeline.audioSegmentStream.on("segmentTimingInfo", self.trigger.bind(self, "audioSegmentTimingInfo"));
                                pipeline.adtsStream.pipe(pipeline.audioSegmentStream).pipe(pipeline.coalesceStream);
                            }
                            self.trigger("trackinfo", {
                                hasAudio: !!audioTrack,
                                hasVideo: !!videoTrack
                            });
                        }
                    }));
                    pipeline.coalesceStream.on("data", this.trigger.bind(this, "data"));
                    pipeline.coalesceStream.on("id3Frame", (function(id3Frame) {
                        id3Frame.dispatchType = pipeline.metadataStream.dispatchType;
                        self.trigger("id3Frame", id3Frame);
                    }));
                    pipeline.coalesceStream.on("caption", this.trigger.bind(this, "caption"));
                    pipeline.coalesceStream.on("done", this.trigger.bind(this, "done"));
                    addPipelineLogRetriggers(this, pipeline);
                };
                this.setBaseMediaDecodeTime = function(baseMediaDecodeTime) {
                    var pipeline = this.transmuxPipeline_;
                    if (!options.keepOriginalTimestamps) this.baseMediaDecodeTime = baseMediaDecodeTime;
                    if (audioTrack) {
                        audioTrack.timelineStartInfo.dts = void 0;
                        audioTrack.timelineStartInfo.pts = void 0;
                        trackDecodeInfo.clearDtsInfo(audioTrack);
                        if (pipeline.audioTimestampRolloverStream) pipeline.audioTimestampRolloverStream.discontinuity();
                    }
                    if (videoTrack) {
                        if (pipeline.videoSegmentStream) pipeline.videoSegmentStream.gopCache_ = [];
                        videoTrack.timelineStartInfo.dts = void 0;
                        videoTrack.timelineStartInfo.pts = void 0;
                        trackDecodeInfo.clearDtsInfo(videoTrack);
                        pipeline.captionStream.reset();
                    }
                    if (pipeline.timestampRolloverStream) pipeline.timestampRolloverStream.discontinuity();
                };
                this.setAudioAppendStart = function(timestamp) {
                    if (audioTrack) this.transmuxPipeline_.audioSegmentStream.setAudioAppendStart(timestamp);
                };
                this.setRemux = function(val) {
                    var pipeline = this.transmuxPipeline_;
                    options.remux = val;
                    if (pipeline && pipeline.coalesceStream) pipeline.coalesceStream.setRemux(val);
                };
                this.alignGopsWith = function(gopsToAlignWith) {
                    if (videoTrack && this.transmuxPipeline_.videoSegmentStream) this.transmuxPipeline_.videoSegmentStream.alignGopsWith(gopsToAlignWith);
                };
                this.getLogTrigger_ = function(key) {
                    var self = this;
                    return function(event) {
                        event.stream = key;
                        self.trigger("log", event);
                    };
                };
                this.push = function(data) {
                    if (hasFlushed) {
                        var isAac = isLikelyAacData(data);
                        if (isAac && this.transmuxPipeline_.type !== "aac") this.setupAacPipeline(); else if (!isAac && this.transmuxPipeline_.type !== "ts") this.setupTsPipeline();
                        hasFlushed = false;
                    }
                    this.transmuxPipeline_.headOfPipeline.push(data);
                };
                this.flush = function() {
                    hasFlushed = true;
                    this.transmuxPipeline_.headOfPipeline.flush();
                };
                this.endTimeline = function() {
                    this.transmuxPipeline_.headOfPipeline.endTimeline();
                };
                this.reset = function() {
                    if (this.transmuxPipeline_.headOfPipeline) this.transmuxPipeline_.headOfPipeline.reset();
                };
                this.resetCaptions = function() {
                    if (this.transmuxPipeline_.captionStream) this.transmuxPipeline_.captionStream.reset();
                };
            };
            Transmuxer.prototype = new Stream;
            var transmuxer = {
                Transmuxer,
                VideoSegmentStream,
                AudioSegmentStream,
                AUDIO_PROPERTIES,
                VIDEO_PROPERTIES,
                generateSegmentTimingInfo
            };
            var toUnsigned$3 = function(value) {
                return value >>> 0;
            };
            var toHexString$1 = function(value) {
                return ("00" + value.toString(16)).slice(-2);
            };
            var bin = {
                toUnsigned: toUnsigned$3,
                toHexString: toHexString$1
            };
            var parseType$4 = function(buffer) {
                var result = "";
                result += String.fromCharCode(buffer[0]);
                result += String.fromCharCode(buffer[1]);
                result += String.fromCharCode(buffer[2]);
                result += String.fromCharCode(buffer[3]);
                return result;
            };
            var parseType_1 = parseType$4;
            var toUnsigned$2 = bin.toUnsigned;
            var parseType$3 = parseType_1;
            var findBox$5 = function(data, path) {
                var i, size, type, end, subresults, results = [];
                if (!path.length) return null;
                for (i = 0; i < data.byteLength; ) {
                    size = toUnsigned$2(data[i] << 24 | data[i + 1] << 16 | data[i + 2] << 8 | data[i + 3]);
                    type = parseType$3(data.subarray(i + 4, i + 8));
                    end = size > 1 ? i + size : data.byteLength;
                    if (type === path[0]) if (path.length === 1) results.push(data.subarray(i + 8, end)); else {
                        subresults = findBox$5(data.subarray(i + 8, end), path.slice(1));
                        if (subresults.length) results = results.concat(subresults);
                    }
                    i = end;
                }
                return results;
            };
            var findBox_1 = findBox$5;
            var toUnsigned$1 = bin.toUnsigned;
            var getUint64$4 = numbers.getUint64;
            var tfdt = function(data) {
                var result = {
                    version: data[0],
                    flags: new Uint8Array(data.subarray(1, 4))
                };
                if (result.version === 1) result.baseMediaDecodeTime = getUint64$4(data.subarray(4)); else result.baseMediaDecodeTime = toUnsigned$1(data[4] << 24 | data[5] << 16 | data[6] << 8 | data[7]);
                return result;
            };
            var parseTfdt$3 = tfdt;
            var tfhd = function(data) {
                var i, view = new DataView(data.buffer, data.byteOffset, data.byteLength), result = {
                    version: data[0],
                    flags: new Uint8Array(data.subarray(1, 4)),
                    trackId: view.getUint32(4)
                }, baseDataOffsetPresent = result.flags[2] & 1, sampleDescriptionIndexPresent = result.flags[2] & 2, defaultSampleDurationPresent = result.flags[2] & 8, defaultSampleSizePresent = result.flags[2] & 16, defaultSampleFlagsPresent = result.flags[2] & 32, durationIsEmpty = result.flags[0] & 65536, defaultBaseIsMoof = result.flags[0] & 131072;
                i = 8;
                if (baseDataOffsetPresent) {
                    i += 4;
                    result.baseDataOffset = view.getUint32(12);
                    i += 4;
                }
                if (sampleDescriptionIndexPresent) {
                    result.sampleDescriptionIndex = view.getUint32(i);
                    i += 4;
                }
                if (defaultSampleDurationPresent) {
                    result.defaultSampleDuration = view.getUint32(i);
                    i += 4;
                }
                if (defaultSampleSizePresent) {
                    result.defaultSampleSize = view.getUint32(i);
                    i += 4;
                }
                if (defaultSampleFlagsPresent) result.defaultSampleFlags = view.getUint32(i);
                if (durationIsEmpty) result.durationIsEmpty = true;
                if (!baseDataOffsetPresent && defaultBaseIsMoof) result.baseDataOffsetIsMoof = true;
                return result;
            };
            var parseTfhd$2 = tfhd;
            var getUint64$3 = numbers.getUint64;
            var parseSidx = function(data) {
                var view = new DataView(data.buffer, data.byteOffset, data.byteLength), result = {
                    version: data[0],
                    flags: new Uint8Array(data.subarray(1, 4)),
                    references: [],
                    referenceId: view.getUint32(4),
                    timescale: view.getUint32(8)
                }, i = 12;
                if (result.version === 0) {
                    result.earliestPresentationTime = view.getUint32(i);
                    result.firstOffset = view.getUint32(i + 4);
                    i += 8;
                } else {
                    result.earliestPresentationTime = getUint64$3(data.subarray(i));
                    result.firstOffset = getUint64$3(data.subarray(i + 8));
                    i += 16;
                }
                i += 2;
                var referenceCount = view.getUint16(i);
                i += 2;
                for (;referenceCount > 0; i += 12, referenceCount--) result.references.push({
                    referenceType: (data[i] & 128) >>> 7,
                    referencedSize: view.getUint32(i) & 2147483647,
                    subsegmentDuration: view.getUint32(i + 4),
                    startsWithSap: !!(data[i + 8] & 128),
                    sapType: (data[i + 8] & 112) >>> 4,
                    sapDeltaTime: view.getUint32(i + 8) & 268435455
                });
                return result;
            };
            var parseSidx_1 = parseSidx;
            var parseSampleFlags$1 = function(flags) {
                return {
                    isLeading: (flags[0] & 12) >>> 2,
                    dependsOn: flags[0] & 3,
                    isDependedOn: (flags[1] & 192) >>> 6,
                    hasRedundancy: (flags[1] & 48) >>> 4,
                    paddingValue: (flags[1] & 14) >>> 1,
                    isNonSyncSample: flags[1] & 1,
                    degradationPriority: flags[2] << 8 | flags[3]
                };
            };
            var parseSampleFlags_1 = parseSampleFlags$1;
            var parseSampleFlags = parseSampleFlags_1;
            var trun = function(data) {
                var sample, result = {
                    version: data[0],
                    flags: new Uint8Array(data.subarray(1, 4)),
                    samples: []
                }, view = new DataView(data.buffer, data.byteOffset, data.byteLength), dataOffsetPresent = result.flags[2] & 1, firstSampleFlagsPresent = result.flags[2] & 4, sampleDurationPresent = result.flags[1] & 1, sampleSizePresent = result.flags[1] & 2, sampleFlagsPresent = result.flags[1] & 4, sampleCompositionTimeOffsetPresent = result.flags[1] & 8, sampleCount = view.getUint32(4), offset = 8;
                if (dataOffsetPresent) {
                    result.dataOffset = view.getInt32(offset);
                    offset += 4;
                }
                if (firstSampleFlagsPresent && sampleCount) {
                    sample = {
                        flags: parseSampleFlags(data.subarray(offset, offset + 4))
                    };
                    offset += 4;
                    if (sampleDurationPresent) {
                        sample.duration = view.getUint32(offset);
                        offset += 4;
                    }
                    if (sampleSizePresent) {
                        sample.size = view.getUint32(offset);
                        offset += 4;
                    }
                    if (sampleCompositionTimeOffsetPresent) {
                        if (result.version === 1) sample.compositionTimeOffset = view.getInt32(offset); else sample.compositionTimeOffset = view.getUint32(offset);
                        offset += 4;
                    }
                    result.samples.push(sample);
                    sampleCount--;
                }
                while (sampleCount--) {
                    sample = {};
                    if (sampleDurationPresent) {
                        sample.duration = view.getUint32(offset);
                        offset += 4;
                    }
                    if (sampleSizePresent) {
                        sample.size = view.getUint32(offset);
                        offset += 4;
                    }
                    if (sampleFlagsPresent) {
                        sample.flags = parseSampleFlags(data.subarray(offset, offset + 4));
                        offset += 4;
                    }
                    if (sampleCompositionTimeOffsetPresent) {
                        if (result.version === 1) sample.compositionTimeOffset = view.getInt32(offset); else sample.compositionTimeOffset = view.getUint32(offset);
                        offset += 4;
                    }
                    result.samples.push(sample);
                }
                return result;
            };
            var parseTrun$2 = trun;
            var numberHelpers = numbers;
            var getUint64$2 = numberHelpers.getUint64;
            var inspectMp4, textifyMp4, parseMp4Date = function(seconds) {
                return new Date(seconds * 1e3 - 20828448e5);
            }, parseType$2 = parseType_1, findBox$4 = findBox_1, nalParse = function(avcStream) {
                var i, length, avcView = new DataView(avcStream.buffer, avcStream.byteOffset, avcStream.byteLength), result = [];
                for (i = 0; i + 4 < avcStream.length; i += length) {
                    length = avcView.getUint32(i);
                    i += 4;
                    if (length <= 0) {
                        result.push("<span style='color:red;'>MALFORMED DATA</span>");
                        continue;
                    }
                    switch (avcStream[i] & 31) {
                      case 1:
                        result.push("slice_layer_without_partitioning_rbsp");
                        break;

                      case 5:
                        result.push("slice_layer_without_partitioning_rbsp_idr");
                        break;

                      case 6:
                        result.push("sei_rbsp");
                        break;

                      case 7:
                        result.push("seq_parameter_set_rbsp");
                        break;

                      case 8:
                        result.push("pic_parameter_set_rbsp");
                        break;

                      case 9:
                        result.push("access_unit_delimiter_rbsp");
                        break;

                      default:
                        result.push("UNKNOWN NAL - " + avcStream[i] & 31);
                        break;
                    }
                }
                return result;
            }, parse = {
                avc1: function(data) {
                    var view = new DataView(data.buffer, data.byteOffset, data.byteLength);
                    return {
                        dataReferenceIndex: view.getUint16(6),
                        width: view.getUint16(24),
                        height: view.getUint16(26),
                        horizresolution: view.getUint16(28) + view.getUint16(30) / 16,
                        vertresolution: view.getUint16(32) + view.getUint16(34) / 16,
                        frameCount: view.getUint16(40),
                        depth: view.getUint16(74),
                        config: inspectMp4(data.subarray(78, data.byteLength))
                    };
                },
                avcC: function(data) {
                    var numOfPictureParameterSets, nalSize, offset, i, view = new DataView(data.buffer, data.byteOffset, data.byteLength), result = {
                        configurationVersion: data[0],
                        avcProfileIndication: data[1],
                        profileCompatibility: data[2],
                        avcLevelIndication: data[3],
                        lengthSizeMinusOne: data[4] & 3,
                        sps: [],
                        pps: []
                    }, numOfSequenceParameterSets = data[5] & 31;
                    offset = 6;
                    for (i = 0; i < numOfSequenceParameterSets; i++) {
                        nalSize = view.getUint16(offset);
                        offset += 2;
                        result.sps.push(new Uint8Array(data.subarray(offset, offset + nalSize)));
                        offset += nalSize;
                    }
                    numOfPictureParameterSets = data[offset];
                    offset++;
                    for (i = 0; i < numOfPictureParameterSets; i++) {
                        nalSize = view.getUint16(offset);
                        offset += 2;
                        result.pps.push(new Uint8Array(data.subarray(offset, offset + nalSize)));
                        offset += nalSize;
                    }
                    return result;
                },
                btrt: function(data) {
                    var view = new DataView(data.buffer, data.byteOffset, data.byteLength);
                    return {
                        bufferSizeDB: view.getUint32(0),
                        maxBitrate: view.getUint32(4),
                        avgBitrate: view.getUint32(8)
                    };
                },
                edts: function edts(data) {
                    return {
                        boxes: inspectMp4(data)
                    };
                },
                elst: function elst(data) {
                    var i, view = new DataView(data.buffer, data.byteOffset, data.byteLength), result = {
                        version: view.getUint8(0),
                        flags: new Uint8Array(data.subarray(1, 4)),
                        edits: []
                    }, entryCount = view.getUint32(4);
                    for (i = 8; entryCount; entryCount--) if (result.version === 0) {
                        result.edits.push({
                            segmentDuration: view.getUint32(i),
                            mediaTime: view.getInt32(i + 4),
                            mediaRate: view.getUint16(i + 8) + view.getUint16(i + 10) / (256 * 256)
                        });
                        i += 12;
                    } else {
                        result.edits.push({
                            segmentDuration: getUint64$2(data.subarray(i)),
                            mediaTime: getUint64$2(data.subarray(i + 8)),
                            mediaRate: view.getUint16(i + 16) + view.getUint16(i + 18) / (256 * 256)
                        });
                        i += 20;
                    }
                    return result;
                },
                esds: function(data) {
                    return {
                        version: data[0],
                        flags: new Uint8Array(data.subarray(1, 4)),
                        esId: data[6] << 8 | data[7],
                        streamPriority: data[8] & 31,
                        decoderConfig: {
                            objectProfileIndication: data[11],
                            streamType: data[12] >>> 2 & 63,
                            bufferSize: data[13] << 16 | data[14] << 8 | data[15],
                            maxBitrate: data[16] << 24 | data[17] << 16 | data[18] << 8 | data[19],
                            avgBitrate: data[20] << 24 | data[21] << 16 | data[22] << 8 | data[23],
                            decoderConfigDescriptor: {
                                tag: data[24],
                                length: data[25],
                                audioObjectType: data[26] >>> 3 & 31,
                                samplingFrequencyIndex: (data[26] & 7) << 1 | data[27] >>> 7 & 1,
                                channelConfiguration: data[27] >>> 3 & 15
                            }
                        }
                    };
                },
                ftyp: function(data) {
                    var view = new DataView(data.buffer, data.byteOffset, data.byteLength), result = {
                        majorBrand: parseType$2(data.subarray(0, 4)),
                        minorVersion: view.getUint32(4),
                        compatibleBrands: []
                    }, i = 8;
                    while (i < data.byteLength) {
                        result.compatibleBrands.push(parseType$2(data.subarray(i, i + 4)));
                        i += 4;
                    }
                    return result;
                },
                dinf: function(data) {
                    return {
                        boxes: inspectMp4(data)
                    };
                },
                dref: function(data) {
                    return {
                        version: data[0],
                        flags: new Uint8Array(data.subarray(1, 4)),
                        dataReferences: inspectMp4(data.subarray(8))
                    };
                },
                hdlr: function(data) {
                    var view = new DataView(data.buffer, data.byteOffset, data.byteLength), result = {
                        version: view.getUint8(0),
                        flags: new Uint8Array(data.subarray(1, 4)),
                        handlerType: parseType$2(data.subarray(8, 12)),
                        name: ""
                    }, i = 8;
                    for (i = 24; i < data.byteLength; i++) {
                        if (data[i] === 0) {
                            i++;
                            break;
                        }
                        result.name += String.fromCharCode(data[i]);
                    }
                    result.name = decodeURIComponent(escape(result.name));
                    return result;
                },
                mdat: function(data) {
                    return {
                        byteLength: data.byteLength,
                        nals: nalParse(data)
                    };
                },
                mdhd: function(data) {
                    var language, view = new DataView(data.buffer, data.byteOffset, data.byteLength), i = 4, result = {
                        version: view.getUint8(0),
                        flags: new Uint8Array(data.subarray(1, 4)),
                        language: ""
                    };
                    if (result.version === 1) {
                        i += 4;
                        result.creationTime = parseMp4Date(view.getUint32(i));
                        i += 8;
                        result.modificationTime = parseMp4Date(view.getUint32(i));
                        i += 4;
                        result.timescale = view.getUint32(i);
                        i += 8;
                        result.duration = view.getUint32(i);
                    } else {
                        result.creationTime = parseMp4Date(view.getUint32(i));
                        i += 4;
                        result.modificationTime = parseMp4Date(view.getUint32(i));
                        i += 4;
                        result.timescale = view.getUint32(i);
                        i += 4;
                        result.duration = view.getUint32(i);
                    }
                    i += 4;
                    language = view.getUint16(i);
                    result.language += String.fromCharCode((language >> 10) + 96);
                    result.language += String.fromCharCode(((language & 992) >> 5) + 96);
                    result.language += String.fromCharCode((language & 31) + 96);
                    return result;
                },
                mdia: function(data) {
                    return {
                        boxes: inspectMp4(data)
                    };
                },
                mfhd: function(data) {
                    return {
                        version: data[0],
                        flags: new Uint8Array(data.subarray(1, 4)),
                        sequenceNumber: data[4] << 24 | data[5] << 16 | data[6] << 8 | data[7]
                    };
                },
                minf: function(data) {
                    return {
                        boxes: inspectMp4(data)
                    };
                },
                mp4a: function(data) {
                    var view = new DataView(data.buffer, data.byteOffset, data.byteLength), result = {
                        dataReferenceIndex: view.getUint16(6),
                        channelcount: view.getUint16(16),
                        samplesize: view.getUint16(18),
                        samplerate: view.getUint16(24) + view.getUint16(26) / 65536
                    };
                    if (data.byteLength > 28) result.streamDescriptor = inspectMp4(data.subarray(28))[0];
                    return result;
                },
                moof: function(data) {
                    return {
                        boxes: inspectMp4(data)
                    };
                },
                moov: function(data) {
                    return {
                        boxes: inspectMp4(data)
                    };
                },
                mvex: function(data) {
                    return {
                        boxes: inspectMp4(data)
                    };
                },
                mvhd: function(data) {
                    var view = new DataView(data.buffer, data.byteOffset, data.byteLength), i = 4, result = {
                        version: view.getUint8(0),
                        flags: new Uint8Array(data.subarray(1, 4))
                    };
                    if (result.version === 1) {
                        i += 4;
                        result.creationTime = parseMp4Date(view.getUint32(i));
                        i += 8;
                        result.modificationTime = parseMp4Date(view.getUint32(i));
                        i += 4;
                        result.timescale = view.getUint32(i);
                        i += 8;
                        result.duration = view.getUint32(i);
                    } else {
                        result.creationTime = parseMp4Date(view.getUint32(i));
                        i += 4;
                        result.modificationTime = parseMp4Date(view.getUint32(i));
                        i += 4;
                        result.timescale = view.getUint32(i);
                        i += 4;
                        result.duration = view.getUint32(i);
                    }
                    i += 4;
                    result.rate = view.getUint16(i) + view.getUint16(i + 2) / 16;
                    i += 4;
                    result.volume = view.getUint8(i) + view.getUint8(i + 1) / 8;
                    i += 2;
                    i += 2;
                    i += 2 * 4;
                    result.matrix = new Uint32Array(data.subarray(i, i + 9 * 4));
                    i += 9 * 4;
                    i += 6 * 4;
                    result.nextTrackId = view.getUint32(i);
                    return result;
                },
                pdin: function(data) {
                    var view = new DataView(data.buffer, data.byteOffset, data.byteLength);
                    return {
                        version: view.getUint8(0),
                        flags: new Uint8Array(data.subarray(1, 4)),
                        rate: view.getUint32(4),
                        initialDelay: view.getUint32(8)
                    };
                },
                sdtp: function(data) {
                    var i, result = {
                        version: data[0],
                        flags: new Uint8Array(data.subarray(1, 4)),
                        samples: []
                    };
                    for (i = 4; i < data.byteLength; i++) result.samples.push({
                        dependsOn: (data[i] & 48) >> 4,
                        isDependedOn: (data[i] & 12) >> 2,
                        hasRedundancy: data[i] & 3
                    });
                    return result;
                },
                sidx: parseSidx_1,
                smhd: function(data) {
                    return {
                        version: data[0],
                        flags: new Uint8Array(data.subarray(1, 4)),
                        balance: data[4] + data[5] / 256
                    };
                },
                stbl: function(data) {
                    return {
                        boxes: inspectMp4(data)
                    };
                },
                ctts: function(data) {
                    var i, view = new DataView(data.buffer, data.byteOffset, data.byteLength), result = {
                        version: view.getUint8(0),
                        flags: new Uint8Array(data.subarray(1, 4)),
                        compositionOffsets: []
                    }, entryCount = view.getUint32(4);
                    for (i = 8; entryCount; i += 8, entryCount--) result.compositionOffsets.push({
                        sampleCount: view.getUint32(i),
                        sampleOffset: view[result.version === 0 ? "getUint32" : "getInt32"](i + 4)
                    });
                    return result;
                },
                stss: function(data) {
                    var i, view = new DataView(data.buffer, data.byteOffset, data.byteLength), result = {
                        version: view.getUint8(0),
                        flags: new Uint8Array(data.subarray(1, 4)),
                        syncSamples: []
                    }, entryCount = view.getUint32(4);
                    for (i = 8; entryCount; i += 4, entryCount--) result.syncSamples.push(view.getUint32(i));
                    return result;
                },
                stco: function(data) {
                    var i, view = new DataView(data.buffer, data.byteOffset, data.byteLength), result = {
                        version: data[0],
                        flags: new Uint8Array(data.subarray(1, 4)),
                        chunkOffsets: []
                    }, entryCount = view.getUint32(4);
                    for (i = 8; entryCount; i += 4, entryCount--) result.chunkOffsets.push(view.getUint32(i));
                    return result;
                },
                stsc: function(data) {
                    var i, view = new DataView(data.buffer, data.byteOffset, data.byteLength), entryCount = view.getUint32(4), result = {
                        version: data[0],
                        flags: new Uint8Array(data.subarray(1, 4)),
                        sampleToChunks: []
                    };
                    for (i = 8; entryCount; i += 12, entryCount--) result.sampleToChunks.push({
                        firstChunk: view.getUint32(i),
                        samplesPerChunk: view.getUint32(i + 4),
                        sampleDescriptionIndex: view.getUint32(i + 8)
                    });
                    return result;
                },
                stsd: function(data) {
                    return {
                        version: data[0],
                        flags: new Uint8Array(data.subarray(1, 4)),
                        sampleDescriptions: inspectMp4(data.subarray(8))
                    };
                },
                stsz: function(data) {
                    var i, view = new DataView(data.buffer, data.byteOffset, data.byteLength), result = {
                        version: data[0],
                        flags: new Uint8Array(data.subarray(1, 4)),
                        sampleSize: view.getUint32(4),
                        entries: []
                    };
                    for (i = 12; i < data.byteLength; i += 4) result.entries.push(view.getUint32(i));
                    return result;
                },
                stts: function(data) {
                    var i, view = new DataView(data.buffer, data.byteOffset, data.byteLength), result = {
                        version: data[0],
                        flags: new Uint8Array(data.subarray(1, 4)),
                        timeToSamples: []
                    }, entryCount = view.getUint32(4);
                    for (i = 8; entryCount; i += 8, entryCount--) result.timeToSamples.push({
                        sampleCount: view.getUint32(i),
                        sampleDelta: view.getUint32(i + 4)
                    });
                    return result;
                },
                styp: function(data) {
                    return parse.ftyp(data);
                },
                tfdt: parseTfdt$3,
                tfhd: parseTfhd$2,
                tkhd: function(data) {
                    var view = new DataView(data.buffer, data.byteOffset, data.byteLength), i = 4, result = {
                        version: view.getUint8(0),
                        flags: new Uint8Array(data.subarray(1, 4))
                    };
                    if (result.version === 1) {
                        i += 4;
                        result.creationTime = parseMp4Date(view.getUint32(i));
                        i += 8;
                        result.modificationTime = parseMp4Date(view.getUint32(i));
                        i += 4;
                        result.trackId = view.getUint32(i);
                        i += 4;
                        i += 8;
                        result.duration = view.getUint32(i);
                    } else {
                        result.creationTime = parseMp4Date(view.getUint32(i));
                        i += 4;
                        result.modificationTime = parseMp4Date(view.getUint32(i));
                        i += 4;
                        result.trackId = view.getUint32(i);
                        i += 4;
                        i += 4;
                        result.duration = view.getUint32(i);
                    }
                    i += 4;
                    i += 2 * 4;
                    result.layer = view.getUint16(i);
                    i += 2;
                    result.alternateGroup = view.getUint16(i);
                    i += 2;
                    result.volume = view.getUint8(i) + view.getUint8(i + 1) / 8;
                    i += 2;
                    i += 2;
                    result.matrix = new Uint32Array(data.subarray(i, i + 9 * 4));
                    i += 9 * 4;
                    result.width = view.getUint16(i) + view.getUint16(i + 2) / 65536;
                    i += 4;
                    result.height = view.getUint16(i) + view.getUint16(i + 2) / 65536;
                    return result;
                },
                traf: function(data) {
                    return {
                        boxes: inspectMp4(data)
                    };
                },
                trak: function(data) {
                    return {
                        boxes: inspectMp4(data)
                    };
                },
                trex: function(data) {
                    var view = new DataView(data.buffer, data.byteOffset, data.byteLength);
                    return {
                        version: data[0],
                        flags: new Uint8Array(data.subarray(1, 4)),
                        trackId: view.getUint32(4),
                        defaultSampleDescriptionIndex: view.getUint32(8),
                        defaultSampleDuration: view.getUint32(12),
                        defaultSampleSize: view.getUint32(16),
                        sampleDependsOn: data[20] & 3,
                        sampleIsDependedOn: (data[21] & 192) >> 6,
                        sampleHasRedundancy: (data[21] & 48) >> 4,
                        samplePaddingValue: (data[21] & 14) >> 1,
                        sampleIsDifferenceSample: !!(data[21] & 1),
                        sampleDegradationPriority: view.getUint16(22)
                    };
                },
                trun: parseTrun$2,
                "url ": function(data) {
                    return {
                        version: data[0],
                        flags: new Uint8Array(data.subarray(1, 4))
                    };
                },
                vmhd: function(data) {
                    var view = new DataView(data.buffer, data.byteOffset, data.byteLength);
                    return {
                        version: data[0],
                        flags: new Uint8Array(data.subarray(1, 4)),
                        graphicsmode: view.getUint16(4),
                        opcolor: new Uint16Array([ view.getUint16(6), view.getUint16(8), view.getUint16(10) ])
                    };
                }
            };
            inspectMp4 = function(data) {
                var view, size, type, end, box, i = 0, result = [];
                var ab = new ArrayBuffer(data.length);
                var v = new Uint8Array(ab);
                for (var z = 0; z < data.length; ++z) v[z] = data[z];
                view = new DataView(ab);
                while (i < data.byteLength) {
                    size = view.getUint32(i);
                    type = parseType$2(data.subarray(i + 4, i + 8));
                    end = size > 1 ? i + size : data.byteLength;
                    box = (parse[type] || function(data) {
                        return {
                            data
                        };
                    })(data.subarray(i + 8, end));
                    box.size = size;
                    box.type = type;
                    result.push(box);
                    i = end;
                }
                return result;
            };
            textifyMp4 = function(inspectedMp4, depth) {
                var indent;
                depth = depth || 0;
                indent = new Array(depth * 2 + 1).join(" ");
                return inspectedMp4.map((function(box, index) {
                    return indent + box.type + "\n" + Object.keys(box).filter((function(key) {
                        return key !== "type" && key !== "boxes";
                    })).map((function(key) {
                        var prefix = indent + "  " + key + ": ", value = box[key];
                        if (value instanceof Uint8Array || value instanceof Uint32Array) {
                            var bytes = Array.prototype.slice.call(new Uint8Array(value.buffer, value.byteOffset, value.byteLength)).map((function(byte) {
                                return " " + ("00" + byte.toString(16)).slice(-2);
                            })).join("").match(/.{1,24}/g);
                            if (!bytes) return prefix + "<>";
                            if (bytes.length === 1) return prefix + "<" + bytes.join("").slice(1) + ">";
                            return prefix + "<\n" + bytes.map((function(line) {
                                return indent + "  " + line;
                            })).join("\n") + "\n" + indent + "  >";
                        }
                        return prefix + JSON.stringify(value, null, 2).split("\n").map((function(line, index) {
                            if (index === 0) return line;
                            return indent + "  " + line;
                        })).join("\n");
                    })).join("\n") + (box.boxes ? "\n" + textifyMp4(box.boxes, depth + 1) : "");
                })).join("\n");
            };
            var mp4Inspector = {
                inspect: inspectMp4,
                textify: textifyMp4,
                parseType: parseType$2,
                findBox: findBox$4,
                parseTraf: parse.traf,
                parseTfdt: parse.tfdt,
                parseHdlr: parse.hdlr,
                parseTfhd: parse.tfhd,
                parseTrun: parse.trun,
                parseSidx: parse.sidx
            };
            var uint8ToCString$1 = function(data) {
                var index = 0;
                var curChar = String.fromCharCode(data[index]);
                var retString = "";
                while (curChar !== "\0") {
                    retString += curChar;
                    index++;
                    curChar = String.fromCharCode(data[index]);
                }
                retString += curChar;
                return retString;
            };
            var string = {
                uint8ToCString: uint8ToCString$1
            };
            var uint8ToCString = string.uint8ToCString;
            var getUint64$1 = numbers.getUint64;
            var parseEmsgBox = function(boxData) {
                var offset = 4;
                var version = boxData[0];
                var scheme_id_uri, value, timescale, presentation_time, presentation_time_delta, event_duration, id, message_data;
                if (version === 0) {
                    scheme_id_uri = uint8ToCString(boxData.subarray(offset));
                    offset += scheme_id_uri.length;
                    value = uint8ToCString(boxData.subarray(offset));
                    offset += value.length;
                    var dv = new DataView(boxData.buffer);
                    timescale = dv.getUint32(offset);
                    offset += 4;
                    presentation_time_delta = dv.getUint32(offset);
                    offset += 4;
                    event_duration = dv.getUint32(offset);
                    offset += 4;
                    id = dv.getUint32(offset);
                    offset += 4;
                } else if (version === 1) {
                    dv = new DataView(boxData.buffer);
                    timescale = dv.getUint32(offset);
                    offset += 4;
                    presentation_time = getUint64$1(boxData.subarray(offset));
                    offset += 8;
                    event_duration = dv.getUint32(offset);
                    offset += 4;
                    id = dv.getUint32(offset);
                    offset += 4;
                    scheme_id_uri = uint8ToCString(boxData.subarray(offset));
                    offset += scheme_id_uri.length;
                    value = uint8ToCString(boxData.subarray(offset));
                    offset += value.length;
                }
                message_data = new Uint8Array(boxData.subarray(offset, boxData.byteLength));
                var emsgBox = {
                    scheme_id_uri,
                    value,
                    timescale: timescale ? timescale : 1,
                    presentation_time,
                    presentation_time_delta,
                    event_duration,
                    id,
                    message_data
                };
                return isValidEmsgBox(version, emsgBox) ? emsgBox : void 0;
            };
            var scaleTime = function(presentationTime, timescale, timeDelta, offset) {
                return presentationTime || presentationTime === 0 ? presentationTime / timescale : offset + timeDelta / timescale;
            };
            var isValidEmsgBox = function(version, emsg) {
                var hasScheme = emsg.scheme_id_uri !== "\0";
                var isValidV0Box = version === 0 && isDefined(emsg.presentation_time_delta) && hasScheme;
                var isValidV1Box = version === 1 && isDefined(emsg.presentation_time) && hasScheme;
                return !(version > 1) && isValidV0Box || isValidV1Box;
            };
            var isDefined = function(data) {
                return data !== void 0 || data !== null;
            };
            var emsg$1 = {
                parseEmsgBox,
                scaleTime
            };
            var win;
            if (typeof window !== "undefined") win = window; else if (typeof commonjsGlobal !== "undefined") win = commonjsGlobal; else if (typeof self !== "undefined") win = self; else win = {};
            var window_1 = win;
            var toUnsigned = bin.toUnsigned;
            var toHexString = bin.toHexString;
            var findBox$3 = findBox_1;
            var parseType$1 = parseType_1;
            var emsg = emsg$1;
            var parseTfhd$1 = parseTfhd$2;
            var parseTrun$1 = parseTrun$2;
            var parseTfdt$2 = parseTfdt$3;
            var getUint64 = numbers.getUint64;
            var timescale, startTime, compositionStartTime, getVideoTrackIds, getTracks, getTimescaleFromMediaHeader$1, getEmsgID3;
            var window$2 = window_1;
            var parseId3Frames = parseId3.parseId3Frames;
            timescale = function(init) {
                var result = {}, traks = findBox$3(init, [ "moov", "trak" ]);
                return traks.reduce((function(result, trak) {
                    var tkhd, version, index, id, mdhd;
                    tkhd = findBox$3(trak, [ "tkhd" ])[0];
                    if (!tkhd) return null;
                    version = tkhd[0];
                    index = version === 0 ? 12 : 20;
                    id = toUnsigned(tkhd[index] << 24 | tkhd[index + 1] << 16 | tkhd[index + 2] << 8 | tkhd[index + 3]);
                    mdhd = findBox$3(trak, [ "mdia", "mdhd" ])[0];
                    if (!mdhd) return null;
                    version = mdhd[0];
                    index = version === 0 ? 12 : 20;
                    result[id] = toUnsigned(mdhd[index] << 24 | mdhd[index + 1] << 16 | mdhd[index + 2] << 8 | mdhd[index + 3]);
                    return result;
                }), result);
            };
            startTime = function(timescale, fragment) {
                var trafs;
                trafs = findBox$3(fragment, [ "moof", "traf" ]);
                var lowestTime = trafs.reduce((function(acc, traf) {
                    var tfhd = findBox$3(traf, [ "tfhd" ])[0];
                    var id = toUnsigned(tfhd[4] << 24 | tfhd[5] << 16 | tfhd[6] << 8 | tfhd[7]);
                    var scale = timescale[id] || 9e4;
                    var tfdt = findBox$3(traf, [ "tfdt" ])[0];
                    var dv = new DataView(tfdt.buffer, tfdt.byteOffset, tfdt.byteLength);
                    var baseTime;
                    if (tfdt[0] === 1) baseTime = getUint64(tfdt.subarray(4, 12)); else baseTime = dv.getUint32(4);
                    let seconds;
                    if (typeof baseTime === "bigint") seconds = baseTime / window$2.BigInt(scale); else if (typeof baseTime === "number" && !isNaN(baseTime)) seconds = baseTime / scale;
                    if (seconds < Number.MAX_SAFE_INTEGER) seconds = Number(seconds);
                    if (seconds < acc) acc = seconds;
                    return acc;
                }), 1 / 0);
                return typeof lowestTime === "bigint" || isFinite(lowestTime) ? lowestTime : 0;
            };
            compositionStartTime = function(timescales, fragment) {
                var trafBoxes = findBox$3(fragment, [ "moof", "traf" ]);
                var baseMediaDecodeTime = 0;
                var compositionTimeOffset = 0;
                var trackId;
                if (trafBoxes && trafBoxes.length) {
                    var tfhd = findBox$3(trafBoxes[0], [ "tfhd" ])[0];
                    var trun = findBox$3(trafBoxes[0], [ "trun" ])[0];
                    var tfdt = findBox$3(trafBoxes[0], [ "tfdt" ])[0];
                    if (tfhd) {
                        var parsedTfhd = parseTfhd$1(tfhd);
                        trackId = parsedTfhd.trackId;
                    }
                    if (tfdt) {
                        var parsedTfdt = parseTfdt$2(tfdt);
                        baseMediaDecodeTime = parsedTfdt.baseMediaDecodeTime;
                    }
                    if (trun) {
                        var parsedTrun = parseTrun$1(trun);
                        if (parsedTrun.samples && parsedTrun.samples.length) compositionTimeOffset = parsedTrun.samples[0].compositionTimeOffset || 0;
                    }
                }
                var timescale = timescales[trackId] || 9e4;
                if (typeof baseMediaDecodeTime === "bigint") {
                    compositionTimeOffset = window$2.BigInt(compositionTimeOffset);
                    timescale = window$2.BigInt(timescale);
                }
                var result = (baseMediaDecodeTime + compositionTimeOffset) / timescale;
                if (typeof result === "bigint" && result < Number.MAX_SAFE_INTEGER) result = Number(result);
                return result;
            };
            getVideoTrackIds = function(init) {
                var traks = findBox$3(init, [ "moov", "trak" ]);
                var videoTrackIds = [];
                traks.forEach((function(trak) {
                    var hdlrs = findBox$3(trak, [ "mdia", "hdlr" ]);
                    var tkhds = findBox$3(trak, [ "tkhd" ]);
                    hdlrs.forEach((function(hdlr, index) {
                        var handlerType = parseType$1(hdlr.subarray(8, 12));
                        var tkhd = tkhds[index];
                        var view;
                        var version;
                        var trackId;
                        if (handlerType === "vide") {
                            view = new DataView(tkhd.buffer, tkhd.byteOffset, tkhd.byteLength);
                            version = view.getUint8(0);
                            trackId = version === 0 ? view.getUint32(12) : view.getUint32(20);
                            videoTrackIds.push(trackId);
                        }
                    }));
                }));
                return videoTrackIds;
            };
            getTimescaleFromMediaHeader$1 = function(mdhd) {
                var version = mdhd[0];
                var index = version === 0 ? 12 : 20;
                return toUnsigned(mdhd[index] << 24 | mdhd[index + 1] << 16 | mdhd[index + 2] << 8 | mdhd[index + 3]);
            };
            getTracks = function(init) {
                var traks = findBox$3(init, [ "moov", "trak" ]);
                var tracks = [];
                traks.forEach((function(trak) {
                    var track = {};
                    var tkhd = findBox$3(trak, [ "tkhd" ])[0];
                    var view, tkhdVersion;
                    if (tkhd) {
                        view = new DataView(tkhd.buffer, tkhd.byteOffset, tkhd.byteLength);
                        tkhdVersion = view.getUint8(0);
                        track.id = tkhdVersion === 0 ? view.getUint32(12) : view.getUint32(20);
                    }
                    var hdlr = findBox$3(trak, [ "mdia", "hdlr" ])[0];
                    if (hdlr) {
                        var type = parseType$1(hdlr.subarray(8, 12));
                        if (type === "vide") track.type = "video"; else if (type === "soun") track.type = "audio"; else track.type = type;
                    }
                    var stsd = findBox$3(trak, [ "mdia", "minf", "stbl", "stsd" ])[0];
                    if (stsd) {
                        var sampleDescriptions = stsd.subarray(8);
                        track.codec = parseType$1(sampleDescriptions.subarray(4, 8));
                        var codecBox = findBox$3(sampleDescriptions, [ track.codec ])[0];
                        var codecConfig, codecConfigType;
                        if (codecBox) if (/^[asm]vc[1-9]$/i.test(track.codec)) {
                            codecConfig = codecBox.subarray(78);
                            codecConfigType = parseType$1(codecConfig.subarray(4, 8));
                            if (codecConfigType === "avcC" && codecConfig.length > 11) {
                                track.codec += ".";
                                track.codec += toHexString(codecConfig[9]);
                                track.codec += toHexString(codecConfig[10]);
                                track.codec += toHexString(codecConfig[11]);
                            } else track.codec = "avc1.4d400d";
                        } else if (/^mp4[a,v]$/i.test(track.codec)) {
                            codecConfig = codecBox.subarray(28);
                            codecConfigType = parseType$1(codecConfig.subarray(4, 8));
                            if (codecConfigType === "esds" && codecConfig.length > 20 && codecConfig[19] !== 0) {
                                track.codec += "." + toHexString(codecConfig[19]);
                                track.codec += "." + toHexString(codecConfig[20] >>> 2 & 63).replace(/^0/, "");
                            } else track.codec = "mp4a.40.2";
                        } else track.codec = track.codec.toLowerCase();
                    }
                    var mdhd = findBox$3(trak, [ "mdia", "mdhd" ])[0];
                    if (mdhd) track.timescale = getTimescaleFromMediaHeader$1(mdhd);
                    tracks.push(track);
                }));
                return tracks;
            };
            getEmsgID3 = function(segmentData, offset = 0) {
                var emsgBoxes = findBox$3(segmentData, [ "emsg" ]);
                return emsgBoxes.map((data => {
                    var parsedBox = emsg.parseEmsgBox(new Uint8Array(data));
                    var parsedId3Frames = parseId3Frames(parsedBox.message_data);
                    return {
                        cueTime: emsg.scaleTime(parsedBox.presentation_time, parsedBox.timescale, parsedBox.presentation_time_delta, offset),
                        duration: emsg.scaleTime(parsedBox.event_duration, parsedBox.timescale),
                        frames: parsedId3Frames
                    };
                }));
            };
            var probe$2 = {
                findBox: findBox$3,
                parseType: parseType$1,
                timescale,
                startTime,
                compositionStartTime,
                videoTrackIds: getVideoTrackIds,
                tracks: getTracks,
                getTimescaleFromMediaHeader: getTimescaleFromMediaHeader$1,
                getEmsgID3
            };
            const {parseTrun} = mp4Inspector;
            const {findBox: findBox$2} = probe$2;
            var window$1 = window_1;
            var getMdatTrafPairs$2 = function(segment) {
                var trafs = findBox$2(segment, [ "moof", "traf" ]);
                var mdats = findBox$2(segment, [ "mdat" ]);
                var mdatTrafPairs = [];
                mdats.forEach((function(mdat, index) {
                    var matchingTraf = trafs[index];
                    mdatTrafPairs.push({
                        mdat,
                        traf: matchingTraf
                    });
                }));
                return mdatTrafPairs;
            };
            var parseSamples$2 = function(truns, baseMediaDecodeTime, tfhd) {
                var currentDts = baseMediaDecodeTime;
                var defaultSampleDuration = tfhd.defaultSampleDuration || 0;
                var defaultSampleSize = tfhd.defaultSampleSize || 0;
                var trackId = tfhd.trackId;
                var allSamples = [];
                truns.forEach((function(trun) {
                    var trackRun = parseTrun(trun);
                    var samples = trackRun.samples;
                    samples.forEach((function(sample) {
                        if (sample.duration === void 0) sample.duration = defaultSampleDuration;
                        if (sample.size === void 0) sample.size = defaultSampleSize;
                        sample.trackId = trackId;
                        sample.dts = currentDts;
                        if (sample.compositionTimeOffset === void 0) sample.compositionTimeOffset = 0;
                        if (typeof currentDts === "bigint") {
                            sample.pts = currentDts + window$1.BigInt(sample.compositionTimeOffset);
                            currentDts += window$1.BigInt(sample.duration);
                        } else {
                            sample.pts = currentDts + sample.compositionTimeOffset;
                            currentDts += sample.duration;
                        }
                    }));
                    allSamples = allSamples.concat(samples);
                }));
                return allSamples;
            };
            var samples = {
                getMdatTrafPairs: getMdatTrafPairs$2,
                parseSamples: parseSamples$2
            };
            var discardEmulationPreventionBytes = captionPacketParser.discardEmulationPreventionBytes;
            var CaptionStream = captionStream.CaptionStream;
            var findBox$1 = findBox_1;
            var parseTfdt$1 = parseTfdt$3;
            var parseTfhd = parseTfhd$2;
            var {getMdatTrafPairs: getMdatTrafPairs$1, parseSamples: parseSamples$1} = samples;
            var mapToSample = function(offset, samples) {
                var approximateOffset = offset;
                for (var i = 0; i < samples.length; i++) {
                    var sample = samples[i];
                    if (approximateOffset < sample.size) return sample;
                    approximateOffset -= sample.size;
                }
                return null;
            };
            var findSeiNals = function(avcStream, samples, trackId) {
                var seiNal, i, length, lastMatchedSample, avcView = new DataView(avcStream.buffer, avcStream.byteOffset, avcStream.byteLength), result = {
                    logs: [],
                    seiNals: []
                };
                for (i = 0; i + 4 < avcStream.length; i += length) {
                    length = avcView.getUint32(i);
                    i += 4;
                    if (length <= 0) continue;
                    switch (avcStream[i] & 31) {
                      case 6:
                        var data = avcStream.subarray(i + 1, i + 1 + length);
                        var matchingSample = mapToSample(i, samples);
                        seiNal = {
                            nalUnitType: "sei_rbsp",
                            size: length,
                            data,
                            escapedRBSP: discardEmulationPreventionBytes(data),
                            trackId
                        };
                        if (matchingSample) {
                            seiNal.pts = matchingSample.pts;
                            seiNal.dts = matchingSample.dts;
                            lastMatchedSample = matchingSample;
                        } else if (lastMatchedSample) {
                            seiNal.pts = lastMatchedSample.pts;
                            seiNal.dts = lastMatchedSample.dts;
                        } else {
                            result.logs.push({
                                level: "warn",
                                message: "We've encountered a nal unit without data at " + i + " for trackId " + trackId + ". See mux.js#223."
                            });
                            break;
                        }
                        result.seiNals.push(seiNal);
                        break;
                    }
                }
                return result;
            };
            var parseCaptionNals = function(segment, videoTrackId) {
                var captionNals = {};
                var mdatTrafPairs = getMdatTrafPairs$1(segment);
                mdatTrafPairs.forEach((function(pair) {
                    var mdat = pair.mdat;
                    var traf = pair.traf;
                    var tfhd = findBox$1(traf, [ "tfhd" ]);
                    var headerInfo = parseTfhd(tfhd[0]);
                    var trackId = headerInfo.trackId;
                    var tfdt = findBox$1(traf, [ "tfdt" ]);
                    var baseMediaDecodeTime = tfdt.length > 0 ? parseTfdt$1(tfdt[0]).baseMediaDecodeTime : 0;
                    var truns = findBox$1(traf, [ "trun" ]);
                    var samples;
                    var result;
                    if (videoTrackId === trackId && truns.length > 0) {
                        samples = parseSamples$1(truns, baseMediaDecodeTime, headerInfo);
                        result = findSeiNals(mdat, samples, trackId);
                        if (!captionNals[trackId]) captionNals[trackId] = {
                            seiNals: [],
                            logs: []
                        };
                        captionNals[trackId].seiNals = captionNals[trackId].seiNals.concat(result.seiNals);
                        captionNals[trackId].logs = captionNals[trackId].logs.concat(result.logs);
                    }
                }));
                return captionNals;
            };
            var parseEmbeddedCaptions = function(segment, trackId, timescale) {
                var captionNals;
                if (trackId === null) return null;
                captionNals = parseCaptionNals(segment, trackId);
                var trackNals = captionNals[trackId] || {};
                return {
                    seiNals: trackNals.seiNals,
                    logs: trackNals.logs,
                    timescale
                };
            };
            var CaptionParser = function() {
                var isInitialized = false;
                var captionStream;
                var segmentCache;
                var trackId;
                var timescale;
                var parsedCaptions;
                var parsingPartial;
                this.isInitialized = function() {
                    return isInitialized;
                };
                this.init = function(options) {
                    captionStream = new CaptionStream;
                    isInitialized = true;
                    parsingPartial = options ? options.isPartial : false;
                    captionStream.on("data", (function(event) {
                        event.startTime = event.startPts / timescale;
                        event.endTime = event.endPts / timescale;
                        parsedCaptions.captions.push(event);
                        parsedCaptions.captionStreams[event.stream] = true;
                    }));
                    captionStream.on("log", (function(log) {
                        parsedCaptions.logs.push(log);
                    }));
                };
                this.isNewInit = function(videoTrackIds, timescales) {
                    if (videoTrackIds && videoTrackIds.length === 0 || timescales && typeof timescales === "object" && Object.keys(timescales).length === 0) return false;
                    return trackId !== videoTrackIds[0] || timescale !== timescales[trackId];
                };
                this.parse = function(segment, videoTrackIds, timescales) {
                    var parsedData;
                    if (!this.isInitialized()) return null; else if (!videoTrackIds || !timescales) return null; else if (this.isNewInit(videoTrackIds, timescales)) {
                        trackId = videoTrackIds[0];
                        timescale = timescales[trackId];
                    } else if (trackId === null || !timescale) {
                        segmentCache.push(segment);
                        return null;
                    }
                    while (segmentCache.length > 0) {
                        var cachedSegment = segmentCache.shift();
                        this.parse(cachedSegment, videoTrackIds, timescales);
                    }
                    parsedData = parseEmbeddedCaptions(segment, trackId, timescale);
                    if (parsedData && parsedData.logs) parsedCaptions.logs = parsedCaptions.logs.concat(parsedData.logs);
                    if (parsedData === null || !parsedData.seiNals) {
                        if (parsedCaptions.logs.length) return {
                            logs: parsedCaptions.logs,
                            captions: [],
                            captionStreams: []
                        };
                        return null;
                    }
                    this.pushNals(parsedData.seiNals);
                    this.flushStream();
                    return parsedCaptions;
                };
                this.pushNals = function(nals) {
                    if (!this.isInitialized() || !nals || nals.length === 0) return null;
                    nals.forEach((function(nal) {
                        captionStream.push(nal);
                    }));
                };
                this.flushStream = function() {
                    if (!this.isInitialized()) return null;
                    if (!parsingPartial) captionStream.flush(); else captionStream.partialFlush();
                };
                this.clearParsedCaptions = function() {
                    parsedCaptions.captions = [];
                    parsedCaptions.captionStreams = {};
                    parsedCaptions.logs = [];
                };
                this.resetCaptionStream = function() {
                    if (!this.isInitialized()) return null;
                    captionStream.reset();
                };
                this.clearAllCaptions = function() {
                    this.clearParsedCaptions();
                    this.resetCaptionStream();
                };
                this.reset = function() {
                    segmentCache = [];
                    trackId = null;
                    timescale = null;
                    if (!parsedCaptions) parsedCaptions = {
                        captions: [],
                        captionStreams: {},
                        logs: []
                    }; else this.clearParsedCaptions();
                    this.resetCaptionStream();
                };
                this.reset();
            };
            var captionParser = CaptionParser;
            const {parseTfdt} = mp4Inspector;
            const findBox = findBox_1;
            const {getTimescaleFromMediaHeader} = probe$2;
            const {parseSamples, getMdatTrafPairs} = samples;
            const WebVttParser = function() {
                let timescale = 9e4;
                this.init = function(segment) {
                    const mdhd = findBox(segment, [ "moov", "trak", "mdia", "mdhd" ])[0];
                    if (mdhd) timescale = getTimescaleFromMediaHeader(mdhd);
                };
                this.parseSegment = function(segment) {
                    const vttCues = [];
                    const mdatTrafPairs = getMdatTrafPairs(segment);
                    let baseMediaDecodeTime = 0;
                    mdatTrafPairs.forEach((function(pair) {
                        const mdatBox = pair.mdat;
                        const trafBox = pair.traf;
                        const tfdtBox = findBox(trafBox, [ "tfdt" ])[0];
                        const tfhdBox = findBox(trafBox, [ "tfhd" ])[0];
                        const trunBoxes = findBox(trafBox, [ "trun" ]);
                        if (tfdtBox) {
                            const tfdt = parseTfdt(tfdtBox);
                            baseMediaDecodeTime = tfdt.baseMediaDecodeTime;
                        }
                        if (trunBoxes.length && tfhdBox) {
                            const samples = parseSamples(trunBoxes, baseMediaDecodeTime, tfhdBox);
                            let mdatOffset = 0;
                            samples.forEach((function(sample) {
                                const UTF_8 = "utf-8";
                                const textDecoder = new TextDecoder(UTF_8);
                                const sampleData = mdatBox.slice(mdatOffset, mdatOffset + sample.size);
                                const vtteBox = findBox(sampleData, [ "vtte" ])[0];
                                if (vtteBox) {
                                    mdatOffset += sample.size;
                                    return;
                                }
                                const vttcBoxes = findBox(sampleData, [ "vttc" ]);
                                vttcBoxes.forEach((function(vttcBox) {
                                    const paylBox = findBox(vttcBox, [ "payl" ])[0];
                                    const sttgBox = findBox(vttcBox, [ "sttg" ])[0];
                                    const start = sample.pts / timescale;
                                    const end = (sample.pts + sample.duration) / timescale;
                                    let cueText, settings;
                                    if (paylBox) try {
                                        cueText = textDecoder.decode(paylBox);
                                    } catch (e) {
                                        console.error(e);
                                    }
                                    if (sttgBox) try {
                                        settings = textDecoder.decode(sttgBox);
                                    } catch (e) {
                                        console.error(e);
                                    }
                                    if (sample.duration && cueText) vttCues.push({
                                        cueText,
                                        start,
                                        end,
                                        settings
                                    });
                                }));
                                mdatOffset += sample.size;
                            }));
                        }
                    }));
                    return vttCues;
                };
            };
            var webvttParser = WebVttParser;
            var StreamTypes$1 = streamTypes;
            var parsePid = function(packet) {
                var pid = packet[1] & 31;
                pid <<= 8;
                pid |= packet[2];
                return pid;
            };
            var parsePayloadUnitStartIndicator = function(packet) {
                return !!(packet[1] & 64);
            };
            var parseAdaptionField = function(packet) {
                var offset = 0;
                if ((packet[3] & 48) >>> 4 > 1) offset += packet[4] + 1;
                return offset;
            };
            var parseType = function(packet, pmtPid) {
                var pid = parsePid(packet);
                if (pid === 0) return "pat"; else if (pid === pmtPid) return "pmt"; else if (pmtPid) return "pes";
                return null;
            };
            var parsePat = function(packet) {
                var pusi = parsePayloadUnitStartIndicator(packet);
                var offset = 4 + parseAdaptionField(packet);
                if (pusi) offset += packet[offset] + 1;
                return (packet[offset + 10] & 31) << 8 | packet[offset + 11];
            };
            var parsePmt = function(packet) {
                var programMapTable = {};
                var pusi = parsePayloadUnitStartIndicator(packet);
                var payloadOffset = 4 + parseAdaptionField(packet);
                if (pusi) payloadOffset += packet[payloadOffset] + 1;
                if (!(packet[payloadOffset + 5] & 1)) return;
                var sectionLength, tableEnd, programInfoLength;
                sectionLength = (packet[payloadOffset + 1] & 15) << 8 | packet[payloadOffset + 2];
                tableEnd = 3 + sectionLength - 4;
                programInfoLength = (packet[payloadOffset + 10] & 15) << 8 | packet[payloadOffset + 11];
                var offset = 12 + programInfoLength;
                while (offset < tableEnd) {
                    var i = payloadOffset + offset;
                    programMapTable[(packet[i + 1] & 31) << 8 | packet[i + 2]] = packet[i];
                    offset += ((packet[i + 3] & 15) << 8 | packet[i + 4]) + 5;
                }
                return programMapTable;
            };
            var parsePesType = function(packet, programMapTable) {
                var pid = parsePid(packet);
                var type = programMapTable[pid];
                switch (type) {
                  case StreamTypes$1.H264_STREAM_TYPE:
                    return "video";

                  case StreamTypes$1.ADTS_STREAM_TYPE:
                    return "audio";

                  case StreamTypes$1.METADATA_STREAM_TYPE:
                    return "timed-metadata";

                  default:
                    return null;
                }
            };
            var parsePesTime = function(packet) {
                var pusi = parsePayloadUnitStartIndicator(packet);
                if (!pusi) return null;
                var offset = 4 + parseAdaptionField(packet);
                if (offset >= packet.byteLength) return null;
                var pes = null;
                var ptsDtsFlags;
                ptsDtsFlags = packet[offset + 7];
                if (ptsDtsFlags & 192) {
                    pes = {};
                    pes.pts = (packet[offset + 9] & 14) << 27 | (packet[offset + 10] & 255) << 20 | (packet[offset + 11] & 254) << 12 | (packet[offset + 12] & 255) << 5 | (packet[offset + 13] & 254) >>> 3;
                    pes.pts *= 4;
                    pes.pts += (packet[offset + 13] & 6) >>> 1;
                    pes.dts = pes.pts;
                    if (ptsDtsFlags & 64) {
                        pes.dts = (packet[offset + 14] & 14) << 27 | (packet[offset + 15] & 255) << 20 | (packet[offset + 16] & 254) << 12 | (packet[offset + 17] & 255) << 5 | (packet[offset + 18] & 254) >>> 3;
                        pes.dts *= 4;
                        pes.dts += (packet[offset + 18] & 6) >>> 1;
                    }
                }
                return pes;
            };
            var parseNalUnitType = function(type) {
                switch (type) {
                  case 5:
                    return "slice_layer_without_partitioning_rbsp_idr";

                  case 6:
                    return "sei_rbsp";

                  case 7:
                    return "seq_parameter_set_rbsp";

                  case 8:
                    return "pic_parameter_set_rbsp";

                  case 9:
                    return "access_unit_delimiter_rbsp";

                  default:
                    return null;
                }
            };
            var videoPacketContainsKeyFrame = function(packet) {
                var offset = 4 + parseAdaptionField(packet);
                var frameBuffer = packet.subarray(offset);
                var frameI = 0;
                var frameSyncPoint = 0;
                var foundKeyFrame = false;
                var nalType;
                for (;frameSyncPoint < frameBuffer.byteLength - 3; frameSyncPoint++) if (frameBuffer[frameSyncPoint + 2] === 1) {
                    frameI = frameSyncPoint + 5;
                    break;
                }
                while (frameI < frameBuffer.byteLength) switch (frameBuffer[frameI]) {
                  case 0:
                    if (frameBuffer[frameI - 1] !== 0) {
                        frameI += 2;
                        break;
                    } else if (frameBuffer[frameI - 2] !== 0) {
                        frameI++;
                        break;
                    }
                    if (frameSyncPoint + 3 !== frameI - 2) {
                        nalType = parseNalUnitType(frameBuffer[frameSyncPoint + 3] & 31);
                        if (nalType === "slice_layer_without_partitioning_rbsp_idr") foundKeyFrame = true;
                    }
                    do {
                        frameI++;
                    } while (frameBuffer[frameI] !== 1 && frameI < frameBuffer.length);
                    frameSyncPoint = frameI - 2;
                    frameI += 3;
                    break;

                  case 1:
                    if (frameBuffer[frameI - 1] !== 0 || frameBuffer[frameI - 2] !== 0) {
                        frameI += 3;
                        break;
                    }
                    nalType = parseNalUnitType(frameBuffer[frameSyncPoint + 3] & 31);
                    if (nalType === "slice_layer_without_partitioning_rbsp_idr") foundKeyFrame = true;
                    frameSyncPoint = frameI - 2;
                    frameI += 3;
                    break;

                  default:
                    frameI += 3;
                    break;
                }
                frameBuffer = frameBuffer.subarray(frameSyncPoint);
                frameI -= frameSyncPoint;
                frameSyncPoint = 0;
                if (frameBuffer && frameBuffer.byteLength > 3) {
                    nalType = parseNalUnitType(frameBuffer[frameSyncPoint + 3] & 31);
                    if (nalType === "slice_layer_without_partitioning_rbsp_idr") foundKeyFrame = true;
                }
                return foundKeyFrame;
            };
            var probe$1 = {
                parseType,
                parsePat,
                parsePmt,
                parsePayloadUnitStartIndicator,
                parsePesType,
                parsePesTime,
                videoPacketContainsKeyFrame
            };
            var StreamTypes = streamTypes;
            var handleRollover = timestampRolloverStream.handleRollover;
            var probe = {};
            probe.ts = probe$1;
            probe.aac = utils;
            var ONE_SECOND_IN_TS = clock$2.ONE_SECOND_IN_TS;
            var MP2T_PACKET_LENGTH = 188, SYNC_BYTE = 71;
            var parsePsi_ = function(bytes, pmt) {
                var packet, type, startIndex = 0, endIndex = MP2T_PACKET_LENGTH;
                while (endIndex < bytes.byteLength) {
                    if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {
                        packet = bytes.subarray(startIndex, endIndex);
                        type = probe.ts.parseType(packet, pmt.pid);
                        switch (type) {
                          case "pat":
                            pmt.pid = probe.ts.parsePat(packet);
                            break;

                          case "pmt":
                            var table = probe.ts.parsePmt(packet);
                            pmt.table = pmt.table || {};
                            Object.keys(table).forEach((function(key) {
                                pmt.table[key] = table[key];
                            }));
                            break;
                        }
                        startIndex += MP2T_PACKET_LENGTH;
                        endIndex += MP2T_PACKET_LENGTH;
                        continue;
                    }
                    startIndex++;
                    endIndex++;
                }
            };
            var parseAudioPes_ = function(bytes, pmt, result) {
                var packet, type, pesType, pusi, parsed, startIndex = 0, endIndex = MP2T_PACKET_LENGTH;
                var endLoop = false;
                while (endIndex <= bytes.byteLength) {
                    if (bytes[startIndex] === SYNC_BYTE && (bytes[endIndex] === SYNC_BYTE || endIndex === bytes.byteLength)) {
                        packet = bytes.subarray(startIndex, endIndex);
                        type = probe.ts.parseType(packet, pmt.pid);
                        switch (type) {
                          case "pes":
                            pesType = probe.ts.parsePesType(packet, pmt.table);
                            pusi = probe.ts.parsePayloadUnitStartIndicator(packet);
                            if (pesType === "audio" && pusi) {
                                parsed = probe.ts.parsePesTime(packet);
                                if (parsed) {
                                    parsed.type = "audio";
                                    result.audio.push(parsed);
                                    endLoop = true;
                                }
                            }
                            break;
                        }
                        if (endLoop) break;
                        startIndex += MP2T_PACKET_LENGTH;
                        endIndex += MP2T_PACKET_LENGTH;
                        continue;
                    }
                    startIndex++;
                    endIndex++;
                }
                endIndex = bytes.byteLength;
                startIndex = endIndex - MP2T_PACKET_LENGTH;
                endLoop = false;
                while (startIndex >= 0) {
                    if (bytes[startIndex] === SYNC_BYTE && (bytes[endIndex] === SYNC_BYTE || endIndex === bytes.byteLength)) {
                        packet = bytes.subarray(startIndex, endIndex);
                        type = probe.ts.parseType(packet, pmt.pid);
                        switch (type) {
                          case "pes":
                            pesType = probe.ts.parsePesType(packet, pmt.table);
                            pusi = probe.ts.parsePayloadUnitStartIndicator(packet);
                            if (pesType === "audio" && pusi) {
                                parsed = probe.ts.parsePesTime(packet);
                                if (parsed) {
                                    parsed.type = "audio";
                                    result.audio.push(parsed);
                                    endLoop = true;
                                }
                            }
                            break;
                        }
                        if (endLoop) break;
                        startIndex -= MP2T_PACKET_LENGTH;
                        endIndex -= MP2T_PACKET_LENGTH;
                        continue;
                    }
                    startIndex--;
                    endIndex--;
                }
            };
            var parseVideoPes_ = function(bytes, pmt, result) {
                var packet, type, pesType, pusi, parsed, frame, i, pes, startIndex = 0, endIndex = MP2T_PACKET_LENGTH;
                var endLoop = false;
                var currentFrame = {
                    data: [],
                    size: 0
                };
                while (endIndex < bytes.byteLength) {
                    if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {
                        packet = bytes.subarray(startIndex, endIndex);
                        type = probe.ts.parseType(packet, pmt.pid);
                        switch (type) {
                          case "pes":
                            pesType = probe.ts.parsePesType(packet, pmt.table);
                            pusi = probe.ts.parsePayloadUnitStartIndicator(packet);
                            if (pesType === "video") {
                                if (pusi && !endLoop) {
                                    parsed = probe.ts.parsePesTime(packet);
                                    if (parsed) {
                                        parsed.type = "video";
                                        result.video.push(parsed);
                                        endLoop = true;
                                    }
                                }
                                if (!result.firstKeyFrame) {
                                    if (pusi) if (currentFrame.size !== 0) {
                                        frame = new Uint8Array(currentFrame.size);
                                        i = 0;
                                        while (currentFrame.data.length) {
                                            pes = currentFrame.data.shift();
                                            frame.set(pes, i);
                                            i += pes.byteLength;
                                        }
                                        if (probe.ts.videoPacketContainsKeyFrame(frame)) {
                                            var firstKeyFrame = probe.ts.parsePesTime(frame);
                                            if (firstKeyFrame) {
                                                result.firstKeyFrame = firstKeyFrame;
                                                result.firstKeyFrame.type = "video";
                                            } else console.warn("Failed to extract PTS/DTS from PES at first keyframe. " + "This could be an unusual TS segment, or else mux.js did not " + "parse your TS segment correctly. If you know your TS " + "segments do contain PTS/DTS on keyframes please file a bug " + "report! You can try ffprobe to double check for yourself.");
                                        }
                                        currentFrame.size = 0;
                                    }
                                    currentFrame.data.push(packet);
                                    currentFrame.size += packet.byteLength;
                                }
                            }
                            break;
                        }
                        if (endLoop && result.firstKeyFrame) break;
                        startIndex += MP2T_PACKET_LENGTH;
                        endIndex += MP2T_PACKET_LENGTH;
                        continue;
                    }
                    startIndex++;
                    endIndex++;
                }
                endIndex = bytes.byteLength;
                startIndex = endIndex - MP2T_PACKET_LENGTH;
                endLoop = false;
                while (startIndex >= 0) {
                    if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {
                        packet = bytes.subarray(startIndex, endIndex);
                        type = probe.ts.parseType(packet, pmt.pid);
                        switch (type) {
                          case "pes":
                            pesType = probe.ts.parsePesType(packet, pmt.table);
                            pusi = probe.ts.parsePayloadUnitStartIndicator(packet);
                            if (pesType === "video" && pusi) {
                                parsed = probe.ts.parsePesTime(packet);
                                if (parsed) {
                                    parsed.type = "video";
                                    result.video.push(parsed);
                                    endLoop = true;
                                }
                            }
                            break;
                        }
                        if (endLoop) break;
                        startIndex -= MP2T_PACKET_LENGTH;
                        endIndex -= MP2T_PACKET_LENGTH;
                        continue;
                    }
                    startIndex--;
                    endIndex--;
                }
            };
            var adjustTimestamp_ = function(segmentInfo, baseTimestamp) {
                if (segmentInfo.audio && segmentInfo.audio.length) {
                    var audioBaseTimestamp = baseTimestamp;
                    if (typeof audioBaseTimestamp === "undefined" || isNaN(audioBaseTimestamp)) audioBaseTimestamp = segmentInfo.audio[0].dts;
                    segmentInfo.audio.forEach((function(info) {
                        info.dts = handleRollover(info.dts, audioBaseTimestamp);
                        info.pts = handleRollover(info.pts, audioBaseTimestamp);
                        info.dtsTime = info.dts / ONE_SECOND_IN_TS;
                        info.ptsTime = info.pts / ONE_SECOND_IN_TS;
                    }));
                }
                if (segmentInfo.video && segmentInfo.video.length) {
                    var videoBaseTimestamp = baseTimestamp;
                    if (typeof videoBaseTimestamp === "undefined" || isNaN(videoBaseTimestamp)) videoBaseTimestamp = segmentInfo.video[0].dts;
                    segmentInfo.video.forEach((function(info) {
                        info.dts = handleRollover(info.dts, videoBaseTimestamp);
                        info.pts = handleRollover(info.pts, videoBaseTimestamp);
                        info.dtsTime = info.dts / ONE_SECOND_IN_TS;
                        info.ptsTime = info.pts / ONE_SECOND_IN_TS;
                    }));
                    if (segmentInfo.firstKeyFrame) {
                        var frame = segmentInfo.firstKeyFrame;
                        frame.dts = handleRollover(frame.dts, videoBaseTimestamp);
                        frame.pts = handleRollover(frame.pts, videoBaseTimestamp);
                        frame.dtsTime = frame.dts / ONE_SECOND_IN_TS;
                        frame.ptsTime = frame.pts / ONE_SECOND_IN_TS;
                    }
                }
            };
            var inspectAac_ = function(bytes) {
                var packet, endLoop = false, audioCount = 0, sampleRate = null, timestamp = null, frameSize = 0, byteIndex = 0;
                while (bytes.length - byteIndex >= 3) {
                    var type = probe.aac.parseType(bytes, byteIndex);
                    switch (type) {
                      case "timed-metadata":
                        if (bytes.length - byteIndex < 10) {
                            endLoop = true;
                            break;
                        }
                        frameSize = probe.aac.parseId3TagSize(bytes, byteIndex);
                        if (frameSize > bytes.length) {
                            endLoop = true;
                            break;
                        }
                        if (timestamp === null) {
                            packet = bytes.subarray(byteIndex, byteIndex + frameSize);
                            timestamp = probe.aac.parseAacTimestamp(packet);
                        }
                        byteIndex += frameSize;
                        break;

                      case "audio":
                        if (bytes.length - byteIndex < 7) {
                            endLoop = true;
                            break;
                        }
                        frameSize = probe.aac.parseAdtsSize(bytes, byteIndex);
                        if (frameSize > bytes.length) {
                            endLoop = true;
                            break;
                        }
                        if (sampleRate === null) {
                            packet = bytes.subarray(byteIndex, byteIndex + frameSize);
                            sampleRate = probe.aac.parseSampleRate(packet);
                        }
                        audioCount++;
                        byteIndex += frameSize;
                        break;

                      default:
                        byteIndex++;
                        break;
                    }
                    if (endLoop) return null;
                }
                if (sampleRate === null || timestamp === null) return null;
                var audioTimescale = ONE_SECOND_IN_TS / sampleRate;
                var result = {
                    audio: [ {
                        type: "audio",
                        dts: timestamp,
                        pts: timestamp
                    }, {
                        type: "audio",
                        dts: timestamp + audioCount * 1024 * audioTimescale,
                        pts: timestamp + audioCount * 1024 * audioTimescale
                    } ]
                };
                return result;
            };
            var inspectTs_ = function(bytes) {
                var pmt = {
                    pid: null,
                    table: null
                };
                var result = {};
                parsePsi_(bytes, pmt);
                for (var pid in pmt.table) if (pmt.table.hasOwnProperty(pid)) {
                    var type = pmt.table[pid];
                    switch (type) {
                      case StreamTypes.H264_STREAM_TYPE:
                        result.video = [];
                        parseVideoPes_(bytes, pmt, result);
                        if (result.video.length === 0) delete result.video;
                        break;

                      case StreamTypes.ADTS_STREAM_TYPE:
                        result.audio = [];
                        parseAudioPes_(bytes, pmt, result);
                        if (result.audio.length === 0) delete result.audio;
                        break;
                    }
                }
                return result;
            };
            var inspect = function(bytes, baseTimestamp) {
                var isAacData = probe.aac.isLikelyAacData(bytes);
                var result;
                if (isAacData) result = inspectAac_(bytes); else result = inspectTs_(bytes);
                if (!result || !result.audio && !result.video) return null;
                adjustTimestamp_(result, baseTimestamp);
                return result;
            };
            var tsInspector = {
                inspect,
                parseAudioPes_
            };
            const wireTransmuxerEvents = function(self, transmuxer) {
                transmuxer.on("data", (function(segment) {
                    const initArray = segment.initSegment;
                    segment.initSegment = {
                        data: initArray.buffer,
                        byteOffset: initArray.byteOffset,
                        byteLength: initArray.byteLength
                    };
                    const typedArray = segment.data;
                    segment.data = typedArray.buffer;
                    self.postMessage({
                        action: "data",
                        segment,
                        byteOffset: typedArray.byteOffset,
                        byteLength: typedArray.byteLength
                    }, [ segment.data ]);
                }));
                transmuxer.on("done", (function(data) {
                    self.postMessage({
                        action: "done"
                    });
                }));
                transmuxer.on("gopInfo", (function(gopInfo) {
                    self.postMessage({
                        action: "gopInfo",
                        gopInfo
                    });
                }));
                transmuxer.on("videoSegmentTimingInfo", (function(timingInfo) {
                    const videoSegmentTimingInfo = {
                        start: {
                            decode: clock$2.videoTsToSeconds(timingInfo.start.dts),
                            presentation: clock$2.videoTsToSeconds(timingInfo.start.pts)
                        },
                        end: {
                            decode: clock$2.videoTsToSeconds(timingInfo.end.dts),
                            presentation: clock$2.videoTsToSeconds(timingInfo.end.pts)
                        },
                        baseMediaDecodeTime: clock$2.videoTsToSeconds(timingInfo.baseMediaDecodeTime)
                    };
                    if (timingInfo.prependedContentDuration) videoSegmentTimingInfo.prependedContentDuration = clock$2.videoTsToSeconds(timingInfo.prependedContentDuration);
                    self.postMessage({
                        action: "videoSegmentTimingInfo",
                        videoSegmentTimingInfo
                    });
                }));
                transmuxer.on("audioSegmentTimingInfo", (function(timingInfo) {
                    const audioSegmentTimingInfo = {
                        start: {
                            decode: clock$2.videoTsToSeconds(timingInfo.start.dts),
                            presentation: clock$2.videoTsToSeconds(timingInfo.start.pts)
                        },
                        end: {
                            decode: clock$2.videoTsToSeconds(timingInfo.end.dts),
                            presentation: clock$2.videoTsToSeconds(timingInfo.end.pts)
                        },
                        baseMediaDecodeTime: clock$2.videoTsToSeconds(timingInfo.baseMediaDecodeTime)
                    };
                    if (timingInfo.prependedContentDuration) audioSegmentTimingInfo.prependedContentDuration = clock$2.videoTsToSeconds(timingInfo.prependedContentDuration);
                    self.postMessage({
                        action: "audioSegmentTimingInfo",
                        audioSegmentTimingInfo
                    });
                }));
                transmuxer.on("id3Frame", (function(id3Frame) {
                    self.postMessage({
                        action: "id3Frame",
                        id3Frame
                    });
                }));
                transmuxer.on("caption", (function(caption) {
                    self.postMessage({
                        action: "caption",
                        caption
                    });
                }));
                transmuxer.on("trackinfo", (function(trackInfo) {
                    self.postMessage({
                        action: "trackinfo",
                        trackInfo
                    });
                }));
                transmuxer.on("audioTimingInfo", (function(audioTimingInfo) {
                    self.postMessage({
                        action: "audioTimingInfo",
                        audioTimingInfo: {
                            start: clock$2.videoTsToSeconds(audioTimingInfo.start),
                            end: clock$2.videoTsToSeconds(audioTimingInfo.end)
                        }
                    });
                }));
                transmuxer.on("videoTimingInfo", (function(videoTimingInfo) {
                    self.postMessage({
                        action: "videoTimingInfo",
                        videoTimingInfo: {
                            start: clock$2.videoTsToSeconds(videoTimingInfo.start),
                            end: clock$2.videoTsToSeconds(videoTimingInfo.end)
                        }
                    });
                }));
                transmuxer.on("log", (function(log) {
                    self.postMessage({
                        action: "log",
                        log
                    });
                }));
            };
            class MessageHandlers {
                constructor(self, options) {
                    this.options = options || {};
                    this.self = self;
                    this.init();
                }
                init() {
                    if (this.transmuxer) this.transmuxer.dispose();
                    this.transmuxer = new transmuxer.Transmuxer(this.options);
                    wireTransmuxerEvents(this.self, this.transmuxer);
                }
                pushMp4Captions(data) {
                    if (!this.captionParser) {
                        this.captionParser = new captionParser;
                        this.captionParser.init();
                    }
                    const segment = new Uint8Array(data.data, data.byteOffset, data.byteLength);
                    const parsed = this.captionParser.parse(segment, data.trackIds, data.timescales);
                    this.self.postMessage({
                        action: "mp4Captions",
                        captions: parsed && parsed.captions || [],
                        logs: parsed && parsed.logs || [],
                        data: segment.buffer
                    }, [ segment.buffer ]);
                }
                initMp4WebVttParser(data) {
                    if (!this.webVttParser) this.webVttParser = new webvttParser;
                    const segment = new Uint8Array(data.data, data.byteOffset, data.byteLength);
                    this.webVttParser.init(segment);
                }
                getMp4WebVttText(data) {
                    if (!this.webVttParser) this.webVttParser = new webvttParser;
                    const segment = new Uint8Array(data.data, data.byteOffset, data.byteLength);
                    const parsed = this.webVttParser.parseSegment(segment);
                    this.self.postMessage({
                        action: "getMp4WebVttText",
                        mp4VttCues: parsed || [],
                        data: segment.buffer
                    }, [ segment.buffer ]);
                }
                probeMp4StartTime({timescales, data}) {
                    const startTime = probe$2.startTime(timescales, data);
                    this.self.postMessage({
                        action: "probeMp4StartTime",
                        startTime,
                        data
                    }, [ data.buffer ]);
                }
                probeMp4Tracks({data}) {
                    const tracks = probe$2.tracks(data);
                    this.self.postMessage({
                        action: "probeMp4Tracks",
                        tracks,
                        data
                    }, [ data.buffer ]);
                }
                probeEmsgID3({data, offset}) {
                    const id3Frames = probe$2.getEmsgID3(data, offset);
                    this.self.postMessage({
                        action: "probeEmsgID3",
                        id3Frames,
                        emsgData: data
                    }, [ data.buffer ]);
                }
                probeTs({data, baseStartTime}) {
                    const tsStartTime = typeof baseStartTime === "number" && !isNaN(baseStartTime) ? baseStartTime * clock$2.ONE_SECOND_IN_TS : void 0;
                    const timeInfo = tsInspector.inspect(data, tsStartTime);
                    let result = null;
                    if (timeInfo) {
                        result = {
                            hasVideo: timeInfo.video && timeInfo.video.length === 2 || false,
                            hasAudio: timeInfo.audio && timeInfo.audio.length === 2 || false
                        };
                        if (result.hasVideo) result.videoStart = timeInfo.video[0].ptsTime;
                        if (result.hasAudio) result.audioStart = timeInfo.audio[0].ptsTime;
                    }
                    this.self.postMessage({
                        action: "probeTs",
                        result,
                        data
                    }, [ data.buffer ]);
                }
                clearAllMp4Captions() {
                    if (this.captionParser) this.captionParser.clearAllCaptions();
                }
                clearParsedMp4Captions() {
                    if (this.captionParser) this.captionParser.clearParsedCaptions();
                }
                push(data) {
                    const segment = new Uint8Array(data.data, data.byteOffset, data.byteLength);
                    this.transmuxer.push(segment);
                }
                reset() {
                    this.transmuxer.reset();
                }
                setTimestampOffset(data) {
                    const timestampOffset = data.timestampOffset || 0;
                    this.transmuxer.setBaseMediaDecodeTime(Math.round(clock$2.secondsToVideoTs(timestampOffset)));
                }
                setAudioAppendStart(data) {
                    this.transmuxer.setAudioAppendStart(Math.ceil(clock$2.secondsToVideoTs(data.appendStart)));
                }
                setRemux(data) {
                    this.transmuxer.setRemux(data.remux);
                }
                flush(data) {
                    this.transmuxer.flush();
                    self.postMessage({
                        action: "done",
                        type: "transmuxed"
                    });
                }
                endTimeline() {
                    this.transmuxer.endTimeline();
                    self.postMessage({
                        action: "endedtimeline",
                        type: "transmuxed"
                    });
                }
                alignGopsWith(data) {
                    this.transmuxer.alignGopsWith(data.gopsToAlignWith.slice());
                }
            }
            self.onmessage = function(event) {
                if (event.data.action === "init" && event.data.options) {
                    this.messageHandlers = new MessageHandlers(self, event.data.options);
                    return;
                }
                if (!this.messageHandlers) this.messageHandlers = new MessageHandlers(self);
                if (event.data && event.data.action && event.data.action !== "init") if (this.messageHandlers[event.data.action]) this.messageHandlers[event.data.action](event.data);
            };
        })));
        var app_TransmuxWorker = app_factory(app_workerCode$1);
        const app_handleData_ = (event, transmuxedData, callback) => {
            const {type, initSegment, captions, captionStreams, metadata, videoFrameDtsTime, videoFramePtsTime} = event.data.segment;
            transmuxedData.buffer.push({
                captions,
                captionStreams,
                metadata
            });
            const boxes = event.data.segment.boxes || {
                data: event.data.segment.data
            };
            const result = {
                type,
                data: new Uint8Array(boxes.data, boxes.data.byteOffset, boxes.data.byteLength),
                initSegment: new Uint8Array(initSegment.data, initSegment.byteOffset, initSegment.byteLength)
            };
            if (typeof videoFrameDtsTime !== "undefined") result.videoFrameDtsTime = videoFrameDtsTime;
            if (typeof videoFramePtsTime !== "undefined") result.videoFramePtsTime = videoFramePtsTime;
            callback(result);
        };
        const app_handleDone_ = ({transmuxedData, callback}) => {
            transmuxedData.buffer = [];
            callback(transmuxedData);
        };
        const app_handleGopInfo_ = (event, transmuxedData) => {
            transmuxedData.gopInfo = event.data.gopInfo;
        };
        const app_processTransmux = options => {
            const {transmuxer, bytes, audioAppendStart, gopsToAlignWith, remux, onData, onTrackInfo, onAudioTimingInfo, onVideoTimingInfo, onVideoSegmentTimingInfo, onAudioSegmentTimingInfo, onId3, onCaptions, onDone, onEndedTimeline, onTransmuxerLog, isEndOfTimeline, segment, triggerSegmentEventFn} = options;
            const transmuxedData = {
                buffer: []
            };
            let waitForEndedTimelineEvent = isEndOfTimeline;
            const handleMessage = event => {
                if (transmuxer.currentTransmux !== options) return;
                if (event.data.action === "data") app_handleData_(event, transmuxedData, onData);
                if (event.data.action === "trackinfo") onTrackInfo(event.data.trackInfo);
                if (event.data.action === "gopInfo") app_handleGopInfo_(event, transmuxedData);
                if (event.data.action === "audioTimingInfo") onAudioTimingInfo(event.data.audioTimingInfo);
                if (event.data.action === "videoTimingInfo") onVideoTimingInfo(event.data.videoTimingInfo);
                if (event.data.action === "videoSegmentTimingInfo") onVideoSegmentTimingInfo(event.data.videoSegmentTimingInfo);
                if (event.data.action === "audioSegmentTimingInfo") onAudioSegmentTimingInfo(event.data.audioSegmentTimingInfo);
                if (event.data.action === "id3Frame") onId3([ event.data.id3Frame ], event.data.id3Frame.dispatchType);
                if (event.data.action === "caption") onCaptions(event.data.caption);
                if (event.data.action === "endedtimeline") {
                    waitForEndedTimelineEvent = false;
                    onEndedTimeline();
                }
                if (event.data.action === "log") onTransmuxerLog(event.data.log);
                if (event.data.type !== "transmuxed") return;
                if (waitForEndedTimelineEvent) return;
                transmuxer.onmessage = null;
                app_handleDone_({
                    transmuxedData,
                    callback: onDone
                });
                app_dequeue(transmuxer);
            };
            const handleError = () => {
                const error = {
                    message: "Received an error message from the transmuxer worker",
                    metadata: {
                        errorType: app_videojs.Error.StreamingFailedToTransmuxSegment,
                        segmentInfo: app_segmentInfoPayload({
                            segment
                        })
                    }
                };
                onDone(null, error);
            };
            transmuxer.onmessage = handleMessage;
            transmuxer.onerror = handleError;
            if (audioAppendStart) transmuxer.postMessage({
                action: "setAudioAppendStart",
                appendStart: audioAppendStart
            });
            if (Array.isArray(gopsToAlignWith)) transmuxer.postMessage({
                action: "alignGopsWith",
                gopsToAlignWith
            });
            if (typeof remux !== "undefined") transmuxer.postMessage({
                action: "setRemux",
                remux
            });
            if (bytes.byteLength) {
                const buffer = bytes instanceof ArrayBuffer ? bytes : bytes.buffer;
                const byteOffset = bytes instanceof ArrayBuffer ? 0 : bytes.byteOffset;
                triggerSegmentEventFn({
                    type: "segmenttransmuxingstart",
                    segment
                });
                transmuxer.postMessage({
                    action: "push",
                    data: buffer,
                    byteOffset,
                    byteLength: bytes.byteLength
                }, [ buffer ]);
            }
            if (isEndOfTimeline) transmuxer.postMessage({
                action: "endTimeline"
            });
            transmuxer.postMessage({
                action: "flush"
            });
        };
        const app_dequeue = transmuxer => {
            transmuxer.currentTransmux = null;
            if (transmuxer.transmuxQueue.length) {
                transmuxer.currentTransmux = transmuxer.transmuxQueue.shift();
                if (typeof transmuxer.currentTransmux === "function") transmuxer.currentTransmux(); else app_processTransmux(transmuxer.currentTransmux);
            }
        };
        const app_processAction = (transmuxer, action) => {
            transmuxer.postMessage({
                action
            });
            app_dequeue(transmuxer);
        };
        const app_enqueueAction = (action, transmuxer) => {
            if (!transmuxer.currentTransmux) {
                transmuxer.currentTransmux = action;
                app_processAction(transmuxer, action);
                return;
            }
            transmuxer.transmuxQueue.push(app_processAction.bind(null, transmuxer, action));
        };
        const app_video_es_reset = transmuxer => {
            app_enqueueAction("reset", transmuxer);
        };
        const app_endTimeline = transmuxer => {
            app_enqueueAction("endTimeline", transmuxer);
        };
        const app_transmux = options => {
            if (!options.transmuxer.currentTransmux) {
                options.transmuxer.currentTransmux = options;
                app_processTransmux(options);
                return;
            }
            options.transmuxer.transmuxQueue.push(options);
        };
        const app_createTransmuxer = options => {
            const transmuxer = new app_TransmuxWorker;
            transmuxer.currentTransmux = null;
            transmuxer.transmuxQueue = [];
            const term = transmuxer.terminate;
            transmuxer.terminate = () => {
                transmuxer.currentTransmux = null;
                transmuxer.transmuxQueue.length = 0;
                return term.call(transmuxer);
            };
            transmuxer.postMessage({
                action: "init",
                options
            });
            return transmuxer;
        };
        var app_segmentTransmuxer = {
            reset: app_video_es_reset,
            endTimeline: app_endTimeline,
            transmux: app_transmux,
            createTransmuxer: app_createTransmuxer
        };
        const app_workerCallback = function(options) {
            const transmuxer = options.transmuxer;
            const endAction = options.endAction || options.action;
            const callback = options.callback;
            const message = app_extends({}, options, {
                endAction: null,
                transmuxer: null,
                callback: null
            });
            const listenForEndEvent = event => {
                if (event.data.action !== endAction) return;
                transmuxer.removeEventListener("message", listenForEndEvent);
                if (event.data.data) {
                    event.data.data = new Uint8Array(event.data.data, options.byteOffset || 0, options.byteLength || event.data.data.byteLength);
                    if (options.data) options.data = event.data.data;
                }
                callback(event.data);
            };
            transmuxer.addEventListener("message", listenForEndEvent);
            if (options.data) {
                const isArrayBuffer = options.data instanceof ArrayBuffer;
                message.byteOffset = isArrayBuffer ? 0 : options.data.byteOffset;
                message.byteLength = options.data.byteLength;
                const transfers = [ isArrayBuffer ? options.data : options.data.buffer ];
                transmuxer.postMessage(message, transfers);
            } else transmuxer.postMessage(message);
        };
        const app_REQUEST_ERRORS = {
            FAILURE: 2,
            TIMEOUT: -101,
            ABORTED: -102
        };
        const app_WEB_VTT_CODEC = "wvtt";
        const app_abortAll = activeXhrs => {
            activeXhrs.forEach((xhr => {
                xhr.abort();
            }));
        };
        const app_getRequestStats = request => ({
            bandwidth: request.bandwidth,
            bytesReceived: request.bytesReceived || 0,
            roundTripTime: request.roundTripTime || 0
        });
        const app_getProgressStats = progressEvent => {
            const request = progressEvent.target;
            const roundTripTime = Date.now() - request.requestTime;
            const stats = {
                bandwidth: 1 / 0,
                bytesReceived: 0,
                roundTripTime: roundTripTime || 0
            };
            stats.bytesReceived = progressEvent.loaded;
            stats.bandwidth = Math.floor(stats.bytesReceived / stats.roundTripTime * 8 * 1e3);
            return stats;
        };
        const app_handleErrors = (error, request) => {
            const {requestType} = request;
            const metadata = app_getStreamingNetworkErrorMetadata({
                requestType,
                request,
                error
            });
            if (request.timedout) return {
                status: request.status,
                message: "HLS request timed-out at URL: " + request.uri,
                code: app_REQUEST_ERRORS.TIMEOUT,
                xhr: request,
                metadata
            };
            if (request.aborted) return {
                status: request.status,
                message: "HLS request aborted at URL: " + request.uri,
                code: app_REQUEST_ERRORS.ABORTED,
                xhr: request,
                metadata
            };
            if (error) return {
                status: request.status,
                message: "HLS request errored at URL: " + request.uri,
                code: app_REQUEST_ERRORS.FAILURE,
                xhr: request,
                metadata
            };
            if (request.responseType === "arraybuffer" && request.response.byteLength === 0) return {
                status: request.status,
                message: "Empty HLS response at URL: " + request.uri,
                code: app_REQUEST_ERRORS.FAILURE,
                xhr: request,
                metadata
            };
            return null;
        };
        const app_handleKeyResponse = (segment, objects, finishProcessingFn, triggerSegmentEventFn) => (error, request) => {
            const response = request.response;
            const errorObj = app_handleErrors(error, request);
            if (errorObj) return finishProcessingFn(errorObj, segment);
            if (response.byteLength !== 16) return finishProcessingFn({
                status: request.status,
                message: "Invalid HLS key at URL: " + request.uri,
                code: app_REQUEST_ERRORS.FAILURE,
                xhr: request
            }, segment);
            const view = new DataView(response);
            const bytes = new Uint32Array([ view.getUint32(0), view.getUint32(4), view.getUint32(8), view.getUint32(12) ]);
            for (let i = 0; i < objects.length; i++) objects[i].bytes = bytes;
            const keyInfo = {
                uri: request.uri
            };
            triggerSegmentEventFn({
                type: "segmentkeyloadcomplete",
                segment,
                keyInfo
            });
            return finishProcessingFn(null, segment);
        };
        const app_initMp4Text = (segment, codec) => {
            if (codec === app_WEB_VTT_CODEC) segment.transmuxer.postMessage({
                action: "initMp4WebVttParser",
                data: segment.map.bytes
            });
        };
        const app_parseMp4TextSegment = (segment, codec, doneFn) => {
            if (codec === app_WEB_VTT_CODEC) app_workerCallback({
                action: "getMp4WebVttText",
                data: segment.bytes,
                transmuxer: segment.transmuxer,
                callback: ({data, mp4VttCues}) => {
                    segment.bytes = data;
                    doneFn(null, segment, {
                        mp4VttCues
                    });
                }
            });
        };
        const app_parseInitSegment = (segment, callback) => {
            const type = app_detectContainerForBytes(segment.map.bytes);
            if (type !== "mp4") {
                const uri = segment.map.resolvedUri || segment.map.uri;
                const mediaType = type || "unknown";
                return callback({
                    internal: true,
                    message: `Found unsupported ${mediaType} container for initialization segment at URL: ${uri}`,
                    code: app_REQUEST_ERRORS.FAILURE,
                    metadata: {
                        mediaType
                    }
                });
            }
            app_workerCallback({
                action: "probeMp4Tracks",
                data: segment.map.bytes,
                transmuxer: segment.transmuxer,
                callback: ({tracks, data}) => {
                    segment.map.bytes = data;
                    tracks.forEach((function(track) {
                        segment.map.tracks = segment.map.tracks || {};
                        if (segment.map.tracks[track.type]) return;
                        segment.map.tracks[track.type] = track;
                        if (typeof track.id === "number" && track.timescale) {
                            segment.map.timescales = segment.map.timescales || {};
                            segment.map.timescales[track.id] = track.timescale;
                        }
                        if (track.type === "text") app_initMp4Text(segment, track.codec);
                    }));
                    return callback(null);
                }
            });
        };
        const app_handleInitSegmentResponse = ({segment, finishProcessingFn, triggerSegmentEventFn}) => (error, request) => {
            const errorObj = app_handleErrors(error, request);
            if (errorObj) return finishProcessingFn(errorObj, segment);
            const bytes = new Uint8Array(request.response);
            triggerSegmentEventFn({
                type: "segmentloaded",
                segment
            });
            if (segment.map.key) {
                segment.map.encryptedBytes = bytes;
                return finishProcessingFn(null, segment);
            }
            segment.map.bytes = bytes;
            app_parseInitSegment(segment, (function(parseError) {
                if (parseError) {
                    parseError.xhr = request;
                    parseError.status = request.status;
                    return finishProcessingFn(parseError, segment);
                }
                finishProcessingFn(null, segment);
            }));
        };
        const app_handleSegmentResponse = ({segment, finishProcessingFn, responseType, triggerSegmentEventFn}) => (error, request) => {
            const errorObj = app_handleErrors(error, request);
            if (errorObj) return finishProcessingFn(errorObj, segment);
            triggerSegmentEventFn({
                type: "segmentloaded",
                segment
            });
            const newBytes = responseType === "arraybuffer" || !request.responseText ? request.response : app_stringToArrayBuffer(request.responseText.substring(segment.lastReachedChar || 0));
            segment.stats = app_getRequestStats(request);
            if (segment.key) segment.encryptedBytes = new Uint8Array(newBytes); else segment.bytes = new Uint8Array(newBytes);
            return finishProcessingFn(null, segment);
        };
        const app_transmuxAndNotify = ({segment, bytes, trackInfoFn, timingInfoFn, videoSegmentTimingInfoFn, audioSegmentTimingInfoFn, id3Fn, captionsFn, isEndOfTimeline, endedTimelineFn, dataFn, doneFn, onTransmuxerLog, triggerSegmentEventFn}) => {
            const fmp4Tracks = segment.map && segment.map.tracks || {};
            const isMuxed = Boolean(fmp4Tracks.audio && fmp4Tracks.video);
            let audioStartFn = timingInfoFn.bind(null, segment, "audio", "start");
            const audioEndFn = timingInfoFn.bind(null, segment, "audio", "end");
            let videoStartFn = timingInfoFn.bind(null, segment, "video", "start");
            const videoEndFn = timingInfoFn.bind(null, segment, "video", "end");
            const finish = () => app_transmux({
                bytes,
                transmuxer: segment.transmuxer,
                audioAppendStart: segment.audioAppendStart,
                gopsToAlignWith: segment.gopsToAlignWith,
                remux: isMuxed,
                onData: result => {
                    result.type = result.type === "combined" ? "video" : result.type;
                    dataFn(segment, result);
                },
                onTrackInfo: trackInfo => {
                    if (trackInfoFn) {
                        if (isMuxed) trackInfo.isMuxed = true;
                        trackInfoFn(segment, trackInfo);
                    }
                },
                onAudioTimingInfo: audioTimingInfo => {
                    if (audioStartFn && typeof audioTimingInfo.start !== "undefined") {
                        audioStartFn(audioTimingInfo.start);
                        audioStartFn = null;
                    }
                    if (audioEndFn && typeof audioTimingInfo.end !== "undefined") audioEndFn(audioTimingInfo.end);
                },
                onVideoTimingInfo: videoTimingInfo => {
                    if (videoStartFn && typeof videoTimingInfo.start !== "undefined") {
                        videoStartFn(videoTimingInfo.start);
                        videoStartFn = null;
                    }
                    if (videoEndFn && typeof videoTimingInfo.end !== "undefined") videoEndFn(videoTimingInfo.end);
                },
                onVideoSegmentTimingInfo: videoSegmentTimingInfo => {
                    const timingInfo = {
                        pts: {
                            start: videoSegmentTimingInfo.start.presentation,
                            end: videoSegmentTimingInfo.end.presentation
                        },
                        dts: {
                            start: videoSegmentTimingInfo.start.decode,
                            end: videoSegmentTimingInfo.end.decode
                        }
                    };
                    triggerSegmentEventFn({
                        type: "segmenttransmuxingtiminginfoavailable",
                        segment,
                        timingInfo
                    });
                    videoSegmentTimingInfoFn(videoSegmentTimingInfo);
                },
                onAudioSegmentTimingInfo: audioSegmentTimingInfo => {
                    const timingInfo = {
                        pts: {
                            start: audioSegmentTimingInfo.start.pts,
                            end: audioSegmentTimingInfo.end.pts
                        },
                        dts: {
                            start: audioSegmentTimingInfo.start.dts,
                            end: audioSegmentTimingInfo.end.dts
                        }
                    };
                    triggerSegmentEventFn({
                        type: "segmenttransmuxingtiminginfoavailable",
                        segment,
                        timingInfo
                    });
                    audioSegmentTimingInfoFn(audioSegmentTimingInfo);
                },
                onId3: (id3Frames, dispatchType) => {
                    id3Fn(segment, id3Frames, dispatchType);
                },
                onCaptions: captions => {
                    captionsFn(segment, [ captions ]);
                },
                isEndOfTimeline,
                onEndedTimeline: () => {
                    endedTimelineFn();
                },
                onTransmuxerLog,
                onDone: (result, error) => {
                    if (!doneFn) return;
                    result.type = result.type === "combined" ? "video" : result.type;
                    triggerSegmentEventFn({
                        type: "segmenttransmuxingcomplete",
                        segment
                    });
                    doneFn(error, segment, result);
                },
                segment,
                triggerSegmentEventFn
            });
            app_workerCallback({
                action: "probeTs",
                transmuxer: segment.transmuxer,
                data: bytes,
                baseStartTime: segment.baseStartTime,
                callback: data => {
                    segment.bytes = bytes = data.data;
                    const probeResult = data.result;
                    if (probeResult) {
                        trackInfoFn(segment, {
                            hasAudio: probeResult.hasAudio,
                            hasVideo: probeResult.hasVideo,
                            isMuxed
                        });
                        trackInfoFn = null;
                    }
                    finish();
                }
            });
        };
        const app_handleSegmentBytes = ({segment, bytes, trackInfoFn, timingInfoFn, videoSegmentTimingInfoFn, audioSegmentTimingInfoFn, id3Fn, captionsFn, isEndOfTimeline, endedTimelineFn, dataFn, doneFn, onTransmuxerLog, triggerSegmentEventFn}) => {
            let bytesAsUint8Array = new Uint8Array(bytes);
            if (app_isLikelyFmp4MediaSegment(bytesAsUint8Array)) {
                segment.isFmp4 = true;
                const {tracks} = segment.map;
                const isMp4TextSegment = tracks.text && (!tracks.audio || !tracks.video);
                if (isMp4TextSegment) {
                    dataFn(segment, {
                        data: bytesAsUint8Array,
                        type: "text"
                    });
                    app_parseMp4TextSegment(segment, tracks.text.codec, doneFn);
                    return;
                }
                const trackInfo = {
                    isFmp4: true,
                    hasVideo: !!tracks.video,
                    hasAudio: !!tracks.audio
                };
                if (tracks.audio && tracks.audio.codec && tracks.audio.codec !== "enca") trackInfo.audioCodec = tracks.audio.codec;
                if (tracks.video && tracks.video.codec && tracks.video.codec !== "encv") trackInfo.videoCodec = tracks.video.codec;
                if (tracks.video && tracks.audio) trackInfo.isMuxed = true;
                trackInfoFn(segment, trackInfo);
                const finishLoading = (captions, id3Frames) => {
                    dataFn(segment, {
                        data: bytesAsUint8Array,
                        type: trackInfo.hasAudio && !trackInfo.isMuxed ? "audio" : "video"
                    });
                    if (id3Frames && id3Frames.length) id3Fn(segment, id3Frames);
                    if (captions && captions.length) captionsFn(segment, captions);
                    doneFn(null, segment, {});
                };
                app_workerCallback({
                    action: "probeMp4StartTime",
                    timescales: segment.map.timescales,
                    data: bytesAsUint8Array,
                    transmuxer: segment.transmuxer,
                    callback: ({data, startTime}) => {
                        bytes = data.buffer;
                        segment.bytes = bytesAsUint8Array = data;
                        if (trackInfo.hasAudio && !trackInfo.isMuxed) timingInfoFn(segment, "audio", "start", startTime);
                        if (trackInfo.hasVideo) timingInfoFn(segment, "video", "start", startTime);
                        app_workerCallback({
                            action: "probeEmsgID3",
                            data: bytesAsUint8Array,
                            transmuxer: segment.transmuxer,
                            offset: startTime,
                            callback: ({emsgData, id3Frames}) => {
                                bytes = emsgData.buffer;
                                segment.bytes = bytesAsUint8Array = emsgData;
                                if (!tracks.video || !emsgData.byteLength || !segment.transmuxer) {
                                    finishLoading(void 0, id3Frames);
                                    return;
                                }
                                app_workerCallback({
                                    action: "pushMp4Captions",
                                    endAction: "mp4Captions",
                                    transmuxer: segment.transmuxer,
                                    data: bytesAsUint8Array,
                                    timescales: segment.map.timescales,
                                    trackIds: [ tracks.video.id ],
                                    callback: message => {
                                        bytes = message.data.buffer;
                                        segment.bytes = bytesAsUint8Array = message.data;
                                        message.logs.forEach((function(log) {
                                            onTransmuxerLog(app_video_es_merge(log, {
                                                stream: "mp4CaptionParser"
                                            }));
                                        }));
                                        finishLoading(message.captions, id3Frames);
                                    }
                                });
                            }
                        });
                    }
                });
                return;
            }
            if (!segment.transmuxer) {
                doneFn(null, segment, {});
                return;
            }
            if (typeof segment.container === "undefined") segment.container = app_detectContainerForBytes(bytesAsUint8Array);
            if (segment.container !== "ts" && segment.container !== "aac") {
                trackInfoFn(segment, {
                    hasAudio: false,
                    hasVideo: false
                });
                doneFn(null, segment, {});
                return;
            }
            app_transmuxAndNotify({
                segment,
                bytes,
                trackInfoFn,
                timingInfoFn,
                videoSegmentTimingInfoFn,
                audioSegmentTimingInfoFn,
                id3Fn,
                captionsFn,
                isEndOfTimeline,
                endedTimelineFn,
                dataFn,
                doneFn,
                onTransmuxerLog,
                triggerSegmentEventFn
            });
        };
        const app_decrypt = function({id, key, encryptedBytes, decryptionWorker, segment, doneFn}, callback) {
            const decryptionHandler = event => {
                if (event.data.source === id) {
                    decryptionWorker.removeEventListener("message", decryptionHandler);
                    const decrypted = event.data.decrypted;
                    callback(new Uint8Array(decrypted.bytes, decrypted.byteOffset, decrypted.byteLength));
                }
            };
            decryptionWorker.onerror = () => {
                const message = "An error occurred in the decryption worker";
                const segmentInfo = app_segmentInfoPayload({
                    segment
                });
                const decryptError = {
                    message,
                    metadata: {
                        error: new Error(message),
                        errorType: app_videojs.Error.StreamingFailedToDecryptSegment,
                        segmentInfo,
                        keyInfo: {
                            uri: segment.key.resolvedUri || segment.map.key.resolvedUri
                        }
                    }
                };
                doneFn(decryptError, segment);
            };
            decryptionWorker.addEventListener("message", decryptionHandler);
            let keyBytes;
            if (key.bytes.slice) keyBytes = key.bytes.slice(); else keyBytes = new Uint32Array(Array.prototype.slice.call(key.bytes));
            decryptionWorker.postMessage(app_createTransferableMessage({
                source: id,
                encrypted: encryptedBytes,
                key: keyBytes,
                iv: key.iv
            }), [ encryptedBytes.buffer, keyBytes.buffer ]);
        };
        const app_decryptSegment = ({decryptionWorker, segment, trackInfoFn, timingInfoFn, videoSegmentTimingInfoFn, audioSegmentTimingInfoFn, id3Fn, captionsFn, isEndOfTimeline, endedTimelineFn, dataFn, doneFn, onTransmuxerLog, triggerSegmentEventFn}) => {
            triggerSegmentEventFn({
                type: "segmentdecryptionstart"
            });
            app_decrypt({
                id: segment.requestId,
                key: segment.key,
                encryptedBytes: segment.encryptedBytes,
                decryptionWorker,
                segment,
                doneFn
            }, (decryptedBytes => {
                segment.bytes = decryptedBytes;
                triggerSegmentEventFn({
                    type: "segmentdecryptioncomplete",
                    segment
                });
                app_handleSegmentBytes({
                    segment,
                    bytes: segment.bytes,
                    trackInfoFn,
                    timingInfoFn,
                    videoSegmentTimingInfoFn,
                    audioSegmentTimingInfoFn,
                    id3Fn,
                    captionsFn,
                    isEndOfTimeline,
                    endedTimelineFn,
                    dataFn,
                    doneFn,
                    onTransmuxerLog,
                    triggerSegmentEventFn
                });
            }));
        };
        const app_waitForCompletion = ({activeXhrs, decryptionWorker, trackInfoFn, timingInfoFn, videoSegmentTimingInfoFn, audioSegmentTimingInfoFn, id3Fn, captionsFn, isEndOfTimeline, endedTimelineFn, dataFn, doneFn, onTransmuxerLog, triggerSegmentEventFn}) => {
            let count = 0;
            let didError = false;
            return (error, segment) => {
                if (didError) return;
                if (error) {
                    didError = true;
                    app_abortAll(activeXhrs);
                    return doneFn(error, segment);
                }
                count += 1;
                if (count === activeXhrs.length) {
                    const segmentFinish = function() {
                        if (segment.encryptedBytes) return app_decryptSegment({
                            decryptionWorker,
                            segment,
                            trackInfoFn,
                            timingInfoFn,
                            videoSegmentTimingInfoFn,
                            audioSegmentTimingInfoFn,
                            id3Fn,
                            captionsFn,
                            isEndOfTimeline,
                            endedTimelineFn,
                            dataFn,
                            doneFn,
                            onTransmuxerLog,
                            triggerSegmentEventFn
                        });
                        app_handleSegmentBytes({
                            segment,
                            bytes: segment.bytes,
                            trackInfoFn,
                            timingInfoFn,
                            videoSegmentTimingInfoFn,
                            audioSegmentTimingInfoFn,
                            id3Fn,
                            captionsFn,
                            isEndOfTimeline,
                            endedTimelineFn,
                            dataFn,
                            doneFn,
                            onTransmuxerLog,
                            triggerSegmentEventFn
                        });
                    };
                    segment.endOfAllRequests = Date.now();
                    if (segment.map && segment.map.encryptedBytes && !segment.map.bytes) {
                        triggerSegmentEventFn({
                            type: "segmentdecryptionstart",
                            segment
                        });
                        return app_decrypt({
                            decryptionWorker,
                            id: segment.requestId + "-init",
                            encryptedBytes: segment.map.encryptedBytes,
                            key: segment.map.key,
                            segment,
                            doneFn
                        }, (decryptedBytes => {
                            segment.map.bytes = decryptedBytes;
                            triggerSegmentEventFn({
                                type: "segmentdecryptioncomplete",
                                segment
                            });
                            app_parseInitSegment(segment, (parseError => {
                                if (parseError) {
                                    app_abortAll(activeXhrs);
                                    return doneFn(parseError, segment);
                                }
                                segmentFinish();
                            }));
                        }));
                    }
                    segmentFinish();
                }
            };
        };
        const app_handleLoadEnd = ({loadendState, abortFn}) => event => {
            const request = event.target;
            if (request.aborted && abortFn && !loadendState.calledAbortFn) {
                abortFn();
                loadendState.calledAbortFn = true;
            }
        };
        const app_handleProgress = ({segment, progressFn, trackInfoFn, timingInfoFn, videoSegmentTimingInfoFn, audioSegmentTimingInfoFn, id3Fn, captionsFn, isEndOfTimeline, endedTimelineFn, dataFn}) => event => {
            const request = event.target;
            if (request.aborted) return;
            segment.stats = app_video_es_merge(segment.stats, app_getProgressStats(event));
            if (!segment.stats.firstBytesReceivedAt && segment.stats.bytesReceived) segment.stats.firstBytesReceivedAt = Date.now();
            return progressFn(event, segment);
        };
        const app_mediaSegmentRequest = ({xhr, xhrOptions, decryptionWorker, segment, abortFn, progressFn, trackInfoFn, timingInfoFn, videoSegmentTimingInfoFn, audioSegmentTimingInfoFn, id3Fn, captionsFn, isEndOfTimeline, endedTimelineFn, dataFn, doneFn, onTransmuxerLog, triggerSegmentEventFn}) => {
            const activeXhrs = [];
            const finishProcessingFn = app_waitForCompletion({
                activeXhrs,
                decryptionWorker,
                trackInfoFn,
                timingInfoFn,
                videoSegmentTimingInfoFn,
                audioSegmentTimingInfoFn,
                id3Fn,
                captionsFn,
                isEndOfTimeline,
                endedTimelineFn,
                dataFn,
                doneFn,
                onTransmuxerLog,
                triggerSegmentEventFn
            });
            if (segment.key && !segment.key.bytes) {
                const objects = [ segment.key ];
                if (segment.map && !segment.map.bytes && segment.map.key && segment.map.key.resolvedUri === segment.key.resolvedUri) objects.push(segment.map.key);
                const keyRequestOptions = app_video_es_merge(xhrOptions, {
                    uri: segment.key.resolvedUri,
                    responseType: "arraybuffer",
                    requestType: "segment-key"
                });
                const keyRequestCallback = app_handleKeyResponse(segment, objects, finishProcessingFn, triggerSegmentEventFn);
                const keyInfo = {
                    uri: segment.key.resolvedUri
                };
                triggerSegmentEventFn({
                    type: "segmentkeyloadstart",
                    segment,
                    keyInfo
                });
                const keyXhr = xhr(keyRequestOptions, keyRequestCallback);
                activeXhrs.push(keyXhr);
            }
            if (segment.map && !segment.map.bytes) {
                const differentMapKey = segment.map.key && (!segment.key || segment.key.resolvedUri !== segment.map.key.resolvedUri);
                if (differentMapKey) {
                    const mapKeyRequestOptions = app_video_es_merge(xhrOptions, {
                        uri: segment.map.key.resolvedUri,
                        responseType: "arraybuffer",
                        requestType: "segment-key"
                    });
                    const mapKeyRequestCallback = app_handleKeyResponse(segment, [ segment.map.key ], finishProcessingFn, triggerSegmentEventFn);
                    const keyInfo = {
                        uri: segment.map.key.resolvedUri
                    };
                    triggerSegmentEventFn({
                        type: "segmentkeyloadstart",
                        segment,
                        keyInfo
                    });
                    const mapKeyXhr = xhr(mapKeyRequestOptions, mapKeyRequestCallback);
                    activeXhrs.push(mapKeyXhr);
                }
                const initSegmentOptions = app_video_es_merge(xhrOptions, {
                    uri: segment.map.resolvedUri,
                    responseType: "arraybuffer",
                    headers: app_segmentXhrHeaders(segment.map),
                    requestType: "segment-media-initialization"
                });
                const initSegmentRequestCallback = app_handleInitSegmentResponse({
                    segment,
                    finishProcessingFn,
                    triggerSegmentEventFn
                });
                triggerSegmentEventFn({
                    type: "segmentloadstart",
                    segment
                });
                const initSegmentXhr = xhr(initSegmentOptions, initSegmentRequestCallback);
                activeXhrs.push(initSegmentXhr);
            }
            const segmentRequestOptions = app_video_es_merge(xhrOptions, {
                uri: segment.part && segment.part.resolvedUri || segment.resolvedUri,
                responseType: "arraybuffer",
                headers: app_segmentXhrHeaders(segment),
                requestType: "segment"
            });
            const segmentRequestCallback = app_handleSegmentResponse({
                segment,
                finishProcessingFn,
                responseType: segmentRequestOptions.responseType,
                triggerSegmentEventFn
            });
            triggerSegmentEventFn({
                type: "segmentloadstart",
                segment
            });
            const segmentXhr = xhr(segmentRequestOptions, segmentRequestCallback);
            segmentXhr.addEventListener("progress", app_handleProgress({
                segment,
                progressFn,
                trackInfoFn,
                timingInfoFn,
                videoSegmentTimingInfoFn,
                audioSegmentTimingInfoFn,
                id3Fn,
                captionsFn,
                isEndOfTimeline,
                endedTimelineFn,
                dataFn
            }));
            activeXhrs.push(segmentXhr);
            const loadendState = {};
            activeXhrs.forEach((activeXhr => {
                activeXhr.addEventListener("loadend", app_handleLoadEnd({
                    loadendState,
                    abortFn
                }));
            }));
            return () => app_abortAll(activeXhrs);
        };
        const app_logFn$1 = app_logger("CodecUtils");
        const app_getCodecs = function(media) {
            const mediaAttributes = media.attributes || {};
            if (mediaAttributes.CODECS) return app_parseCodecs(mediaAttributes.CODECS);
        };
        const app_isMaat = (main, media) => {
            const mediaAttributes = media.attributes || {};
            return main && main.mediaGroups && main.mediaGroups.AUDIO && mediaAttributes.AUDIO && main.mediaGroups.AUDIO[mediaAttributes.AUDIO];
        };
        const app_isMuxed = (main, media) => {
            if (!app_isMaat(main, media)) return true;
            const mediaAttributes = media.attributes || {};
            const audioGroup = main.mediaGroups.AUDIO[mediaAttributes.AUDIO];
            for (const groupId in audioGroup) if (!audioGroup[groupId].uri && !audioGroup[groupId].playlists) return true;
            return false;
        };
        const app_unwrapCodecList = function(codecList) {
            const codecs = {};
            codecList.forEach((({mediaType, type, details}) => {
                codecs[mediaType] = codecs[mediaType] || [];
                codecs[mediaType].push(app_translateLegacyCodec(`${type}${details}`));
            }));
            Object.keys(codecs).forEach((function(mediaType) {
                if (codecs[mediaType].length > 1) {
                    app_logFn$1(`multiple ${mediaType} codecs found as attributes: ${codecs[mediaType].join(", ")}. Setting playlist codecs to null so that we wait for mux.js to probe segments for real codecs.`);
                    codecs[mediaType] = null;
                    return;
                }
                codecs[mediaType] = codecs[mediaType][0];
            }));
            return codecs;
        };
        const app_codecCount = function(codecObj) {
            let count = 0;
            if (codecObj.audio) count++;
            if (codecObj.video) count++;
            return count;
        };
        const app_codecsForPlaylist = function(main, media) {
            const mediaAttributes = media.attributes || {};
            const codecInfo = app_unwrapCodecList(app_getCodecs(media) || []);
            if (app_isMaat(main, media) && !codecInfo.audio) if (!app_isMuxed(main, media)) {
                const defaultCodecs = app_unwrapCodecList(app_codecsFromDefault(main, mediaAttributes.AUDIO) || []);
                if (defaultCodecs.audio) codecInfo.audio = defaultCodecs.audio;
            }
            return codecInfo;
        };
        const app_logFn = app_logger("PlaylistSelector");
        const app_representationToString = function(representation) {
            if (!representation || !representation.playlist) return;
            const playlist = representation.playlist;
            return JSON.stringify({
                id: playlist.id,
                bandwidth: representation.bandwidth,
                width: representation.width,
                height: representation.height,
                codecs: playlist.attributes && playlist.attributes.CODECS || ""
            });
        };
        const app_safeGetComputedStyle = function(el, property) {
            if (!el) return "";
            const result = app_window_default().getComputedStyle(el);
            if (!result) return "";
            return result[property];
        };
        const app_stableSort = function(array, sortFn) {
            const newArray = array.slice();
            array.sort((function(left, right) {
                const cmp = sortFn(left, right);
                if (cmp === 0) return newArray.indexOf(left) - newArray.indexOf(right);
                return cmp;
            }));
        };
        const app_comparePlaylistBandwidth = function(left, right) {
            let leftBandwidth;
            let rightBandwidth;
            if (left.attributes.BANDWIDTH) leftBandwidth = left.attributes.BANDWIDTH;
            leftBandwidth = leftBandwidth || app_window_default().Number.MAX_VALUE;
            if (right.attributes.BANDWIDTH) rightBandwidth = right.attributes.BANDWIDTH;
            rightBandwidth = rightBandwidth || app_window_default().Number.MAX_VALUE;
            return leftBandwidth - rightBandwidth;
        };
        const app_comparePlaylistResolution = function(left, right) {
            let leftWidth;
            let rightWidth;
            if (left.attributes.RESOLUTION && left.attributes.RESOLUTION.width) leftWidth = left.attributes.RESOLUTION.width;
            leftWidth = leftWidth || app_window_default().Number.MAX_VALUE;
            if (right.attributes.RESOLUTION && right.attributes.RESOLUTION.width) rightWidth = right.attributes.RESOLUTION.width;
            rightWidth = rightWidth || app_window_default().Number.MAX_VALUE;
            if (leftWidth === rightWidth && left.attributes.BANDWIDTH && right.attributes.BANDWIDTH) return left.attributes.BANDWIDTH - right.attributes.BANDWIDTH;
            return leftWidth - rightWidth;
        };
        let app_simpleSelector = function(main, playerBandwidth, playerWidth, playerHeight, limitRenditionByPlayerDimensions, playlistController) {
            if (!main) return;
            const options = {
                bandwidth: playerBandwidth,
                width: playerWidth,
                height: playerHeight,
                limitRenditionByPlayerDimensions
            };
            let playlists = main.playlists;
            if (app_Playlist.isAudioOnly(main)) {
                playlists = playlistController.getAudioTrackPlaylists_();
                options.audioOnly = true;
            }
            let sortedPlaylistReps = playlists.map((playlist => {
                let bandwidth;
                const width = playlist.attributes && playlist.attributes.RESOLUTION && playlist.attributes.RESOLUTION.width;
                const height = playlist.attributes && playlist.attributes.RESOLUTION && playlist.attributes.RESOLUTION.height;
                bandwidth = playlist.attributes && playlist.attributes.BANDWIDTH;
                bandwidth = bandwidth || app_window_default().Number.MAX_VALUE;
                return {
                    bandwidth,
                    width,
                    height,
                    playlist
                };
            }));
            app_stableSort(sortedPlaylistReps, ((left, right) => left.bandwidth - right.bandwidth));
            sortedPlaylistReps = sortedPlaylistReps.filter((rep => !app_Playlist.isIncompatible(rep.playlist)));
            let enabledPlaylistReps = sortedPlaylistReps.filter((rep => app_Playlist.isEnabled(rep.playlist)));
            if (!enabledPlaylistReps.length) enabledPlaylistReps = sortedPlaylistReps.filter((rep => !app_Playlist.isDisabled(rep.playlist)));
            const bandwidthPlaylistReps = enabledPlaylistReps.filter((rep => rep.bandwidth * app_Config.BANDWIDTH_VARIANCE < playerBandwidth));
            let highestRemainingBandwidthRep = bandwidthPlaylistReps[bandwidthPlaylistReps.length - 1];
            const bandwidthBestRep = bandwidthPlaylistReps.filter((rep => rep.bandwidth === highestRemainingBandwidthRep.bandwidth))[0];
            if (limitRenditionByPlayerDimensions === false) {
                const chosenRep = bandwidthBestRep || enabledPlaylistReps[0] || sortedPlaylistReps[0];
                if (chosenRep && chosenRep.playlist) {
                    let type = "sortedPlaylistReps";
                    if (bandwidthBestRep) type = "bandwidthBestRep";
                    if (enabledPlaylistReps[0]) type = "enabledPlaylistReps";
                    app_logFn(`choosing ${app_representationToString(chosenRep)} using ${type} with options`, options);
                    return chosenRep.playlist;
                }
                app_logFn("could not choose a playlist with options", options);
                return null;
            }
            const haveResolution = bandwidthPlaylistReps.filter((rep => rep.width && rep.height));
            app_stableSort(haveResolution, ((left, right) => left.width - right.width));
            const resolutionBestRepList = haveResolution.filter((rep => rep.width === playerWidth && rep.height === playerHeight));
            highestRemainingBandwidthRep = resolutionBestRepList[resolutionBestRepList.length - 1];
            const resolutionBestRep = resolutionBestRepList.filter((rep => rep.bandwidth === highestRemainingBandwidthRep.bandwidth))[0];
            let resolutionPlusOneList;
            let resolutionPlusOneSmallest;
            let resolutionPlusOneRep;
            if (!resolutionBestRep) {
                resolutionPlusOneList = haveResolution.filter((rep => rep.width > playerWidth || rep.height > playerHeight));
                resolutionPlusOneSmallest = resolutionPlusOneList.filter((rep => rep.width === resolutionPlusOneList[0].width && rep.height === resolutionPlusOneList[0].height));
                highestRemainingBandwidthRep = resolutionPlusOneSmallest[resolutionPlusOneSmallest.length - 1];
                resolutionPlusOneRep = resolutionPlusOneSmallest.filter((rep => rep.bandwidth === highestRemainingBandwidthRep.bandwidth))[0];
            }
            let leastPixelDiffRep;
            if (playlistController.leastPixelDiffSelector) {
                const leastPixelDiffList = haveResolution.map((rep => {
                    rep.pixelDiff = Math.abs(rep.width - playerWidth) + Math.abs(rep.height - playerHeight);
                    return rep;
                }));
                app_stableSort(leastPixelDiffList, ((left, right) => {
                    if (left.pixelDiff === right.pixelDiff) return right.bandwidth - left.bandwidth;
                    return left.pixelDiff - right.pixelDiff;
                }));
                leastPixelDiffRep = leastPixelDiffList[0];
            }
            const chosenRep = leastPixelDiffRep || resolutionPlusOneRep || resolutionBestRep || bandwidthBestRep || enabledPlaylistReps[0] || sortedPlaylistReps[0];
            if (chosenRep && chosenRep.playlist) {
                let type = "sortedPlaylistReps";
                if (leastPixelDiffRep) type = "leastPixelDiffRep"; else if (resolutionPlusOneRep) type = "resolutionPlusOneRep"; else if (resolutionBestRep) type = "resolutionBestRep"; else if (bandwidthBestRep) type = "bandwidthBestRep"; else if (enabledPlaylistReps[0]) type = "enabledPlaylistReps";
                app_logFn(`choosing ${app_representationToString(chosenRep)} using ${type} with options`, options);
                return chosenRep.playlist;
            }
            app_logFn("could not choose a playlist with options", options);
            return null;
        };
        const app_lastBandwidthSelector = function() {
            let pixelRatio = this.useDevicePixelRatio ? app_window_default().devicePixelRatio || 1 : 1;
            if (!isNaN(this.customPixelRatio)) pixelRatio = this.customPixelRatio;
            return app_simpleSelector(this.playlists.main, this.systemBandwidth, parseInt(app_safeGetComputedStyle(this.tech_.el(), "width"), 10) * pixelRatio, parseInt(app_safeGetComputedStyle(this.tech_.el(), "height"), 10) * pixelRatio, this.limitRenditionByPlayerDimensions, this.playlistController_);
        };
        const app_movingAverageBandwidthSelector = function(decay) {
            let average = -1;
            let lastSystemBandwidth = -1;
            if (decay < 0 || decay > 1) throw new Error("Moving average bandwidth decay must be between 0 and 1.");
            return function() {
                let pixelRatio = this.useDevicePixelRatio ? app_window_default().devicePixelRatio || 1 : 1;
                if (!isNaN(this.customPixelRatio)) pixelRatio = this.customPixelRatio;
                if (average < 0) {
                    average = this.systemBandwidth;
                    lastSystemBandwidth = this.systemBandwidth;
                }
                if (this.systemBandwidth > 0 && this.systemBandwidth !== lastSystemBandwidth) {
                    average = decay * this.systemBandwidth + (1 - decay) * average;
                    lastSystemBandwidth = this.systemBandwidth;
                }
                return app_simpleSelector(this.playlists.main, average, parseInt(app_safeGetComputedStyle(this.tech_.el(), "width"), 10) * pixelRatio, parseInt(app_safeGetComputedStyle(this.tech_.el(), "height"), 10) * pixelRatio, this.limitRenditionByPlayerDimensions, this.playlistController_);
            };
        };
        const app_minRebufferMaxBandwidthSelector = function(settings) {
            const {main, currentTime, bandwidth, duration, segmentDuration, timeUntilRebuffer, currentTimeline, syncController} = settings;
            const compatiblePlaylists = main.playlists.filter((playlist => !app_Playlist.isIncompatible(playlist)));
            let enabledPlaylists = compatiblePlaylists.filter(app_Playlist.isEnabled);
            if (!enabledPlaylists.length) enabledPlaylists = compatiblePlaylists.filter((playlist => !app_Playlist.isDisabled(playlist)));
            const bandwidthPlaylists = enabledPlaylists.filter(app_Playlist.hasAttribute.bind(null, "BANDWIDTH"));
            const rebufferingEstimates = bandwidthPlaylists.map((playlist => {
                const syncPoint = syncController.getSyncPoint(playlist, duration, currentTimeline, currentTime);
                const numRequests = syncPoint ? 1 : 2;
                const requestTimeEstimate = app_Playlist.estimateSegmentRequestTime(segmentDuration, bandwidth, playlist);
                const rebufferingImpact = requestTimeEstimate * numRequests - timeUntilRebuffer;
                return {
                    playlist,
                    rebufferingImpact
                };
            }));
            const noRebufferingPlaylists = rebufferingEstimates.filter((estimate => estimate.rebufferingImpact <= 0));
            app_stableSort(noRebufferingPlaylists, ((a, b) => app_comparePlaylistBandwidth(b.playlist, a.playlist)));
            if (noRebufferingPlaylists.length) return noRebufferingPlaylists[0];
            app_stableSort(rebufferingEstimates, ((a, b) => a.rebufferingImpact - b.rebufferingImpact));
            return rebufferingEstimates[0] || null;
        };
        const app_lowestBitrateCompatibleVariantSelector = function() {
            const playlists = this.playlists.main.playlists.filter(app_Playlist.isEnabled);
            app_stableSort(playlists, ((a, b) => app_comparePlaylistBandwidth(a, b)));
            const playlistsWithVideo = playlists.filter((playlist => !!app_codecsForPlaylist(this.playlists.main, playlist).video));
            return playlistsWithVideo[0] || null;
        };
        const app_concatSegments = segmentObj => {
            let offset = 0;
            let tempBuffer;
            if (segmentObj.bytes) {
                tempBuffer = new Uint8Array(segmentObj.bytes);
                segmentObj.segments.forEach((segment => {
                    tempBuffer.set(segment, offset);
                    offset += segment.byteLength;
                }));
            }
            return tempBuffer;
        };
        function app_compactSegmentUrlDescription(resolvedUri) {
            try {
                return new URL(resolvedUri).pathname.split("/").slice(-2).join("/");
            } catch (e) {
                return "";
            }
        }
        const app_createCaptionsTrackIfNotExists = function(inbandTextTracks, tech, captionStream) {
            if (!inbandTextTracks[captionStream]) {
                tech.trigger({
                    type: "usage",
                    name: "vhs-608"
                });
                let instreamId = captionStream;
                if (/^cc708_/.test(captionStream)) instreamId = "SERVICE" + captionStream.split("_")[1];
                const track = tech.textTracks().getTrackById(instreamId);
                if (track) inbandTextTracks[captionStream] = track; else {
                    const captionServices = tech.options_.vhs && tech.options_.vhs.captionServices || {};
                    let label = captionStream;
                    let language = captionStream;
                    let def = false;
                    const captionService = captionServices[instreamId];
                    if (captionService) {
                        label = captionService.label;
                        language = captionService.language;
                        def = captionService.default;
                    }
                    inbandTextTracks[captionStream] = tech.addRemoteTextTrack({
                        kind: "captions",
                        id: instreamId,
                        default: def,
                        label,
                        language
                    }, false).track;
                }
            }
        };
        const app_addCaptionData = function({inbandTextTracks, captionArray, timestampOffset}) {
            if (!captionArray) return;
            const Cue = app_window_default().WebKitDataCue || app_window_default().VTTCue;
            captionArray.forEach((caption => {
                const track = caption.stream;
                if (caption.content) caption.content.forEach((value => {
                    const cue = new Cue(caption.startTime + timestampOffset, caption.endTime + timestampOffset, value.text);
                    cue.line = value.line;
                    cue.align = "left";
                    cue.position = value.position;
                    cue.positionAlign = "line-left";
                    inbandTextTracks[track].addCue(cue);
                })); else inbandTextTracks[track].addCue(new Cue(caption.startTime + timestampOffset, caption.endTime + timestampOffset, caption.text));
            }));
        };
        const app_deprecateOldCue = function(cue) {
            Object.defineProperties(cue.frame, {
                id: {
                    get() {
                        app_videojs.log.warn("cue.frame.id is deprecated. Use cue.value.key instead.");
                        return cue.value.key;
                    }
                },
                value: {
                    get() {
                        app_videojs.log.warn("cue.frame.value is deprecated. Use cue.value.data instead.");
                        return cue.value.data;
                    }
                },
                privateData: {
                    get() {
                        app_videojs.log.warn("cue.frame.privateData is deprecated. Use cue.value.data instead.");
                        return cue.value.data;
                    }
                }
            });
        };
        const app_addMetadata = ({inbandTextTracks, metadataArray, timestampOffset, videoDuration}) => {
            if (!metadataArray) return;
            const Cue = app_window_default().WebKitDataCue || app_window_default().VTTCue;
            const metadataTrack = inbandTextTracks.metadataTrack_;
            if (!metadataTrack) return;
            metadataArray.forEach((metadata => {
                const time = metadata.cueTime + timestampOffset;
                if (typeof time !== "number" || app_window_default().isNaN(time) || time < 0 || !(time < 1 / 0)) return;
                if (!metadata.frames || !metadata.frames.length) return;
                metadata.frames.forEach((frame => {
                    const cue = new Cue(time, time, frame.value || frame.url || frame.data || "");
                    cue.frame = frame;
                    cue.value = frame;
                    app_deprecateOldCue(cue);
                    metadataTrack.addCue(cue);
                }));
            }));
            if (!metadataTrack.cues || !metadataTrack.cues.length) return;
            const cues = metadataTrack.cues;
            const cuesArray = [];
            for (let i = 0; i < cues.length; i++) if (cues[i]) cuesArray.push(cues[i]);
            const cuesGroupedByStartTime = cuesArray.reduce(((obj, cue) => {
                const timeSlot = obj[cue.startTime] || [];
                timeSlot.push(cue);
                obj[cue.startTime] = timeSlot;
                return obj;
            }), {});
            const sortedStartTimes = Object.keys(cuesGroupedByStartTime).sort(((a, b) => Number(a) - Number(b)));
            sortedStartTimes.forEach(((startTime, idx) => {
                const cueGroup = cuesGroupedByStartTime[startTime];
                const finiteDuration = isFinite(videoDuration) ? videoDuration : startTime;
                const nextTime = Number(sortedStartTimes[idx + 1]) || finiteDuration;
                cueGroup.forEach((cue => {
                    cue.endTime = nextTime;
                }));
            }));
        };
        const app_dateRangeAttr = {
            id: "ID",
            class: "CLASS",
            startDate: "START-DATE",
            duration: "DURATION",
            endDate: "END-DATE",
            endOnNext: "END-ON-NEXT",
            plannedDuration: "PLANNED-DURATION",
            scte35Out: "SCTE35-OUT",
            scte35In: "SCTE35-IN"
        };
        const app_dateRangeKeysToOmit = new Set([ "id", "class", "startDate", "duration", "endDate", "endOnNext", "startTime", "endTime", "processDateRange" ]);
        const app_addDateRangeMetadata = ({inbandTextTracks, dateRanges}) => {
            const metadataTrack = inbandTextTracks.metadataTrack_;
            if (!metadataTrack) return;
            const Cue = app_window_default().WebKitDataCue || app_window_default().VTTCue;
            dateRanges.forEach((dateRange => {
                for (const key of Object.keys(dateRange)) {
                    if (app_dateRangeKeysToOmit.has(key)) continue;
                    const cue = new Cue(dateRange.startTime, dateRange.endTime, "");
                    cue.id = dateRange.id;
                    cue.type = "com.apple.quicktime.HLS";
                    cue.value = {
                        key: app_dateRangeAttr[key],
                        data: dateRange[key]
                    };
                    if (key === "scte35Out" || key === "scte35In") cue.value.data = new Uint8Array(cue.value.data.match(/[\da-f]{2}/gi)).buffer;
                    metadataTrack.addCue(cue);
                }
                dateRange.processDateRange();
            }));
        };
        const app_createMetadataTrackIfNotExists = (inbandTextTracks, dispatchType, tech) => {
            if (inbandTextTracks.metadataTrack_) return;
            inbandTextTracks.metadataTrack_ = tech.addRemoteTextTrack({
                kind: "metadata",
                label: "Timed Metadata"
            }, false).track;
            if (!app_videojs.browser.IS_ANY_SAFARI) inbandTextTracks.metadataTrack_.inBandMetadataTrackDispatchType = dispatchType;
        };
        const app_removeCuesFromTrack = function(start, end, track) {
            let i;
            let cue;
            if (!track) return;
            if (!track.cues) return;
            i = track.cues.length;
            while (i--) {
                cue = track.cues[i];
                if (cue.startTime >= start && cue.endTime <= end) track.removeCue(cue);
            }
        };
        const app_removeDuplicateCuesFromTrack = function(track) {
            const cues = track.cues;
            if (!cues) return;
            const uniqueCues = {};
            for (let i = cues.length - 1; i >= 0; i--) {
                const cue = cues[i];
                const cueKey = `${cue.startTime}-${cue.endTime}-${cue.text}`;
                if (uniqueCues[cueKey]) track.removeCue(cue); else uniqueCues[cueKey] = cue;
            }
        };
        const app_gopsSafeToAlignWith = (buffer, currentTime, mapping) => {
            if (typeof currentTime === "undefined" || currentTime === null || !buffer.length) return [];
            const currentTimePts = Math.ceil((currentTime - mapping + 3) * app_clock.ONE_SECOND_IN_TS);
            let i;
            for (i = 0; i < buffer.length; i++) if (buffer[i].pts > currentTimePts) break;
            return buffer.slice(i);
        };
        const app_updateGopBuffer = (buffer, gops, replace) => {
            if (!gops.length) return buffer;
            if (replace) return gops.slice();
            const start = gops[0].pts;
            let i = 0;
            for (i; i < buffer.length; i++) if (buffer[i].pts >= start) break;
            return buffer.slice(0, i).concat(gops);
        };
        const app_removeGopBuffer = (buffer, start, end, mapping) => {
            const startPts = Math.ceil((start - mapping) * app_clock.ONE_SECOND_IN_TS);
            const endPts = Math.ceil((end - mapping) * app_clock.ONE_SECOND_IN_TS);
            const updatedBuffer = buffer.slice();
            let i = buffer.length;
            while (i--) if (buffer[i].pts <= endPts) break;
            if (i === -1) return updatedBuffer;
            let j = i + 1;
            while (j--) if (buffer[j].pts <= startPts) break;
            j = Math.max(j, 0);
            updatedBuffer.splice(j, i - j + 1);
            return updatedBuffer;
        };
        const app_shallowEqual = function(a, b) {
            if (!a && !b || !a && b || a && !b) return false;
            if (a === b) return true;
            const akeys = Object.keys(a).sort();
            const bkeys = Object.keys(b).sort();
            if (akeys.length !== bkeys.length) return false;
            for (let i = 0; i < akeys.length; i++) {
                const key = akeys[i];
                if (key !== bkeys[i]) return false;
                if (a[key] !== b[key]) return false;
            }
            return true;
        };
        const app_getSyncSegmentCandidate = function(currentTimeline, segments, targetTime) {
            segments = segments || [];
            const timelineSegments = [];
            let time = 0;
            for (let i = 0; i < segments.length; i++) {
                const segment = segments[i];
                if (currentTimeline === segment.timeline) {
                    timelineSegments.push(i);
                    time += segment.duration;
                    if (time > targetTime) return i;
                }
            }
            if (timelineSegments.length === 0) return 0;
            return timelineSegments[timelineSegments.length - 1];
        };
        const app_MIN_BACK_BUFFER = 1;
        const app_CHECK_BUFFER_DELAY = 500;
        const app_finite = num => typeof num === "number" && isFinite(num);
        const app_MIN_SEGMENT_DURATION_TO_SAVE_STATS = 1 / 60;
        const app_illegalMediaSwitch = (loaderType, startingMedia, trackInfo) => {
            if (loaderType !== "main" || !startingMedia || !trackInfo) return null;
            if (!trackInfo.hasAudio && !trackInfo.hasVideo) return "Neither audio nor video found in segment.";
            if (startingMedia.hasVideo && !trackInfo.hasVideo) return "Only audio found in segment when we expected video." + " We can't switch to audio only from a stream that had video." + " To get rid of this message, please add codec information to the manifest.";
            if (!startingMedia.hasVideo && trackInfo.hasVideo) return "Video found in segment when we expected only audio." + " We can't switch to a stream with video from an audio only stream." + " To get rid of this message, please add codec information to the manifest.";
            return null;
        };
        const app_safeBackBufferTrimTime = (seekable, currentTime, targetDuration) => {
            let trimTime = currentTime - app_Config.BACK_BUFFER_LENGTH;
            if (seekable.length) trimTime = Math.max(trimTime, seekable.start(0));
            const maxTrimTime = currentTime - targetDuration;
            return Math.min(maxTrimTime, trimTime);
        };
        const app_segmentInfoString = segmentInfo => {
            const {startOfSegment, duration, segment, part, playlist: {mediaSequence: seq, id, segments = []}, mediaIndex: index, partIndex, timeline} = segmentInfo;
            const segmentLen = segments.length - 1;
            let selection = "mediaIndex/partIndex increment";
            if (segmentInfo.getMediaInfoForTime) selection = `getMediaInfoForTime (${segmentInfo.getMediaInfoForTime})`; else if (segmentInfo.isSyncRequest) selection = "getSyncSegmentCandidate (isSyncRequest)";
            if (segmentInfo.independent) selection += ` with independent ${segmentInfo.independent}`;
            const hasPartIndex = typeof partIndex === "number";
            const name = segmentInfo.segment.uri ? "segment" : "pre-segment";
            const zeroBasedPartCount = hasPartIndex ? app_getKnownPartCount({
                preloadSegment: segment
            }) - 1 : 0;
            return `${name} [${seq + index}/${seq + segmentLen}]` + (hasPartIndex ? ` part [${partIndex}/${zeroBasedPartCount}]` : "") + ` segment start/end [${segment.start} => ${segment.end}]` + (hasPartIndex ? ` part start/end [${part.start} => ${part.end}]` : "") + ` startOfSegment [${startOfSegment}]` + ` duration [${duration}]` + ` timeline [${timeline}]` + ` selected by [${selection}]` + ` playlist [${id}]`;
        };
        const app_timingInfoPropertyForMedia = mediaType => `${mediaType}TimingInfo`;
        const app_timestampOffsetForSegment = ({segmentTimeline, currentTimeline, startOfSegment, buffered, overrideCheck}) => {
            if (!overrideCheck && segmentTimeline === currentTimeline) return null;
            if (segmentTimeline < currentTimeline) return startOfSegment;
            return buffered.length ? buffered.end(buffered.length - 1) : startOfSegment;
        };
        const app_shouldWaitForTimelineChange = ({timelineChangeController, currentTimeline, segmentTimeline, loaderType, audioDisabled}) => {
            if (currentTimeline === segmentTimeline) return false;
            if (loaderType === "audio") {
                const lastMainTimelineChange = timelineChangeController.lastTimelineChange({
                    type: "main"
                });
                return !lastMainTimelineChange || lastMainTimelineChange.to !== segmentTimeline;
            }
            if (loaderType === "main" && audioDisabled) {
                const pendingAudioTimelineChange = timelineChangeController.pendingTimelineChange({
                    type: "audio"
                });
                if (pendingAudioTimelineChange && pendingAudioTimelineChange.to === segmentTimeline) return false;
                return true;
            }
            return false;
        };
        const app_shouldFixBadTimelineChanges = timelineChangeController => {
            if (!timelineChangeController) return false;
            const pendingAudioTimelineChange = timelineChangeController.pendingTimelineChange({
                type: "audio"
            });
            const pendingMainTimelineChange = timelineChangeController.pendingTimelineChange({
                type: "main"
            });
            const hasPendingTimelineChanges = pendingAudioTimelineChange && pendingMainTimelineChange;
            const differentPendingChanges = hasPendingTimelineChanges && pendingAudioTimelineChange.to !== pendingMainTimelineChange.to;
            const isNotInitialPendingTimelineChange = hasPendingTimelineChanges && pendingAudioTimelineChange.from !== -1 && pendingMainTimelineChange.from !== -1;
            if (isNotInitialPendingTimelineChange && differentPendingChanges) return true;
            return false;
        };
        const app_isAudioTimelineBehind = segmentLoader => {
            const pendingAudioTimelineChange = segmentLoader.timelineChangeController_.pendingTimelineChange({
                type: "audio"
            });
            const pendingMainTimelineChange = segmentLoader.timelineChangeController_.pendingTimelineChange({
                type: "main"
            });
            const hasPendingTimelineChanges = pendingAudioTimelineChange && pendingMainTimelineChange;
            return hasPendingTimelineChanges && pendingAudioTimelineChange.to < pendingMainTimelineChange.to;
        };
        const app_checkAndFixTimelines = segmentLoader => {
            const segmentInfo = segmentLoader.pendingSegment_;
            if (!segmentInfo) return;
            const waitingForTimelineChange = app_shouldWaitForTimelineChange({
                timelineChangeController: segmentLoader.timelineChangeController_,
                currentTimeline: segmentLoader.currentTimeline_,
                segmentTimeline: segmentInfo.timeline,
                loaderType: segmentLoader.loaderType_,
                audioDisabled: segmentLoader.audioDisabled_
            });
            if (waitingForTimelineChange && app_shouldFixBadTimelineChanges(segmentLoader.timelineChangeController_)) {
                if (app_isAudioTimelineBehind(segmentLoader)) {
                    segmentLoader.timelineChangeController_.trigger("audioTimelineBehind");
                    return;
                }
                segmentLoader.timelineChangeController_.trigger("fixBadTimelineChange");
            }
        };
        const app_mediaDuration = timingInfos => {
            let maxDuration = 0;
            [ "video", "audio" ].forEach((function(type) {
                const typeTimingInfo = timingInfos[`${type}TimingInfo`];
                if (!typeTimingInfo) return;
                const {start, end} = typeTimingInfo;
                let duration;
                if (typeof start === "bigint" || typeof end === "bigint") duration = app_window_default().BigInt(end) - app_window_default().BigInt(start); else if (typeof start === "number" && typeof end === "number") duration = end - start;
                if (typeof duration !== "undefined" && duration > maxDuration) maxDuration = duration;
            }));
            if (typeof maxDuration === "bigint" && maxDuration < Number.MAX_SAFE_INTEGER) maxDuration = Number(maxDuration);
            return maxDuration;
        };
        const app_segmentTooLong = ({segmentDuration, maxDuration}) => {
            if (!segmentDuration) return false;
            return Math.round(segmentDuration) > maxDuration + app_TIME_FUDGE_FACTOR;
        };
        const app_getTroublesomeSegmentDurationMessage = (segmentInfo, sourceType) => {
            if (sourceType !== "hls") return null;
            const segmentDuration = app_mediaDuration({
                audioTimingInfo: segmentInfo.audioTimingInfo,
                videoTimingInfo: segmentInfo.videoTimingInfo
            });
            if (!segmentDuration) return null;
            const targetDuration = segmentInfo.playlist.targetDuration;
            const isSegmentWayTooLong = app_segmentTooLong({
                segmentDuration,
                maxDuration: targetDuration * 2
            });
            const isSegmentSlightlyTooLong = app_segmentTooLong({
                segmentDuration,
                maxDuration: targetDuration
            });
            const segmentTooLongMessage = `Segment with index ${segmentInfo.mediaIndex} ` + `from playlist ${segmentInfo.playlist.id} ` + `has a duration of ${segmentDuration} ` + `when the reported duration is ${segmentInfo.duration} ` + `and the target duration is ${targetDuration}. ` + "For HLS content, a duration in excess of the target duration may result in " + "playback issues. See the HLS specification section on EXT-X-TARGETDURATION for " + "more details: " + "https://tools.ietf.org/html/draft-pantos-http-live-streaming-23#section-4.3.3.1";
            if (isSegmentWayTooLong || isSegmentSlightlyTooLong) return {
                severity: isSegmentWayTooLong ? "warn" : "info",
                message: segmentTooLongMessage
            };
            return null;
        };
        const app_segmentInfoPayload = ({type, segment}) => {
            if (!segment) return;
            const isEncrypted = Boolean(segment.key || segment.map && segment.map.ke);
            const isMediaInitialization = Boolean(segment.map && !segment.map.bytes);
            const start = segment.startOfSegment === void 0 ? segment.start : segment.startOfSegment;
            return {
                type: type || segment.type,
                uri: segment.resolvedUri || segment.uri,
                start,
                duration: segment.duration,
                isEncrypted,
                isMediaInitialization
            };
        };
        class app_SegmentLoader extends app_videojs.EventTarget {
            constructor(settings, options = {}) {
                super();
                if (!settings) throw new TypeError("Initialization settings are required");
                if (typeof settings.currentTime !== "function") throw new TypeError("No currentTime getter specified");
                if (!settings.mediaSource) throw new TypeError("No MediaSource specified");
                this.bandwidth = settings.bandwidth;
                this.throughput = {
                    rate: 0,
                    count: 0
                };
                this.roundTrip = NaN;
                this.resetStats_();
                this.mediaIndex = null;
                this.partIndex = null;
                this.hasPlayed_ = settings.hasPlayed;
                this.currentTime_ = settings.currentTime;
                this.seekable_ = settings.seekable;
                this.seeking_ = settings.seeking;
                this.duration_ = settings.duration;
                this.mediaSource_ = settings.mediaSource;
                this.vhs_ = settings.vhs;
                this.loaderType_ = settings.loaderType;
                this.currentMediaInfo_ = void 0;
                this.startingMediaInfo_ = void 0;
                this.segmentMetadataTrack_ = settings.segmentMetadataTrack;
                this.goalBufferLength_ = settings.goalBufferLength;
                this.sourceType_ = settings.sourceType;
                this.sourceUpdater_ = settings.sourceUpdater;
                this.inbandTextTracks_ = settings.inbandTextTracks;
                this.state_ = "INIT";
                this.timelineChangeController_ = settings.timelineChangeController;
                this.shouldSaveSegmentTimingInfo_ = true;
                this.parse708captions_ = settings.parse708captions;
                this.useDtsForTimestampOffset_ = settings.useDtsForTimestampOffset;
                this.captionServices_ = settings.captionServices;
                this.exactManifestTimings = settings.exactManifestTimings;
                this.addMetadataToTextTrack = settings.addMetadataToTextTrack;
                this.checkBufferTimeout_ = null;
                this.error_ = void 0;
                this.currentTimeline_ = -1;
                this.shouldForceTimestampOffsetAfterResync_ = false;
                this.pendingSegment_ = null;
                this.xhrOptions_ = null;
                this.pendingSegments_ = [];
                this.audioDisabled_ = false;
                this.isPendingTimestampOffset_ = false;
                this.gopBuffer_ = [];
                this.timeMapping_ = 0;
                this.safeAppend_ = false;
                this.appendInitSegment_ = {
                    audio: true,
                    video: true
                };
                this.playlistOfLastInitSegment_ = {
                    audio: null,
                    video: null
                };
                this.callQueue_ = [];
                this.loadQueue_ = [];
                this.metadataQueue_ = {
                    id3: [],
                    caption: []
                };
                this.waitingOnRemove_ = false;
                this.quotaExceededErrorRetryTimeout_ = null;
                this.activeInitSegmentId_ = null;
                this.initSegments_ = {};
                this.cacheEncryptionKeys_ = settings.cacheEncryptionKeys;
                this.keyCache_ = {};
                this.decrypter_ = settings.decrypter;
                this.syncController_ = settings.syncController;
                this.syncPoint_ = {
                    segmentIndex: 0,
                    time: 0
                };
                this.transmuxer_ = this.createTransmuxer_();
                this.triggerSyncInfoUpdate_ = () => this.trigger("syncinfoupdate");
                this.syncController_.on("syncinfoupdate", this.triggerSyncInfoUpdate_);
                this.mediaSource_.addEventListener("sourceopen", (() => {
                    if (!this.isEndOfStream_()) this.ended_ = false;
                }));
                this.fetchAtBuffer_ = false;
                this.logger_ = app_logger(`SegmentLoader[${this.loaderType_}]`);
                Object.defineProperty(this, "state", {
                    get() {
                        return this.state_;
                    },
                    set(newState) {
                        if (newState !== this.state_) {
                            this.logger_(`${this.state_} -> ${newState}`);
                            this.state_ = newState;
                            this.trigger("statechange");
                        }
                    }
                });
                this.sourceUpdater_.on("ready", (() => {
                    if (this.hasEnoughInfoToAppend_()) this.processCallQueue_(); else app_checkAndFixTimelines(this);
                }));
                this.sourceUpdater_.on("codecschange", (metadata => {
                    this.trigger(app_extends({
                        type: "codecschange"
                    }, metadata));
                }));
                if (this.loaderType_ === "main") this.timelineChangeController_.on("pendingtimelinechange", (() => {
                    if (this.hasEnoughInfoToAppend_()) this.processCallQueue_(); else app_checkAndFixTimelines(this);
                }));
                if (this.loaderType_ === "audio") this.timelineChangeController_.on("timelinechange", (metadata => {
                    this.trigger(app_extends({
                        type: "timelinechange"
                    }, metadata));
                    if (this.hasEnoughInfoToLoad_()) this.processLoadQueue_(); else app_checkAndFixTimelines(this);
                    if (this.hasEnoughInfoToAppend_()) this.processCallQueue_(); else app_checkAndFixTimelines(this);
                }));
            }
            get mediaSequenceSync_() {
                return this.syncController_.getMediaSequenceSync(this.loaderType_);
            }
            createTransmuxer_() {
                return app_segmentTransmuxer.createTransmuxer({
                    remux: false,
                    alignGopsAtEnd: this.safeAppend_,
                    keepOriginalTimestamps: true,
                    parse708captions: this.parse708captions_,
                    captionServices: this.captionServices_
                });
            }
            resetStats_() {
                this.mediaBytesTransferred = 0;
                this.mediaRequests = 0;
                this.mediaRequestsAborted = 0;
                this.mediaRequestsTimedout = 0;
                this.mediaRequestsErrored = 0;
                this.mediaTransferDuration = 0;
                this.mediaSecondsLoaded = 0;
                this.mediaAppends = 0;
            }
            dispose() {
                this.trigger("dispose");
                this.state = "DISPOSED";
                this.pause();
                this.abort_();
                if (this.transmuxer_) this.transmuxer_.terminate();
                this.resetStats_();
                if (this.checkBufferTimeout_) app_window_default().clearTimeout(this.checkBufferTimeout_);
                if (this.syncController_ && this.triggerSyncInfoUpdate_) this.syncController_.off("syncinfoupdate", this.triggerSyncInfoUpdate_);
                this.off();
            }
            setAudio(enable) {
                this.audioDisabled_ = !enable;
                if (enable) this.appendInitSegment_.audio = true; else this.sourceUpdater_.removeAudio(0, this.duration_());
            }
            abort() {
                if (this.state !== "WAITING") {
                    if (this.pendingSegment_) this.pendingSegment_ = null;
                    this.timelineChangeController_.clearPendingTimelineChange(this.loaderType_);
                    return;
                }
                this.abort_();
                this.state = "READY";
                if (!this.paused()) this.monitorBuffer_();
            }
            abort_() {
                if (this.pendingSegment_ && this.pendingSegment_.abortRequests) this.pendingSegment_.abortRequests();
                this.pendingSegment_ = null;
                this.callQueue_ = [];
                this.loadQueue_ = [];
                this.metadataQueue_.id3 = [];
                this.metadataQueue_.caption = [];
                this.timelineChangeController_.clearPendingTimelineChange(this.loaderType_);
                this.waitingOnRemove_ = false;
                app_window_default().clearTimeout(this.quotaExceededErrorRetryTimeout_);
                this.quotaExceededErrorRetryTimeout_ = null;
            }
            checkForAbort_(requestId) {
                if (this.state === "APPENDING" && !this.pendingSegment_) {
                    this.state = "READY";
                    return true;
                }
                if (!this.pendingSegment_ || this.pendingSegment_.requestId !== requestId) return true;
                return false;
            }
            error(error) {
                if (typeof error !== "undefined") {
                    this.logger_("error occurred:", error);
                    this.error_ = error;
                }
                this.pendingSegment_ = null;
                return this.error_;
            }
            endOfStream() {
                this.ended_ = true;
                if (this.transmuxer_) app_segmentTransmuxer.reset(this.transmuxer_);
                this.gopBuffer_.length = 0;
                this.pause();
                this.trigger("ended");
            }
            buffered_() {
                const trackInfo = this.getMediaInfo_();
                if (!this.sourceUpdater_ || !trackInfo) return app_createTimeRanges();
                if (this.loaderType_ === "main") {
                    const {hasAudio, hasVideo, isMuxed} = trackInfo;
                    if (hasVideo && hasAudio && !this.audioDisabled_ && !isMuxed) return this.sourceUpdater_.buffered();
                    if (hasVideo) return this.sourceUpdater_.videoBuffered();
                }
                return this.sourceUpdater_.audioBuffered();
            }
            initSegmentForMap(map, set = false) {
                if (!map) return null;
                const id = app_initSegmentId(map);
                let storedMap = this.initSegments_[id];
                if (set && !storedMap && map.bytes) this.initSegments_[id] = storedMap = {
                    resolvedUri: map.resolvedUri,
                    byterange: map.byterange,
                    bytes: map.bytes,
                    tracks: map.tracks,
                    timescales: map.timescales
                };
                return storedMap || map;
            }
            segmentKey(key, set = false) {
                if (!key) return null;
                const id = app_segmentKeyId(key);
                let storedKey = this.keyCache_[id];
                if (this.cacheEncryptionKeys_ && set && !storedKey && key.bytes) this.keyCache_[id] = storedKey = {
                    resolvedUri: key.resolvedUri,
                    bytes: key.bytes
                };
                const result = {
                    resolvedUri: (storedKey || key).resolvedUri
                };
                if (storedKey) result.bytes = storedKey.bytes;
                return result;
            }
            couldBeginLoading_() {
                return this.playlist_ && !this.paused();
            }
            load() {
                this.monitorBuffer_();
                if (!this.playlist_) return;
                if (this.state === "INIT" && this.couldBeginLoading_()) return this.init_();
                if (!this.couldBeginLoading_() || this.state !== "READY" && this.state !== "INIT") return;
                this.state = "READY";
            }
            init_() {
                this.state = "READY";
                this.resetEverything();
                return this.monitorBuffer_();
            }
            playlist(newPlaylist, options = {}) {
                if (!newPlaylist) return;
                if (this.playlist_ && this.playlist_.endList && newPlaylist.endList && this.playlist_.uri === newPlaylist.uri) return;
                const oldPlaylist = this.playlist_;
                const segmentInfo = this.pendingSegment_;
                this.playlist_ = newPlaylist;
                this.xhrOptions_ = options;
                if (this.state === "INIT") {
                    newPlaylist.syncInfo = {
                        mediaSequence: newPlaylist.mediaSequence,
                        time: 0
                    };
                    if (this.loaderType_ === "main") this.syncController_.setDateTimeMappingForStart(newPlaylist);
                }
                let oldId = null;
                if (oldPlaylist) if (oldPlaylist.id) oldId = oldPlaylist.id; else if (oldPlaylist.uri) oldId = oldPlaylist.uri;
                this.logger_(`playlist update [${oldId} => ${newPlaylist.id || newPlaylist.uri}]`);
                if (this.mediaSequenceSync_) {
                    this.mediaSequenceSync_.update(newPlaylist, this.currentTime_());
                    this.logger_(`Playlist update:\ncurrentTime: ${this.currentTime_()}\nbufferedEnd: ${app_lastBufferedEnd(this.buffered_())}\n`, this.mediaSequenceSync_.diagnostics);
                }
                this.trigger("syncinfoupdate");
                if (this.state === "INIT" && this.couldBeginLoading_()) return this.init_();
                if (!oldPlaylist || oldPlaylist.uri !== newPlaylist.uri) {
                    if (this.mediaIndex !== null) {
                        const isLLHLS = !newPlaylist.endList && typeof newPlaylist.partTargetDuration === "number";
                        if (isLLHLS) this.resetLoader(); else this.resyncLoader();
                    }
                    this.currentMediaInfo_ = void 0;
                    this.trigger("playlistupdate");
                    return;
                }
                const mediaSequenceDiff = newPlaylist.mediaSequence - oldPlaylist.mediaSequence;
                this.logger_(`live window shift [${mediaSequenceDiff}]`);
                if (this.mediaIndex !== null) {
                    this.mediaIndex -= mediaSequenceDiff;
                    if (this.mediaIndex < 0) {
                        this.mediaIndex = null;
                        this.partIndex = null;
                    } else {
                        const segment = this.playlist_.segments[this.mediaIndex];
                        if (this.partIndex && (!segment.parts || !segment.parts.length || !segment.parts[this.partIndex])) {
                            const mediaIndex = this.mediaIndex;
                            this.logger_(`currently processing part (index ${this.partIndex}) no longer exists.`);
                            this.resetLoader();
                            this.mediaIndex = mediaIndex;
                        }
                    }
                }
                if (segmentInfo) {
                    segmentInfo.mediaIndex -= mediaSequenceDiff;
                    if (segmentInfo.mediaIndex < 0) {
                        segmentInfo.mediaIndex = null;
                        segmentInfo.partIndex = null;
                    } else {
                        if (segmentInfo.mediaIndex >= 0) segmentInfo.segment = newPlaylist.segments[segmentInfo.mediaIndex];
                        if (segmentInfo.partIndex >= 0 && segmentInfo.segment.parts) segmentInfo.part = segmentInfo.segment.parts[segmentInfo.partIndex];
                    }
                }
                this.syncController_.saveExpiredSegmentInfo(oldPlaylist, newPlaylist);
            }
            pause() {
                if (this.checkBufferTimeout_) {
                    app_window_default().clearTimeout(this.checkBufferTimeout_);
                    this.checkBufferTimeout_ = null;
                }
            }
            paused() {
                return this.checkBufferTimeout_ === null;
            }
            resetEverything(done) {
                this.ended_ = false;
                this.activeInitSegmentId_ = null;
                this.appendInitSegment_ = {
                    audio: true,
                    video: true
                };
                this.resetLoader();
                this.remove(0, 1 / 0, done);
                if (this.transmuxer_) {
                    this.transmuxer_.postMessage({
                        action: "clearAllMp4Captions"
                    });
                    this.transmuxer_.postMessage({
                        action: "reset"
                    });
                }
            }
            resetLoader() {
                this.fetchAtBuffer_ = false;
                if (this.mediaSequenceSync_) this.mediaSequenceSync_.resetAppendedStatus();
                this.resyncLoader();
            }
            resyncLoader() {
                if (this.transmuxer_) app_segmentTransmuxer.reset(this.transmuxer_);
                this.mediaIndex = null;
                this.partIndex = null;
                this.syncPoint_ = null;
                this.isPendingTimestampOffset_ = false;
                const isFmp4 = this.currentMediaInfo_ && this.currentMediaInfo_.isFmp4;
                const isHlsTs = this.sourceType_ === "hls" && !isFmp4;
                if (isHlsTs) this.shouldForceTimestampOffsetAfterResync_ = true;
                this.callQueue_ = [];
                this.loadQueue_ = [];
                this.metadataQueue_.id3 = [];
                this.metadataQueue_.caption = [];
                this.abort();
                if (this.transmuxer_) this.transmuxer_.postMessage({
                    action: "clearParsedMp4Captions"
                });
            }
            remove(start, end, done = () => {}, force = false) {
                if (end === 1 / 0) end = this.duration_();
                if (end <= start) {
                    this.logger_("skipping remove because end ${end} is <= start ${start}");
                    return;
                }
                if (!this.sourceUpdater_ || !this.getMediaInfo_()) {
                    this.logger_("skipping remove because no source updater or starting media info");
                    return;
                }
                let removesRemaining = 1;
                const removeFinished = () => {
                    removesRemaining--;
                    if (removesRemaining === 0) done();
                };
                if (force || !this.audioDisabled_) {
                    removesRemaining++;
                    this.sourceUpdater_.removeAudio(start, end, removeFinished);
                }
                if (force || this.loaderType_ === "main") {
                    this.gopBuffer_ = app_removeGopBuffer(this.gopBuffer_, start, end, this.timeMapping_);
                    removesRemaining++;
                    this.sourceUpdater_.removeVideo(start, end, removeFinished);
                }
                for (const track in this.inbandTextTracks_) app_removeCuesFromTrack(start, end, this.inbandTextTracks_[track]);
                app_removeCuesFromTrack(start, end, this.segmentMetadataTrack_);
                removeFinished();
            }
            monitorBuffer_() {
                if (this.checkBufferTimeout_) app_window_default().clearTimeout(this.checkBufferTimeout_);
                this.checkBufferTimeout_ = app_window_default().setTimeout(this.monitorBufferTick_.bind(this), 1);
            }
            monitorBufferTick_() {
                if (this.state === "READY") this.fillBuffer_();
                if (this.checkBufferTimeout_) app_window_default().clearTimeout(this.checkBufferTimeout_);
                this.checkBufferTimeout_ = app_window_default().setTimeout(this.monitorBufferTick_.bind(this), app_CHECK_BUFFER_DELAY);
            }
            fillBuffer_() {
                if (this.sourceUpdater_.updating()) return;
                const segmentInfo = this.chooseNextRequest_();
                if (!segmentInfo) return;
                const metadata = {
                    segmentInfo: app_segmentInfoPayload({
                        type: this.loaderType_,
                        segment: segmentInfo
                    })
                };
                this.trigger({
                    type: "segmentselected",
                    metadata
                });
                if (typeof segmentInfo.timestampOffset === "number") {
                    this.isPendingTimestampOffset_ = false;
                    this.timelineChangeController_.pendingTimelineChange({
                        type: this.loaderType_,
                        from: this.currentTimeline_,
                        to: segmentInfo.timeline
                    });
                }
                this.loadSegment_(segmentInfo);
            }
            isEndOfStream_(mediaIndex = this.mediaIndex, playlist = this.playlist_, partIndex = this.partIndex) {
                if (!playlist || !this.mediaSource_) return false;
                const segment = typeof mediaIndex === "number" && playlist.segments[mediaIndex];
                const appendedLastSegment = mediaIndex + 1 === playlist.segments.length;
                const appendedLastPart = !segment || !segment.parts || partIndex + 1 === segment.parts.length;
                return playlist.endList && this.mediaSource_.readyState === "open" && appendedLastSegment && appendedLastPart;
            }
            chooseNextRequest_() {
                const buffered = this.buffered_();
                const bufferedEnd = app_lastBufferedEnd(buffered) || 0;
                const bufferedTime = app_timeAheadOf(buffered, this.currentTime_());
                const preloaded = !this.hasPlayed_() && bufferedTime >= 1;
                const haveEnoughBuffer = bufferedTime >= this.goalBufferLength_();
                const segments = this.playlist_.segments;
                if (!segments.length || preloaded || haveEnoughBuffer) return null;
                this.syncPoint_ = this.syncPoint_ || this.syncController_.getSyncPoint(this.playlist_, this.duration_(), this.currentTimeline_, this.currentTime_(), this.loaderType_);
                const next = {
                    partIndex: null,
                    mediaIndex: null,
                    startOfSegment: null,
                    playlist: this.playlist_,
                    isSyncRequest: Boolean(!this.syncPoint_)
                };
                if (next.isSyncRequest) {
                    next.mediaIndex = app_getSyncSegmentCandidate(this.currentTimeline_, segments, bufferedEnd);
                    this.logger_(`choose next request. Can not find sync point. Fallback to media Index: ${next.mediaIndex}`);
                } else if (this.mediaIndex !== null) {
                    const segment = segments[this.mediaIndex];
                    const partIndex = typeof this.partIndex === "number" ? this.partIndex : -1;
                    next.startOfSegment = segment.end ? segment.end : bufferedEnd;
                    if (segment.parts && segment.parts[partIndex + 1]) {
                        next.mediaIndex = this.mediaIndex;
                        next.partIndex = partIndex + 1;
                    } else next.mediaIndex = this.mediaIndex + 1;
                } else {
                    let segmentIndex;
                    let partIndex;
                    let startTime;
                    const targetTime = this.fetchAtBuffer_ ? bufferedEnd : this.currentTime_();
                    if (this.mediaSequenceSync_) this.logger_(`chooseNextRequest_ request after Quality Switch:\nFor TargetTime: ${targetTime}.\nCurrentTime: ${this.currentTime_()}\nBufferedEnd: ${bufferedEnd}\nFetch At Buffer: ${this.fetchAtBuffer_}\n`, this.mediaSequenceSync_.diagnostics);
                    if (this.mediaSequenceSync_ && this.mediaSequenceSync_.isReliable) {
                        const syncInfo = this.getSyncInfoFromMediaSequenceSync_(targetTime);
                        if (!syncInfo) {
                            const message = "No sync info found while using media sequence sync";
                            this.error({
                                message,
                                metadata: {
                                    errorType: app_videojs.Error.StreamingFailedToSelectNextSegment,
                                    error: new Error(message)
                                }
                            });
                            this.logger_("chooseNextRequest_ - no sync info found using media sequence sync");
                            return null;
                        }
                        this.logger_(`chooseNextRequest_ mediaSequence syncInfo (${syncInfo.start} --\x3e ${syncInfo.end})`);
                        segmentIndex = syncInfo.segmentIndex;
                        partIndex = syncInfo.partIndex;
                        startTime = syncInfo.start;
                    } else {
                        this.logger_("chooseNextRequest_ - fallback to a regular segment selection algorithm, based on a syncPoint.");
                        const mediaInfoForTime = app_Playlist.getMediaInfoForTime({
                            exactManifestTimings: this.exactManifestTimings,
                            playlist: this.playlist_,
                            currentTime: targetTime,
                            startingPartIndex: this.syncPoint_.partIndex,
                            startingSegmentIndex: this.syncPoint_.segmentIndex,
                            startTime: this.syncPoint_.time
                        });
                        segmentIndex = mediaInfoForTime.segmentIndex;
                        partIndex = mediaInfoForTime.partIndex;
                        startTime = mediaInfoForTime.startTime;
                    }
                    next.getMediaInfoForTime = this.fetchAtBuffer_ ? `bufferedEnd ${targetTime}` : `currentTime ${targetTime}`;
                    next.mediaIndex = segmentIndex;
                    next.startOfSegment = startTime;
                    next.partIndex = partIndex;
                    this.logger_(`choose next request. Playlist switched and we have a sync point. Media Index: ${next.mediaIndex} `);
                }
                const nextSegment = segments[next.mediaIndex];
                let nextPart = nextSegment && typeof next.partIndex === "number" && nextSegment.parts && nextSegment.parts[next.partIndex];
                if (!nextSegment || typeof next.partIndex === "number" && !nextPart) return null;
                if (typeof next.partIndex !== "number" && nextSegment.parts) {
                    next.partIndex = 0;
                    nextPart = nextSegment.parts[0];
                }
                const hasIndependentSegments = this.vhs_.playlists && this.vhs_.playlists.main && this.vhs_.playlists.main.independentSegments || this.playlist_.independentSegments;
                if (!bufferedTime && nextPart && !hasIndependentSegments && !nextPart.independent) if (next.partIndex === 0) {
                    const lastSegment = segments[next.mediaIndex - 1];
                    const lastSegmentLastPart = lastSegment.parts && lastSegment.parts.length && lastSegment.parts[lastSegment.parts.length - 1];
                    if (lastSegmentLastPart && lastSegmentLastPart.independent) {
                        next.mediaIndex -= 1;
                        next.partIndex = lastSegment.parts.length - 1;
                        next.independent = "previous segment";
                    }
                } else if (nextSegment.parts[next.partIndex - 1].independent) {
                    next.partIndex -= 1;
                    next.independent = "previous part";
                }
                const ended = this.mediaSource_ && this.mediaSource_.readyState === "ended";
                if (next.mediaIndex >= segments.length - 1 && ended && !this.seeking_()) return null;
                if (this.shouldForceTimestampOffsetAfterResync_) {
                    this.shouldForceTimestampOffsetAfterResync_ = false;
                    next.forceTimestampOffset = true;
                    this.logger_("choose next request. Force timestamp offset after loader resync");
                }
                return this.generateSegmentInfo_(next);
            }
            getSyncInfoFromMediaSequenceSync_(targetTime) {
                if (!this.mediaSequenceSync_) return null;
                const finalTargetTime = Math.max(targetTime, this.mediaSequenceSync_.start);
                if (targetTime !== finalTargetTime) this.logger_(`getSyncInfoFromMediaSequenceSync_. Pulled target time from ${targetTime} to ${finalTargetTime}`);
                const mediaSequenceSyncInfo = this.mediaSequenceSync_.getSyncInfoForTime(finalTargetTime);
                if (!mediaSequenceSyncInfo) return null;
                if (!mediaSequenceSyncInfo.isAppended) return mediaSequenceSyncInfo;
                const nextMediaSequenceSyncInfo = this.mediaSequenceSync_.getSyncInfoForTime(mediaSequenceSyncInfo.end);
                if (!nextMediaSequenceSyncInfo) return null;
                if (nextMediaSequenceSyncInfo.isAppended) this.logger_("getSyncInfoFromMediaSequenceSync_: We encounter unexpected scenario where next media sequence sync info is also appended!");
                return nextMediaSequenceSyncInfo;
            }
            generateSegmentInfo_(options) {
                const {independent, playlist, mediaIndex, startOfSegment, isSyncRequest, partIndex, forceTimestampOffset, getMediaInfoForTime} = options;
                const segment = playlist.segments[mediaIndex];
                const part = typeof partIndex === "number" && segment.parts[partIndex];
                const segmentInfo = {
                    requestId: "segment-loader-" + Math.random(),
                    uri: part && part.resolvedUri || segment.resolvedUri,
                    mediaIndex,
                    partIndex: part ? partIndex : null,
                    isSyncRequest,
                    startOfSegment,
                    playlist,
                    bytes: null,
                    encryptedBytes: null,
                    timestampOffset: null,
                    timeline: segment.timeline,
                    duration: part && part.duration || segment.duration,
                    segment,
                    part,
                    byteLength: 0,
                    transmuxer: this.transmuxer_,
                    getMediaInfoForTime,
                    independent
                };
                const overrideCheck = typeof forceTimestampOffset !== "undefined" ? forceTimestampOffset : this.isPendingTimestampOffset_;
                segmentInfo.timestampOffset = this.timestampOffsetForSegment_({
                    segmentTimeline: segment.timeline,
                    currentTimeline: this.currentTimeline_,
                    startOfSegment,
                    buffered: this.buffered_(),
                    overrideCheck
                });
                const audioBufferedEnd = app_lastBufferedEnd(this.sourceUpdater_.audioBuffered());
                if (typeof audioBufferedEnd === "number") segmentInfo.audioAppendStart = audioBufferedEnd - this.sourceUpdater_.audioTimestampOffset();
                if (this.sourceUpdater_.videoBuffered().length) segmentInfo.gopsToAlignWith = app_gopsSafeToAlignWith(this.gopBuffer_, this.currentTime_() - this.sourceUpdater_.videoTimestampOffset(), this.timeMapping_);
                return segmentInfo;
            }
            timestampOffsetForSegment_(options) {
                return app_timestampOffsetForSegment(options);
            }
            earlyAbortWhenNeeded_(stats) {
                if (this.vhs_.tech_.paused() || !this.xhrOptions_.timeout || !this.playlist_.attributes.BANDWIDTH) return;
                if (Date.now() - (stats.firstBytesReceivedAt || Date.now()) < 1e3) return;
                const currentTime = this.currentTime_();
                const measuredBandwidth = stats.bandwidth;
                const segmentDuration = this.pendingSegment_.duration;
                const requestTimeRemaining = app_Playlist.estimateSegmentRequestTime(segmentDuration, measuredBandwidth, this.playlist_, stats.bytesReceived);
                const timeUntilRebuffer$1 = app_timeUntilRebuffer(this.buffered_(), currentTime, this.vhs_.tech_.playbackRate()) - 1;
                if (requestTimeRemaining <= timeUntilRebuffer$1) return;
                const switchCandidate = app_minRebufferMaxBandwidthSelector({
                    main: this.vhs_.playlists.main,
                    currentTime,
                    bandwidth: measuredBandwidth,
                    duration: this.duration_(),
                    segmentDuration,
                    timeUntilRebuffer: timeUntilRebuffer$1,
                    currentTimeline: this.currentTimeline_,
                    syncController: this.syncController_
                });
                if (!switchCandidate) return;
                const rebufferingImpact = requestTimeRemaining - timeUntilRebuffer$1;
                const timeSavedBySwitching = rebufferingImpact - switchCandidate.rebufferingImpact;
                let minimumTimeSaving = .5;
                if (timeUntilRebuffer$1 <= app_TIME_FUDGE_FACTOR) minimumTimeSaving = 1;
                if (!switchCandidate.playlist || switchCandidate.playlist.uri === this.playlist_.uri || timeSavedBySwitching < minimumTimeSaving) return;
                this.bandwidth = switchCandidate.playlist.attributes.BANDWIDTH * app_Config.BANDWIDTH_VARIANCE + 1;
                this.trigger("earlyabort");
            }
            handleAbort_(segmentInfo) {
                this.logger_(`Aborting ${app_segmentInfoString(segmentInfo)}`);
                this.mediaRequestsAborted += 1;
            }
            handleProgress_(event, simpleSegment) {
                this.earlyAbortWhenNeeded_(simpleSegment.stats);
                if (this.checkForAbort_(simpleSegment.requestId)) return;
                this.trigger("progress");
            }
            handleTrackInfo_(simpleSegment, trackInfo) {
                const {hasAudio, hasVideo} = trackInfo;
                const metadata = {
                    segmentInfo: app_segmentInfoPayload({
                        type: this.loaderType_,
                        segment: simpleSegment
                    }),
                    trackInfo: {
                        hasAudio,
                        hasVideo
                    }
                };
                this.trigger({
                    type: "segmenttransmuxingtrackinfoavailable",
                    metadata
                });
                this.earlyAbortWhenNeeded_(simpleSegment.stats);
                if (this.checkForAbort_(simpleSegment.requestId)) return;
                if (this.checkForIllegalMediaSwitch(trackInfo)) return;
                trackInfo = trackInfo || {};
                if (!app_shallowEqual(this.currentMediaInfo_, trackInfo)) {
                    this.appendInitSegment_ = {
                        audio: true,
                        video: true
                    };
                    this.startingMediaInfo_ = trackInfo;
                    this.currentMediaInfo_ = trackInfo;
                    this.logger_("trackinfo update", trackInfo);
                    this.trigger("trackinfo");
                }
                if (this.checkForAbort_(simpleSegment.requestId)) return;
                this.pendingSegment_.trackInfo = trackInfo;
                if (this.hasEnoughInfoToAppend_()) this.processCallQueue_(); else app_checkAndFixTimelines(this);
            }
            handleTimingInfo_(simpleSegment, mediaType, timeType, time) {
                this.earlyAbortWhenNeeded_(simpleSegment.stats);
                if (this.checkForAbort_(simpleSegment.requestId)) return;
                const segmentInfo = this.pendingSegment_;
                const timingInfoProperty = app_timingInfoPropertyForMedia(mediaType);
                segmentInfo[timingInfoProperty] = segmentInfo[timingInfoProperty] || {};
                segmentInfo[timingInfoProperty][timeType] = time;
                this.logger_(`timinginfo: ${mediaType} - ${timeType} - ${time}`);
                if (this.hasEnoughInfoToAppend_()) this.processCallQueue_(); else app_checkAndFixTimelines(this);
            }
            handleCaptions_(simpleSegment, captionData) {
                this.earlyAbortWhenNeeded_(simpleSegment.stats);
                if (this.checkForAbort_(simpleSegment.requestId)) return;
                if (captionData.length === 0) {
                    this.logger_("SegmentLoader received no captions from a caption event");
                    return;
                }
                const segmentInfo = this.pendingSegment_;
                if (!segmentInfo.hasAppendedData_) {
                    this.metadataQueue_.caption.push(this.handleCaptions_.bind(this, simpleSegment, captionData));
                    return;
                }
                const timestampOffset = this.sourceUpdater_.videoTimestampOffset() === null ? this.sourceUpdater_.audioTimestampOffset() : this.sourceUpdater_.videoTimestampOffset();
                const captionTracks = {};
                captionData.forEach((caption => {
                    captionTracks[caption.stream] = captionTracks[caption.stream] || {
                        startTime: 1 / 0,
                        captions: [],
                        endTime: 0
                    };
                    const captionTrack = captionTracks[caption.stream];
                    captionTrack.startTime = Math.min(captionTrack.startTime, caption.startTime + timestampOffset);
                    captionTrack.endTime = Math.max(captionTrack.endTime, caption.endTime + timestampOffset);
                    captionTrack.captions.push(caption);
                }));
                Object.keys(captionTracks).forEach((trackName => {
                    const {startTime, endTime, captions} = captionTracks[trackName];
                    const inbandTextTracks = this.inbandTextTracks_;
                    this.logger_(`adding cues from ${startTime} -> ${endTime} for ${trackName}`);
                    app_createCaptionsTrackIfNotExists(inbandTextTracks, this.vhs_.tech_, trackName);
                    app_removeCuesFromTrack(startTime, endTime, inbandTextTracks[trackName]);
                    app_addCaptionData({
                        captionArray: captions,
                        inbandTextTracks,
                        timestampOffset
                    });
                }));
                if (this.transmuxer_) this.transmuxer_.postMessage({
                    action: "clearParsedMp4Captions"
                });
            }
            handleId3_(simpleSegment, id3Frames, dispatchType) {
                this.earlyAbortWhenNeeded_(simpleSegment.stats);
                if (this.checkForAbort_(simpleSegment.requestId)) return;
                const segmentInfo = this.pendingSegment_;
                if (!segmentInfo.hasAppendedData_) {
                    this.metadataQueue_.id3.push(this.handleId3_.bind(this, simpleSegment, id3Frames, dispatchType));
                    return;
                }
                this.addMetadataToTextTrack(dispatchType, id3Frames, this.duration_());
            }
            processMetadataQueue_() {
                this.metadataQueue_.id3.forEach((fn => fn()));
                this.metadataQueue_.caption.forEach((fn => fn()));
                this.metadataQueue_.id3 = [];
                this.metadataQueue_.caption = [];
            }
            processCallQueue_() {
                const callQueue = this.callQueue_;
                this.callQueue_ = [];
                callQueue.forEach((fun => fun()));
            }
            processLoadQueue_() {
                const loadQueue = this.loadQueue_;
                this.loadQueue_ = [];
                loadQueue.forEach((fun => fun()));
            }
            hasEnoughInfoToLoad_() {
                if (this.loaderType_ !== "audio") return true;
                const segmentInfo = this.pendingSegment_;
                if (!segmentInfo) return false;
                if (!this.getCurrentMediaInfo_()) return true;
                if (app_shouldWaitForTimelineChange({
                    timelineChangeController: this.timelineChangeController_,
                    currentTimeline: this.currentTimeline_,
                    segmentTimeline: segmentInfo.timeline,
                    loaderType: this.loaderType_,
                    audioDisabled: this.audioDisabled_
                })) return false;
                return true;
            }
            getCurrentMediaInfo_(segmentInfo = this.pendingSegment_) {
                return segmentInfo && segmentInfo.trackInfo || this.currentMediaInfo_;
            }
            getMediaInfo_(segmentInfo = this.pendingSegment_) {
                return this.getCurrentMediaInfo_(segmentInfo) || this.startingMediaInfo_;
            }
            getPendingSegmentPlaylist() {
                return this.pendingSegment_ ? this.pendingSegment_.playlist : null;
            }
            hasEnoughInfoToAppend_() {
                if (!this.sourceUpdater_.ready()) return false;
                if (this.waitingOnRemove_ || this.quotaExceededErrorRetryTimeout_) return false;
                const segmentInfo = this.pendingSegment_;
                const trackInfo = this.getCurrentMediaInfo_();
                if (!segmentInfo || !trackInfo) return false;
                const {hasAudio, hasVideo, isMuxed} = trackInfo;
                if (hasVideo && !segmentInfo.videoTimingInfo) return false;
                if (hasAudio && !this.audioDisabled_ && !isMuxed && !segmentInfo.audioTimingInfo) return false;
                if (app_shouldWaitForTimelineChange({
                    timelineChangeController: this.timelineChangeController_,
                    currentTimeline: this.currentTimeline_,
                    segmentTimeline: segmentInfo.timeline,
                    loaderType: this.loaderType_,
                    audioDisabled: this.audioDisabled_
                })) return false;
                return true;
            }
            handleData_(simpleSegment, result) {
                this.earlyAbortWhenNeeded_(simpleSegment.stats);
                if (this.checkForAbort_(simpleSegment.requestId)) return;
                if (this.callQueue_.length || !this.hasEnoughInfoToAppend_()) {
                    app_checkAndFixTimelines(this);
                    this.callQueue_.push(this.handleData_.bind(this, simpleSegment, result));
                    return;
                }
                const segmentInfo = this.pendingSegment_;
                this.setTimeMapping_(segmentInfo.timeline);
                this.updateMediaSecondsLoaded_(segmentInfo.part || segmentInfo.segment);
                if (this.mediaSource_.readyState === "closed") return;
                if (simpleSegment.map) {
                    simpleSegment.map = this.initSegmentForMap(simpleSegment.map, true);
                    segmentInfo.segment.map = simpleSegment.map;
                }
                if (simpleSegment.key) this.segmentKey(simpleSegment.key, true);
                segmentInfo.isFmp4 = simpleSegment.isFmp4;
                segmentInfo.timingInfo = segmentInfo.timingInfo || {};
                if (segmentInfo.isFmp4) {
                    this.trigger("fmp4");
                    segmentInfo.timingInfo.start = segmentInfo[app_timingInfoPropertyForMedia(result.type)].start;
                } else {
                    const trackInfo = this.getCurrentMediaInfo_();
                    const useVideoTimingInfo = this.loaderType_ === "main" && trackInfo && trackInfo.hasVideo;
                    let firstVideoFrameTimeForData;
                    if (useVideoTimingInfo) firstVideoFrameTimeForData = segmentInfo.videoTimingInfo.start;
                    segmentInfo.timingInfo.start = this.trueSegmentStart_({
                        currentStart: segmentInfo.timingInfo.start,
                        playlist: segmentInfo.playlist,
                        mediaIndex: segmentInfo.mediaIndex,
                        currentVideoTimestampOffset: this.sourceUpdater_.videoTimestampOffset(),
                        useVideoTimingInfo,
                        firstVideoFrameTimeForData,
                        videoTimingInfo: segmentInfo.videoTimingInfo,
                        audioTimingInfo: segmentInfo.audioTimingInfo
                    });
                }
                this.updateAppendInitSegmentStatus(segmentInfo, result.type);
                this.updateSourceBufferTimestampOffset_(segmentInfo);
                if (segmentInfo.isSyncRequest) {
                    this.updateTimingInfoEnd_(segmentInfo);
                    this.syncController_.saveSegmentTimingInfo({
                        segmentInfo,
                        shouldSaveTimelineMapping: this.loaderType_ === "main"
                    });
                    const next = this.chooseNextRequest_();
                    if (next.mediaIndex !== segmentInfo.mediaIndex || next.partIndex !== segmentInfo.partIndex) {
                        this.logger_("sync segment was incorrect, not appending");
                        return;
                    }
                    this.logger_("sync segment was correct, appending");
                }
                segmentInfo.hasAppendedData_ = true;
                this.processMetadataQueue_();
                this.appendData_(segmentInfo, result);
            }
            updateAppendInitSegmentStatus(segmentInfo, type) {
                if (this.loaderType_ === "main" && typeof segmentInfo.timestampOffset === "number" && !segmentInfo.changedTimestampOffset) this.appendInitSegment_ = {
                    audio: true,
                    video: true
                };
                if (this.playlistOfLastInitSegment_[type] !== segmentInfo.playlist) this.appendInitSegment_[type] = true;
            }
            getInitSegmentAndUpdateState_({type, initSegment, map, playlist}) {
                if (map) {
                    const id = app_initSegmentId(map);
                    if (this.activeInitSegmentId_ === id) return null;
                    initSegment = this.initSegmentForMap(map, true).bytes;
                    this.activeInitSegmentId_ = id;
                }
                if (initSegment && this.appendInitSegment_[type]) {
                    this.playlistOfLastInitSegment_[type] = playlist;
                    this.appendInitSegment_[type] = false;
                    this.activeInitSegmentId_ = null;
                    return initSegment;
                }
                return null;
            }
            handleQuotaExceededError_({segmentInfo, type, bytes}, error) {
                const audioBuffered = this.sourceUpdater_.audioBuffered();
                const videoBuffered = this.sourceUpdater_.videoBuffered();
                if (audioBuffered.length > 1) this.logger_("On QUOTA_EXCEEDED_ERR, found gaps in the audio buffer: " + app_timeRangesToArray(audioBuffered).join(", "));
                if (videoBuffered.length > 1) this.logger_("On QUOTA_EXCEEDED_ERR, found gaps in the video buffer: " + app_timeRangesToArray(videoBuffered).join(", "));
                const audioBufferStart = audioBuffered.length ? audioBuffered.start(0) : 0;
                const audioBufferEnd = audioBuffered.length ? audioBuffered.end(audioBuffered.length - 1) : 0;
                const videoBufferStart = videoBuffered.length ? videoBuffered.start(0) : 0;
                const videoBufferEnd = videoBuffered.length ? videoBuffered.end(videoBuffered.length - 1) : 0;
                if (audioBufferEnd - audioBufferStart <= app_MIN_BACK_BUFFER && videoBufferEnd - videoBufferStart <= app_MIN_BACK_BUFFER) {
                    this.logger_("On QUOTA_EXCEEDED_ERR, single segment too large to append to " + "buffer, triggering an error. " + `Appended byte length: ${bytes.byteLength}, ` + `audio buffer: ${app_timeRangesToArray(audioBuffered).join(", ")}, ` + `video buffer: ${app_timeRangesToArray(videoBuffered).join(", ")}, `);
                    this.error({
                        message: "Quota exceeded error with append of a single segment of content",
                        excludeUntil: 1 / 0
                    });
                    this.trigger("error");
                    return;
                }
                this.waitingOnRemove_ = true;
                this.callQueue_.push(this.appendToSourceBuffer_.bind(this, {
                    segmentInfo,
                    type,
                    bytes
                }));
                const currentTime = this.currentTime_();
                const timeToRemoveUntil = currentTime - app_MIN_BACK_BUFFER;
                this.logger_(`On QUOTA_EXCEEDED_ERR, removing audio/video from 0 to ${timeToRemoveUntil}`);
                this.remove(0, timeToRemoveUntil, (() => {
                    this.logger_(`On QUOTA_EXCEEDED_ERR, retrying append in ${app_MIN_BACK_BUFFER}s`);
                    this.waitingOnRemove_ = false;
                    this.quotaExceededErrorRetryTimeout_ = app_window_default().setTimeout((() => {
                        this.logger_("On QUOTA_EXCEEDED_ERR, re-processing call queue");
                        this.quotaExceededErrorRetryTimeout_ = null;
                        this.processCallQueue_();
                    }), app_MIN_BACK_BUFFER * 1e3);
                }), true);
            }
            handleAppendError_({segmentInfo, type, bytes}, error) {
                if (!error) return;
                if (error.code === app_QUOTA_EXCEEDED_ERR) {
                    this.handleQuotaExceededError_({
                        segmentInfo,
                        type,
                        bytes
                    });
                    return;
                }
                this.logger_("Received non QUOTA_EXCEEDED_ERR on append", error);
                this.error({
                    message: `${type} append of ${bytes.length}b failed for segment ` + `#${segmentInfo.mediaIndex} in playlist ${segmentInfo.playlist.id}`,
                    metadata: {
                        errorType: app_videojs.Error.StreamingFailedToAppendSegment
                    }
                });
                this.trigger("appenderror");
            }
            appendToSourceBuffer_({segmentInfo, type, initSegment, data, bytes}) {
                if (!bytes) {
                    const segments = [ data ];
                    let byteLength = data.byteLength;
                    if (initSegment) {
                        segments.unshift(initSegment);
                        byteLength += initSegment.byteLength;
                    }
                    bytes = app_concatSegments({
                        bytes: byteLength,
                        segments
                    });
                }
                const metadata = {
                    segmentInfo: app_segmentInfoPayload({
                        type: this.loaderType_,
                        segment: segmentInfo
                    })
                };
                this.trigger({
                    type: "segmentappendstart",
                    metadata
                });
                this.sourceUpdater_.appendBuffer({
                    segmentInfo,
                    type,
                    bytes
                }, this.handleAppendError_.bind(this, {
                    segmentInfo,
                    type,
                    bytes
                }));
            }
            handleSegmentTimingInfo_(type, requestId, segmentTimingInfo) {
                if (!this.pendingSegment_ || requestId !== this.pendingSegment_.requestId) return;
                const segment = this.pendingSegment_.segment;
                const timingInfoProperty = `${type}TimingInfo`;
                if (!segment[timingInfoProperty]) segment[timingInfoProperty] = {};
                segment[timingInfoProperty].transmuxerPrependedSeconds = segmentTimingInfo.prependedContentDuration || 0;
                segment[timingInfoProperty].transmuxedPresentationStart = segmentTimingInfo.start.presentation;
                segment[timingInfoProperty].transmuxedDecodeStart = segmentTimingInfo.start.decode;
                segment[timingInfoProperty].transmuxedPresentationEnd = segmentTimingInfo.end.presentation;
                segment[timingInfoProperty].transmuxedDecodeEnd = segmentTimingInfo.end.decode;
                segment[timingInfoProperty].baseMediaDecodeTime = segmentTimingInfo.baseMediaDecodeTime;
            }
            appendData_(segmentInfo, result) {
                const {type, data} = result;
                if (!data || !data.byteLength) return;
                if (type === "audio" && this.audioDisabled_) return;
                const initSegment = this.getInitSegmentAndUpdateState_({
                    type,
                    initSegment: result.initSegment,
                    playlist: segmentInfo.playlist,
                    map: segmentInfo.isFmp4 ? segmentInfo.segment.map : null
                });
                this.appendToSourceBuffer_({
                    segmentInfo,
                    type,
                    initSegment,
                    data
                });
            }
            loadSegment_(segmentInfo) {
                this.state = "WAITING";
                this.pendingSegment_ = segmentInfo;
                this.trimBackBuffer_(segmentInfo);
                if (typeof segmentInfo.timestampOffset === "number") if (this.transmuxer_) this.transmuxer_.postMessage({
                    action: "clearAllMp4Captions"
                });
                if (!this.hasEnoughInfoToLoad_()) {
                    app_checkAndFixTimelines(this);
                    this.loadQueue_.push((() => {
                        const options = app_extends({}, segmentInfo, {
                            forceTimestampOffset: true
                        });
                        app_extends(segmentInfo, this.generateSegmentInfo_(options));
                        this.isPendingTimestampOffset_ = false;
                        this.updateTransmuxerAndRequestSegment_(segmentInfo);
                    }));
                    return;
                }
                this.updateTransmuxerAndRequestSegment_(segmentInfo);
            }
            updateTransmuxerAndRequestSegment_(segmentInfo) {
                if (this.shouldUpdateTransmuxerTimestampOffset_(segmentInfo.timestampOffset)) {
                    this.gopBuffer_.length = 0;
                    segmentInfo.gopsToAlignWith = [];
                    this.timeMapping_ = 0;
                    this.transmuxer_.postMessage({
                        action: "reset"
                    });
                    this.transmuxer_.postMessage({
                        action: "setTimestampOffset",
                        timestampOffset: segmentInfo.timestampOffset
                    });
                }
                const simpleSegment = this.createSimplifiedSegmentObj_(segmentInfo);
                const isEndOfStream = this.isEndOfStream_(segmentInfo.mediaIndex, segmentInfo.playlist, segmentInfo.partIndex);
                const isWalkingForward = this.mediaIndex !== null;
                const isDiscontinuity = segmentInfo.timeline !== this.currentTimeline_ && segmentInfo.timeline > 0;
                const isEndOfTimeline = isEndOfStream || isWalkingForward && isDiscontinuity;
                this.logger_(`Requesting\n${app_compactSegmentUrlDescription(segmentInfo.uri)}\n${app_segmentInfoString(segmentInfo)}`);
                if (simpleSegment.map && !simpleSegment.map.bytes) {
                    this.logger_("going to request init segment.");
                    this.appendInitSegment_ = {
                        video: true,
                        audio: true
                    };
                }
                segmentInfo.abortRequests = app_mediaSegmentRequest({
                    xhr: this.vhs_.xhr,
                    xhrOptions: this.xhrOptions_,
                    decryptionWorker: this.decrypter_,
                    segment: simpleSegment,
                    abortFn: this.handleAbort_.bind(this, segmentInfo),
                    progressFn: this.handleProgress_.bind(this),
                    trackInfoFn: this.handleTrackInfo_.bind(this),
                    timingInfoFn: this.handleTimingInfo_.bind(this),
                    videoSegmentTimingInfoFn: this.handleSegmentTimingInfo_.bind(this, "video", segmentInfo.requestId),
                    audioSegmentTimingInfoFn: this.handleSegmentTimingInfo_.bind(this, "audio", segmentInfo.requestId),
                    captionsFn: this.handleCaptions_.bind(this),
                    isEndOfTimeline,
                    endedTimelineFn: () => {
                        this.logger_("received endedtimeline callback");
                    },
                    id3Fn: this.handleId3_.bind(this),
                    dataFn: this.handleData_.bind(this),
                    doneFn: this.segmentRequestFinished_.bind(this),
                    onTransmuxerLog: ({message, level, stream}) => {
                        this.logger_(`${app_segmentInfoString(segmentInfo)} logged from transmuxer stream ${stream} as a ${level}: ${message}`);
                    },
                    triggerSegmentEventFn: ({type, segment, keyInfo, trackInfo, timingInfo}) => {
                        const segInfo = app_segmentInfoPayload({
                            segment
                        });
                        const metadata = {
                            segmentInfo: segInfo
                        };
                        if (keyInfo) metadata.keyInfo = keyInfo;
                        if (trackInfo) metadata.trackInfo = trackInfo;
                        if (timingInfo) metadata.timingInfo = timingInfo;
                        this.trigger({
                            type,
                            metadata
                        });
                    }
                });
            }
            trimBackBuffer_(segmentInfo) {
                const removeToTime = app_safeBackBufferTrimTime(this.seekable_(), this.currentTime_(), this.playlist_.targetDuration || 10);
                if (removeToTime > 0) this.remove(0, removeToTime);
            }
            createSimplifiedSegmentObj_(segmentInfo) {
                const segment = segmentInfo.segment;
                const part = segmentInfo.part;
                const isEncrypted = segmentInfo.segment.key || segmentInfo.segment.map && segmentInfo.segment.map.key;
                const isMediaInitialization = segmentInfo.segment.map && !segmentInfo.segment.map.bytes;
                const simpleSegment = {
                    resolvedUri: part ? part.resolvedUri : segment.resolvedUri,
                    byterange: part ? part.byterange : segment.byterange,
                    requestId: segmentInfo.requestId,
                    transmuxer: segmentInfo.transmuxer,
                    audioAppendStart: segmentInfo.audioAppendStart,
                    gopsToAlignWith: segmentInfo.gopsToAlignWith,
                    part: segmentInfo.part,
                    type: this.loaderType_,
                    start: segmentInfo.startOfSegment,
                    duration: segmentInfo.duration,
                    isEncrypted,
                    isMediaInitialization
                };
                const previousSegment = segmentInfo.playlist.segments[segmentInfo.mediaIndex - 1];
                if (previousSegment && previousSegment.timeline === segment.timeline) if (previousSegment.videoTimingInfo) simpleSegment.baseStartTime = previousSegment.videoTimingInfo.transmuxedDecodeEnd; else if (previousSegment.audioTimingInfo) simpleSegment.baseStartTime = previousSegment.audioTimingInfo.transmuxedDecodeEnd;
                if (segment.key) {
                    const iv = segment.key.iv || new Uint32Array([ 0, 0, 0, segmentInfo.mediaIndex + segmentInfo.playlist.mediaSequence ]);
                    simpleSegment.key = this.segmentKey(segment.key);
                    simpleSegment.key.iv = iv;
                }
                if (segment.map) simpleSegment.map = this.initSegmentForMap(segment.map);
                return simpleSegment;
            }
            saveTransferStats_(stats) {
                this.mediaRequests += 1;
                if (stats) {
                    this.mediaBytesTransferred += stats.bytesReceived;
                    this.mediaTransferDuration += stats.roundTripTime;
                }
            }
            saveBandwidthRelatedStats_(duration, stats) {
                this.pendingSegment_.byteLength = stats.bytesReceived;
                if (duration < app_MIN_SEGMENT_DURATION_TO_SAVE_STATS) {
                    this.logger_(`Ignoring segment's bandwidth because its duration of ${duration}` + ` is less than the min to record ${app_MIN_SEGMENT_DURATION_TO_SAVE_STATS}`);
                    return;
                }
                const metadata = {
                    bandwidthInfo: {
                        from: this.bandwidth,
                        to: stats.bandwidth
                    }
                };
                this.trigger({
                    type: "bandwidthupdated",
                    metadata
                });
                this.bandwidth = stats.bandwidth;
                this.roundTrip = stats.roundTripTime;
            }
            handleTimeout_() {
                this.mediaRequestsTimedout += 1;
                this.bandwidth = 1;
                this.roundTrip = NaN;
                this.trigger("bandwidthupdate");
                this.trigger("timeout");
            }
            segmentRequestFinished_(error, simpleSegment, result) {
                if (this.callQueue_.length) {
                    this.callQueue_.push(this.segmentRequestFinished_.bind(this, error, simpleSegment, result));
                    return;
                }
                this.saveTransferStats_(simpleSegment.stats);
                if (!this.pendingSegment_) return;
                if (simpleSegment.requestId !== this.pendingSegment_.requestId) return;
                if (error) {
                    this.pendingSegment_ = null;
                    this.state = "READY";
                    if (error.code === app_REQUEST_ERRORS.ABORTED) return;
                    this.pause();
                    if (error.code === app_REQUEST_ERRORS.TIMEOUT) {
                        this.handleTimeout_();
                        return;
                    }
                    this.mediaRequestsErrored += 1;
                    this.error(error);
                    this.trigger("error");
                    return;
                }
                const segmentInfo = this.pendingSegment_;
                this.saveBandwidthRelatedStats_(segmentInfo.duration, simpleSegment.stats);
                segmentInfo.endOfAllRequests = simpleSegment.endOfAllRequests;
                if (result.gopInfo) this.gopBuffer_ = app_updateGopBuffer(this.gopBuffer_, result.gopInfo, this.safeAppend_);
                this.state = "APPENDING";
                this.trigger("appending");
                this.waitForAppendsToComplete_(segmentInfo);
            }
            setTimeMapping_(timeline) {
                const timelineMapping = this.syncController_.mappingForTimeline(timeline);
                if (timelineMapping !== null) this.timeMapping_ = timelineMapping;
            }
            updateMediaSecondsLoaded_(segment) {
                if (typeof segment.start === "number" && typeof segment.end === "number") this.mediaSecondsLoaded += segment.end - segment.start; else this.mediaSecondsLoaded += segment.duration;
            }
            shouldUpdateTransmuxerTimestampOffset_(timestampOffset) {
                if (timestampOffset === null) return false;
                if (this.loaderType_ === "main" && timestampOffset !== this.sourceUpdater_.videoTimestampOffset()) return true;
                if (!this.audioDisabled_ && timestampOffset !== this.sourceUpdater_.audioTimestampOffset()) return true;
                return false;
            }
            trueSegmentStart_({currentStart, playlist, mediaIndex, firstVideoFrameTimeForData, currentVideoTimestampOffset, useVideoTimingInfo, videoTimingInfo, audioTimingInfo}) {
                if (typeof currentStart !== "undefined") return currentStart;
                if (!useVideoTimingInfo) return audioTimingInfo.start;
                const previousSegment = playlist.segments[mediaIndex - 1];
                if (mediaIndex === 0 || !previousSegment || typeof previousSegment.start === "undefined" || previousSegment.end !== firstVideoFrameTimeForData + currentVideoTimestampOffset) return firstVideoFrameTimeForData;
                return videoTimingInfo.start;
            }
            waitForAppendsToComplete_(segmentInfo) {
                const trackInfo = this.getCurrentMediaInfo_(segmentInfo);
                if (!trackInfo) {
                    this.error({
                        message: "No starting media returned, likely due to an unsupported media format.",
                        playlistExclusionDuration: 1 / 0
                    });
                    this.trigger("error");
                    return;
                }
                const {hasAudio, hasVideo, isMuxed} = trackInfo;
                const waitForVideo = this.loaderType_ === "main" && hasVideo;
                const waitForAudio = !this.audioDisabled_ && hasAudio && !isMuxed;
                segmentInfo.waitingOnAppends = 0;
                if (!segmentInfo.hasAppendedData_) {
                    if (!segmentInfo.timingInfo && typeof segmentInfo.timestampOffset === "number") this.isPendingTimestampOffset_ = true;
                    segmentInfo.timingInfo = {
                        start: 0
                    };
                    segmentInfo.waitingOnAppends++;
                    if (!this.isPendingTimestampOffset_) {
                        this.updateSourceBufferTimestampOffset_(segmentInfo);
                        this.processMetadataQueue_();
                    }
                    this.checkAppendsDone_(segmentInfo);
                    return;
                }
                if (waitForVideo) segmentInfo.waitingOnAppends++;
                if (waitForAudio) segmentInfo.waitingOnAppends++;
                if (waitForVideo) this.sourceUpdater_.videoQueueCallback(this.checkAppendsDone_.bind(this, segmentInfo));
                if (waitForAudio) this.sourceUpdater_.audioQueueCallback(this.checkAppendsDone_.bind(this, segmentInfo));
            }
            checkAppendsDone_(segmentInfo) {
                if (this.checkForAbort_(segmentInfo.requestId)) return;
                segmentInfo.waitingOnAppends--;
                if (segmentInfo.waitingOnAppends === 0) this.handleAppendsDone_();
            }
            checkForIllegalMediaSwitch(trackInfo) {
                const illegalMediaSwitchError = app_illegalMediaSwitch(this.loaderType_, this.getCurrentMediaInfo_(), trackInfo);
                if (illegalMediaSwitchError) {
                    this.error({
                        message: illegalMediaSwitchError,
                        playlistExclusionDuration: 1 / 0
                    });
                    this.trigger("error");
                    return true;
                }
                return false;
            }
            updateSourceBufferTimestampOffset_(segmentInfo) {
                if (segmentInfo.timestampOffset === null || typeof segmentInfo.timingInfo.start !== "number" || segmentInfo.changedTimestampOffset || this.loaderType_ !== "main") return;
                let didChange = false;
                segmentInfo.timestampOffset -= this.getSegmentStartTimeForTimestampOffsetCalculation_({
                    videoTimingInfo: segmentInfo.segment.videoTimingInfo,
                    audioTimingInfo: segmentInfo.segment.audioTimingInfo,
                    timingInfo: segmentInfo.timingInfo
                });
                segmentInfo.changedTimestampOffset = true;
                if (segmentInfo.timestampOffset !== this.sourceUpdater_.videoTimestampOffset()) {
                    this.sourceUpdater_.videoTimestampOffset(segmentInfo.timestampOffset);
                    didChange = true;
                }
                if (segmentInfo.timestampOffset !== this.sourceUpdater_.audioTimestampOffset()) {
                    this.sourceUpdater_.audioTimestampOffset(segmentInfo.timestampOffset);
                    didChange = true;
                }
                if (didChange) this.trigger("timestampoffset");
            }
            getSegmentStartTimeForTimestampOffsetCalculation_({videoTimingInfo, audioTimingInfo, timingInfo}) {
                if (!this.useDtsForTimestampOffset_) return timingInfo.start;
                if (videoTimingInfo && typeof videoTimingInfo.transmuxedDecodeStart === "number") return videoTimingInfo.transmuxedDecodeStart;
                if (audioTimingInfo && typeof audioTimingInfo.transmuxedDecodeStart === "number") return audioTimingInfo.transmuxedDecodeStart;
                return timingInfo.start;
            }
            updateTimingInfoEnd_(segmentInfo) {
                segmentInfo.timingInfo = segmentInfo.timingInfo || {};
                const trackInfo = this.getMediaInfo_();
                const useVideoTimingInfo = this.loaderType_ === "main" && trackInfo && trackInfo.hasVideo;
                const prioritizedTimingInfo = useVideoTimingInfo && segmentInfo.videoTimingInfo ? segmentInfo.videoTimingInfo : segmentInfo.audioTimingInfo;
                if (!prioritizedTimingInfo) return;
                segmentInfo.timingInfo.end = typeof prioritizedTimingInfo.end === "number" ? prioritizedTimingInfo.end : prioritizedTimingInfo.start + segmentInfo.duration;
            }
            handleAppendsDone_() {
                if (this.pendingSegment_) {
                    const metadata = {
                        segmentInfo: app_segmentInfoPayload({
                            type: this.loaderType_,
                            segment: this.pendingSegment_
                        })
                    };
                    this.trigger({
                        type: "appendsdone",
                        metadata
                    });
                }
                if (!this.pendingSegment_) {
                    this.state = "READY";
                    if (!this.paused()) this.monitorBuffer_();
                    return;
                }
                const segmentInfo = this.pendingSegment_;
                if (segmentInfo.part && segmentInfo.part.syncInfo) segmentInfo.part.syncInfo.markAppended(); else if (segmentInfo.segment.syncInfo) segmentInfo.segment.syncInfo.markAppended();
                this.updateTimingInfoEnd_(segmentInfo);
                if (this.shouldSaveSegmentTimingInfo_) this.syncController_.saveSegmentTimingInfo({
                    segmentInfo,
                    shouldSaveTimelineMapping: this.loaderType_ === "main"
                });
                const segmentDurationMessage = app_getTroublesomeSegmentDurationMessage(segmentInfo, this.sourceType_);
                if (segmentDurationMessage) if (segmentDurationMessage.severity === "warn") app_videojs.log.warn(segmentDurationMessage.message); else this.logger_(segmentDurationMessage.message);
                this.recordThroughput_(segmentInfo);
                this.pendingSegment_ = null;
                this.state = "READY";
                if (segmentInfo.isSyncRequest) {
                    this.trigger("syncinfoupdate");
                    if (!segmentInfo.hasAppendedData_) {
                        this.logger_(`Throwing away un-appended sync request ${app_segmentInfoString(segmentInfo)}`);
                        return;
                    }
                }
                this.logger_(`Appended ${app_segmentInfoString(segmentInfo)}`);
                this.addSegmentMetadataCue_(segmentInfo);
                this.fetchAtBuffer_ = true;
                if (this.currentTimeline_ !== segmentInfo.timeline) {
                    this.timelineChangeController_.lastTimelineChange({
                        type: this.loaderType_,
                        from: this.currentTimeline_,
                        to: segmentInfo.timeline
                    });
                    if (this.loaderType_ === "main" && !this.audioDisabled_) this.timelineChangeController_.lastTimelineChange({
                        type: "audio",
                        from: this.currentTimeline_,
                        to: segmentInfo.timeline
                    });
                }
                this.currentTimeline_ = segmentInfo.timeline;
                this.trigger("syncinfoupdate");
                const segment = segmentInfo.segment;
                const part = segmentInfo.part;
                const badSegmentGuess = segment.end && this.currentTime_() - segment.end > segmentInfo.playlist.targetDuration * 3;
                const badPartGuess = part && part.end && this.currentTime_() - part.end > segmentInfo.playlist.partTargetDuration * 3;
                if (badSegmentGuess || badPartGuess) {
                    this.logger_(`bad ${badSegmentGuess ? "segment" : "part"} ${app_segmentInfoString(segmentInfo)}`);
                    this.resetEverything();
                    return;
                }
                const isWalkingForward = this.mediaIndex !== null;
                if (isWalkingForward) this.trigger("bandwidthupdate");
                this.trigger("progress");
                this.mediaIndex = segmentInfo.mediaIndex;
                this.partIndex = segmentInfo.partIndex;
                if (this.isEndOfStream_(segmentInfo.mediaIndex, segmentInfo.playlist, segmentInfo.partIndex)) this.endOfStream();
                this.trigger("appended");
                if (segmentInfo.hasAppendedData_) this.mediaAppends++;
                if (!this.paused()) this.monitorBuffer_();
            }
            recordThroughput_(segmentInfo) {
                if (segmentInfo.duration < app_MIN_SEGMENT_DURATION_TO_SAVE_STATS) {
                    this.logger_(`Ignoring segment's throughput because its duration of ${segmentInfo.duration}` + ` is less than the min to record ${app_MIN_SEGMENT_DURATION_TO_SAVE_STATS}`);
                    return;
                }
                const rate = this.throughput.rate;
                const segmentProcessingTime = Date.now() - segmentInfo.endOfAllRequests + 1;
                const segmentProcessingThroughput = Math.floor(segmentInfo.byteLength / segmentProcessingTime * 8 * 1e3);
                this.throughput.rate += (segmentProcessingThroughput - rate) / ++this.throughput.count;
            }
            addSegmentMetadataCue_(segmentInfo) {
                if (!this.segmentMetadataTrack_) return;
                const segment = segmentInfo.segment;
                const start = segment.start;
                const end = segment.end;
                if (!app_finite(start) || !app_finite(end)) return;
                app_removeCuesFromTrack(start, end, this.segmentMetadataTrack_);
                const Cue = app_window_default().WebKitDataCue || app_window_default().VTTCue;
                const value = {
                    custom: segment.custom,
                    dateTimeObject: segment.dateTimeObject,
                    dateTimeString: segment.dateTimeString,
                    programDateTime: segment.programDateTime,
                    bandwidth: segmentInfo.playlist.attributes.BANDWIDTH,
                    resolution: segmentInfo.playlist.attributes.RESOLUTION,
                    codecs: segmentInfo.playlist.attributes.CODECS,
                    byteLength: segmentInfo.byteLength,
                    uri: segmentInfo.uri,
                    timeline: segmentInfo.timeline,
                    playlist: segmentInfo.playlist.id,
                    start,
                    end
                };
                const data = JSON.stringify(value);
                const cue = new Cue(start, end, data);
                cue.value = value;
                this.segmentMetadataTrack_.addCue(cue);
            }
        }
        function app_noop() {}
        const app_toTitleCase = function(string) {
            if (typeof string !== "string") return string;
            return string.replace(/./, (w => w.toUpperCase()));
        };
        const app_bufferTypes = [ "video", "audio" ];
        const app_updating = (type, sourceUpdater) => {
            const sourceBuffer = sourceUpdater[`${type}Buffer`];
            return sourceBuffer && sourceBuffer.updating || sourceUpdater.queuePending[type];
        };
        const app_nextQueueIndexOfType = (type, queue) => {
            for (let i = 0; i < queue.length; i++) {
                const queueEntry = queue[i];
                if (queueEntry.type === "mediaSource") return null;
                if (queueEntry.type === type) return i;
            }
            return null;
        };
        const app_shiftQueue = (type, sourceUpdater) => {
            if (sourceUpdater.queue.length === 0) return;
            let queueIndex = 0;
            let queueEntry = sourceUpdater.queue[queueIndex];
            if (queueEntry.type === "mediaSource") {
                if (!sourceUpdater.updating() && sourceUpdater.mediaSource.readyState !== "closed") {
                    sourceUpdater.queue.shift();
                    queueEntry.action(sourceUpdater);
                    if (queueEntry.doneFn) queueEntry.doneFn();
                    app_shiftQueue("audio", sourceUpdater);
                    app_shiftQueue("video", sourceUpdater);
                }
                return;
            }
            if (type === "mediaSource") return;
            if (!sourceUpdater.ready() || sourceUpdater.mediaSource.readyState === "closed" || app_updating(type, sourceUpdater)) return;
            if (queueEntry.type !== type) {
                queueIndex = app_nextQueueIndexOfType(type, sourceUpdater.queue);
                if (queueIndex === null) return;
                queueEntry = sourceUpdater.queue[queueIndex];
            }
            sourceUpdater.queue.splice(queueIndex, 1);
            sourceUpdater.queuePending[type] = queueEntry;
            queueEntry.action(type, sourceUpdater);
            if (!queueEntry.doneFn) {
                sourceUpdater.queuePending[type] = null;
                app_shiftQueue(type, sourceUpdater);
                return;
            }
        };
        const app_cleanupBuffer = (type, sourceUpdater) => {
            const buffer = sourceUpdater[`${type}Buffer`];
            const titleType = app_toTitleCase(type);
            if (!buffer) return;
            buffer.removeEventListener("updateend", sourceUpdater[`on${titleType}UpdateEnd_`]);
            buffer.removeEventListener("error", sourceUpdater[`on${titleType}Error_`]);
            sourceUpdater.codecs[type] = null;
            sourceUpdater[`${type}Buffer`] = null;
        };
        const app_inSourceBuffers = (mediaSource, sourceBuffer) => mediaSource && sourceBuffer && Array.prototype.indexOf.call(mediaSource.sourceBuffers, sourceBuffer) !== -1;
        const app_actions = {
            appendBuffer: (bytes, segmentInfo, onError) => (type, sourceUpdater) => {
                const sourceBuffer = sourceUpdater[`${type}Buffer`];
                if (!app_inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) return;
                sourceUpdater.logger_(`Appending segment ${segmentInfo.mediaIndex}'s ${bytes.length} bytes to ${type}Buffer`);
                try {
                    sourceBuffer.appendBuffer(bytes);
                } catch (e) {
                    sourceUpdater.logger_(`Error with code ${e.code} ` + (e.code === app_QUOTA_EXCEEDED_ERR ? "(QUOTA_EXCEEDED_ERR) " : "") + `when appending segment ${segmentInfo.mediaIndex} to ${type}Buffer`);
                    sourceUpdater.queuePending[type] = null;
                    onError(e);
                }
            },
            remove: (start, end) => (type, sourceUpdater) => {
                const sourceBuffer = sourceUpdater[`${type}Buffer`];
                if (!app_inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) return;
                sourceUpdater.logger_(`Removing ${start} to ${end} from ${type}Buffer`);
                try {
                    sourceBuffer.remove(start, end);
                } catch (e) {
                    sourceUpdater.logger_(`Remove ${start} to ${end} from ${type}Buffer failed`);
                }
            },
            timestampOffset: offset => (type, sourceUpdater) => {
                const sourceBuffer = sourceUpdater[`${type}Buffer`];
                if (!app_inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) return;
                sourceUpdater.logger_(`Setting ${type}timestampOffset to ${offset}`);
                sourceBuffer.timestampOffset = offset;
            },
            callback: callback => (type, sourceUpdater) => {
                callback();
            },
            endOfStream: error => sourceUpdater => {
                if (sourceUpdater.mediaSource.readyState !== "open") return;
                sourceUpdater.logger_(`Calling mediaSource endOfStream(${error || ""})`);
                try {
                    sourceUpdater.mediaSource.endOfStream(error);
                } catch (e) {
                    app_videojs.log.warn("Failed to call media source endOfStream", e);
                }
            },
            duration: duration => sourceUpdater => {
                sourceUpdater.logger_(`Setting mediaSource duration to ${duration}`);
                try {
                    sourceUpdater.mediaSource.duration = duration;
                } catch (e) {
                    app_videojs.log.warn("Failed to set media source duration", e);
                }
            },
            abort: () => (type, sourceUpdater) => {
                if (sourceUpdater.mediaSource.readyState !== "open") return;
                const sourceBuffer = sourceUpdater[`${type}Buffer`];
                if (!app_inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) return;
                sourceUpdater.logger_(`calling abort on ${type}Buffer`);
                try {
                    sourceBuffer.abort();
                } catch (e) {
                    app_videojs.log.warn(`Failed to abort on ${type}Buffer`, e);
                }
            },
            addSourceBuffer: (type, codec) => sourceUpdater => {
                const titleType = app_toTitleCase(type);
                const mime = app_getMimeForCodec(codec);
                sourceUpdater.logger_(`Adding ${type}Buffer with codec ${codec} to mediaSource`);
                const sourceBuffer = sourceUpdater.mediaSource.addSourceBuffer(mime);
                sourceBuffer.addEventListener("updateend", sourceUpdater[`on${titleType}UpdateEnd_`]);
                sourceBuffer.addEventListener("error", sourceUpdater[`on${titleType}Error_`]);
                sourceUpdater.codecs[type] = codec;
                sourceUpdater[`${type}Buffer`] = sourceBuffer;
            },
            removeSourceBuffer: type => sourceUpdater => {
                const sourceBuffer = sourceUpdater[`${type}Buffer`];
                app_cleanupBuffer(type, sourceUpdater);
                if (!app_inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) return;
                sourceUpdater.logger_(`Removing ${type}Buffer with codec ${sourceUpdater.codecs[type]} from mediaSource`);
                try {
                    sourceUpdater.mediaSource.removeSourceBuffer(sourceBuffer);
                } catch (e) {
                    app_videojs.log.warn(`Failed to removeSourceBuffer ${type}Buffer`, e);
                }
            },
            changeType: codec => (type, sourceUpdater) => {
                const sourceBuffer = sourceUpdater[`${type}Buffer`];
                const mime = app_getMimeForCodec(codec);
                if (!app_inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) return;
                const newCodecBase = codec.substring(0, codec.indexOf("."));
                const oldCodec = sourceUpdater.codecs[type];
                const oldCodecBase = oldCodec.substring(0, oldCodec.indexOf("."));
                if (oldCodecBase === newCodecBase) return;
                const metadata = {
                    codecsChangeInfo: {
                        from: oldCodec,
                        to: codec
                    }
                };
                sourceUpdater.trigger({
                    type: "codecschange",
                    metadata
                });
                sourceUpdater.logger_(`changing ${type}Buffer codec from ${oldCodec} to ${codec}`);
                try {
                    sourceBuffer.changeType(mime);
                    sourceUpdater.codecs[type] = codec;
                } catch (e) {
                    metadata.errorType = app_videojs.Error.StreamingCodecsChangeError;
                    metadata.error = e;
                    e.metadata = metadata;
                    sourceUpdater.error_ = e;
                    sourceUpdater.trigger("error");
                    app_videojs.log.warn(`Failed to changeType on ${type}Buffer`, e);
                }
            }
        };
        const app_pushQueue = ({type, sourceUpdater, action, doneFn, name}) => {
            sourceUpdater.queue.push({
                type,
                action,
                doneFn,
                name
            });
            app_shiftQueue(type, sourceUpdater);
        };
        const app_onUpdateend = (type, sourceUpdater) => e => {
            const bufferedRangesForType = sourceUpdater[`${type}Buffered`]();
            const descriptiveString = app_bufferedRangesToString(bufferedRangesForType);
            sourceUpdater.logger_(`received "updateend" event for ${type} Source Buffer: `, descriptiveString);
            if (sourceUpdater.queuePending[type]) {
                const doneFn = sourceUpdater.queuePending[type].doneFn;
                sourceUpdater.queuePending[type] = null;
                if (doneFn) doneFn(sourceUpdater[`${type}Error_`]);
            }
            app_shiftQueue(type, sourceUpdater);
        };
        class app_SourceUpdater extends app_videojs.EventTarget {
            constructor(mediaSource) {
                super();
                this.mediaSource = mediaSource;
                this.sourceopenListener_ = () => app_shiftQueue("mediaSource", this);
                this.mediaSource.addEventListener("sourceopen", this.sourceopenListener_);
                this.logger_ = app_logger("SourceUpdater");
                this.audioTimestampOffset_ = 0;
                this.videoTimestampOffset_ = 0;
                this.queue = [];
                this.queuePending = {
                    audio: null,
                    video: null
                };
                this.delayedAudioAppendQueue_ = [];
                this.videoAppendQueued_ = false;
                this.codecs = {};
                this.onVideoUpdateEnd_ = app_onUpdateend("video", this);
                this.onAudioUpdateEnd_ = app_onUpdateend("audio", this);
                this.onVideoError_ = e => {
                    this.videoError_ = e;
                };
                this.onAudioError_ = e => {
                    this.audioError_ = e;
                };
                this.createdSourceBuffers_ = false;
                this.initializedEme_ = false;
                this.triggeredReady_ = false;
            }
            initializedEme() {
                this.initializedEme_ = true;
                this.triggerReady();
            }
            hasCreatedSourceBuffers() {
                return this.createdSourceBuffers_;
            }
            hasInitializedAnyEme() {
                return this.initializedEme_;
            }
            ready() {
                return this.hasCreatedSourceBuffers() && this.hasInitializedAnyEme();
            }
            createSourceBuffers(codecs) {
                if (this.hasCreatedSourceBuffers()) return;
                this.addOrChangeSourceBuffers(codecs);
                this.createdSourceBuffers_ = true;
                this.trigger("createdsourcebuffers");
                this.triggerReady();
            }
            triggerReady() {
                if (this.ready() && !this.triggeredReady_) {
                    this.triggeredReady_ = true;
                    this.trigger("ready");
                }
            }
            addSourceBuffer(type, codec) {
                app_pushQueue({
                    type: "mediaSource",
                    sourceUpdater: this,
                    action: app_actions.addSourceBuffer(type, codec),
                    name: "addSourceBuffer"
                });
            }
            abort(type) {
                app_pushQueue({
                    type,
                    sourceUpdater: this,
                    action: app_actions.abort(type),
                    name: "abort"
                });
            }
            removeSourceBuffer(type) {
                if (!this.canRemoveSourceBuffer()) {
                    app_videojs.log.error("removeSourceBuffer is not supported!");
                    return;
                }
                app_pushQueue({
                    type: "mediaSource",
                    sourceUpdater: this,
                    action: app_actions.removeSourceBuffer(type),
                    name: "removeSourceBuffer"
                });
            }
            canRemoveSourceBuffer() {
                return !app_videojs.browser.IS_FIREFOX && app_window_default().MediaSource && app_window_default().MediaSource.prototype && typeof app_window_default().MediaSource.prototype.removeSourceBuffer === "function";
            }
            static canChangeType() {
                return app_window_default().SourceBuffer && app_window_default().SourceBuffer.prototype && typeof app_window_default().SourceBuffer.prototype.changeType === "function";
            }
            canChangeType() {
                return this.constructor.canChangeType();
            }
            changeType(type, codec) {
                if (!this.canChangeType()) {
                    app_videojs.log.error("changeType is not supported!");
                    return;
                }
                app_pushQueue({
                    type,
                    sourceUpdater: this,
                    action: app_actions.changeType(codec),
                    name: "changeType"
                });
            }
            addOrChangeSourceBuffers(codecs) {
                if (!codecs || typeof codecs !== "object" || Object.keys(codecs).length === 0) throw new Error("Cannot addOrChangeSourceBuffers to undefined codecs");
                Object.keys(codecs).forEach((type => {
                    const codec = codecs[type];
                    if (!this.hasCreatedSourceBuffers()) return this.addSourceBuffer(type, codec);
                    if (this.canChangeType()) this.changeType(type, codec);
                }));
            }
            appendBuffer(options, doneFn) {
                const {segmentInfo, type, bytes} = options;
                this.processedAppend_ = true;
                if (type === "audio" && this.videoBuffer && !this.videoAppendQueued_) {
                    this.delayedAudioAppendQueue_.push([ options, doneFn ]);
                    this.logger_(`delayed audio append of ${bytes.length} until video append`);
                    return;
                }
                const onError = doneFn;
                app_pushQueue({
                    type,
                    sourceUpdater: this,
                    action: app_actions.appendBuffer(bytes, segmentInfo || {
                        mediaIndex: -1
                    }, onError),
                    doneFn,
                    name: "appendBuffer"
                });
                if (type === "video") {
                    this.videoAppendQueued_ = true;
                    if (!this.delayedAudioAppendQueue_.length) return;
                    const queue = this.delayedAudioAppendQueue_.slice();
                    this.logger_(`queuing delayed audio ${queue.length} appendBuffers`);
                    this.delayedAudioAppendQueue_.length = 0;
                    queue.forEach((que => {
                        this.appendBuffer.apply(this, que);
                    }));
                }
            }
            audioBuffered() {
                if (!app_inSourceBuffers(this.mediaSource, this.audioBuffer)) return app_createTimeRanges();
                return this.audioBuffer.buffered ? this.audioBuffer.buffered : app_createTimeRanges();
            }
            videoBuffered() {
                if (!app_inSourceBuffers(this.mediaSource, this.videoBuffer)) return app_createTimeRanges();
                return this.videoBuffer.buffered ? this.videoBuffer.buffered : app_createTimeRanges();
            }
            buffered() {
                const video = app_inSourceBuffers(this.mediaSource, this.videoBuffer) ? this.videoBuffer : null;
                const audio = app_inSourceBuffers(this.mediaSource, this.audioBuffer) ? this.audioBuffer : null;
                if (audio && !video) return this.audioBuffered();
                if (video && !audio) return this.videoBuffered();
                return app_bufferIntersection(this.audioBuffered(), this.videoBuffered());
            }
            setDuration(duration, doneFn = app_noop) {
                app_pushQueue({
                    type: "mediaSource",
                    sourceUpdater: this,
                    action: app_actions.duration(duration),
                    name: "duration",
                    doneFn
                });
            }
            endOfStream(error = null, doneFn = app_noop) {
                if (typeof error !== "string") error = void 0;
                app_pushQueue({
                    type: "mediaSource",
                    sourceUpdater: this,
                    action: app_actions.endOfStream(error),
                    name: "endOfStream",
                    doneFn
                });
            }
            removeAudio(start, end, done = app_noop) {
                if (!this.audioBuffered().length || this.audioBuffered().end(0) === 0) {
                    done();
                    return;
                }
                app_pushQueue({
                    type: "audio",
                    sourceUpdater: this,
                    action: app_actions.remove(start, end),
                    doneFn: done,
                    name: "remove"
                });
            }
            removeVideo(start, end, done = app_noop) {
                if (!this.videoBuffered().length || this.videoBuffered().end(0) === 0) {
                    done();
                    return;
                }
                app_pushQueue({
                    type: "video",
                    sourceUpdater: this,
                    action: app_actions.remove(start, end),
                    doneFn: done,
                    name: "remove"
                });
            }
            updating() {
                if (app_updating("audio", this) || app_updating("video", this)) return true;
                return false;
            }
            audioTimestampOffset(offset) {
                if (typeof offset !== "undefined" && this.audioBuffer && this.audioTimestampOffset_ !== offset) {
                    app_pushQueue({
                        type: "audio",
                        sourceUpdater: this,
                        action: app_actions.timestampOffset(offset),
                        name: "timestampOffset"
                    });
                    this.audioTimestampOffset_ = offset;
                }
                return this.audioTimestampOffset_;
            }
            videoTimestampOffset(offset) {
                if (typeof offset !== "undefined" && this.videoBuffer && this.videoTimestampOffset_ !== offset) {
                    app_pushQueue({
                        type: "video",
                        sourceUpdater: this,
                        action: app_actions.timestampOffset(offset),
                        name: "timestampOffset"
                    });
                    this.videoTimestampOffset_ = offset;
                }
                return this.videoTimestampOffset_;
            }
            audioQueueCallback(callback) {
                if (!this.audioBuffer) return;
                app_pushQueue({
                    type: "audio",
                    sourceUpdater: this,
                    action: app_actions.callback(callback),
                    name: "callback"
                });
            }
            videoQueueCallback(callback) {
                if (!this.videoBuffer) return;
                app_pushQueue({
                    type: "video",
                    sourceUpdater: this,
                    action: app_actions.callback(callback),
                    name: "callback"
                });
            }
            dispose() {
                this.trigger("dispose");
                app_bufferTypes.forEach((type => {
                    this.abort(type);
                    if (this.canRemoveSourceBuffer()) this.removeSourceBuffer(type); else this[`${type}QueueCallback`]((() => app_cleanupBuffer(type, this)));
                }));
                this.videoAppendQueued_ = false;
                this.delayedAudioAppendQueue_.length = 0;
                if (this.sourceopenListener_) this.mediaSource.removeEventListener("sourceopen", this.sourceopenListener_);
                this.off();
            }
        }
        const app_uint8ToUtf8 = uintArray => decodeURIComponent(escape(String.fromCharCode.apply(null, uintArray)));
        const app_bufferToHexString = buffer => {
            const uInt8Buffer = new Uint8Array(buffer);
            return Array.from(uInt8Buffer).map((byte => byte.toString(16).padStart(2, "0"))).join("");
        };
        const app_VTT_LINE_TERMINATORS = new Uint8Array("\n\n".split("").map((char => char.charCodeAt(0))));
        class app_NoVttJsError extends Error {
            constructor() {
                super("Trying to parse received VTT cues, but there is no WebVTT. Make sure vtt.js is loaded.");
            }
        }
        class app_VTTSegmentLoader extends app_SegmentLoader {
            constructor(settings, options = {}) {
                super(settings, options);
                this.mediaSource_ = null;
                this.subtitlesTrack_ = null;
                this.featuresNativeTextTracks_ = settings.featuresNativeTextTracks;
                this.loadVttJs = settings.loadVttJs;
                this.shouldSaveSegmentTimingInfo_ = false;
            }
            buffered_() {
                if (!this.subtitlesTrack_ || !this.subtitlesTrack_.cues || !this.subtitlesTrack_.cues.length) return app_createTimeRanges();
                const cues = this.subtitlesTrack_.cues;
                const start = cues[0].startTime;
                const end = cues[cues.length - 1].startTime;
                return app_createTimeRanges([ [ start, end ] ]);
            }
            initSegmentForMap(map, set = false) {
                if (!map) return null;
                const id = app_initSegmentId(map);
                let storedMap = this.initSegments_[id];
                if (set && !storedMap && map.bytes) {
                    const combinedByteLength = app_VTT_LINE_TERMINATORS.byteLength + map.bytes.byteLength;
                    const combinedSegment = new Uint8Array(combinedByteLength);
                    combinedSegment.set(map.bytes);
                    combinedSegment.set(app_VTT_LINE_TERMINATORS, map.bytes.byteLength);
                    this.initSegments_[id] = storedMap = {
                        resolvedUri: map.resolvedUri,
                        byterange: map.byterange,
                        bytes: combinedSegment
                    };
                }
                return storedMap || map;
            }
            couldBeginLoading_() {
                return this.playlist_ && this.subtitlesTrack_ && !this.paused();
            }
            init_() {
                this.state = "READY";
                this.resetEverything();
                return this.monitorBuffer_();
            }
            track(track) {
                if (typeof track === "undefined") return this.subtitlesTrack_;
                this.subtitlesTrack_ = track;
                if (this.state === "INIT" && this.couldBeginLoading_()) this.init_();
                return this.subtitlesTrack_;
            }
            remove(start, end) {
                app_removeCuesFromTrack(start, end, this.subtitlesTrack_);
            }
            fillBuffer_() {
                const segmentInfo = this.chooseNextRequest_();
                if (!segmentInfo) return;
                if (this.syncController_.timestampOffsetForTimeline(segmentInfo.timeline) === null) {
                    const checkTimestampOffset = () => {
                        this.state = "READY";
                        if (!this.paused()) this.monitorBuffer_();
                    };
                    this.syncController_.one("timestampoffset", checkTimestampOffset);
                    this.state = "WAITING_ON_TIMELINE";
                    return;
                }
                this.loadSegment_(segmentInfo);
            }
            timestampOffsetForSegment_() {
                return null;
            }
            chooseNextRequest_() {
                return this.skipEmptySegments_(super.chooseNextRequest_());
            }
            skipEmptySegments_(segmentInfo) {
                while (segmentInfo && segmentInfo.segment.empty) {
                    if (segmentInfo.mediaIndex + 1 >= segmentInfo.playlist.segments.length) {
                        segmentInfo = null;
                        break;
                    }
                    segmentInfo = this.generateSegmentInfo_({
                        playlist: segmentInfo.playlist,
                        mediaIndex: segmentInfo.mediaIndex + 1,
                        startOfSegment: segmentInfo.startOfSegment + segmentInfo.duration,
                        isSyncRequest: segmentInfo.isSyncRequest
                    });
                }
                return segmentInfo;
            }
            stopForError(error) {
                this.error(error);
                this.state = "READY";
                this.pause();
                this.trigger("error");
            }
            segmentRequestFinished_(error, simpleSegment, result) {
                if (!this.subtitlesTrack_) {
                    this.state = "READY";
                    return;
                }
                this.saveTransferStats_(simpleSegment.stats);
                if (!this.pendingSegment_) {
                    this.state = "READY";
                    this.mediaRequestsAborted += 1;
                    return;
                }
                if (error) {
                    if (error.code === app_REQUEST_ERRORS.TIMEOUT) this.handleTimeout_();
                    if (error.code === app_REQUEST_ERRORS.ABORTED) this.mediaRequestsAborted += 1; else this.mediaRequestsErrored += 1;
                    this.stopForError(error);
                    return;
                }
                const segmentInfo = this.pendingSegment_;
                const isMp4WebVttSegmentWithCues = result.mp4VttCues && result.mp4VttCues.length;
                if (isMp4WebVttSegmentWithCues) segmentInfo.mp4VttCues = result.mp4VttCues;
                this.saveBandwidthRelatedStats_(segmentInfo.duration, simpleSegment.stats);
                if (simpleSegment.key) this.segmentKey(simpleSegment.key, true);
                this.state = "APPENDING";
                this.trigger("appending");
                const segment = segmentInfo.segment;
                if (segment.map) segment.map.bytes = simpleSegment.map.bytes;
                segmentInfo.bytes = simpleSegment.bytes;
                if (typeof app_window_default().WebVTT !== "function" && typeof this.loadVttJs === "function") {
                    this.state = "WAITING_ON_VTTJS";
                    this.loadVttJs().then((() => this.segmentRequestFinished_(error, simpleSegment, result)), (() => this.stopForError({
                        message: "Error loading vtt.js"
                    })));
                    return;
                }
                segment.requested = true;
                try {
                    this.parseVTTCues_(segmentInfo);
                } catch (e) {
                    this.stopForError({
                        message: e.message,
                        metadata: {
                            errorType: app_videojs.Error.StreamingVttParserError,
                            error: e
                        }
                    });
                    return;
                }
                if (!isMp4WebVttSegmentWithCues) this.updateTimeMapping_(segmentInfo, this.syncController_.timelines[segmentInfo.timeline], this.playlist_);
                if (segmentInfo.cues.length) segmentInfo.timingInfo = {
                    start: segmentInfo.cues[0].startTime,
                    end: segmentInfo.cues[segmentInfo.cues.length - 1].endTime
                }; else segmentInfo.timingInfo = {
                    start: segmentInfo.startOfSegment,
                    end: segmentInfo.startOfSegment + segmentInfo.duration
                };
                if (segmentInfo.isSyncRequest) {
                    this.trigger("syncinfoupdate");
                    this.pendingSegment_ = null;
                    this.state = "READY";
                    return;
                }
                segmentInfo.byteLength = segmentInfo.bytes.byteLength;
                this.mediaSecondsLoaded += segment.duration;
                segmentInfo.cues.forEach((cue => {
                    this.subtitlesTrack_.addCue(this.featuresNativeTextTracks_ ? new (app_window_default().VTTCue)(cue.startTime, cue.endTime, cue.text) : cue);
                }));
                app_removeDuplicateCuesFromTrack(this.subtitlesTrack_);
                this.handleAppendsDone_();
            }
            handleData_(simpleSegment, result) {
                const isVttType = simpleSegment && simpleSegment.type === "vtt";
                const isTextResult = result && result.type === "text";
                const isFmp4VttSegment = isVttType && isTextResult;
                if (isFmp4VttSegment) super.handleData_(simpleSegment, result);
            }
            updateTimingInfoEnd_() {}
            parseMp4VttCues_(segmentInfo) {
                const timestampOffset = this.sourceUpdater_.videoTimestampOffset() === null ? this.sourceUpdater_.audioTimestampOffset() : this.sourceUpdater_.videoTimestampOffset();
                segmentInfo.mp4VttCues.forEach((cue => {
                    const start = cue.start + timestampOffset;
                    const end = cue.end + timestampOffset;
                    const vttCue = new (app_window_default().VTTCue)(start, end, cue.cueText);
                    if (cue.settings) cue.settings.split(" ").forEach((cueSetting => {
                        const keyValString = cueSetting.split(":");
                        const key = keyValString[0];
                        const value = keyValString[1];
                        vttCue[key] = isNaN(value) ? value : Number(value);
                    }));
                    segmentInfo.cues.push(vttCue);
                }));
            }
            parseVTTCues_(segmentInfo) {
                let decoder;
                let decodeBytesToString = false;
                if (typeof app_window_default().WebVTT !== "function") throw new app_NoVttJsError;
                segmentInfo.cues = [];
                segmentInfo.timestampmap = {
                    MPEGTS: 0,
                    LOCAL: 0
                };
                if (segmentInfo.mp4VttCues) {
                    this.parseMp4VttCues_(segmentInfo);
                    return;
                }
                if (typeof app_window_default().TextDecoder === "function") decoder = new (app_window_default().TextDecoder)("utf8"); else {
                    decoder = app_window_default().WebVTT.StringDecoder();
                    decodeBytesToString = true;
                }
                const parser = new (app_window_default().WebVTT.Parser)(app_window_default(), app_window_default().vttjs, decoder);
                parser.oncue = segmentInfo.cues.push.bind(segmentInfo.cues);
                parser.ontimestampmap = map => {
                    segmentInfo.timestampmap = map;
                };
                parser.onparsingerror = error => {
                    app_videojs.log.warn("Error encountered when parsing cues: " + error.message);
                };
                if (segmentInfo.segment.map) {
                    let mapData = segmentInfo.segment.map.bytes;
                    if (decodeBytesToString) mapData = app_uint8ToUtf8(mapData);
                    parser.parse(mapData);
                }
                let segmentData = segmentInfo.bytes;
                if (decodeBytesToString) segmentData = app_uint8ToUtf8(segmentData);
                parser.parse(segmentData);
                parser.flush();
            }
            updateTimeMapping_(segmentInfo, mappingObj, playlist) {
                const segment = segmentInfo.segment;
                if (!mappingObj) return;
                if (!segmentInfo.cues.length) {
                    segment.empty = true;
                    return;
                }
                const {MPEGTS, LOCAL} = segmentInfo.timestampmap;
                const mpegTsInSeconds = MPEGTS / app_clock.ONE_SECOND_IN_TS;
                const diff = mpegTsInSeconds - LOCAL + mappingObj.mapping;
                segmentInfo.cues.forEach((cue => {
                    const duration = cue.endTime - cue.startTime;
                    const startTime = this.handleRollover_(cue.startTime + diff, mappingObj.time);
                    cue.startTime = Math.max(startTime, 0);
                    cue.endTime = Math.max(startTime + duration, 0);
                }));
                if (!playlist.syncInfo) {
                    const firstStart = segmentInfo.cues[0].startTime;
                    const lastStart = segmentInfo.cues[segmentInfo.cues.length - 1].startTime;
                    playlist.syncInfo = {
                        mediaSequence: playlist.mediaSequence + segmentInfo.mediaIndex,
                        time: Math.min(firstStart, lastStart - segment.duration)
                    };
                }
            }
            handleRollover_(value, reference) {
                if (reference === null) return value;
                let valueIn90khz = value * app_clock.ONE_SECOND_IN_TS;
                const referenceIn90khz = reference * app_clock.ONE_SECOND_IN_TS;
                let offset;
                if (referenceIn90khz < valueIn90khz) offset = -8589934592; else offset = 8589934592;
                while (Math.abs(valueIn90khz - referenceIn90khz) > 4294967296) valueIn90khz += offset;
                return valueIn90khz / app_clock.ONE_SECOND_IN_TS;
            }
        }
        const app_findAdCue = function(track, mediaTime) {
            const cues = track.cues;
            for (let i = 0; i < cues.length; i++) {
                const cue = cues[i];
                if (mediaTime >= cue.adStartTime && mediaTime <= cue.adEndTime) return cue;
            }
            return null;
        };
        const app_updateAdCues = function(media, track, offset = 0) {
            if (!media.segments) return;
            let mediaTime = offset;
            let cue;
            for (let i = 0; i < media.segments.length; i++) {
                const segment = media.segments[i];
                if (!cue) cue = app_findAdCue(track, mediaTime + segment.duration / 2);
                if (cue) {
                    if ("cueIn" in segment) {
                        cue.endTime = mediaTime;
                        cue.adEndTime = mediaTime;
                        mediaTime += segment.duration;
                        cue = null;
                        continue;
                    }
                    if (mediaTime < cue.endTime) {
                        mediaTime += segment.duration;
                        continue;
                    }
                    cue.endTime += segment.duration;
                } else {
                    if ("cueOut" in segment) {
                        cue = new (app_window_default().VTTCue)(mediaTime, mediaTime + segment.duration, segment.cueOut);
                        cue.adStartTime = mediaTime;
                        cue.adEndTime = mediaTime + parseFloat(segment.cueOut);
                        track.addCue(cue);
                    }
                    if ("cueOutCont" in segment) {
                        const [adOffset, adTotal] = segment.cueOutCont.split("/").map(parseFloat);
                        cue = new (app_window_default().VTTCue)(mediaTime, mediaTime + segment.duration, "");
                        cue.adStartTime = mediaTime - adOffset;
                        cue.adEndTime = cue.adStartTime + adTotal;
                        track.addCue(cue);
                    }
                }
                mediaTime += segment.duration;
            }
        };
        class app_SyncInfo {
            constructor({start, end, segmentIndex, partIndex = null, appended = false}) {
                this.start_ = start;
                this.end_ = end;
                this.segmentIndex_ = segmentIndex;
                this.partIndex_ = partIndex;
                this.appended_ = appended;
            }
            isInRange(targetTime) {
                return targetTime >= this.start && targetTime < this.end;
            }
            markAppended() {
                this.appended_ = true;
            }
            resetAppendedStatus() {
                this.appended_ = false;
            }
            get isAppended() {
                return this.appended_;
            }
            get start() {
                return this.start_;
            }
            get end() {
                return this.end_;
            }
            get segmentIndex() {
                return this.segmentIndex_;
            }
            get partIndex() {
                return this.partIndex_;
            }
        }
        class app_SyncInfoData {
            constructor(segmentSyncInfo, partsSyncInfo = []) {
                this.segmentSyncInfo_ = segmentSyncInfo;
                this.partsSyncInfo_ = partsSyncInfo;
            }
            get segmentSyncInfo() {
                return this.segmentSyncInfo_;
            }
            get partsSyncInfo() {
                return this.partsSyncInfo_;
            }
            get hasPartsSyncInfo() {
                return this.partsSyncInfo_.length > 0;
            }
            resetAppendStatus() {
                this.segmentSyncInfo_.resetAppendedStatus();
                this.partsSyncInfo_.forEach((partSyncInfo => partSyncInfo.resetAppendedStatus()));
            }
        }
        class app_MediaSequenceSync {
            constructor() {
                this.storage_ = new Map;
                this.diagnostics_ = "";
                this.isReliable_ = false;
                this.start_ = -1 / 0;
                this.end_ = 1 / 0;
            }
            get start() {
                return this.start_;
            }
            get end() {
                return this.end_;
            }
            get diagnostics() {
                return this.diagnostics_;
            }
            get isReliable() {
                return this.isReliable_;
            }
            resetAppendedStatus() {
                this.storage_.forEach((syncInfoData => syncInfoData.resetAppendStatus()));
            }
            update(playlist, currentTime) {
                const {mediaSequence, segments} = playlist;
                this.isReliable_ = this.isReliablePlaylist_(mediaSequence, segments);
                if (!this.isReliable_) return;
                return this.updateStorage_(segments, mediaSequence, this.calculateBaseTime_(mediaSequence, segments, currentTime));
            }
            getSyncInfoForTime(targetTime) {
                for (const {segmentSyncInfo, partsSyncInfo} of this.storage_.values()) if (!partsSyncInfo.length) {
                    if (segmentSyncInfo.isInRange(targetTime)) return segmentSyncInfo;
                } else for (const partSyncInfo of partsSyncInfo) if (partSyncInfo.isInRange(targetTime)) return partSyncInfo;
                return null;
            }
            getSyncInfoForMediaSequence(mediaSequence) {
                return this.storage_.get(mediaSequence);
            }
            updateStorage_(segments, startingMediaSequence, startingTime) {
                const newStorage = new Map;
                let newDiagnostics = "\n";
                let currentStart = startingTime;
                let currentMediaSequence = startingMediaSequence;
                this.start_ = currentStart;
                segments.forEach(((segment, segmentIndex) => {
                    const prevSyncInfoData = this.storage_.get(currentMediaSequence);
                    const segmentStart = currentStart;
                    const segmentEnd = segmentStart + segment.duration;
                    const segmentIsAppended = Boolean(prevSyncInfoData && prevSyncInfoData.segmentSyncInfo && prevSyncInfoData.segmentSyncInfo.isAppended);
                    const segmentSyncInfo = new app_SyncInfo({
                        start: segmentStart,
                        end: segmentEnd,
                        appended: segmentIsAppended,
                        segmentIndex
                    });
                    segment.syncInfo = segmentSyncInfo;
                    let currentPartStart = currentStart;
                    const partsSyncInfo = (segment.parts || []).map(((part, partIndex) => {
                        const partStart = currentPartStart;
                        const partEnd = currentPartStart + part.duration;
                        const partIsAppended = Boolean(prevSyncInfoData && prevSyncInfoData.partsSyncInfo && prevSyncInfoData.partsSyncInfo[partIndex] && prevSyncInfoData.partsSyncInfo[partIndex].isAppended);
                        const partSyncInfo = new app_SyncInfo({
                            start: partStart,
                            end: partEnd,
                            appended: partIsAppended,
                            segmentIndex,
                            partIndex
                        });
                        currentPartStart = partEnd;
                        newDiagnostics += `Media Sequence: ${currentMediaSequence}.${partIndex} | Range: ${partStart} --\x3e ${partEnd} | Appended: ${partIsAppended}\n`;
                        part.syncInfo = partSyncInfo;
                        return partSyncInfo;
                    }));
                    newStorage.set(currentMediaSequence, new app_SyncInfoData(segmentSyncInfo, partsSyncInfo));
                    newDiagnostics += `${app_compactSegmentUrlDescription(segment.resolvedUri)} | Media Sequence: ${currentMediaSequence} | Range: ${segmentStart} --\x3e ${segmentEnd} | Appended: ${segmentIsAppended}\n`;
                    currentMediaSequence++;
                    currentStart = segmentEnd;
                }));
                this.end_ = currentStart;
                this.storage_ = newStorage;
                this.diagnostics_ = newDiagnostics;
            }
            calculateBaseTime_(mediaSequence, segments, fallback) {
                if (!this.storage_.size) return 0;
                if (this.storage_.has(mediaSequence)) return this.storage_.get(mediaSequence).segmentSyncInfo.start;
                const minMediaSequenceFromStorage = Math.min(...this.storage_.keys());
                if (mediaSequence < minMediaSequenceFromStorage) {
                    const mediaSequenceDiff = minMediaSequenceFromStorage - mediaSequence;
                    let baseTime = this.storage_.get(minMediaSequenceFromStorage).segmentSyncInfo.start;
                    for (let i = 0; i < mediaSequenceDiff; i++) {
                        const segment = segments[i];
                        baseTime -= segment.duration;
                    }
                    return baseTime;
                }
                return fallback;
            }
            isReliablePlaylist_(mediaSequence, segments) {
                return mediaSequence !== void 0 && mediaSequence !== null && Array.isArray(segments) && segments.length;
            }
        }
        class app_DependantMediaSequenceSync extends app_MediaSequenceSync {
            constructor(parent) {
                super();
                this.parent_ = parent;
            }
            calculateBaseTime_(mediaSequence, segments, fallback) {
                if (!this.storage_.size) {
                    const info = this.parent_.getSyncInfoForMediaSequence(mediaSequence);
                    if (info) return info.segmentSyncInfo.start;
                    return 0;
                }
                return super.calculateBaseTime_(mediaSequence, segments, fallback);
            }
        }
        const app_MAX_MEDIA_SEQUENCE_DIFF_FOR_SYNC = 86400;
        const app_syncPointStrategies = [ {
            name: "VOD",
            run: (syncController, playlist, duration, currentTimeline, currentTime) => {
                if (duration !== 1 / 0) {
                    const syncPoint = {
                        time: 0,
                        segmentIndex: 0,
                        partIndex: null
                    };
                    return syncPoint;
                }
                return null;
            }
        }, {
            name: "MediaSequence",
            run: (syncController, playlist, duration, currentTimeline, currentTime, type) => {
                const mediaSequenceSync = syncController.getMediaSequenceSync(type);
                if (!mediaSequenceSync) return null;
                if (!mediaSequenceSync.isReliable) return null;
                const syncInfo = mediaSequenceSync.getSyncInfoForTime(currentTime);
                if (!syncInfo) return null;
                return {
                    time: syncInfo.start,
                    partIndex: syncInfo.partIndex,
                    segmentIndex: syncInfo.segmentIndex
                };
            }
        }, {
            name: "ProgramDateTime",
            run: (syncController, playlist, duration, currentTimeline, currentTime) => {
                if (!Object.keys(syncController.timelineToDatetimeMappings).length) return null;
                let syncPoint = null;
                let lastDistance = null;
                const partsAndSegments = app_getPartsAndSegments(playlist);
                currentTime = currentTime || 0;
                for (let i = 0; i < partsAndSegments.length; i++) {
                    const index = playlist.endList || currentTime === 0 ? i : partsAndSegments.length - (i + 1);
                    const partAndSegment = partsAndSegments[index];
                    const segment = partAndSegment.segment;
                    const datetimeMapping = syncController.timelineToDatetimeMappings[segment.timeline];
                    if (!datetimeMapping || !segment.dateTimeObject) continue;
                    const segmentTime = segment.dateTimeObject.getTime() / 1e3;
                    let start = segmentTime + datetimeMapping;
                    if (segment.parts && typeof partAndSegment.partIndex === "number") for (let z = 0; z < partAndSegment.partIndex; z++) start += segment.parts[z].duration;
                    const distance = Math.abs(currentTime - start);
                    if (lastDistance !== null && (distance === 0 || lastDistance < distance)) break;
                    lastDistance = distance;
                    syncPoint = {
                        time: start,
                        segmentIndex: partAndSegment.segmentIndex,
                        partIndex: partAndSegment.partIndex
                    };
                }
                return syncPoint;
            }
        }, {
            name: "Segment",
            run: (syncController, playlist, duration, currentTimeline, currentTime) => {
                let syncPoint = null;
                let lastDistance = null;
                currentTime = currentTime || 0;
                const partsAndSegments = app_getPartsAndSegments(playlist);
                for (let i = 0; i < partsAndSegments.length; i++) {
                    const index = playlist.endList || currentTime === 0 ? i : partsAndSegments.length - (i + 1);
                    const partAndSegment = partsAndSegments[index];
                    const segment = partAndSegment.segment;
                    const start = partAndSegment.part && partAndSegment.part.start || segment && segment.start;
                    if (segment.timeline === currentTimeline && typeof start !== "undefined") {
                        const distance = Math.abs(currentTime - start);
                        if (lastDistance !== null && lastDistance < distance) break;
                        if (!syncPoint || lastDistance === null || lastDistance >= distance) {
                            lastDistance = distance;
                            syncPoint = {
                                time: start,
                                segmentIndex: partAndSegment.segmentIndex,
                                partIndex: partAndSegment.partIndex
                            };
                        }
                    }
                }
                return syncPoint;
            }
        }, {
            name: "Discontinuity",
            run: (syncController, playlist, duration, currentTimeline, currentTime) => {
                let syncPoint = null;
                currentTime = currentTime || 0;
                if (playlist.discontinuityStarts && playlist.discontinuityStarts.length) {
                    let lastDistance = null;
                    for (let i = 0; i < playlist.discontinuityStarts.length; i++) {
                        const segmentIndex = playlist.discontinuityStarts[i];
                        const discontinuity = playlist.discontinuitySequence + i + 1;
                        const discontinuitySync = syncController.discontinuities[discontinuity];
                        if (discontinuitySync) {
                            const distance = Math.abs(currentTime - discontinuitySync.time);
                            if (lastDistance !== null && lastDistance < distance) break;
                            if (!syncPoint || lastDistance === null || lastDistance >= distance) {
                                lastDistance = distance;
                                syncPoint = {
                                    time: discontinuitySync.time,
                                    segmentIndex,
                                    partIndex: null
                                };
                            }
                        }
                    }
                }
                return syncPoint;
            }
        }, {
            name: "Playlist",
            run: (syncController, playlist, duration, currentTimeline, currentTime) => {
                if (playlist.syncInfo) {
                    const syncPoint = {
                        time: playlist.syncInfo.time,
                        segmentIndex: playlist.syncInfo.mediaSequence - playlist.mediaSequence,
                        partIndex: null
                    };
                    return syncPoint;
                }
                return null;
            }
        } ];
        class app_SyncController extends app_videojs.EventTarget {
            constructor(options = {}) {
                super();
                this.timelines = [];
                this.discontinuities = [];
                this.timelineToDatetimeMappings = {};
                const main = new app_MediaSequenceSync;
                const audio = new app_DependantMediaSequenceSync(main);
                const vtt = new app_DependantMediaSequenceSync(main);
                this.mediaSequenceStorage_ = {
                    main,
                    audio,
                    vtt
                };
                this.logger_ = app_logger("SyncController");
            }
            getMediaSequenceSync(loaderType) {
                return this.mediaSequenceStorage_[loaderType] || null;
            }
            getSyncPoint(playlist, duration, currentTimeline, currentTime, type) {
                if (duration !== 1 / 0) {
                    const vodSyncPointStrategy = app_syncPointStrategies.find((({name}) => name === "VOD"));
                    return vodSyncPointStrategy.run(this, playlist, duration);
                }
                const syncPoints = this.runStrategies_(playlist, duration, currentTimeline, currentTime, type);
                if (!syncPoints.length) return null;
                for (const syncPointInfo of syncPoints) {
                    const {syncPoint, strategy} = syncPointInfo;
                    const {segmentIndex, time} = syncPoint;
                    if (segmentIndex < 0) continue;
                    const selectedSegment = playlist.segments[segmentIndex];
                    const start = time;
                    const end = start + selectedSegment.duration;
                    this.logger_(`Strategy: ${strategy}. Current time: ${currentTime}. selected segment: ${segmentIndex}. Time: [${start} -> ${end}]}`);
                    if (currentTime >= start && currentTime < end) {
                        this.logger_("Found sync point with exact match: ", syncPoint);
                        return syncPoint;
                    }
                }
                return this.selectSyncPoint_(syncPoints, {
                    key: "time",
                    value: currentTime
                });
            }
            getExpiredTime(playlist, duration) {
                if (!playlist || !playlist.segments) return null;
                const syncPoints = this.runStrategies_(playlist, duration, playlist.discontinuitySequence, 0);
                if (!syncPoints.length) return null;
                const syncPoint = this.selectSyncPoint_(syncPoints, {
                    key: "segmentIndex",
                    value: 0
                });
                if (syncPoint.segmentIndex > 0) syncPoint.time *= -1;
                return Math.abs(syncPoint.time + app_sumDurations({
                    defaultDuration: playlist.targetDuration,
                    durationList: playlist.segments,
                    startIndex: syncPoint.segmentIndex,
                    endIndex: 0
                }));
            }
            runStrategies_(playlist, duration, currentTimeline, currentTime, type) {
                const syncPoints = [];
                for (let i = 0; i < app_syncPointStrategies.length; i++) {
                    const strategy = app_syncPointStrategies[i];
                    const syncPoint = strategy.run(this, playlist, duration, currentTimeline, currentTime, type);
                    if (syncPoint) {
                        syncPoint.strategy = strategy.name;
                        syncPoints.push({
                            strategy: strategy.name,
                            syncPoint
                        });
                    }
                }
                return syncPoints;
            }
            selectSyncPoint_(syncPoints, target) {
                let bestSyncPoint = syncPoints[0].syncPoint;
                let bestDistance = Math.abs(syncPoints[0].syncPoint[target.key] - target.value);
                let bestStrategy = syncPoints[0].strategy;
                for (let i = 1; i < syncPoints.length; i++) {
                    const newDistance = Math.abs(syncPoints[i].syncPoint[target.key] - target.value);
                    if (newDistance < bestDistance) {
                        bestDistance = newDistance;
                        bestSyncPoint = syncPoints[i].syncPoint;
                        bestStrategy = syncPoints[i].strategy;
                    }
                }
                this.logger_(`syncPoint for [${target.key}: ${target.value}] chosen with strategy` + ` [${bestStrategy}]: [time:${bestSyncPoint.time},` + ` segmentIndex:${bestSyncPoint.segmentIndex}` + (typeof bestSyncPoint.partIndex === "number" ? `,partIndex:${bestSyncPoint.partIndex}` : "") + "]");
                return bestSyncPoint;
            }
            saveExpiredSegmentInfo(oldPlaylist, newPlaylist) {
                const mediaSequenceDiff = newPlaylist.mediaSequence - oldPlaylist.mediaSequence;
                if (mediaSequenceDiff > app_MAX_MEDIA_SEQUENCE_DIFF_FOR_SYNC) {
                    app_videojs.log.warn(`Not saving expired segment info. Media sequence gap ${mediaSequenceDiff} is too large.`);
                    return;
                }
                for (let i = mediaSequenceDiff - 1; i >= 0; i--) {
                    const lastRemovedSegment = oldPlaylist.segments[i];
                    if (lastRemovedSegment && typeof lastRemovedSegment.start !== "undefined") {
                        newPlaylist.syncInfo = {
                            mediaSequence: oldPlaylist.mediaSequence + i,
                            time: lastRemovedSegment.start
                        };
                        this.logger_(`playlist refresh sync: [time:${newPlaylist.syncInfo.time},` + ` mediaSequence: ${newPlaylist.syncInfo.mediaSequence}]`);
                        this.trigger("syncinfoupdate");
                        break;
                    }
                }
            }
            setDateTimeMappingForStart(playlist) {
                this.timelineToDatetimeMappings = {};
                if (playlist.segments && playlist.segments.length && playlist.segments[0].dateTimeObject) {
                    const firstSegment = playlist.segments[0];
                    const playlistTimestamp = firstSegment.dateTimeObject.getTime() / 1e3;
                    this.timelineToDatetimeMappings[firstSegment.timeline] = -playlistTimestamp;
                }
            }
            saveSegmentTimingInfo({segmentInfo, shouldSaveTimelineMapping}) {
                const didCalculateSegmentTimeMapping = this.calculateSegmentTimeMapping_(segmentInfo, segmentInfo.timingInfo, shouldSaveTimelineMapping);
                const segment = segmentInfo.segment;
                if (didCalculateSegmentTimeMapping) {
                    this.saveDiscontinuitySyncInfo_(segmentInfo);
                    if (!segmentInfo.playlist.syncInfo) segmentInfo.playlist.syncInfo = {
                        mediaSequence: segmentInfo.playlist.mediaSequence + segmentInfo.mediaIndex,
                        time: segment.start
                    };
                }
                const dateTime = segment.dateTimeObject;
                if (segment.discontinuity && shouldSaveTimelineMapping && dateTime) this.timelineToDatetimeMappings[segment.timeline] = -dateTime.getTime() / 1e3;
            }
            timestampOffsetForTimeline(timeline) {
                if (typeof this.timelines[timeline] === "undefined") return null;
                return this.timelines[timeline].time;
            }
            mappingForTimeline(timeline) {
                if (typeof this.timelines[timeline] === "undefined") return null;
                return this.timelines[timeline].mapping;
            }
            calculateSegmentTimeMapping_(segmentInfo, timingInfo, shouldSaveTimelineMapping) {
                const segment = segmentInfo.segment;
                const part = segmentInfo.part;
                let mappingObj = this.timelines[segmentInfo.timeline];
                let start;
                let end;
                if (typeof segmentInfo.timestampOffset === "number") {
                    mappingObj = {
                        time: segmentInfo.startOfSegment,
                        mapping: segmentInfo.startOfSegment - timingInfo.start
                    };
                    if (shouldSaveTimelineMapping) {
                        this.timelines[segmentInfo.timeline] = mappingObj;
                        this.trigger("timestampoffset");
                        this.logger_(`time mapping for timeline ${segmentInfo.timeline}: ` + `[time: ${mappingObj.time}] [mapping: ${mappingObj.mapping}]`);
                    }
                    start = segmentInfo.startOfSegment;
                    end = timingInfo.end + mappingObj.mapping;
                } else if (mappingObj) {
                    start = timingInfo.start + mappingObj.mapping;
                    end = timingInfo.end + mappingObj.mapping;
                } else return false;
                if (part) {
                    part.start = start;
                    part.end = end;
                }
                if (!segment.start || start < segment.start) segment.start = start;
                segment.end = end;
                return true;
            }
            saveDiscontinuitySyncInfo_(segmentInfo) {
                const playlist = segmentInfo.playlist;
                const segment = segmentInfo.segment;
                if (segment.discontinuity) this.discontinuities[segment.timeline] = {
                    time: segment.start,
                    accuracy: 0
                }; else if (playlist.discontinuityStarts && playlist.discontinuityStarts.length) for (let i = 0; i < playlist.discontinuityStarts.length; i++) {
                    const segmentIndex = playlist.discontinuityStarts[i];
                    const discontinuity = playlist.discontinuitySequence + i + 1;
                    const mediaIndexDiff = segmentIndex - segmentInfo.mediaIndex;
                    const accuracy = Math.abs(mediaIndexDiff);
                    if (!this.discontinuities[discontinuity] || this.discontinuities[discontinuity].accuracy > accuracy) {
                        let time;
                        if (mediaIndexDiff < 0) time = segment.start - app_sumDurations({
                            defaultDuration: playlist.targetDuration,
                            durationList: playlist.segments,
                            startIndex: segmentInfo.mediaIndex,
                            endIndex: segmentIndex
                        }); else time = segment.end + app_sumDurations({
                            defaultDuration: playlist.targetDuration,
                            durationList: playlist.segments,
                            startIndex: segmentInfo.mediaIndex + 1,
                            endIndex: segmentIndex
                        });
                        this.discontinuities[discontinuity] = {
                            time,
                            accuracy
                        };
                    }
                }
            }
            dispose() {
                this.trigger("dispose");
                this.off();
            }
        }
        class app_TimelineChangeController extends app_videojs.EventTarget {
            constructor() {
                super();
                this.pendingTimelineChanges_ = {};
                this.lastTimelineChanges_ = {};
            }
            clearPendingTimelineChange(type) {
                this.pendingTimelineChanges_[type] = null;
                this.trigger("pendingtimelinechange");
            }
            pendingTimelineChange({type, from, to}) {
                if (typeof from === "number" && typeof to === "number") {
                    this.pendingTimelineChanges_[type] = {
                        type,
                        from,
                        to
                    };
                    this.trigger("pendingtimelinechange");
                }
                return this.pendingTimelineChanges_[type];
            }
            lastTimelineChange({type, from, to}) {
                if (typeof from === "number" && typeof to === "number") {
                    this.lastTimelineChanges_[type] = {
                        type,
                        from,
                        to
                    };
                    delete this.pendingTimelineChanges_[type];
                    const metadata = {
                        timelineChangeInfo: {
                            from,
                            to
                        }
                    };
                    this.trigger({
                        type: "timelinechange",
                        metadata
                    });
                }
                return this.lastTimelineChanges_[type];
            }
            dispose() {
                this.trigger("dispose");
                this.pendingTimelineChanges_ = {};
                this.lastTimelineChanges_ = {};
                this.off();
            }
        }
        const app_workerCode = app_transform(app_getWorkerString((function() {
            var Stream = function() {
                function Stream() {
                    this.listeners = {};
                }
                var _proto = Stream.prototype;
                _proto.on = function on(type, listener) {
                    if (!this.listeners[type]) this.listeners[type] = [];
                    this.listeners[type].push(listener);
                };
                _proto.off = function off(type, listener) {
                    if (!this.listeners[type]) return false;
                    var index = this.listeners[type].indexOf(listener);
                    this.listeners[type] = this.listeners[type].slice(0);
                    this.listeners[type].splice(index, 1);
                    return index > -1;
                };
                _proto.trigger = function trigger(type) {
                    var callbacks = this.listeners[type];
                    if (!callbacks) return;
                    if (arguments.length === 2) {
                        var length = callbacks.length;
                        for (var i = 0; i < length; ++i) callbacks[i].call(this, arguments[1]);
                    } else {
                        var args = Array.prototype.slice.call(arguments, 1);
                        var _length = callbacks.length;
                        for (var _i = 0; _i < _length; ++_i) callbacks[_i].apply(this, args);
                    }
                };
                _proto.dispose = function dispose() {
                    this.listeners = {};
                };
                _proto.pipe = function pipe(destination) {
                    this.on("data", (function(data) {
                        destination.push(data);
                    }));
                };
                return Stream;
            }();
            /*! @name pkcs7 @version 1.0.4 @license Apache-2.0 */            function unpad(padded) {
                return padded.subarray(0, padded.byteLength - padded[padded.byteLength - 1]);
            }
            /*! @name aes-decrypter @version 4.0.2 @license Apache-2.0 */            const precompute = function() {
                const tables = [ [ [], [], [], [], [] ], [ [], [], [], [], [] ] ];
                const encTable = tables[0];
                const decTable = tables[1];
                const sbox = encTable[4];
                const sboxInv = decTable[4];
                let i;
                let x;
                let xInv;
                const d = [];
                const th = [];
                let x2;
                let x4;
                let x8;
                let s;
                let tEnc;
                let tDec;
                for (i = 0; i < 256; i++) th[(d[i] = i << 1 ^ (i >> 7) * 283) ^ i] = i;
                for (x = xInv = 0; !sbox[x]; x ^= x2 || 1, xInv = th[xInv] || 1) {
                    s = xInv ^ xInv << 1 ^ xInv << 2 ^ xInv << 3 ^ xInv << 4;
                    s = s >> 8 ^ s & 255 ^ 99;
                    sbox[x] = s;
                    sboxInv[s] = x;
                    x8 = d[x4 = d[x2 = d[x]]];
                    tDec = x8 * 16843009 ^ x4 * 65537 ^ x2 * 257 ^ x * 16843008;
                    tEnc = d[s] * 257 ^ s * 16843008;
                    for (i = 0; i < 4; i++) {
                        encTable[i][x] = tEnc = tEnc << 24 ^ tEnc >>> 8;
                        decTable[i][s] = tDec = tDec << 24 ^ tDec >>> 8;
                    }
                }
                for (i = 0; i < 5; i++) {
                    encTable[i] = encTable[i].slice(0);
                    decTable[i] = decTable[i].slice(0);
                }
                return tables;
            };
            let aesTables = null;
            class AES {
                constructor(key) {
                    if (!aesTables) aesTables = precompute();
                    this._tables = [ [ aesTables[0][0].slice(), aesTables[0][1].slice(), aesTables[0][2].slice(), aesTables[0][3].slice(), aesTables[0][4].slice() ], [ aesTables[1][0].slice(), aesTables[1][1].slice(), aesTables[1][2].slice(), aesTables[1][3].slice(), aesTables[1][4].slice() ] ];
                    let i;
                    let j;
                    let tmp;
                    const sbox = this._tables[0][4];
                    const decTable = this._tables[1];
                    const keyLen = key.length;
                    let rcon = 1;
                    if (keyLen !== 4 && keyLen !== 6 && keyLen !== 8) throw new Error("Invalid aes key size");
                    const encKey = key.slice(0);
                    const decKey = [];
                    this._key = [ encKey, decKey ];
                    for (i = keyLen; i < 4 * keyLen + 28; i++) {
                        tmp = encKey[i - 1];
                        if (i % keyLen === 0 || keyLen === 8 && i % keyLen === 4) {
                            tmp = sbox[tmp >>> 24] << 24 ^ sbox[tmp >> 16 & 255] << 16 ^ sbox[tmp >> 8 & 255] << 8 ^ sbox[tmp & 255];
                            if (i % keyLen === 0) {
                                tmp = tmp << 8 ^ tmp >>> 24 ^ rcon << 24;
                                rcon = rcon << 1 ^ (rcon >> 7) * 283;
                            }
                        }
                        encKey[i] = encKey[i - keyLen] ^ tmp;
                    }
                    for (j = 0; i; j++, i--) {
                        tmp = encKey[j & 3 ? i : i - 4];
                        if (i <= 4 || j < 4) decKey[j] = tmp; else decKey[j] = decTable[0][sbox[tmp >>> 24]] ^ decTable[1][sbox[tmp >> 16 & 255]] ^ decTable[2][sbox[tmp >> 8 & 255]] ^ decTable[3][sbox[tmp & 255]];
                    }
                }
                decrypt(encrypted0, encrypted1, encrypted2, encrypted3, out, offset) {
                    const key = this._key[1];
                    let a = encrypted0 ^ key[0];
                    let b = encrypted3 ^ key[1];
                    let c = encrypted2 ^ key[2];
                    let d = encrypted1 ^ key[3];
                    let a2;
                    let b2;
                    let c2;
                    const nInnerRounds = key.length / 4 - 2;
                    let i;
                    let kIndex = 4;
                    const table = this._tables[1];
                    const table0 = table[0];
                    const table1 = table[1];
                    const table2 = table[2];
                    const table3 = table[3];
                    const sbox = table[4];
                    for (i = 0; i < nInnerRounds; i++) {
                        a2 = table0[a >>> 24] ^ table1[b >> 16 & 255] ^ table2[c >> 8 & 255] ^ table3[d & 255] ^ key[kIndex];
                        b2 = table0[b >>> 24] ^ table1[c >> 16 & 255] ^ table2[d >> 8 & 255] ^ table3[a & 255] ^ key[kIndex + 1];
                        c2 = table0[c >>> 24] ^ table1[d >> 16 & 255] ^ table2[a >> 8 & 255] ^ table3[b & 255] ^ key[kIndex + 2];
                        d = table0[d >>> 24] ^ table1[a >> 16 & 255] ^ table2[b >> 8 & 255] ^ table3[c & 255] ^ key[kIndex + 3];
                        kIndex += 4;
                        a = a2;
                        b = b2;
                        c = c2;
                    }
                    for (i = 0; i < 4; i++) {
                        out[(3 & -i) + offset] = sbox[a >>> 24] << 24 ^ sbox[b >> 16 & 255] << 16 ^ sbox[c >> 8 & 255] << 8 ^ sbox[d & 255] ^ key[kIndex++];
                        a2 = a;
                        a = b;
                        b = c;
                        c = d;
                        d = a2;
                    }
                }
            }
            class AsyncStream extends Stream {
                constructor() {
                    super(Stream);
                    this.jobs = [];
                    this.delay = 1;
                    this.timeout_ = null;
                }
                processJob_() {
                    this.jobs.shift()();
                    if (this.jobs.length) this.timeout_ = setTimeout(this.processJob_.bind(this), this.delay); else this.timeout_ = null;
                }
                push(job) {
                    this.jobs.push(job);
                    if (!this.timeout_) this.timeout_ = setTimeout(this.processJob_.bind(this), this.delay);
                }
            }
            const ntoh = function(word) {
                return word << 24 | (word & 65280) << 8 | (word & 16711680) >> 8 | word >>> 24;
            };
            const decrypt = function(encrypted, key, initVector) {
                const encrypted32 = new Int32Array(encrypted.buffer, encrypted.byteOffset, encrypted.byteLength >> 2);
                const decipher = new AES(Array.prototype.slice.call(key));
                const decrypted = new Uint8Array(encrypted.byteLength);
                const decrypted32 = new Int32Array(decrypted.buffer);
                let init0;
                let init1;
                let init2;
                let init3;
                let encrypted0;
                let encrypted1;
                let encrypted2;
                let encrypted3;
                let wordIx;
                init0 = initVector[0];
                init1 = initVector[1];
                init2 = initVector[2];
                init3 = initVector[3];
                for (wordIx = 0; wordIx < encrypted32.length; wordIx += 4) {
                    encrypted0 = ntoh(encrypted32[wordIx]);
                    encrypted1 = ntoh(encrypted32[wordIx + 1]);
                    encrypted2 = ntoh(encrypted32[wordIx + 2]);
                    encrypted3 = ntoh(encrypted32[wordIx + 3]);
                    decipher.decrypt(encrypted0, encrypted1, encrypted2, encrypted3, decrypted32, wordIx);
                    decrypted32[wordIx] = ntoh(decrypted32[wordIx] ^ init0);
                    decrypted32[wordIx + 1] = ntoh(decrypted32[wordIx + 1] ^ init1);
                    decrypted32[wordIx + 2] = ntoh(decrypted32[wordIx + 2] ^ init2);
                    decrypted32[wordIx + 3] = ntoh(decrypted32[wordIx + 3] ^ init3);
                    init0 = encrypted0;
                    init1 = encrypted1;
                    init2 = encrypted2;
                    init3 = encrypted3;
                }
                return decrypted;
            };
            class Decrypter {
                constructor(encrypted, key, initVector, done) {
                    const step = Decrypter.STEP;
                    const encrypted32 = new Int32Array(encrypted.buffer);
                    const decrypted = new Uint8Array(encrypted.byteLength);
                    let i = 0;
                    this.asyncStream_ = new AsyncStream;
                    this.asyncStream_.push(this.decryptChunk_(encrypted32.subarray(i, i + step), key, initVector, decrypted));
                    for (i = step; i < encrypted32.length; i += step) {
                        initVector = new Uint32Array([ ntoh(encrypted32[i - 4]), ntoh(encrypted32[i - 3]), ntoh(encrypted32[i - 2]), ntoh(encrypted32[i - 1]) ]);
                        this.asyncStream_.push(this.decryptChunk_(encrypted32.subarray(i, i + step), key, initVector, decrypted));
                    }
                    this.asyncStream_.push((function() {
                        done(null, unpad(decrypted));
                    }));
                }
                static get STEP() {
                    return 32e3;
                }
                decryptChunk_(encrypted, key, initVector, decrypted) {
                    return function() {
                        const bytes = decrypt(encrypted, key, initVector);
                        decrypted.set(bytes, encrypted.byteOffset);
                    };
                }
            }
            var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof __webpack_require__.g !== "undefined" ? __webpack_require__.g : typeof self !== "undefined" ? self : {};
            var win;
            if (typeof window !== "undefined") win = window; else if (typeof commonjsGlobal !== "undefined") win = commonjsGlobal; else if (typeof self !== "undefined") win = self; else win = {};
            var window_1 = win;
            var isArrayBufferView = function isArrayBufferView(obj) {
                if (ArrayBuffer.isView === "function") return ArrayBuffer.isView(obj);
                return obj && obj.buffer instanceof ArrayBuffer;
            };
            var BigInt = window_1.BigInt || Number;
            [ BigInt("0x1"), BigInt("0x100"), BigInt("0x10000"), BigInt("0x1000000"), BigInt("0x100000000"), BigInt("0x10000000000"), BigInt("0x1000000000000"), BigInt("0x100000000000000"), BigInt("0x10000000000000000") ];
            (function() {
                var a = new Uint16Array([ 65484 ]);
                var b = new Uint8Array(a.buffer, a.byteOffset, a.byteLength);
                if (b[0] === 255) return "big";
                if (b[0] === 204) return "little";
                return "unknown";
            })();
            const createTransferableMessage = function(message) {
                const transferable = {};
                Object.keys(message).forEach((key => {
                    const value = message[key];
                    if (isArrayBufferView(value)) transferable[key] = {
                        bytes: value.buffer,
                        byteOffset: value.byteOffset,
                        byteLength: value.byteLength
                    }; else transferable[key] = value;
                }));
                return transferable;
            };
            self.onmessage = function(event) {
                const data = event.data;
                const encrypted = new Uint8Array(data.encrypted.bytes, data.encrypted.byteOffset, data.encrypted.byteLength);
                const key = new Uint32Array(data.key.bytes, data.key.byteOffset, data.key.byteLength / 4);
                const iv = new Uint32Array(data.iv.bytes, data.iv.byteOffset, data.iv.byteLength / 4);
                new Decrypter(encrypted, key, iv, (function(err, bytes) {
                    self.postMessage(createTransferableMessage({
                        source: data.source,
                        decrypted: bytes
                    }), [ bytes.buffer ]);
                }));
            };
        })));
        var app_Decrypter = app_factory(app_workerCode);
        const app_audioTrackKind_ = properties => {
            let kind = properties.default ? "main" : "alternative";
            if (properties.characteristics && properties.characteristics.indexOf("public.accessibility.describes-video") >= 0) kind = "main-desc";
            return kind;
        };
        const app_stopLoaders = (segmentLoader, mediaType) => {
            segmentLoader.abort();
            segmentLoader.pause();
            if (mediaType && mediaType.activePlaylistLoader) {
                mediaType.activePlaylistLoader.pause();
                mediaType.activePlaylistLoader = null;
            }
        };
        const app_startLoaders = (playlistLoader, mediaType) => {
            mediaType.activePlaylistLoader = playlistLoader;
            playlistLoader.load();
        };
        const app_onGroupChanged = (type, settings) => () => {
            const {segmentLoaders: {[type]: segmentLoader, main: mainSegmentLoader}, mediaTypes: {[type]: mediaType}} = settings;
            const activeTrack = mediaType.activeTrack();
            const activeGroup = mediaType.getActiveGroup();
            const previousActiveLoader = mediaType.activePlaylistLoader;
            const lastGroup = mediaType.lastGroup_;
            if (activeGroup && lastGroup && activeGroup.id === lastGroup.id) return;
            mediaType.lastGroup_ = activeGroup;
            mediaType.lastTrack_ = activeTrack;
            app_stopLoaders(segmentLoader, mediaType);
            if (!activeGroup || activeGroup.isMainPlaylist) return;
            if (!activeGroup.playlistLoader) {
                if (previousActiveLoader) mainSegmentLoader.resetEverything();
                return;
            }
            segmentLoader.resyncLoader();
            app_startLoaders(activeGroup.playlistLoader, mediaType);
        };
        const app_onGroupChanging = (type, settings) => () => {
            const {segmentLoaders: {[type]: segmentLoader}, mediaTypes: {[type]: mediaType}} = settings;
            mediaType.lastGroup_ = null;
            segmentLoader.abort();
            segmentLoader.pause();
        };
        const app_onTrackChanged = (type, settings) => () => {
            const {mainPlaylistLoader, segmentLoaders: {[type]: segmentLoader, main: mainSegmentLoader}, mediaTypes: {[type]: mediaType}} = settings;
            const activeTrack = mediaType.activeTrack();
            const activeGroup = mediaType.getActiveGroup();
            const previousActiveLoader = mediaType.activePlaylistLoader;
            const lastTrack = mediaType.lastTrack_;
            if (lastTrack && activeTrack && lastTrack.id === activeTrack.id) return;
            mediaType.lastGroup_ = activeGroup;
            mediaType.lastTrack_ = activeTrack;
            app_stopLoaders(segmentLoader, mediaType);
            if (!activeGroup) return;
            if (activeGroup.isMainPlaylist) {
                if (!activeTrack || !lastTrack || activeTrack.id === lastTrack.id) return;
                const pc = settings.vhs.playlistController_;
                const newPlaylist = pc.selectPlaylist();
                if (pc.media() === newPlaylist) return;
                mediaType.logger_(`track change. Switching main audio from ${lastTrack.id} to ${activeTrack.id}`);
                mainPlaylistLoader.pause();
                mainSegmentLoader.resetEverything();
                pc.fastQualityChange_(newPlaylist);
                return;
            }
            if (type === "AUDIO") {
                if (!activeGroup.playlistLoader) {
                    mainSegmentLoader.setAudio(true);
                    mainSegmentLoader.resetEverything();
                    return;
                }
                segmentLoader.setAudio(true);
                mainSegmentLoader.setAudio(false);
            }
            if (previousActiveLoader === activeGroup.playlistLoader) {
                app_startLoaders(activeGroup.playlistLoader, mediaType);
                return;
            }
            if (segmentLoader.track) segmentLoader.track(activeTrack);
            segmentLoader.resetEverything();
            app_startLoaders(activeGroup.playlistLoader, mediaType);
        };
        const app_onError = {
            AUDIO: (type, settings) => () => {
                const {mediaTypes: {[type]: mediaType}, excludePlaylist} = settings;
                const activeTrack = mediaType.activeTrack();
                const activeGroup = mediaType.activeGroup();
                const id = (activeGroup.filter((group => group.default))[0] || activeGroup[0]).id;
                const defaultTrack = mediaType.tracks[id];
                if (activeTrack === defaultTrack) {
                    excludePlaylist({
                        error: {
                            message: "Problem encountered loading the default audio track."
                        }
                    });
                    return;
                }
                app_videojs.log.warn("Problem encountered loading the alternate audio track." + "Switching back to default.");
                for (const trackId in mediaType.tracks) mediaType.tracks[trackId].enabled = mediaType.tracks[trackId] === defaultTrack;
                mediaType.onTrackChanged();
            },
            SUBTITLES: (type, settings) => () => {
                const {mediaTypes: {[type]: mediaType}} = settings;
                app_videojs.log.warn("Problem encountered loading the subtitle track." + "Disabling subtitle track.");
                const track = mediaType.activeTrack();
                if (track) track.mode = "disabled";
                mediaType.onTrackChanged();
            }
        };
        const app_setupListeners = {
            AUDIO: (type, playlistLoader, settings) => {
                if (!playlistLoader) return;
                const {tech, requestOptions, segmentLoaders: {[type]: segmentLoader}} = settings;
                playlistLoader.on("loadedmetadata", (() => {
                    const media = playlistLoader.media();
                    segmentLoader.playlist(media, requestOptions);
                    if (!tech.paused() || media.endList && tech.preload() !== "none") segmentLoader.load();
                }));
                playlistLoader.on("loadedplaylist", (() => {
                    segmentLoader.playlist(playlistLoader.media(), requestOptions);
                    if (!tech.paused()) segmentLoader.load();
                }));
                playlistLoader.on("error", app_onError[type](type, settings));
            },
            SUBTITLES: (type, playlistLoader, settings) => {
                const {tech, requestOptions, segmentLoaders: {[type]: segmentLoader}, mediaTypes: {[type]: mediaType}} = settings;
                playlistLoader.on("loadedmetadata", (() => {
                    const media = playlistLoader.media();
                    segmentLoader.playlist(media, requestOptions);
                    segmentLoader.track(mediaType.activeTrack());
                    if (!tech.paused() || media.endList && tech.preload() !== "none") segmentLoader.load();
                }));
                playlistLoader.on("loadedplaylist", (() => {
                    segmentLoader.playlist(playlistLoader.media(), requestOptions);
                    if (!tech.paused()) segmentLoader.load();
                }));
                playlistLoader.on("error", app_onError[type](type, settings));
            }
        };
        const app_initialize = {
            AUDIO: (type, settings) => {
                const {vhs, sourceType, segmentLoaders: {[type]: segmentLoader}, requestOptions, main: {mediaGroups}, mediaTypes: {[type]: {groups, tracks, logger_}}, mainPlaylistLoader} = settings;
                const audioOnlyMain = app_isAudioOnly(mainPlaylistLoader.main);
                if (!mediaGroups[type] || Object.keys(mediaGroups[type]).length === 0) {
                    mediaGroups[type] = {
                        main: {
                            default: {
                                default: true
                            }
                        }
                    };
                    if (audioOnlyMain) mediaGroups[type].main.default.playlists = mainPlaylistLoader.main.playlists;
                }
                for (const groupId in mediaGroups[type]) {
                    if (!groups[groupId]) groups[groupId] = [];
                    for (const variantLabel in mediaGroups[type][groupId]) {
                        let properties = mediaGroups[type][groupId][variantLabel];
                        let playlistLoader;
                        if (audioOnlyMain) {
                            logger_(`AUDIO group '${groupId}' label '${variantLabel}' is a main playlist`);
                            properties.isMainPlaylist = true;
                            playlistLoader = null;
                        } else if (sourceType === "vhs-json" && properties.playlists) playlistLoader = new app_PlaylistLoader(properties.playlists[0], vhs, requestOptions); else if (properties.resolvedUri) playlistLoader = new app_PlaylistLoader(properties.resolvedUri, vhs, requestOptions); else if (properties.playlists && sourceType === "dash") playlistLoader = new app_DashPlaylistLoader(properties.playlists[0], vhs, requestOptions, mainPlaylistLoader); else playlistLoader = null;
                        properties = app_video_es_merge({
                            id: variantLabel,
                            playlistLoader
                        }, properties);
                        app_setupListeners[type](type, properties.playlistLoader, settings);
                        groups[groupId].push(properties);
                        if (typeof tracks[variantLabel] === "undefined") {
                            const track = new app_videojs.AudioTrack({
                                id: variantLabel,
                                kind: app_audioTrackKind_(properties),
                                enabled: false,
                                language: properties.language,
                                default: properties.default,
                                label: variantLabel
                            });
                            tracks[variantLabel] = track;
                        }
                    }
                }
                segmentLoader.on("error", app_onError[type](type, settings));
            },
            SUBTITLES: (type, settings) => {
                const {tech, vhs, sourceType, segmentLoaders: {[type]: segmentLoader}, requestOptions, main: {mediaGroups}, mediaTypes: {[type]: {groups, tracks}}, mainPlaylistLoader} = settings;
                for (const groupId in mediaGroups[type]) {
                    if (!groups[groupId]) groups[groupId] = [];
                    for (const variantLabel in mediaGroups[type][groupId]) {
                        if (!vhs.options_.useForcedSubtitles && mediaGroups[type][groupId][variantLabel].forced) continue;
                        let properties = mediaGroups[type][groupId][variantLabel];
                        let playlistLoader;
                        if (sourceType === "hls") playlistLoader = new app_PlaylistLoader(properties.resolvedUri, vhs, requestOptions); else if (sourceType === "dash") {
                            const playlists = properties.playlists.filter((p => p.excludeUntil !== 1 / 0));
                            if (!playlists.length) return;
                            playlistLoader = new app_DashPlaylistLoader(properties.playlists[0], vhs, requestOptions, mainPlaylistLoader);
                        } else if (sourceType === "vhs-json") playlistLoader = new app_PlaylistLoader(properties.playlists ? properties.playlists[0] : properties.resolvedUri, vhs, requestOptions);
                        properties = app_video_es_merge({
                            id: variantLabel,
                            playlistLoader
                        }, properties);
                        app_setupListeners[type](type, properties.playlistLoader, settings);
                        groups[groupId].push(properties);
                        if (typeof tracks[variantLabel] === "undefined") {
                            const track = tech.addRemoteTextTrack({
                                id: variantLabel,
                                kind: "subtitles",
                                default: properties.default && properties.autoselect,
                                language: properties.language,
                                label: variantLabel
                            }, false).track;
                            tracks[variantLabel] = track;
                        }
                    }
                }
                segmentLoader.on("error", app_onError[type](type, settings));
            },
            "CLOSED-CAPTIONS": (type, settings) => {
                const {tech, main: {mediaGroups}, mediaTypes: {[type]: {groups, tracks}}} = settings;
                for (const groupId in mediaGroups[type]) {
                    if (!groups[groupId]) groups[groupId] = [];
                    for (const variantLabel in mediaGroups[type][groupId]) {
                        const properties = mediaGroups[type][groupId][variantLabel];
                        if (!/^(?:CC|SERVICE)/.test(properties.instreamId)) continue;
                        const captionServices = tech.options_.vhs && tech.options_.vhs.captionServices || {};
                        let newProps = {
                            label: variantLabel,
                            language: properties.language,
                            instreamId: properties.instreamId,
                            default: properties.default && properties.autoselect
                        };
                        if (captionServices[newProps.instreamId]) newProps = app_video_es_merge(newProps, captionServices[newProps.instreamId]);
                        if (newProps.default === void 0) delete newProps.default;
                        groups[groupId].push(app_video_es_merge({
                            id: variantLabel
                        }, properties));
                        if (typeof tracks[variantLabel] === "undefined") {
                            const track = tech.addRemoteTextTrack({
                                id: newProps.instreamId,
                                kind: "captions",
                                default: newProps.default,
                                language: newProps.language,
                                label: newProps.label
                            }, false).track;
                            tracks[variantLabel] = track;
                        }
                    }
                }
            }
        };
        const app_groupMatch = (list, media) => {
            for (let i = 0; i < list.length; i++) {
                if (app_playlistMatch(media, list[i])) return true;
                if (list[i].playlists && app_groupMatch(list[i].playlists, media)) return true;
            }
            return false;
        };
        const app_activeGroup = (type, settings) => track => {
            const {mainPlaylistLoader, mediaTypes: {[type]: {groups}}} = settings;
            const media = mainPlaylistLoader.media();
            if (!media) return null;
            let variants = null;
            if (media.attributes[type]) variants = groups[media.attributes[type]];
            const groupKeys = Object.keys(groups);
            if (!variants) if (type === "AUDIO" && groupKeys.length > 1 && app_isAudioOnly(settings.main)) for (let i = 0; i < groupKeys.length; i++) {
                const groupPropertyList = groups[groupKeys[i]];
                if (app_groupMatch(groupPropertyList, media)) {
                    variants = groupPropertyList;
                    break;
                }
            } else if (groups.main) variants = groups.main; else if (groupKeys.length === 1) variants = groups[groupKeys[0]];
            if (typeof track === "undefined") return variants;
            if (track === null || !variants) return null;
            return variants.filter((props => props.id === track.id))[0] || null;
        };
        const app_activeTrack = {
            AUDIO: (type, settings) => () => {
                const {mediaTypes: {[type]: {tracks}}} = settings;
                for (const id in tracks) if (tracks[id].enabled) return tracks[id];
                return null;
            },
            SUBTITLES: (type, settings) => () => {
                const {mediaTypes: {[type]: {tracks}}} = settings;
                for (const id in tracks) if (tracks[id].mode === "showing" || tracks[id].mode === "hidden") return tracks[id];
                return null;
            }
        };
        const app_getActiveGroup = (type, {mediaTypes}) => () => {
            const activeTrack_ = mediaTypes[type].activeTrack();
            if (!activeTrack_) return null;
            return mediaTypes[type].activeGroup(activeTrack_);
        };
        const app_setupMediaGroups = settings => {
            [ "AUDIO", "SUBTITLES", "CLOSED-CAPTIONS" ].forEach((type => {
                app_initialize[type](type, settings);
            }));
            const {mediaTypes, mainPlaylistLoader, tech, vhs, segmentLoaders: {["AUDIO"]: audioSegmentLoader, main: mainSegmentLoader}} = settings;
            [ "AUDIO", "SUBTITLES" ].forEach((type => {
                mediaTypes[type].activeGroup = app_activeGroup(type, settings);
                mediaTypes[type].activeTrack = app_activeTrack[type](type, settings);
                mediaTypes[type].onGroupChanged = app_onGroupChanged(type, settings);
                mediaTypes[type].onGroupChanging = app_onGroupChanging(type, settings);
                mediaTypes[type].onTrackChanged = app_onTrackChanged(type, settings);
                mediaTypes[type].getActiveGroup = app_getActiveGroup(type, settings);
            }));
            const audioGroup = mediaTypes.AUDIO.activeGroup();
            if (audioGroup) {
                const groupId = (audioGroup.filter((group => group.default))[0] || audioGroup[0]).id;
                mediaTypes.AUDIO.tracks[groupId].enabled = true;
                mediaTypes.AUDIO.onGroupChanged();
                mediaTypes.AUDIO.onTrackChanged();
                const activeAudioGroup = mediaTypes.AUDIO.getActiveGroup();
                if (!activeAudioGroup.playlistLoader) mainSegmentLoader.setAudio(true); else {
                    mainSegmentLoader.setAudio(false);
                    audioSegmentLoader.setAudio(true);
                }
            }
            mainPlaylistLoader.on("mediachange", (() => {
                [ "AUDIO", "SUBTITLES" ].forEach((type => mediaTypes[type].onGroupChanged()));
            }));
            mainPlaylistLoader.on("mediachanging", (() => {
                [ "AUDIO", "SUBTITLES" ].forEach((type => mediaTypes[type].onGroupChanging()));
            }));
            const onAudioTrackChanged = () => {
                mediaTypes.AUDIO.onTrackChanged();
                tech.trigger({
                    type: "usage",
                    name: "vhs-audio-change"
                });
            };
            tech.audioTracks().addEventListener("change", onAudioTrackChanged);
            tech.remoteTextTracks().addEventListener("change", mediaTypes.SUBTITLES.onTrackChanged);
            vhs.on("dispose", (() => {
                tech.audioTracks().removeEventListener("change", onAudioTrackChanged);
                tech.remoteTextTracks().removeEventListener("change", mediaTypes.SUBTITLES.onTrackChanged);
            }));
            tech.clearTracks("audio");
            for (const id in mediaTypes.AUDIO.tracks) tech.audioTracks().addTrack(mediaTypes.AUDIO.tracks[id]);
        };
        const app_createMediaTypes = () => {
            const mediaTypes = {};
            [ "AUDIO", "SUBTITLES", "CLOSED-CAPTIONS" ].forEach((type => {
                mediaTypes[type] = {
                    groups: {},
                    tracks: {},
                    activePlaylistLoader: null,
                    activeGroup: app_noop,
                    activeTrack: app_noop,
                    getActiveGroup: app_noop,
                    onGroupChanged: app_noop,
                    onTrackChanged: app_noop,
                    lastTrack_: null,
                    logger_: app_logger(`MediaGroups[${type}]`)
                };
            }));
            return mediaTypes;
        };
        class app_SteeringManifest {
            constructor() {
                this.priority_ = [];
                this.pathwayClones_ = new Map;
            }
            set version(number) {
                if (number === 1) this.version_ = number;
            }
            set ttl(seconds) {
                this.ttl_ = seconds || 300;
            }
            set reloadUri(uri) {
                if (uri) this.reloadUri_ = app_video_es_resolveUrl(this.reloadUri_, uri);
            }
            set priority(array) {
                if (array && array.length) this.priority_ = array;
            }
            set pathwayClones(array) {
                if (array && array.length) this.pathwayClones_ = new Map(array.map((clone => [ clone.ID, clone ])));
            }
            get version() {
                return this.version_;
            }
            get ttl() {
                return this.ttl_;
            }
            get reloadUri() {
                return this.reloadUri_;
            }
            get priority() {
                return this.priority_;
            }
            get pathwayClones() {
                return this.pathwayClones_;
            }
        }
        class app_ContentSteeringController extends app_videojs.EventTarget {
            constructor(xhr, bandwidth) {
                super();
                this.currentPathway = null;
                this.defaultPathway = null;
                this.queryBeforeStart = false;
                this.availablePathways_ = new Set;
                this.steeringManifest = new app_SteeringManifest;
                this.proxyServerUrl_ = null;
                this.manifestType_ = null;
                this.ttlTimeout_ = null;
                this.request_ = null;
                this.currentPathwayClones = new Map;
                this.nextPathwayClones = new Map;
                this.excludedSteeringManifestURLs = new Set;
                this.logger_ = app_logger("Content Steering");
                this.xhr_ = xhr;
                this.getBandwidth_ = bandwidth;
            }
            assignTagProperties(baseUrl, steeringTag) {
                this.manifestType_ = steeringTag.serverUri ? "HLS" : "DASH";
                const steeringUri = steeringTag.serverUri || steeringTag.serverURL;
                if (!steeringUri) {
                    this.logger_(`steering manifest URL is ${steeringUri}, cannot request steering manifest.`);
                    this.trigger("error");
                    return;
                }
                if (steeringUri.startsWith("data:")) {
                    this.decodeDataUriManifest_(steeringUri.substring(steeringUri.indexOf(",") + 1));
                    return;
                }
                this.steeringManifest.reloadUri = app_video_es_resolveUrl(baseUrl, steeringUri);
                this.defaultPathway = steeringTag.pathwayId || steeringTag.defaultServiceLocation;
                this.queryBeforeStart = steeringTag.queryBeforeStart;
                this.proxyServerUrl_ = steeringTag.proxyServerURL;
                if (this.defaultPathway && !this.queryBeforeStart) this.trigger("content-steering");
            }
            requestSteeringManifest(initial) {
                const reloadUri = this.steeringManifest.reloadUri;
                if (!reloadUri) return;
                const uri = initial ? reloadUri : this.getRequestURI(reloadUri);
                if (!uri) {
                    this.logger_("No valid content steering manifest URIs. Stopping content steering.");
                    this.trigger("error");
                    this.dispose();
                    return;
                }
                const metadata = {
                    contentSteeringInfo: {
                        uri
                    }
                };
                this.trigger({
                    type: "contentsteeringloadstart",
                    metadata
                });
                this.request_ = this.xhr_({
                    uri,
                    requestType: "content-steering-manifest"
                }, ((error, errorInfo) => {
                    if (error) {
                        if (errorInfo.status === 410) {
                            this.logger_(`manifest request 410 ${error}.`);
                            this.logger_(`There will be no more content steering requests to ${uri} this session.`);
                            this.excludedSteeringManifestURLs.add(uri);
                            return;
                        }
                        if (errorInfo.status === 429) {
                            const retrySeconds = errorInfo.responseHeaders["retry-after"];
                            this.logger_(`manifest request 429 ${error}.`);
                            this.logger_(`content steering will retry in ${retrySeconds} seconds.`);
                            this.startTTLTimeout_(parseInt(retrySeconds, 10));
                            return;
                        }
                        this.logger_(`manifest failed to load ${error}.`);
                        this.startTTLTimeout_();
                        return;
                    }
                    this.trigger({
                        type: "contentsteeringloadcomplete",
                        metadata
                    });
                    let steeringManifestJson;
                    try {
                        steeringManifestJson = JSON.parse(this.request_.responseText);
                    } catch (parseError) {
                        const errorMetadata = {
                            errorType: app_videojs.Error.StreamingContentSteeringParserError,
                            error: parseError
                        };
                        this.trigger({
                            type: "error",
                            metadata: errorMetadata
                        });
                    }
                    this.assignSteeringProperties_(steeringManifestJson);
                    const parsedMetadata = {
                        contentSteeringInfo: metadata.contentSteeringInfo,
                        contentSteeringManifest: {
                            version: this.steeringManifest.version,
                            reloadUri: this.steeringManifest.reloadUri,
                            priority: this.steeringManifest.priority
                        }
                    };
                    this.trigger({
                        type: "contentsteeringparsed",
                        metadata: parsedMetadata
                    });
                    this.startTTLTimeout_();
                }));
            }
            setProxyServerUrl_(steeringUrl) {
                const steeringUrlObject = new (app_window_default().URL)(steeringUrl);
                const proxyServerUrlObject = new (app_window_default().URL)(this.proxyServerUrl_);
                proxyServerUrlObject.searchParams.set("url", encodeURI(steeringUrlObject.toString()));
                return this.setSteeringParams_(proxyServerUrlObject.toString());
            }
            decodeDataUriManifest_(dataUri) {
                const steeringManifestJson = JSON.parse(app_window_default().atob(dataUri));
                this.assignSteeringProperties_(steeringManifestJson);
            }
            setSteeringParams_(url) {
                const urlObject = new (app_window_default().URL)(url);
                const path = this.getPathway();
                const networkThroughput = this.getBandwidth_();
                if (path) {
                    const pathwayKey = `_${this.manifestType_}_pathway`;
                    urlObject.searchParams.set(pathwayKey, path);
                }
                if (networkThroughput) {
                    const throughputKey = `_${this.manifestType_}_throughput`;
                    urlObject.searchParams.set(throughputKey, networkThroughput);
                }
                return urlObject.toString();
            }
            assignSteeringProperties_(steeringJson) {
                this.steeringManifest.version = steeringJson.VERSION;
                if (!this.steeringManifest.version) {
                    this.logger_(`manifest version is ${steeringJson.VERSION}, which is not supported.`);
                    this.trigger("error");
                    return;
                }
                this.steeringManifest.ttl = steeringJson.TTL;
                this.steeringManifest.reloadUri = steeringJson["RELOAD-URI"];
                this.steeringManifest.priority = steeringJson["PATHWAY-PRIORITY"] || steeringJson["SERVICE-LOCATION-PRIORITY"];
                this.steeringManifest.pathwayClones = steeringJson["PATHWAY-CLONES"];
                this.nextPathwayClones = this.steeringManifest.pathwayClones;
                if (!this.availablePathways_.size) {
                    this.logger_("There are no available pathways for content steering. Ending content steering.");
                    this.trigger("error");
                    this.dispose();
                }
                const chooseNextPathway = pathwaysByPriority => {
                    for (const path of pathwaysByPriority) if (this.availablePathways_.has(path)) return path;
                    return [ ...this.availablePathways_ ][0];
                };
                const nextPathway = chooseNextPathway(this.steeringManifest.priority);
                if (this.currentPathway !== nextPathway) {
                    this.currentPathway = nextPathway;
                    this.trigger("content-steering");
                }
            }
            getPathway() {
                return this.currentPathway || this.defaultPathway;
            }
            getRequestURI(reloadUri) {
                if (!reloadUri) return null;
                const isExcluded = uri => this.excludedSteeringManifestURLs.has(uri);
                if (this.proxyServerUrl_) {
                    const proxyURI = this.setProxyServerUrl_(reloadUri);
                    if (!isExcluded(proxyURI)) return proxyURI;
                }
                const steeringURI = this.setSteeringParams_(reloadUri);
                if (!isExcluded(steeringURI)) return steeringURI;
                return null;
            }
            startTTLTimeout_(ttl = this.steeringManifest.ttl) {
                const ttlMS = ttl * 1e3;
                this.ttlTimeout_ = app_window_default().setTimeout((() => {
                    this.requestSteeringManifest();
                }), ttlMS);
            }
            clearTTLTimeout_() {
                app_window_default().clearTimeout(this.ttlTimeout_);
                this.ttlTimeout_ = null;
            }
            abort() {
                if (this.request_) this.request_.abort();
                this.request_ = null;
            }
            dispose() {
                this.off("content-steering");
                this.off("error");
                this.abort();
                this.clearTTLTimeout_();
                this.currentPathway = null;
                this.defaultPathway = null;
                this.queryBeforeStart = null;
                this.proxyServerUrl_ = null;
                this.manifestType_ = null;
                this.ttlTimeout_ = null;
                this.request_ = null;
                this.excludedSteeringManifestURLs = new Set;
                this.availablePathways_ = new Set;
                this.steeringManifest = new app_SteeringManifest;
            }
            addAvailablePathway(pathway) {
                if (pathway) this.availablePathways_.add(pathway);
            }
            clearAvailablePathways() {
                this.availablePathways_.clear();
            }
            excludePathway(pathway) {
                return this.availablePathways_.delete(pathway);
            }
            didDASHTagChange(baseURL, newTag) {
                return !newTag && this.steeringManifest.reloadUri || newTag && (app_video_es_resolveUrl(baseURL, newTag.serverURL) !== this.steeringManifest.reloadUri || newTag.defaultServiceLocation !== this.defaultPathway || newTag.queryBeforeStart !== this.queryBeforeStart || newTag.proxyServerURL !== this.proxyServerUrl_);
            }
            getAvailablePathways() {
                return this.availablePathways_;
            }
        }
        const app_debounce = (callback, wait) => {
            let timeoutId = null;
            return (...args) => {
                clearTimeout(timeoutId);
                timeoutId = setTimeout((() => {
                    callback.apply(null, args);
                }), wait);
            };
        };
        const app_ABORT_EARLY_EXCLUSION_SECONDS = 10;
        let app_Vhs$1;
        const app_loaderStats = [ "mediaRequests", "mediaRequestsAborted", "mediaRequestsTimedout", "mediaRequestsErrored", "mediaTransferDuration", "mediaBytesTransferred", "mediaAppends" ];
        const app_sumLoaderStat = function(stat) {
            return this.audioSegmentLoader_[stat] + this.mainSegmentLoader_[stat];
        };
        const app_shouldSwitchToMedia = function({currentPlaylist, buffered, currentTime, nextPlaylist, bufferLowWaterLine, bufferHighWaterLine, duration, bufferBasedABR, log}) {
            if (!nextPlaylist) {
                app_videojs.log.warn("We received no playlist to switch to. Please check your stream.");
                return false;
            }
            const sharedLogLine = `allowing switch ${currentPlaylist && currentPlaylist.id || "null"} -> ${nextPlaylist.id}`;
            if (!currentPlaylist) {
                log(`${sharedLogLine} as current playlist is not set`);
                return true;
            }
            if (nextPlaylist.id === currentPlaylist.id) return false;
            const isBuffered = Boolean(app_findRange(buffered, currentTime).length);
            if (!currentPlaylist.endList) {
                if (!isBuffered && typeof currentPlaylist.partTargetDuration === "number") {
                    log(`not ${sharedLogLine} as current playlist is live llhls, but currentTime isn't in buffered.`);
                    return false;
                }
                log(`${sharedLogLine} as current playlist is live`);
                return true;
            }
            const forwardBuffer = app_timeAheadOf(buffered, currentTime);
            const maxBufferLowWaterLine = bufferBasedABR ? app_Config.EXPERIMENTAL_MAX_BUFFER_LOW_WATER_LINE : app_Config.MAX_BUFFER_LOW_WATER_LINE;
            if (duration < maxBufferLowWaterLine) {
                log(`${sharedLogLine} as duration < max low water line (${duration} < ${maxBufferLowWaterLine})`);
                return true;
            }
            const nextBandwidth = nextPlaylist.attributes.BANDWIDTH;
            const currBandwidth = currentPlaylist.attributes.BANDWIDTH;
            if (nextBandwidth < currBandwidth && (!bufferBasedABR || forwardBuffer < bufferHighWaterLine)) {
                let logLine = `${sharedLogLine} as next bandwidth < current bandwidth (${nextBandwidth} < ${currBandwidth})`;
                if (bufferBasedABR) logLine += ` and forwardBuffer < bufferHighWaterLine (${forwardBuffer} < ${bufferHighWaterLine})`;
                log(logLine);
                return true;
            }
            if ((!bufferBasedABR || nextBandwidth > currBandwidth) && forwardBuffer >= bufferLowWaterLine) {
                let logLine = `${sharedLogLine} as forwardBuffer >= bufferLowWaterLine (${forwardBuffer} >= ${bufferLowWaterLine})`;
                if (bufferBasedABR) logLine += ` and next bandwidth > current bandwidth (${nextBandwidth} > ${currBandwidth})`;
                log(logLine);
                return true;
            }
            log(`not ${sharedLogLine} as no switching criteria met`);
            return false;
        };
        class app_PlaylistController extends app_videojs.EventTarget {
            constructor(options) {
                super();
                this.fastQualityChange_ = app_debounce(this.fastQualityChange_.bind(this), 100);
                const {src, withCredentials, tech, bandwidth, externVhs, useCueTags, playlistExclusionDuration, enableLowInitialPlaylist, sourceType, cacheEncryptionKeys, bufferBasedABR, leastPixelDiffSelector, captionServices, experimentalUseMMS} = options;
                if (!src) throw new Error("A non-empty playlist URL or JSON manifest string is required");
                let {maxPlaylistRetries} = options;
                if (maxPlaylistRetries === null || typeof maxPlaylistRetries === "undefined") maxPlaylistRetries = 1 / 0;
                app_Vhs$1 = externVhs;
                this.bufferBasedABR = Boolean(bufferBasedABR);
                this.leastPixelDiffSelector = Boolean(leastPixelDiffSelector);
                this.withCredentials = withCredentials;
                this.tech_ = tech;
                this.vhs_ = tech.vhs;
                this.player_ = options.player_;
                this.sourceType_ = sourceType;
                this.useCueTags_ = useCueTags;
                this.playlistExclusionDuration = playlistExclusionDuration;
                this.maxPlaylistRetries = maxPlaylistRetries;
                this.enableLowInitialPlaylist = enableLowInitialPlaylist;
                this.usingManagedMediaSource_ = false;
                if (this.useCueTags_) {
                    this.cueTagsTrack_ = this.tech_.addTextTrack("metadata", "ad-cues");
                    this.cueTagsTrack_.inBandMetadataTrackDispatchType = "";
                }
                this.requestOptions_ = {
                    withCredentials,
                    maxPlaylistRetries,
                    timeout: null
                };
                this.on("error", this.pauseLoading);
                this.mediaTypes_ = app_createMediaTypes();
                if (experimentalUseMMS && app_window_default().ManagedMediaSource) {
                    this.tech_.el_.disableRemotePlayback = true;
                    this.mediaSource = new (app_window_default().ManagedMediaSource);
                    this.usingManagedMediaSource_ = true;
                    app_videojs.log("Using ManagedMediaSource");
                } else if (app_window_default().MediaSource) this.mediaSource = new (app_window_default().MediaSource);
                this.handleDurationChange_ = this.handleDurationChange_.bind(this);
                this.handleSourceOpen_ = this.handleSourceOpen_.bind(this);
                this.handleSourceEnded_ = this.handleSourceEnded_.bind(this);
                this.load = this.load.bind(this);
                this.pause = this.pause.bind(this);
                this.mediaSource.addEventListener("durationchange", this.handleDurationChange_);
                this.mediaSource.addEventListener("sourceopen", this.handleSourceOpen_);
                this.mediaSource.addEventListener("sourceended", this.handleSourceEnded_);
                this.mediaSource.addEventListener("startstreaming", this.load);
                this.mediaSource.addEventListener("endstreaming", this.pause);
                this.seekable_ = app_createTimeRanges();
                this.hasPlayed_ = false;
                this.syncController_ = new app_SyncController(options);
                this.segmentMetadataTrack_ = tech.addRemoteTextTrack({
                    kind: "metadata",
                    label: "segment-metadata"
                }, false).track;
                this.decrypter_ = new app_Decrypter;
                this.sourceUpdater_ = new app_SourceUpdater(this.mediaSource);
                this.inbandTextTracks_ = {};
                this.timelineChangeController_ = new app_TimelineChangeController;
                this.keyStatusMap_ = new Map;
                const segmentLoaderSettings = {
                    vhs: this.vhs_,
                    parse708captions: options.parse708captions,
                    useDtsForTimestampOffset: options.useDtsForTimestampOffset,
                    captionServices,
                    mediaSource: this.mediaSource,
                    currentTime: this.tech_.currentTime.bind(this.tech_),
                    seekable: () => this.seekable(),
                    seeking: () => this.tech_.seeking(),
                    duration: () => this.duration(),
                    hasPlayed: () => this.hasPlayed_,
                    goalBufferLength: () => this.goalBufferLength(),
                    bandwidth,
                    syncController: this.syncController_,
                    decrypter: this.decrypter_,
                    sourceType: this.sourceType_,
                    inbandTextTracks: this.inbandTextTracks_,
                    cacheEncryptionKeys,
                    sourceUpdater: this.sourceUpdater_,
                    timelineChangeController: this.timelineChangeController_,
                    exactManifestTimings: options.exactManifestTimings,
                    addMetadataToTextTrack: this.addMetadataToTextTrack.bind(this)
                };
                this.mainPlaylistLoader_ = this.sourceType_ === "dash" ? new app_DashPlaylistLoader(src, this.vhs_, app_video_es_merge(this.requestOptions_, {
                    addMetadataToTextTrack: this.addMetadataToTextTrack.bind(this)
                })) : new app_PlaylistLoader(src, this.vhs_, app_video_es_merge(this.requestOptions_, {
                    addDateRangesToTextTrack: this.addDateRangesToTextTrack_.bind(this)
                }));
                this.setupMainPlaylistLoaderListeners_();
                this.mainSegmentLoader_ = new app_SegmentLoader(app_video_es_merge(segmentLoaderSettings, {
                    segmentMetadataTrack: this.segmentMetadataTrack_,
                    loaderType: "main"
                }), options);
                this.audioSegmentLoader_ = new app_SegmentLoader(app_video_es_merge(segmentLoaderSettings, {
                    loaderType: "audio"
                }), options);
                this.subtitleSegmentLoader_ = new app_VTTSegmentLoader(app_video_es_merge(segmentLoaderSettings, {
                    loaderType: "vtt",
                    featuresNativeTextTracks: this.tech_.featuresNativeTextTracks,
                    loadVttJs: () => new Promise(((resolve, reject) => {
                        function onLoad() {
                            tech.off("vttjserror", onError);
                            resolve();
                        }
                        function onError() {
                            tech.off("vttjsloaded", onLoad);
                            reject();
                        }
                        tech.one("vttjsloaded", onLoad);
                        tech.one("vttjserror", onError);
                        tech.addWebVttScript_();
                    }))
                }), options);
                const getBandwidth = () => this.mainSegmentLoader_.bandwidth;
                this.contentSteeringController_ = new app_ContentSteeringController(this.vhs_.xhr, getBandwidth);
                this.setupSegmentLoaderListeners_();
                if (this.bufferBasedABR) {
                    this.mainPlaylistLoader_.one("loadedplaylist", (() => this.startABRTimer_()));
                    this.tech_.on("pause", (() => this.stopABRTimer_()));
                    this.tech_.on("play", (() => this.startABRTimer_()));
                }
                app_loaderStats.forEach((stat => {
                    this[stat + "_"] = app_sumLoaderStat.bind(this, stat);
                }));
                this.logger_ = app_logger("pc");
                this.triggeredFmp4Usage = false;
                if (this.tech_.preload() === "none") {
                    this.loadOnPlay_ = () => {
                        this.loadOnPlay_ = null;
                        this.mainPlaylistLoader_.load();
                    };
                    this.tech_.one("play", this.loadOnPlay_);
                } else this.mainPlaylistLoader_.load();
                this.timeToLoadedData__ = -1;
                this.mainAppendsToLoadedData__ = -1;
                this.audioAppendsToLoadedData__ = -1;
                const event = this.tech_.preload() === "none" ? "play" : "loadstart";
                this.tech_.one(event, (() => {
                    const timeToLoadedDataStart = Date.now();
                    this.tech_.one("loadeddata", (() => {
                        this.timeToLoadedData__ = Date.now() - timeToLoadedDataStart;
                        this.mainAppendsToLoadedData__ = this.mainSegmentLoader_.mediaAppends;
                        this.audioAppendsToLoadedData__ = this.audioSegmentLoader_.mediaAppends;
                    }));
                }));
            }
            mainAppendsToLoadedData_() {
                return this.mainAppendsToLoadedData__;
            }
            audioAppendsToLoadedData_() {
                return this.audioAppendsToLoadedData__;
            }
            appendsToLoadedData_() {
                const main = this.mainAppendsToLoadedData_();
                const audio = this.audioAppendsToLoadedData_();
                if (main === -1 || audio === -1) return -1;
                return main + audio;
            }
            timeToLoadedData_() {
                return this.timeToLoadedData__;
            }
            checkABR_(reason = "abr") {
                const nextPlaylist = this.selectPlaylist();
                if (nextPlaylist && this.shouldSwitchToMedia_(nextPlaylist)) this.switchMedia_(nextPlaylist, reason);
            }
            switchMedia_(playlist, cause, delay) {
                const oldMedia = this.media();
                const oldId = oldMedia && (oldMedia.id || oldMedia.uri);
                const newId = playlist && (playlist.id || playlist.uri);
                if (oldId && oldId !== newId) {
                    this.logger_(`switch media ${oldId} -> ${newId} from ${cause}`);
                    const metadata = {
                        renditionInfo: {
                            id: newId,
                            bandwidth: playlist.attributes.BANDWIDTH,
                            resolution: playlist.attributes.RESOLUTION,
                            codecs: playlist.attributes.CODECS
                        },
                        cause
                    };
                    this.trigger({
                        type: "renditionselected",
                        metadata
                    });
                    this.tech_.trigger({
                        type: "usage",
                        name: `vhs-rendition-change-${cause}`
                    });
                }
                this.mainPlaylistLoader_.media(playlist, delay);
            }
            switchMediaForDASHContentSteering_() {
                [ "AUDIO", "SUBTITLES", "CLOSED-CAPTIONS" ].forEach((type => {
                    const mediaType = this.mediaTypes_[type];
                    const activeGroup = mediaType ? mediaType.activeGroup() : null;
                    const pathway = this.contentSteeringController_.getPathway();
                    if (activeGroup && pathway) {
                        const mediaPlaylists = activeGroup.length ? activeGroup[0].playlists : activeGroup.playlists;
                        const dashMediaPlaylists = mediaPlaylists.filter((p => p.attributes.serviceLocation === pathway));
                        if (dashMediaPlaylists.length) this.mediaTypes_[type].activePlaylistLoader.media(dashMediaPlaylists[0]);
                    }
                }));
            }
            startABRTimer_() {
                this.stopABRTimer_();
                this.abrTimer_ = app_window_default().setInterval((() => this.checkABR_()), 250);
            }
            stopABRTimer_() {
                if (this.tech_.scrubbing && this.tech_.scrubbing()) return;
                app_window_default().clearInterval(this.abrTimer_);
                this.abrTimer_ = null;
            }
            getAudioTrackPlaylists_() {
                const main = this.main();
                const defaultPlaylists = main && main.playlists || [];
                if (!main || !main.mediaGroups || !main.mediaGroups.AUDIO) return defaultPlaylists;
                const AUDIO = main.mediaGroups.AUDIO;
                const groupKeys = Object.keys(AUDIO);
                let track;
                if (Object.keys(this.mediaTypes_.AUDIO.groups).length) track = this.mediaTypes_.AUDIO.activeTrack(); else {
                    const defaultGroup = AUDIO.main || groupKeys.length && AUDIO[groupKeys[0]];
                    for (const label in defaultGroup) if (defaultGroup[label].default) {
                        track = {
                            label
                        };
                        break;
                    }
                }
                if (!track) return defaultPlaylists;
                const playlists = [];
                for (const group in AUDIO) if (AUDIO[group][track.label]) {
                    const properties = AUDIO[group][track.label];
                    if (properties.playlists && properties.playlists.length) playlists.push.apply(playlists, properties.playlists); else if (properties.uri) playlists.push(properties); else if (main.playlists.length) for (let i = 0; i < main.playlists.length; i++) {
                        const playlist = main.playlists[i];
                        if (playlist.attributes && playlist.attributes.AUDIO && playlist.attributes.AUDIO === group) playlists.push(playlist);
                    }
                }
                if (!playlists.length) return defaultPlaylists;
                return playlists;
            }
            setupMainPlaylistLoaderListeners_() {
                this.mainPlaylistLoader_.on("loadedmetadata", (() => {
                    const media = this.mainPlaylistLoader_.media();
                    const requestTimeout = media.targetDuration * 1.5 * 1e3;
                    if (app_isLowestEnabledRendition(this.mainPlaylistLoader_.main, this.mainPlaylistLoader_.media())) this.requestOptions_.timeout = 0; else this.requestOptions_.timeout = requestTimeout;
                    if (media.endList && this.tech_.preload() !== "none") {
                        this.mainSegmentLoader_.playlist(media, this.requestOptions_);
                        this.mainSegmentLoader_.load();
                    }
                    app_setupMediaGroups({
                        sourceType: this.sourceType_,
                        segmentLoaders: {
                            AUDIO: this.audioSegmentLoader_,
                            SUBTITLES: this.subtitleSegmentLoader_,
                            main: this.mainSegmentLoader_
                        },
                        tech: this.tech_,
                        requestOptions: this.requestOptions_,
                        mainPlaylistLoader: this.mainPlaylistLoader_,
                        vhs: this.vhs_,
                        main: this.main(),
                        mediaTypes: this.mediaTypes_,
                        excludePlaylist: this.excludePlaylist.bind(this)
                    });
                    this.triggerPresenceUsage_(this.main(), media);
                    this.setupFirstPlay();
                    if (!this.mediaTypes_.AUDIO.activePlaylistLoader || this.mediaTypes_.AUDIO.activePlaylistLoader.media()) this.trigger("selectedinitialmedia"); else this.mediaTypes_.AUDIO.activePlaylistLoader.one("loadedmetadata", (() => {
                        this.trigger("selectedinitialmedia");
                    }));
                }));
                this.mainPlaylistLoader_.on("loadedplaylist", (() => {
                    if (this.loadOnPlay_) this.tech_.off("play", this.loadOnPlay_);
                    let updatedPlaylist = this.mainPlaylistLoader_.media();
                    if (!updatedPlaylist) {
                        this.attachContentSteeringListeners_();
                        this.initContentSteeringController_();
                        this.excludeUnsupportedVariants_();
                        let selectedMedia;
                        if (this.enableLowInitialPlaylist) selectedMedia = this.selectInitialPlaylist();
                        if (!selectedMedia) selectedMedia = this.selectPlaylist();
                        if (!selectedMedia || !this.shouldSwitchToMedia_(selectedMedia)) return;
                        this.initialMedia_ = selectedMedia;
                        this.switchMedia_(this.initialMedia_, "initial");
                        const haveJsonSource = this.sourceType_ === "vhs-json" && this.initialMedia_.segments;
                        if (!haveJsonSource) return;
                        updatedPlaylist = this.initialMedia_;
                    }
                    this.handleUpdatedMediaPlaylist(updatedPlaylist);
                }));
                this.mainPlaylistLoader_.on("error", (() => {
                    const error = this.mainPlaylistLoader_.error;
                    this.excludePlaylist({
                        playlistToExclude: error.playlist,
                        error
                    });
                }));
                this.mainPlaylistLoader_.on("mediachanging", (() => {
                    this.mainSegmentLoader_.abort();
                    this.mainSegmentLoader_.pause();
                }));
                this.mainPlaylistLoader_.on("mediachange", (() => {
                    const media = this.mainPlaylistLoader_.media();
                    const requestTimeout = media.targetDuration * 1.5 * 1e3;
                    if (app_isLowestEnabledRendition(this.mainPlaylistLoader_.main, this.mainPlaylistLoader_.media())) this.requestOptions_.timeout = 0; else this.requestOptions_.timeout = requestTimeout;
                    if (this.sourceType_ === "dash") if (this.mainPlaylistLoader_.isPaused) this.mainPlaylistLoader_.load();
                    this.mainSegmentLoader_.pause();
                    this.mainSegmentLoader_.playlist(media, this.requestOptions_);
                    if (this.waitingForFastQualityPlaylistReceived_) this.runFastQualitySwitch_(); else this.mainSegmentLoader_.load();
                    this.tech_.trigger({
                        type: "mediachange",
                        bubbles: true
                    });
                }));
                this.mainPlaylistLoader_.on("playlistunchanged", (() => {
                    const updatedPlaylist = this.mainPlaylistLoader_.media();
                    if (updatedPlaylist.lastExcludeReason_ === "playlist-unchanged") return;
                    const playlistOutdated = this.stuckAtPlaylistEnd_(updatedPlaylist);
                    if (playlistOutdated) {
                        this.excludePlaylist({
                            error: {
                                message: "Playlist no longer updating.",
                                reason: "playlist-unchanged"
                            }
                        });
                        this.tech_.trigger("playliststuck");
                    }
                }));
                this.mainPlaylistLoader_.on("renditiondisabled", (() => {
                    this.tech_.trigger({
                        type: "usage",
                        name: "vhs-rendition-disabled"
                    });
                }));
                this.mainPlaylistLoader_.on("renditionenabled", (() => {
                    this.tech_.trigger({
                        type: "usage",
                        name: "vhs-rendition-enabled"
                    });
                }));
                const playlistLoaderEvents = [ "manifestrequeststart", "manifestrequestcomplete", "manifestparsestart", "manifestparsecomplete", "playlistrequeststart", "playlistrequestcomplete", "playlistparsestart", "playlistparsecomplete", "renditiondisabled", "renditionenabled" ];
                playlistLoaderEvents.forEach((eventName => {
                    this.mainPlaylistLoader_.on(eventName, (metadata => {
                        this.player_.trigger(app_extends({}, metadata));
                    }));
                }));
            }
            handleUpdatedMediaPlaylist(updatedPlaylist) {
                if (this.useCueTags_) this.updateAdCues_(updatedPlaylist);
                this.mainSegmentLoader_.pause();
                this.mainSegmentLoader_.playlist(updatedPlaylist, this.requestOptions_);
                if (this.waitingForFastQualityPlaylistReceived_) this.runFastQualitySwitch_();
                this.updateDuration(!updatedPlaylist.endList);
                if (!this.tech_.paused()) {
                    this.mainSegmentLoader_.load();
                    if (this.audioSegmentLoader_) this.audioSegmentLoader_.load();
                }
            }
            triggerPresenceUsage_(main, media) {
                const mediaGroups = main.mediaGroups || {};
                let defaultDemuxed = true;
                const audioGroupKeys = Object.keys(mediaGroups.AUDIO);
                for (const mediaGroup in mediaGroups.AUDIO) for (const label in mediaGroups.AUDIO[mediaGroup]) {
                    const properties = mediaGroups.AUDIO[mediaGroup][label];
                    if (!properties.uri) defaultDemuxed = false;
                }
                if (defaultDemuxed) this.tech_.trigger({
                    type: "usage",
                    name: "vhs-demuxed"
                });
                if (Object.keys(mediaGroups.SUBTITLES).length) this.tech_.trigger({
                    type: "usage",
                    name: "vhs-webvtt"
                });
                if (app_Vhs$1.Playlist.isAes(media)) this.tech_.trigger({
                    type: "usage",
                    name: "vhs-aes"
                });
                if (audioGroupKeys.length && Object.keys(mediaGroups.AUDIO[audioGroupKeys[0]]).length > 1) this.tech_.trigger({
                    type: "usage",
                    name: "vhs-alternate-audio"
                });
                if (this.useCueTags_) this.tech_.trigger({
                    type: "usage",
                    name: "vhs-playlist-cue-tags"
                });
            }
            shouldSwitchToMedia_(nextPlaylist) {
                const currentPlaylist = this.mainPlaylistLoader_.media() || this.mainPlaylistLoader_.pendingMedia_;
                const currentTime = this.tech_.currentTime();
                const bufferLowWaterLine = this.bufferLowWaterLine();
                const bufferHighWaterLine = this.bufferHighWaterLine();
                const buffered = this.tech_.buffered();
                return app_shouldSwitchToMedia({
                    buffered,
                    currentTime,
                    currentPlaylist,
                    nextPlaylist,
                    bufferLowWaterLine,
                    bufferHighWaterLine,
                    duration: this.duration(),
                    bufferBasedABR: this.bufferBasedABR,
                    log: this.logger_
                });
            }
            setupSegmentLoaderListeners_() {
                this.mainSegmentLoader_.on("bandwidthupdate", (() => {
                    this.checkABR_("bandwidthupdate");
                    this.tech_.trigger("bandwidthupdate");
                }));
                this.mainSegmentLoader_.on("timeout", (() => {
                    if (this.bufferBasedABR) this.mainSegmentLoader_.load();
                }));
                if (!this.bufferBasedABR) this.mainSegmentLoader_.on("progress", (() => {
                    this.trigger("progress");
                }));
                this.mainSegmentLoader_.on("error", (() => {
                    const error = this.mainSegmentLoader_.error();
                    this.excludePlaylist({
                        playlistToExclude: error.playlist,
                        error
                    });
                }));
                this.mainSegmentLoader_.on("appenderror", (() => {
                    this.error = this.mainSegmentLoader_.error_;
                    this.trigger("error");
                }));
                this.mainSegmentLoader_.on("syncinfoupdate", (() => {
                    this.onSyncInfoUpdate_();
                }));
                this.mainSegmentLoader_.on("timestampoffset", (() => {
                    this.tech_.trigger({
                        type: "usage",
                        name: "vhs-timestamp-offset"
                    });
                }));
                this.audioSegmentLoader_.on("syncinfoupdate", (() => {
                    this.onSyncInfoUpdate_();
                }));
                this.audioSegmentLoader_.on("appenderror", (() => {
                    this.error = this.audioSegmentLoader_.error_;
                    this.trigger("error");
                }));
                this.mainSegmentLoader_.on("ended", (() => {
                    this.logger_("main segment loader ended");
                    this.onEndOfStream();
                }));
                this.timelineChangeController_.on("audioTimelineBehind", (() => {
                    const segmentInfo = this.audioSegmentLoader_.pendingSegment_;
                    if (!segmentInfo || !segmentInfo.segment || !segmentInfo.segment.syncInfo) return;
                    const newTime = segmentInfo.segment.syncInfo.end + .01;
                    this.tech_.setCurrentTime(newTime);
                }));
                this.timelineChangeController_.on("fixBadTimelineChange", (() => {
                    this.logger_("Fix bad timeline change. Restarting al segment loaders...");
                    this.mainSegmentLoader_.pause();
                    this.mainSegmentLoader_.resetEverything();
                    if (this.mediaTypes_.AUDIO.activePlaylistLoader) {
                        this.audioSegmentLoader_.pause();
                        this.audioSegmentLoader_.resetEverything();
                    }
                    if (this.mediaTypes_.SUBTITLES.activePlaylistLoader) {
                        this.subtitleSegmentLoader_.pause();
                        this.subtitleSegmentLoader_.resetEverything();
                    }
                    this.load();
                }));
                this.mainSegmentLoader_.on("earlyabort", (event => {
                    if (this.bufferBasedABR) return;
                    this.delegateLoaders_("all", [ "abort" ]);
                    this.excludePlaylist({
                        error: {
                            message: "Aborted early because there isn't enough bandwidth to complete " + "the request without rebuffering."
                        },
                        playlistExclusionDuration: app_ABORT_EARLY_EXCLUSION_SECONDS
                    });
                }));
                const updateCodecs = () => {
                    if (!this.sourceUpdater_.hasCreatedSourceBuffers()) return this.tryToCreateSourceBuffers_();
                    const codecs = this.getCodecsOrExclude_();
                    if (!codecs) return;
                    this.sourceUpdater_.addOrChangeSourceBuffers(codecs);
                };
                this.mainSegmentLoader_.on("trackinfo", updateCodecs);
                this.audioSegmentLoader_.on("trackinfo", updateCodecs);
                this.mainSegmentLoader_.on("fmp4", (() => {
                    if (!this.triggeredFmp4Usage) {
                        this.tech_.trigger({
                            type: "usage",
                            name: "vhs-fmp4"
                        });
                        this.triggeredFmp4Usage = true;
                    }
                }));
                this.audioSegmentLoader_.on("fmp4", (() => {
                    if (!this.triggeredFmp4Usage) {
                        this.tech_.trigger({
                            type: "usage",
                            name: "vhs-fmp4"
                        });
                        this.triggeredFmp4Usage = true;
                    }
                }));
                this.audioSegmentLoader_.on("ended", (() => {
                    this.logger_("audioSegmentLoader ended");
                    this.onEndOfStream();
                }));
                const segmentLoaderEvents = [ "segmentselected", "segmentloadstart", "segmentloaded", "segmentkeyloadstart", "segmentkeyloadcomplete", "segmentdecryptionstart", "segmentdecryptioncomplete", "segmenttransmuxingstart", "segmenttransmuxingcomplete", "segmenttransmuxingtrackinfoavailable", "segmenttransmuxingtiminginfoavailable", "segmentappendstart", "appendsdone", "bandwidthupdated", "timelinechange", "codecschange" ];
                segmentLoaderEvents.forEach((eventName => {
                    this.mainSegmentLoader_.on(eventName, (metadata => {
                        this.player_.trigger(app_extends({}, metadata));
                    }));
                    this.audioSegmentLoader_.on(eventName, (metadata => {
                        this.player_.trigger(app_extends({}, metadata));
                    }));
                    this.subtitleSegmentLoader_.on(eventName, (metadata => {
                        this.player_.trigger(app_extends({}, metadata));
                    }));
                }));
            }
            mediaSecondsLoaded_() {
                return Math.max(this.audioSegmentLoader_.mediaSecondsLoaded + this.mainSegmentLoader_.mediaSecondsLoaded);
            }
            load() {
                this.mainSegmentLoader_.load();
                if (this.mediaTypes_.AUDIO.activePlaylistLoader) this.audioSegmentLoader_.load();
                if (this.mediaTypes_.SUBTITLES.activePlaylistLoader) this.subtitleSegmentLoader_.load();
            }
            pause() {
                this.mainSegmentLoader_.pause();
                if (this.mediaTypes_.AUDIO.activePlaylistLoader) this.audioSegmentLoader_.pause();
                if (this.mediaTypes_.SUBTITLES.activePlaylistLoader) this.subtitleSegmentLoader_.pause();
            }
            fastQualityChange_(media = this.selectPlaylist()) {
                if (media && media === this.mainPlaylistLoader_.media()) {
                    this.logger_("skipping fastQualityChange because new media is same as old");
                    return;
                }
                this.switchMedia_(media, "fast-quality");
                this.waitingForFastQualityPlaylistReceived_ = true;
            }
            runFastQualitySwitch_() {
                this.waitingForFastQualityPlaylistReceived_ = false;
                this.mainSegmentLoader_.pause();
                this.mainSegmentLoader_.resetEverything();
                if (this.mediaTypes_.AUDIO.activePlaylistLoader) {
                    this.audioSegmentLoader_.pause();
                    this.audioSegmentLoader_.resetEverything();
                }
                if (this.mediaTypes_.SUBTITLES.activePlaylistLoader) {
                    this.subtitleSegmentLoader_.pause();
                    this.subtitleSegmentLoader_.resetEverything();
                }
                this.load();
            }
            play() {
                if (this.setupFirstPlay()) return;
                if (this.tech_.ended()) this.tech_.setCurrentTime(0);
                if (this.hasPlayed_) this.load();
                const seekable = this.tech_.seekable();
                if (this.tech_.duration() === 1 / 0) if (this.tech_.currentTime() < seekable.start(0)) return this.tech_.setCurrentTime(seekable.end(seekable.length - 1));
            }
            setupFirstPlay() {
                const media = this.mainPlaylistLoader_.media();
                if (!media || this.tech_.paused() || this.hasPlayed_) return false;
                if (!media.endList || media.start) {
                    const seekable = this.seekable();
                    if (!seekable.length) return false;
                    const seekableEnd = seekable.end(0);
                    let startPoint = seekableEnd;
                    if (media.start) {
                        const offset = media.start.timeOffset;
                        if (offset < 0) startPoint = Math.max(seekableEnd + offset, seekable.start(0)); else startPoint = Math.min(seekableEnd, offset);
                    }
                    this.trigger("firstplay");
                    this.tech_.setCurrentTime(startPoint);
                }
                this.hasPlayed_ = true;
                this.load();
                return true;
            }
            handleSourceOpen_() {
                this.tryToCreateSourceBuffers_();
                if (this.tech_.autoplay()) {
                    const playPromise = this.tech_.play();
                    if (typeof playPromise !== "undefined" && typeof playPromise.then === "function") playPromise.then(null, (e => {}));
                }
                this.trigger("sourceopen");
            }
            handleSourceEnded_() {
                if (!this.inbandTextTracks_.metadataTrack_) return;
                const cues = this.inbandTextTracks_.metadataTrack_.cues;
                if (!cues || !cues.length) return;
                const duration = this.duration();
                cues[cues.length - 1].endTime = isNaN(duration) || Math.abs(duration) === 1 / 0 ? Number.MAX_VALUE : duration;
            }
            handleDurationChange_() {
                this.tech_.trigger("durationchange");
            }
            onEndOfStream() {
                let isEndOfStream = this.mainSegmentLoader_.ended_;
                if (this.mediaTypes_.AUDIO.activePlaylistLoader) {
                    const mainMediaInfo = this.mainSegmentLoader_.getCurrentMediaInfo_();
                    if (!mainMediaInfo || mainMediaInfo.hasVideo) isEndOfStream = isEndOfStream && this.audioSegmentLoader_.ended_; else isEndOfStream = this.audioSegmentLoader_.ended_;
                }
                if (!isEndOfStream) return;
                this.stopABRTimer_();
                this.sourceUpdater_.endOfStream();
            }
            stuckAtPlaylistEnd_(playlist) {
                const seekable = this.seekable();
                if (!seekable.length) return false;
                const expired = this.syncController_.getExpiredTime(playlist, this.duration());
                if (expired === null) return false;
                const absolutePlaylistEnd = app_Vhs$1.Playlist.playlistEnd(playlist, expired);
                const currentTime = this.tech_.currentTime();
                const buffered = this.tech_.buffered();
                if (!buffered.length) return absolutePlaylistEnd - currentTime <= app_SAFE_TIME_DELTA;
                const bufferedEnd = buffered.end(buffered.length - 1);
                return bufferedEnd - currentTime <= app_SAFE_TIME_DELTA && absolutePlaylistEnd - bufferedEnd <= app_SAFE_TIME_DELTA;
            }
            excludePlaylist({playlistToExclude = this.mainPlaylistLoader_.media(), error = {}, playlistExclusionDuration}) {
                playlistToExclude = playlistToExclude || this.mainPlaylistLoader_.media();
                playlistExclusionDuration = playlistExclusionDuration || error.playlistExclusionDuration || this.playlistExclusionDuration;
                if (!playlistToExclude) {
                    this.error = error;
                    if (this.mediaSource.readyState !== "open") this.trigger("error"); else this.sourceUpdater_.endOfStream("network");
                    return;
                }
                playlistToExclude.playlistErrors_++;
                const playlists = this.mainPlaylistLoader_.main.playlists;
                const enabledPlaylists = playlists.filter(app_isEnabled);
                const isFinalRendition = enabledPlaylists.length === 1 && enabledPlaylists[0] === playlistToExclude;
                if (playlists.length === 1 && playlistExclusionDuration !== 1 / 0) {
                    app_videojs.log.warn(`Problem encountered with playlist ${playlistToExclude.id}. ` + "Trying again since it is the only playlist.");
                    this.tech_.trigger("retryplaylist");
                    return this.mainPlaylistLoader_.load(isFinalRendition);
                }
                if (isFinalRendition) {
                    if (this.main().contentSteering) {
                        const pathway = this.pathwayAttribute_(playlistToExclude);
                        const reIncludeDelay = this.contentSteeringController_.steeringManifest.ttl * 1e3;
                        this.contentSteeringController_.excludePathway(pathway);
                        this.excludeThenChangePathway_();
                        setTimeout((() => {
                            this.contentSteeringController_.addAvailablePathway(pathway);
                        }), reIncludeDelay);
                        return;
                    }
                    let reincluded = false;
                    playlists.forEach((playlist => {
                        if (playlist === playlistToExclude) return;
                        const excludeUntil = playlist.excludeUntil;
                        if (typeof excludeUntil !== "undefined" && excludeUntil !== 1 / 0) {
                            reincluded = true;
                            delete playlist.excludeUntil;
                        }
                    }));
                    if (reincluded) {
                        app_videojs.log.warn("Removing other playlists from the exclusion list because the last " + "rendition is about to be excluded.");
                        this.tech_.trigger("retryplaylist");
                    }
                }
                let excludeUntil;
                if (playlistToExclude.playlistErrors_ > this.maxPlaylistRetries) excludeUntil = 1 / 0; else excludeUntil = Date.now() + playlistExclusionDuration * 1e3;
                playlistToExclude.excludeUntil = excludeUntil;
                if (error.reason) playlistToExclude.lastExcludeReason_ = error.reason;
                this.tech_.trigger("excludeplaylist");
                this.tech_.trigger({
                    type: "usage",
                    name: "vhs-rendition-excluded"
                });
                const nextPlaylist = this.selectPlaylist();
                if (!nextPlaylist) {
                    this.error = "Playback cannot continue. No available working or supported playlists.";
                    this.trigger("error");
                    return;
                }
                const logFn = error.internal ? this.logger_ : app_videojs.log.warn;
                const errorMessage = error.message ? " " + error.message : "";
                logFn(`${error.internal ? "Internal problem" : "Problem"} encountered with playlist ${playlistToExclude.id}.` + `${errorMessage} Switching to playlist ${nextPlaylist.id}.`);
                if (nextPlaylist.attributes.AUDIO !== playlistToExclude.attributes.AUDIO) this.delegateLoaders_("audio", [ "abort", "pause" ]);
                if (nextPlaylist.attributes.SUBTITLES !== playlistToExclude.attributes.SUBTITLES) this.delegateLoaders_("subtitle", [ "abort", "pause" ]);
                this.delegateLoaders_("main", [ "abort", "pause" ]);
                const delayDuration = nextPlaylist.targetDuration / 2 * 1e3 || 5 * 1e3;
                const shouldDelay = typeof nextPlaylist.lastRequest === "number" && Date.now() - nextPlaylist.lastRequest <= delayDuration;
                return this.switchMedia_(nextPlaylist, "exclude", isFinalRendition || shouldDelay);
            }
            pauseLoading() {
                this.delegateLoaders_("all", [ "abort", "pause" ]);
                this.stopABRTimer_();
            }
            delegateLoaders_(filter, fnNames) {
                const loaders = [];
                const dontFilterPlaylist = filter === "all";
                if (dontFilterPlaylist || filter === "main") loaders.push(this.mainPlaylistLoader_);
                const mediaTypes = [];
                if (dontFilterPlaylist || filter === "audio") mediaTypes.push("AUDIO");
                if (dontFilterPlaylist || filter === "subtitle") {
                    mediaTypes.push("CLOSED-CAPTIONS");
                    mediaTypes.push("SUBTITLES");
                }
                mediaTypes.forEach((mediaType => {
                    const loader = this.mediaTypes_[mediaType] && this.mediaTypes_[mediaType].activePlaylistLoader;
                    if (loader) loaders.push(loader);
                }));
                [ "main", "audio", "subtitle" ].forEach((name => {
                    const loader = this[`${name}SegmentLoader_`];
                    if (loader && (filter === name || filter === "all")) loaders.push(loader);
                }));
                loaders.forEach((loader => fnNames.forEach((fnName => {
                    if (typeof loader[fnName] === "function") loader[fnName]();
                }))));
            }
            setCurrentTime(currentTime) {
                const buffered = app_findRange(this.tech_.buffered(), currentTime);
                if (!(this.mainPlaylistLoader_ && this.mainPlaylistLoader_.media())) return 0;
                if (!this.mainPlaylistLoader_.media().segments) return 0;
                if (buffered && buffered.length) return currentTime;
                this.mainSegmentLoader_.pause();
                this.mainSegmentLoader_.resetEverything();
                if (this.mediaTypes_.AUDIO.activePlaylistLoader) {
                    this.audioSegmentLoader_.pause();
                    this.audioSegmentLoader_.resetEverything();
                }
                if (this.mediaTypes_.SUBTITLES.activePlaylistLoader) {
                    this.subtitleSegmentLoader_.pause();
                    this.subtitleSegmentLoader_.resetEverything();
                }
                this.load();
            }
            duration() {
                if (!this.mainPlaylistLoader_) return 0;
                const media = this.mainPlaylistLoader_.media();
                if (!media) return 0;
                if (!media.endList) return 1 / 0;
                if (this.mediaSource) return this.mediaSource.duration;
                return app_Vhs$1.Playlist.duration(media);
            }
            seekable() {
                return this.seekable_;
            }
            getSeekableRange_(playlistLoader, mediaType) {
                const media = playlistLoader.media();
                if (!media) return null;
                const mediaSequenceSync = this.syncController_.getMediaSequenceSync(mediaType);
                if (mediaSequenceSync && mediaSequenceSync.isReliable) {
                    const start = mediaSequenceSync.start;
                    const end = mediaSequenceSync.end;
                    if (!isFinite(start) || !isFinite(end)) return null;
                    const liveEdgeDelay = app_Vhs$1.Playlist.liveEdgeDelay(this.mainPlaylistLoader_.main, media);
                    const calculatedEnd = Math.max(0, end - liveEdgeDelay);
                    if (calculatedEnd < start) return null;
                    return app_createTimeRanges([ [ start, calculatedEnd ] ]);
                }
                const expired = this.syncController_.getExpiredTime(media, this.duration());
                if (expired === null) return null;
                const seekable = app_Vhs$1.Playlist.seekable(media, expired, app_Vhs$1.Playlist.liveEdgeDelay(this.mainPlaylistLoader_.main, media));
                return seekable.length ? seekable : null;
            }
            computeFinalSeekable_(mainSeekable, audioSeekable) {
                if (!audioSeekable) return mainSeekable;
                const mainStart = mainSeekable.start(0);
                const mainEnd = mainSeekable.end(0);
                const audioStart = audioSeekable.start(0);
                const audioEnd = audioSeekable.end(0);
                if (audioStart > mainEnd || mainStart > audioEnd) return mainSeekable;
                return app_createTimeRanges([ [ Math.max(mainStart, audioStart), Math.min(mainEnd, audioEnd) ] ]);
            }
            onSyncInfoUpdate_() {
                if (!this.mainPlaylistLoader_) return;
                const mainSeekable = this.getSeekableRange_(this.mainPlaylistLoader_, "main");
                if (!mainSeekable) return;
                let audioSeekable;
                if (this.mediaTypes_.AUDIO.activePlaylistLoader) {
                    audioSeekable = this.getSeekableRange_(this.mediaTypes_.AUDIO.activePlaylistLoader, "audio");
                    if (!audioSeekable) return;
                }
                const oldSeekable = this.seekable_;
                this.seekable_ = this.computeFinalSeekable_(mainSeekable, audioSeekable);
                if (!this.seekable_) return;
                if (oldSeekable && oldSeekable.length && this.seekable_.length) if (oldSeekable.start(0) === this.seekable_.start(0) && oldSeekable.end(0) === this.seekable_.end(0)) return;
                this.logger_(`seekable updated [${app_printableRange(this.seekable_)}]`);
                const metadata = {
                    seekableRanges: this.seekable_
                };
                this.trigger({
                    type: "seekablerangeschanged",
                    metadata
                });
                this.tech_.trigger("seekablechanged");
            }
            updateDuration(isLive) {
                if (this.updateDuration_) {
                    this.mediaSource.removeEventListener("sourceopen", this.updateDuration_);
                    this.updateDuration_ = null;
                }
                if (this.mediaSource.readyState !== "open") {
                    this.updateDuration_ = this.updateDuration.bind(this, isLive);
                    this.mediaSource.addEventListener("sourceopen", this.updateDuration_);
                    return;
                }
                if (isLive) {
                    const seekable = this.seekable();
                    if (!seekable.length) return;
                    if (isNaN(this.mediaSource.duration) || this.mediaSource.duration < seekable.end(seekable.length - 1)) this.sourceUpdater_.setDuration(seekable.end(seekable.length - 1));
                    return;
                }
                const buffered = this.tech_.buffered();
                let duration = app_Vhs$1.Playlist.duration(this.mainPlaylistLoader_.media());
                if (buffered.length > 0) duration = Math.max(duration, buffered.end(buffered.length - 1));
                if (this.mediaSource.duration !== duration) this.sourceUpdater_.setDuration(duration);
            }
            dispose() {
                this.trigger("dispose");
                this.decrypter_.terminate();
                this.mainPlaylistLoader_.dispose();
                this.mainSegmentLoader_.dispose();
                this.contentSteeringController_.dispose();
                this.keyStatusMap_.clear();
                if (this.loadOnPlay_) this.tech_.off("play", this.loadOnPlay_);
                [ "AUDIO", "SUBTITLES" ].forEach((type => {
                    const groups = this.mediaTypes_[type].groups;
                    for (const id in groups) groups[id].forEach((group => {
                        if (group.playlistLoader) group.playlistLoader.dispose();
                    }));
                }));
                this.audioSegmentLoader_.dispose();
                this.subtitleSegmentLoader_.dispose();
                this.sourceUpdater_.dispose();
                this.timelineChangeController_.dispose();
                this.stopABRTimer_();
                if (this.updateDuration_) this.mediaSource.removeEventListener("sourceopen", this.updateDuration_);
                this.mediaSource.removeEventListener("durationchange", this.handleDurationChange_);
                this.mediaSource.removeEventListener("sourceopen", this.handleSourceOpen_);
                this.mediaSource.removeEventListener("sourceended", this.handleSourceEnded_);
                this.off();
            }
            main() {
                return this.mainPlaylistLoader_.main;
            }
            media() {
                return this.mainPlaylistLoader_.media() || this.initialMedia_;
            }
            areMediaTypesKnown_() {
                const usingAudioLoader = !!this.mediaTypes_.AUDIO.activePlaylistLoader;
                const hasMainMediaInfo = !!this.mainSegmentLoader_.getCurrentMediaInfo_();
                const hasAudioMediaInfo = !usingAudioLoader ? true : !!this.audioSegmentLoader_.getCurrentMediaInfo_();
                if (!hasMainMediaInfo || !hasAudioMediaInfo) return false;
                return true;
            }
            getCodecsOrExclude_() {
                const media = {
                    main: this.mainSegmentLoader_.getCurrentMediaInfo_() || {},
                    audio: this.audioSegmentLoader_.getCurrentMediaInfo_() || {}
                };
                const playlist = this.mainSegmentLoader_.getPendingSegmentPlaylist() || this.media();
                media.video = media.main;
                const playlistCodecs = app_codecsForPlaylist(this.main(), playlist);
                const codecs = {};
                const usingAudioLoader = !!this.mediaTypes_.AUDIO.activePlaylistLoader;
                if (media.main.hasVideo) codecs.video = playlistCodecs.video || media.main.videoCodec || app_DEFAULT_VIDEO_CODEC;
                if (media.main.isMuxed) codecs.video += `,${playlistCodecs.audio || media.main.audioCodec || app_DEFAULT_AUDIO_CODEC}`;
                if (media.main.hasAudio && !media.main.isMuxed || media.audio.hasAudio || usingAudioLoader) {
                    codecs.audio = playlistCodecs.audio || media.main.audioCodec || media.audio.audioCodec || app_DEFAULT_AUDIO_CODEC;
                    media.audio.isFmp4 = media.main.hasAudio && !media.main.isMuxed ? media.main.isFmp4 : media.audio.isFmp4;
                }
                if (!codecs.audio && !codecs.video) {
                    this.excludePlaylist({
                        playlistToExclude: playlist,
                        error: {
                            message: "Could not determine codecs for playlist."
                        },
                        playlistExclusionDuration: 1 / 0
                    });
                    return;
                }
                const supportFunction = (isFmp4, codec) => isFmp4 ? app_browserSupportsCodec(codec, this.usingManagedMediaSource_) : app_muxerSupportsCodec(codec);
                const unsupportedCodecs = {};
                let unsupportedAudio;
                [ "video", "audio" ].forEach((function(type) {
                    if (codecs.hasOwnProperty(type) && !supportFunction(media[type].isFmp4, codecs[type])) {
                        const supporter = media[type].isFmp4 ? "browser" : "muxer";
                        unsupportedCodecs[supporter] = unsupportedCodecs[supporter] || [];
                        unsupportedCodecs[supporter].push(codecs[type]);
                        if (type === "audio") unsupportedAudio = supporter;
                    }
                }));
                if (usingAudioLoader && unsupportedAudio && playlist.attributes.AUDIO) {
                    const audioGroup = playlist.attributes.AUDIO;
                    this.main().playlists.forEach((variant => {
                        const variantAudioGroup = variant.attributes && variant.attributes.AUDIO;
                        if (variantAudioGroup === audioGroup && variant !== playlist) variant.excludeUntil = 1 / 0;
                    }));
                    this.logger_(`excluding audio group ${audioGroup} as ${unsupportedAudio} does not support codec(s): "${codecs.audio}"`);
                }
                if (Object.keys(unsupportedCodecs).length) {
                    const message = Object.keys(unsupportedCodecs).reduce(((acc, supporter) => {
                        if (acc) acc += ", ";
                        acc += `${supporter} does not support codec(s): "${unsupportedCodecs[supporter].join(",")}"`;
                        return acc;
                    }), "") + ".";
                    this.excludePlaylist({
                        playlistToExclude: playlist,
                        error: {
                            internal: true,
                            message
                        },
                        playlistExclusionDuration: 1 / 0
                    });
                    return;
                }
                if (this.sourceUpdater_.hasCreatedSourceBuffers() && !this.sourceUpdater_.canChangeType()) {
                    const switchMessages = [];
                    [ "video", "audio" ].forEach((type => {
                        const newCodec = (app_parseCodecs(this.sourceUpdater_.codecs[type] || "")[0] || {}).type;
                        const oldCodec = (app_parseCodecs(codecs[type] || "")[0] || {}).type;
                        if (newCodec && oldCodec && newCodec.toLowerCase() !== oldCodec.toLowerCase()) switchMessages.push(`"${this.sourceUpdater_.codecs[type]}" -> "${codecs[type]}"`);
                    }));
                    if (switchMessages.length) {
                        this.excludePlaylist({
                            playlistToExclude: playlist,
                            error: {
                                message: `Codec switching not supported: ${switchMessages.join(", ")}.`,
                                internal: true
                            },
                            playlistExclusionDuration: 1 / 0
                        });
                        return;
                    }
                }
                return codecs;
            }
            tryToCreateSourceBuffers_() {
                if (this.mediaSource.readyState !== "open" || this.sourceUpdater_.hasCreatedSourceBuffers()) return;
                if (!this.areMediaTypesKnown_()) return;
                const codecs = this.getCodecsOrExclude_();
                if (!codecs) return;
                this.sourceUpdater_.createSourceBuffers(codecs);
                const codecString = [ codecs.video, codecs.audio ].filter(Boolean).join(",");
                this.excludeIncompatibleVariants_(codecString);
            }
            excludeUnsupportedVariants_() {
                const playlists = this.main().playlists;
                const ids = [];
                Object.keys(playlists).forEach((key => {
                    const variant = playlists[key];
                    if (ids.indexOf(variant.id) !== -1) return;
                    ids.push(variant.id);
                    const codecs = app_codecsForPlaylist(this.main, variant);
                    const unsupported = [];
                    if (codecs.audio && !app_muxerSupportsCodec(codecs.audio) && !app_browserSupportsCodec(codecs.audio, this.usingManagedMediaSource_)) unsupported.push(`audio codec ${codecs.audio}`);
                    if (codecs.video && !app_muxerSupportsCodec(codecs.video) && !app_browserSupportsCodec(codecs.video, this.usingManagedMediaSource_)) unsupported.push(`video codec ${codecs.video}`);
                    if (codecs.text && codecs.text === "stpp.ttml.im1t") unsupported.push(`text codec ${codecs.text}`);
                    if (unsupported.length) {
                        variant.excludeUntil = 1 / 0;
                        this.logger_(`excluding ${variant.id} for unsupported: ${unsupported.join(", ")}`);
                    }
                }));
            }
            excludeIncompatibleVariants_(codecString) {
                const ids = [];
                const playlists = this.main().playlists;
                const codecs = app_unwrapCodecList(app_parseCodecs(codecString));
                const codecCount_ = app_codecCount(codecs);
                const videoDetails = codecs.video && app_parseCodecs(codecs.video)[0] || null;
                const audioDetails = codecs.audio && app_parseCodecs(codecs.audio)[0] || null;
                Object.keys(playlists).forEach((key => {
                    const variant = playlists[key];
                    if (ids.indexOf(variant.id) !== -1 || variant.excludeUntil === 1 / 0) return;
                    ids.push(variant.id);
                    const exclusionReasons = [];
                    const variantCodecs = app_codecsForPlaylist(this.mainPlaylistLoader_.main, variant);
                    const variantCodecCount = app_codecCount(variantCodecs);
                    if (!variantCodecs.audio && !variantCodecs.video) return;
                    if (variantCodecCount !== codecCount_) exclusionReasons.push(`codec count "${variantCodecCount}" !== "${codecCount_}"`);
                    if (!this.sourceUpdater_.canChangeType()) {
                        const variantVideoDetails = variantCodecs.video && app_parseCodecs(variantCodecs.video)[0] || null;
                        const variantAudioDetails = variantCodecs.audio && app_parseCodecs(variantCodecs.audio)[0] || null;
                        if (variantVideoDetails && videoDetails && variantVideoDetails.type.toLowerCase() !== videoDetails.type.toLowerCase()) exclusionReasons.push(`video codec "${variantVideoDetails.type}" !== "${videoDetails.type}"`);
                        if (variantAudioDetails && audioDetails && variantAudioDetails.type.toLowerCase() !== audioDetails.type.toLowerCase()) exclusionReasons.push(`audio codec "${variantAudioDetails.type}" !== "${audioDetails.type}"`);
                    }
                    if (exclusionReasons.length) {
                        variant.excludeUntil = 1 / 0;
                        this.logger_(`excluding ${variant.id}: ${exclusionReasons.join(" && ")}`);
                    }
                }));
            }
            updateAdCues_(media) {
                let offset = 0;
                const seekable = this.seekable();
                if (seekable.length) offset = seekable.start(0);
                app_updateAdCues(media, this.cueTagsTrack_, offset);
            }
            goalBufferLength() {
                const currentTime = this.tech_.currentTime();
                const initial = app_Config.GOAL_BUFFER_LENGTH;
                const rate = app_Config.GOAL_BUFFER_LENGTH_RATE;
                const max = Math.max(initial, app_Config.MAX_GOAL_BUFFER_LENGTH);
                return Math.min(initial + currentTime * rate, max);
            }
            bufferLowWaterLine() {
                const currentTime = this.tech_.currentTime();
                const initial = app_Config.BUFFER_LOW_WATER_LINE;
                const rate = app_Config.BUFFER_LOW_WATER_LINE_RATE;
                const max = Math.max(initial, app_Config.MAX_BUFFER_LOW_WATER_LINE);
                const newMax = Math.max(initial, app_Config.EXPERIMENTAL_MAX_BUFFER_LOW_WATER_LINE);
                return Math.min(initial + currentTime * rate, this.bufferBasedABR ? newMax : max);
            }
            bufferHighWaterLine() {
                return app_Config.BUFFER_HIGH_WATER_LINE;
            }
            addDateRangesToTextTrack_(dateRanges) {
                app_createMetadataTrackIfNotExists(this.inbandTextTracks_, "com.apple.streaming", this.tech_);
                app_addDateRangeMetadata({
                    inbandTextTracks: this.inbandTextTracks_,
                    dateRanges
                });
            }
            addMetadataToTextTrack(dispatchType, metadataArray, videoDuration) {
                const timestampOffset = this.sourceUpdater_.videoBuffer ? this.sourceUpdater_.videoTimestampOffset() : this.sourceUpdater_.audioTimestampOffset();
                app_createMetadataTrackIfNotExists(this.inbandTextTracks_, dispatchType, this.tech_);
                app_addMetadata({
                    inbandTextTracks: this.inbandTextTracks_,
                    metadataArray,
                    timestampOffset,
                    videoDuration
                });
            }
            pathwayAttribute_(playlist) {
                return playlist.attributes["PATHWAY-ID"] || playlist.attributes.serviceLocation;
            }
            initContentSteeringController_() {
                const main = this.main();
                if (!main.contentSteering) return;
                for (const playlist of main.playlists) this.contentSteeringController_.addAvailablePathway(this.pathwayAttribute_(playlist));
                this.contentSteeringController_.assignTagProperties(main.uri, main.contentSteering);
                if (this.contentSteeringController_.queryBeforeStart) {
                    this.contentSteeringController_.requestSteeringManifest(true);
                    return;
                }
                this.tech_.one("canplay", (() => {
                    this.contentSteeringController_.requestSteeringManifest();
                }));
            }
            resetContentSteeringController_() {
                this.contentSteeringController_.clearAvailablePathways();
                this.contentSteeringController_.dispose();
                this.initContentSteeringController_();
            }
            attachContentSteeringListeners_() {
                this.contentSteeringController_.on("content-steering", this.excludeThenChangePathway_.bind(this));
                const contentSteeringEvents = [ "contentsteeringloadstart", "contentsteeringloadcomplete", "contentsteeringparsed" ];
                contentSteeringEvents.forEach((eventName => {
                    this.contentSteeringController_.on(eventName, (metadata => {
                        this.trigger(app_extends({}, metadata));
                    }));
                }));
                if (this.sourceType_ === "dash") this.mainPlaylistLoader_.on("loadedplaylist", (() => {
                    const main = this.main();
                    const didDashTagChange = this.contentSteeringController_.didDASHTagChange(main.uri, main.contentSteering);
                    const didPathwaysChange = () => {
                        const availablePathways = this.contentSteeringController_.getAvailablePathways();
                        const newPathways = [];
                        for (const playlist of main.playlists) {
                            const serviceLocation = playlist.attributes.serviceLocation;
                            if (serviceLocation) {
                                newPathways.push(serviceLocation);
                                if (!availablePathways.has(serviceLocation)) return true;
                            }
                        }
                        if (!newPathways.length && availablePathways.size) return true;
                        return false;
                    };
                    if (didDashTagChange || didPathwaysChange()) this.resetContentSteeringController_();
                }));
            }
            excludeThenChangePathway_() {
                const currentPathway = this.contentSteeringController_.getPathway();
                if (!currentPathway) return;
                this.handlePathwayClones_();
                const main = this.main();
                const playlists = main.playlists;
                const ids = new Set;
                let didEnablePlaylists = false;
                Object.keys(playlists).forEach((key => {
                    const variant = playlists[key];
                    const pathwayId = this.pathwayAttribute_(variant);
                    const differentPathwayId = pathwayId && currentPathway !== pathwayId;
                    const steeringExclusion = variant.excludeUntil === 1 / 0 && variant.lastExcludeReason_ === "content-steering";
                    if (steeringExclusion && !differentPathwayId) {
                        delete variant.excludeUntil;
                        delete variant.lastExcludeReason_;
                        didEnablePlaylists = true;
                    }
                    const noExcludeUntil = !variant.excludeUntil && variant.excludeUntil !== 1 / 0;
                    const shouldExclude = !ids.has(variant.id) && differentPathwayId && noExcludeUntil;
                    if (!shouldExclude) return;
                    ids.add(variant.id);
                    variant.excludeUntil = 1 / 0;
                    variant.lastExcludeReason_ = "content-steering";
                    this.logger_(`excluding ${variant.id} for ${variant.lastExcludeReason_}`);
                }));
                if (this.contentSteeringController_.manifestType_ === "DASH") Object.keys(this.mediaTypes_).forEach((key => {
                    const type = this.mediaTypes_[key];
                    if (type.activePlaylistLoader) {
                        const currentPlaylist = type.activePlaylistLoader.media_;
                        if (currentPlaylist && currentPlaylist.attributes.serviceLocation !== currentPathway) didEnablePlaylists = true;
                    }
                }));
                if (didEnablePlaylists) this.changeSegmentPathway_();
            }
            handlePathwayClones_() {
                const main = this.main();
                const playlists = main.playlists;
                const currentPathwayClones = this.contentSteeringController_.currentPathwayClones;
                const nextPathwayClones = this.contentSteeringController_.nextPathwayClones;
                const hasClones = currentPathwayClones && currentPathwayClones.size || nextPathwayClones && nextPathwayClones.size;
                if (!hasClones) return;
                for (const [id, clone] of currentPathwayClones.entries()) {
                    const newClone = nextPathwayClones.get(id);
                    if (!newClone) {
                        this.mainPlaylistLoader_.updateOrDeleteClone(clone);
                        this.contentSteeringController_.excludePathway(id);
                    }
                }
                for (const [id, clone] of nextPathwayClones.entries()) {
                    const oldClone = currentPathwayClones.get(id);
                    if (!oldClone) {
                        const playlistsToClone = playlists.filter((p => p.attributes["PATHWAY-ID"] === clone["BASE-ID"]));
                        playlistsToClone.forEach((p => {
                            this.mainPlaylistLoader_.addClonePathway(clone, p);
                        }));
                        this.contentSteeringController_.addAvailablePathway(id);
                        continue;
                    }
                    if (this.equalPathwayClones_(oldClone, clone)) continue;
                    this.mainPlaylistLoader_.updateOrDeleteClone(clone, true);
                    this.contentSteeringController_.addAvailablePathway(id);
                }
                this.contentSteeringController_.currentPathwayClones = new Map(JSON.parse(JSON.stringify([ ...nextPathwayClones ])));
            }
            equalPathwayClones_(a, b) {
                if (a["BASE-ID"] !== b["BASE-ID"] || a.ID !== b.ID || a["URI-REPLACEMENT"].HOST !== b["URI-REPLACEMENT"].HOST) return false;
                const aParams = a["URI-REPLACEMENT"].PARAMS;
                const bParams = b["URI-REPLACEMENT"].PARAMS;
                for (const p in aParams) if (aParams[p] !== bParams[p]) return false;
                for (const p in bParams) if (aParams[p] !== bParams[p]) return false;
                return true;
            }
            changeSegmentPathway_() {
                const nextPlaylist = this.selectPlaylist();
                this.pauseLoading();
                if (this.contentSteeringController_.manifestType_ === "DASH") this.switchMediaForDASHContentSteering_();
                this.switchMedia_(nextPlaylist, "content-steering");
            }
            excludeNonUsablePlaylistsByKeyId_() {
                if (!this.mainPlaylistLoader_ || !this.mainPlaylistLoader_.main) return;
                let nonUsableKeyStatusCount = 0;
                const NON_USABLE = "non-usable";
                this.mainPlaylistLoader_.main.playlists.forEach((playlist => {
                    const keyIdSet = this.mainPlaylistLoader_.getKeyIdSet(playlist);
                    if (!keyIdSet || !keyIdSet.size) return;
                    keyIdSet.forEach((key => {
                        const USABLE = "usable";
                        const hasUsableKeyStatus = this.keyStatusMap_.has(key) && this.keyStatusMap_.get(key) === USABLE;
                        const nonUsableExclusion = playlist.lastExcludeReason_ === NON_USABLE && playlist.excludeUntil === 1 / 0;
                        if (!hasUsableKeyStatus) {
                            if (playlist.excludeUntil !== 1 / 0 && playlist.lastExcludeReason_ !== NON_USABLE) {
                                playlist.excludeUntil = 1 / 0;
                                playlist.lastExcludeReason_ = NON_USABLE;
                                this.logger_(`excluding playlist ${playlist.id} because the key ID ${key} doesn't exist in the keyStatusMap or is not ${USABLE}`);
                            }
                            nonUsableKeyStatusCount++;
                        } else if (hasUsableKeyStatus && nonUsableExclusion) {
                            delete playlist.excludeUntil;
                            delete playlist.lastExcludeReason_;
                            this.logger_(`enabling playlist ${playlist.id} because key ID ${key} is ${USABLE}`);
                        }
                    }));
                }));
                if (nonUsableKeyStatusCount >= this.mainPlaylistLoader_.main.playlists.length) this.mainPlaylistLoader_.main.playlists.forEach((playlist => {
                    const isNonHD = playlist && playlist.attributes && playlist.attributes.RESOLUTION && playlist.attributes.RESOLUTION.height < 720;
                    const excludedForNonUsableKey = playlist.excludeUntil === 1 / 0 && playlist.lastExcludeReason_ === NON_USABLE;
                    if (isNonHD && excludedForNonUsableKey) {
                        delete playlist.excludeUntil;
                        app_videojs.log.warn(`enabling non-HD playlist ${playlist.id} because all playlists were excluded due to ${NON_USABLE} key IDs`);
                    }
                }));
            }
            addKeyStatus_(keyId, status) {
                const isString = typeof keyId === "string";
                const keyIdHexString = isString ? keyId : app_bufferToHexString(keyId);
                const formattedKeyIdString = keyIdHexString.slice(0, 32).toLowerCase();
                this.logger_(`KeyStatus '${status}' with key ID ${formattedKeyIdString} added to the keyStatusMap`);
                this.keyStatusMap_.set(formattedKeyIdString, status);
            }
            updatePlaylistByKeyStatus(keyId, status) {
                this.addKeyStatus_(keyId, status);
                if (!this.waitingForFastQualityPlaylistReceived_) this.excludeNonUsableThenChangePlaylist_();
                this.mainPlaylistLoader_.off("loadedplaylist", this.excludeNonUsableThenChangePlaylist_.bind(this));
                this.mainPlaylistLoader_.on("loadedplaylist", this.excludeNonUsableThenChangePlaylist_.bind(this));
            }
            excludeNonUsableThenChangePlaylist_() {
                this.excludeNonUsablePlaylistsByKeyId_();
                this.fastQualityChange_();
            }
        }
        const app_enableFunction = (loader, playlistID, changePlaylistFn) => enable => {
            const playlist = loader.main.playlists[playlistID];
            const incompatible = app_isIncompatible(playlist);
            const currentlyEnabled = app_isEnabled(playlist);
            if (typeof enable === "undefined") return currentlyEnabled;
            if (enable) delete playlist.disabled; else playlist.disabled = true;
            const metadata = {
                renditionInfo: {
                    id: playlistID,
                    bandwidth: playlist.attributes.BANDWIDTH,
                    resolution: playlist.attributes.RESOLUTION,
                    codecs: playlist.attributes.CODECS
                },
                cause: "fast-quality"
            };
            if (enable !== currentlyEnabled && !incompatible) if (enable) {
                changePlaylistFn(playlist);
                loader.trigger({
                    type: "renditionenabled",
                    metadata
                });
            } else loader.trigger({
                type: "renditiondisabled",
                metadata
            });
            return enable;
        };
        class app_Representation {
            constructor(vhsHandler, playlist, id) {
                const {playlistController_: pc} = vhsHandler;
                const qualityChangeFunction = pc.fastQualityChange_.bind(pc);
                if (playlist.attributes) {
                    const resolution = playlist.attributes.RESOLUTION;
                    this.width = resolution && resolution.width;
                    this.height = resolution && resolution.height;
                    this.bandwidth = playlist.attributes.BANDWIDTH;
                    this.frameRate = playlist.attributes["FRAME-RATE"];
                }
                this.codecs = app_codecsForPlaylist(pc.main(), playlist);
                this.playlist = playlist;
                this.id = id;
                this.enabled = app_enableFunction(vhsHandler.playlists, playlist.id, qualityChangeFunction);
            }
        }
        const app_renditionSelectionMixin = function(vhsHandler) {
            vhsHandler.representations = () => {
                const main = vhsHandler.playlistController_.main();
                const playlists = app_isAudioOnly(main) ? vhsHandler.playlistController_.getAudioTrackPlaylists_() : main.playlists;
                if (!playlists) return [];
                return playlists.filter((media => !app_isIncompatible(media))).map(((e, i) => new app_Representation(vhsHandler, e, e.id)));
            };
        };
        const app_timerCancelEvents = [ "seeking", "seeked", "pause", "playing", "error" ];
        class app_PlaybackWatcher extends app_videojs.EventTarget {
            constructor(options) {
                super();
                this.playlistController_ = options.playlistController;
                this.tech_ = options.tech;
                this.seekable = options.seekable;
                this.allowSeeksWithinUnsafeLiveWindow = options.allowSeeksWithinUnsafeLiveWindow;
                this.liveRangeSafeTimeDelta = options.liveRangeSafeTimeDelta;
                this.media = options.media;
                this.playedRanges_ = [];
                this.consecutiveUpdates = 0;
                this.lastRecordedTime = null;
                this.checkCurrentTimeTimeout_ = null;
                this.logger_ = app_logger("PlaybackWatcher");
                this.logger_("initialize");
                const playHandler = () => this.monitorCurrentTime_();
                const canPlayHandler = () => this.monitorCurrentTime_();
                const waitingHandler = () => this.techWaiting_();
                const cancelTimerHandler = () => this.resetTimeUpdate_();
                const pc = this.playlistController_;
                const loaderTypes = [ "main", "subtitle", "audio" ];
                const loaderChecks = {};
                loaderTypes.forEach((type => {
                    loaderChecks[type] = {
                        reset: () => this.resetSegmentDownloads_(type),
                        updateend: () => this.checkSegmentDownloads_(type)
                    };
                    pc[`${type}SegmentLoader_`].on("appendsdone", loaderChecks[type].updateend);
                    pc[`${type}SegmentLoader_`].on("playlistupdate", loaderChecks[type].reset);
                    this.tech_.on([ "seeked", "seeking" ], loaderChecks[type].reset);
                }));
                const setSeekingHandlers = fn => {
                    [ "main", "audio" ].forEach((type => {
                        pc[`${type}SegmentLoader_`][fn]("appended", this.seekingAppendCheck_);
                    }));
                };
                this.seekingAppendCheck_ = () => {
                    if (this.fixesBadSeeks_()) {
                        this.consecutiveUpdates = 0;
                        this.lastRecordedTime = this.tech_.currentTime();
                        setSeekingHandlers("off");
                    }
                };
                this.clearSeekingAppendCheck_ = () => setSeekingHandlers("off");
                this.watchForBadSeeking_ = () => {
                    this.clearSeekingAppendCheck_();
                    setSeekingHandlers("on");
                };
                this.tech_.on("seeked", this.clearSeekingAppendCheck_);
                this.tech_.on("seeking", this.watchForBadSeeking_);
                this.tech_.on("waiting", waitingHandler);
                this.tech_.on(app_timerCancelEvents, cancelTimerHandler);
                this.tech_.on("canplay", canPlayHandler);
                this.tech_.one("play", playHandler);
                this.dispose = () => {
                    this.clearSeekingAppendCheck_();
                    this.logger_("dispose");
                    this.tech_.off("waiting", waitingHandler);
                    this.tech_.off(app_timerCancelEvents, cancelTimerHandler);
                    this.tech_.off("canplay", canPlayHandler);
                    this.tech_.off("play", playHandler);
                    this.tech_.off("seeking", this.watchForBadSeeking_);
                    this.tech_.off("seeked", this.clearSeekingAppendCheck_);
                    loaderTypes.forEach((type => {
                        pc[`${type}SegmentLoader_`].off("appendsdone", loaderChecks[type].updateend);
                        pc[`${type}SegmentLoader_`].off("playlistupdate", loaderChecks[type].reset);
                        this.tech_.off([ "seeked", "seeking" ], loaderChecks[type].reset);
                    }));
                    if (this.checkCurrentTimeTimeout_) app_window_default().clearTimeout(this.checkCurrentTimeTimeout_);
                    this.resetTimeUpdate_();
                };
            }
            monitorCurrentTime_() {
                this.checkCurrentTime_();
                if (this.checkCurrentTimeTimeout_) app_window_default().clearTimeout(this.checkCurrentTimeTimeout_);
                this.checkCurrentTimeTimeout_ = app_window_default().setTimeout(this.monitorCurrentTime_.bind(this), 250);
            }
            resetSegmentDownloads_(type) {
                const loader = this.playlistController_[`${type}SegmentLoader_`];
                if (this[`${type}StalledDownloads_`] > 0) this.logger_(`resetting possible stalled download count for ${type} loader`);
                this[`${type}StalledDownloads_`] = 0;
                this[`${type}Buffered_`] = loader.buffered_();
            }
            checkSegmentDownloads_(type) {
                const pc = this.playlistController_;
                const loader = pc[`${type}SegmentLoader_`];
                const buffered = loader.buffered_();
                const isBufferedDifferent = app_isRangeDifferent(this[`${type}Buffered_`], buffered);
                this[`${type}Buffered_`] = buffered;
                if (isBufferedDifferent) {
                    const metadata = {
                        bufferedRanges: buffered
                    };
                    pc.trigger({
                        type: "bufferedrangeschanged",
                        metadata
                    });
                    this.resetSegmentDownloads_(type);
                    return;
                }
                this[`${type}StalledDownloads_`]++;
                this.logger_(`found #${this[`${type}StalledDownloads_`]} ${type} appends that did not increase buffer (possible stalled download)`, {
                    playlistId: loader.playlist_ && loader.playlist_.id,
                    buffered: app_timeRangesToArray(buffered)
                });
                if (this[`${type}StalledDownloads_`] < 10) return;
                this.logger_(`${type} loader stalled download exclusion`);
                this.resetSegmentDownloads_(type);
                this.tech_.trigger({
                    type: "usage",
                    name: `vhs-${type}-download-exclusion`
                });
                if (type === "subtitle") return;
                pc.excludePlaylist({
                    error: {
                        message: `Excessive ${type} segment downloading detected.`
                    },
                    playlistExclusionDuration: 1 / 0
                });
            }
            checkCurrentTime_() {
                if (this.tech_.paused() || this.tech_.seeking()) return;
                const currentTime = this.tech_.currentTime();
                const buffered = this.tech_.buffered();
                if (this.lastRecordedTime === currentTime && (!buffered.length || currentTime + app_SAFE_TIME_DELTA >= buffered.end(buffered.length - 1))) return this.techWaiting_();
                if (this.consecutiveUpdates >= 5 && currentTime === this.lastRecordedTime) {
                    this.consecutiveUpdates++;
                    this.waiting_();
                } else if (currentTime === this.lastRecordedTime) this.consecutiveUpdates++; else {
                    this.playedRanges_.push(app_createTimeRanges([ this.lastRecordedTime, currentTime ]));
                    const metadata = {
                        playedRanges: this.playedRanges_
                    };
                    this.playlistController_.trigger({
                        type: "playedrangeschanged",
                        metadata
                    });
                    this.consecutiveUpdates = 0;
                    this.lastRecordedTime = currentTime;
                }
            }
            resetTimeUpdate_() {
                this.consecutiveUpdates = 0;
            }
            fixesBadSeeks_() {
                const seeking = this.tech_.seeking();
                if (!seeking) return false;
                const seekable = this.seekable();
                const currentTime = this.tech_.currentTime();
                const isAfterSeekableRange = this.afterSeekableWindow_(seekable, currentTime, this.media(), this.allowSeeksWithinUnsafeLiveWindow);
                let seekTo;
                if (isAfterSeekableRange) {
                    const seekableEnd = seekable.end(seekable.length - 1);
                    seekTo = seekableEnd;
                }
                if (this.beforeSeekableWindow_(seekable, currentTime)) {
                    const seekableStart = seekable.start(0);
                    seekTo = seekableStart + (seekableStart === seekable.end(0) ? 0 : app_SAFE_TIME_DELTA);
                }
                if (typeof seekTo !== "undefined") {
                    this.logger_(`Trying to seek outside of seekable at time ${currentTime} with ` + `seekable range ${app_printableRange(seekable)}. Seeking to ` + `${seekTo}.`);
                    this.tech_.setCurrentTime(seekTo);
                    return true;
                }
                const sourceUpdater = this.playlistController_.sourceUpdater_;
                const buffered = this.tech_.buffered();
                const audioBuffered = sourceUpdater.audioBuffer ? sourceUpdater.audioBuffered() : null;
                const videoBuffered = sourceUpdater.videoBuffer ? sourceUpdater.videoBuffered() : null;
                const media = this.media();
                const minAppendedDuration = media.partTargetDuration ? media.partTargetDuration : (media.targetDuration - app_TIME_FUDGE_FACTOR) * 2;
                const bufferedToCheck = [ audioBuffered, videoBuffered ];
                for (let i = 0; i < bufferedToCheck.length; i++) {
                    if (!bufferedToCheck[i]) continue;
                    const timeAhead = app_timeAheadOf(bufferedToCheck[i], currentTime);
                    if (timeAhead < minAppendedDuration) return false;
                }
                const nextRange = app_findNextRange(buffered, currentTime);
                if (nextRange.length === 0) return false;
                seekTo = nextRange.start(0) + app_SAFE_TIME_DELTA;
                this.logger_(`Buffered region starts (${nextRange.start(0)}) ` + ` just beyond seek point (${currentTime}). Seeking to ${seekTo}.`);
                this.tech_.setCurrentTime(seekTo);
                return true;
            }
            waiting_() {
                if (this.techWaiting_()) return;
                const currentTime = this.tech_.currentTime();
                const buffered = this.tech_.buffered();
                const currentRange = app_findRange(buffered, currentTime);
                if (currentRange.length && currentTime + 3 <= currentRange.end(0)) {
                    this.resetTimeUpdate_();
                    this.tech_.setCurrentTime(currentTime);
                    this.logger_(`Stopped at ${currentTime} while inside a buffered region ` + `[${currentRange.start(0)} -> ${currentRange.end(0)}]. Attempting to resume ` + "playback by seeking to the current time.");
                    this.tech_.trigger({
                        type: "usage",
                        name: "vhs-unknown-waiting"
                    });
                    return;
                }
            }
            techWaiting_() {
                const seekable = this.seekable();
                const currentTime = this.tech_.currentTime();
                if (this.tech_.seeking()) return true;
                if (this.beforeSeekableWindow_(seekable, currentTime)) {
                    const livePoint = seekable.end(seekable.length - 1);
                    this.logger_(`Fell out of live window at time ${currentTime}. Seeking to ` + `live point (seekable end) ${livePoint}`);
                    this.resetTimeUpdate_();
                    this.tech_.setCurrentTime(livePoint);
                    this.tech_.trigger({
                        type: "usage",
                        name: "vhs-live-resync"
                    });
                    return true;
                }
                const sourceUpdater = this.tech_.vhs.playlistController_.sourceUpdater_;
                const buffered = this.tech_.buffered();
                const videoUnderflow = this.videoUnderflow_({
                    audioBuffered: sourceUpdater.audioBuffered(),
                    videoBuffered: sourceUpdater.videoBuffered(),
                    currentTime
                });
                if (videoUnderflow) {
                    this.resetTimeUpdate_();
                    this.tech_.setCurrentTime(currentTime);
                    this.tech_.trigger({
                        type: "usage",
                        name: "vhs-video-underflow"
                    });
                    return true;
                }
                const nextRange = app_findNextRange(buffered, currentTime);
                if (nextRange.length > 0) {
                    this.logger_(`Stopped at ${currentTime} and seeking to ${nextRange.start(0)}`);
                    this.resetTimeUpdate_();
                    this.skipTheGap_(currentTime);
                    return true;
                }
                return false;
            }
            afterSeekableWindow_(seekable, currentTime, playlist, allowSeeksWithinUnsafeLiveWindow = false) {
                if (!seekable.length) return false;
                let allowedEnd = seekable.end(seekable.length - 1) + app_SAFE_TIME_DELTA;
                const isLive = !playlist.endList;
                const isLLHLS = typeof playlist.partTargetDuration === "number";
                if (isLive && (isLLHLS || allowSeeksWithinUnsafeLiveWindow)) allowedEnd = seekable.end(seekable.length - 1) + playlist.targetDuration * 3;
                if (currentTime > allowedEnd) return true;
                return false;
            }
            beforeSeekableWindow_(seekable, currentTime) {
                if (seekable.length && seekable.start(0) > 0 && currentTime < seekable.start(0) - this.liveRangeSafeTimeDelta) return true;
                return false;
            }
            videoUnderflow_({videoBuffered, audioBuffered, currentTime}) {
                if (!videoBuffered) return;
                let gap;
                if (videoBuffered.length && audioBuffered.length) {
                    const lastVideoRange = app_findRange(videoBuffered, currentTime - 3);
                    const videoRange = app_findRange(videoBuffered, currentTime);
                    const audioRange = app_findRange(audioBuffered, currentTime);
                    if (audioRange.length && !videoRange.length && lastVideoRange.length) gap = {
                        start: lastVideoRange.end(0),
                        end: audioRange.end(0)
                    };
                } else {
                    const nextRange = app_findNextRange(videoBuffered, currentTime);
                    if (!nextRange.length) gap = this.gapFromVideoUnderflow_(videoBuffered, currentTime);
                }
                if (gap) {
                    this.logger_(`Encountered a gap in video from ${gap.start} to ${gap.end}. ` + `Seeking to current time ${currentTime}`);
                    return true;
                }
                return false;
            }
            skipTheGap_(scheduledCurrentTime) {
                const buffered = this.tech_.buffered();
                const currentTime = this.tech_.currentTime();
                const nextRange = app_findNextRange(buffered, currentTime);
                this.resetTimeUpdate_();
                if (nextRange.length === 0 || currentTime !== scheduledCurrentTime) return;
                this.logger_("skipTheGap_:", "currentTime:", currentTime, "scheduled currentTime:", scheduledCurrentTime, "nextRange start:", nextRange.start(0));
                this.tech_.setCurrentTime(nextRange.start(0) + app_TIME_FUDGE_FACTOR);
                const metadata = {
                    gapInfo: {
                        from: currentTime,
                        to: nextRange.start(0)
                    }
                };
                this.playlistController_.trigger({
                    type: "gapjumped",
                    metadata
                });
                this.tech_.trigger({
                    type: "usage",
                    name: "vhs-gap-skip"
                });
            }
            gapFromVideoUnderflow_(buffered, currentTime) {
                const gaps = app_findGaps(buffered);
                for (let i = 0; i < gaps.length; i++) {
                    const start = gaps.start(i);
                    const end = gaps.end(i);
                    if (currentTime - start < 4 && currentTime - start > 2) return {
                        start,
                        end
                    };
                }
                return null;
            }
        }
        const app_defaultOptions = {
            errorInterval: 30,
            getSource(next) {
                const tech = this.tech({
                    IWillNotUseThisInPlugins: true
                });
                const sourceObj = tech.currentSource_ || this.currentSource();
                return next(sourceObj);
            }
        };
        const app_initPlugin = function(player, options) {
            let lastCalled = 0;
            let seekTo = 0;
            const localOptions = app_video_es_merge(app_defaultOptions, options);
            player.ready((() => {
                player.trigger({
                    type: "usage",
                    name: "vhs-error-reload-initialized"
                });
            }));
            const loadedMetadataHandler = function() {
                if (seekTo) player.currentTime(seekTo);
            };
            const setSource = function(sourceObj) {
                if (sourceObj === null || sourceObj === void 0) return;
                seekTo = player.duration() !== 1 / 0 && player.currentTime() || 0;
                player.one("loadedmetadata", loadedMetadataHandler);
                player.src(sourceObj);
                player.trigger({
                    type: "usage",
                    name: "vhs-error-reload"
                });
                player.play();
            };
            const errorHandler = function() {
                if (Date.now() - lastCalled < localOptions.errorInterval * 1e3) {
                    player.trigger({
                        type: "usage",
                        name: "vhs-error-reload-canceled"
                    });
                    return;
                }
                if (!localOptions.getSource || typeof localOptions.getSource !== "function") {
                    app_videojs.log.error("ERROR: reloadSourceOnError - The option getSource must be a function!");
                    return;
                }
                lastCalled = Date.now();
                return localOptions.getSource.call(player, setSource);
            };
            const cleanupEvents = function() {
                player.off("loadedmetadata", loadedMetadataHandler);
                player.off("error", errorHandler);
                player.off("dispose", cleanupEvents);
            };
            const reinitPlugin = function(newOptions) {
                cleanupEvents();
                app_initPlugin(player, newOptions);
            };
            player.on("error", errorHandler);
            player.on("dispose", cleanupEvents);
            player.reloadSourceOnError = reinitPlugin;
        };
        const app_reloadSourceOnError = function(options) {
            app_initPlugin(this, options);
        };
        var app_version$4 = "3.16.2";
        var app_version$3 = "7.1.0";
        var app_version$2 = "1.3.1";
        var app_version$1 = "7.2.0";
        var app_video_es_version = "4.0.2";
        const app_Vhs = {
            PlaylistLoader: app_PlaylistLoader,
            Playlist: app_Playlist,
            utils: app_utils,
            STANDARD_PLAYLIST_SELECTOR: app_lastBandwidthSelector,
            INITIAL_PLAYLIST_SELECTOR: app_lowestBitrateCompatibleVariantSelector,
            lastBandwidthSelector: app_lastBandwidthSelector,
            movingAverageBandwidthSelector: app_movingAverageBandwidthSelector,
            comparePlaylistBandwidth: app_comparePlaylistBandwidth,
            comparePlaylistResolution: app_comparePlaylistResolution,
            xhr: app_xhrFactory()
        };
        Object.keys(app_Config).forEach((prop => {
            Object.defineProperty(app_Vhs, prop, {
                get() {
                    app_videojs.log.warn(`using Vhs.${prop} is UNSAFE be sure you know what you are doing`);
                    return app_Config[prop];
                },
                set(value) {
                    app_videojs.log.warn(`using Vhs.${prop} is UNSAFE be sure you know what you are doing`);
                    if (typeof value !== "number" || value < 0) {
                        app_videojs.log.warn(`value of Vhs.${prop} must be greater than or equal to 0`);
                        return;
                    }
                    app_Config[prop] = value;
                }
            });
        }));
        const app_LOCAL_STORAGE_KEY = "videojs-vhs";
        const app_handleVhsMediaChange = function(qualityLevels, playlistLoader) {
            const newPlaylist = playlistLoader.media();
            let selectedIndex = -1;
            for (let i = 0; i < qualityLevels.length; i++) if (qualityLevels[i].id === newPlaylist.id) {
                selectedIndex = i;
                break;
            }
            qualityLevels.selectedIndex_ = selectedIndex;
            qualityLevels.trigger({
                selectedIndex,
                type: "change"
            });
        };
        const app_handleVhsLoadedMetadata = function(qualityLevels, vhs) {
            vhs.representations().forEach((rep => {
                qualityLevels.addQualityLevel(rep);
            }));
            app_handleVhsMediaChange(qualityLevels, vhs.playlists);
        };
        app_Vhs.canPlaySource = function() {
            return app_videojs.log.warn("VHS is no longer a tech. Please remove it from " + "your player's techOrder.");
        };
        const app_emeKeySystems = (keySystemOptions, mainPlaylist, audioPlaylist) => {
            if (!keySystemOptions) return keySystemOptions;
            let codecs = {};
            if (mainPlaylist && mainPlaylist.attributes && mainPlaylist.attributes.CODECS) codecs = app_unwrapCodecList(app_parseCodecs(mainPlaylist.attributes.CODECS));
            if (audioPlaylist && audioPlaylist.attributes && audioPlaylist.attributes.CODECS) codecs.audio = audioPlaylist.attributes.CODECS;
            const videoContentType = app_getMimeForCodec(codecs.video);
            const audioContentType = app_getMimeForCodec(codecs.audio);
            const keySystemContentTypes = {};
            for (const keySystem in keySystemOptions) {
                keySystemContentTypes[keySystem] = {};
                if (audioContentType) keySystemContentTypes[keySystem].audioContentType = audioContentType;
                if (videoContentType) keySystemContentTypes[keySystem].videoContentType = videoContentType;
                if (mainPlaylist.contentProtection && mainPlaylist.contentProtection[keySystem] && mainPlaylist.contentProtection[keySystem].pssh) keySystemContentTypes[keySystem].pssh = mainPlaylist.contentProtection[keySystem].pssh;
                if (typeof keySystemOptions[keySystem] === "string") keySystemContentTypes[keySystem].url = keySystemOptions[keySystem];
            }
            return app_video_es_merge(keySystemOptions, keySystemContentTypes);
        };
        const app_getAllPsshKeySystemsOptions = (playlists, keySystems) => playlists.reduce(((keySystemsArr, playlist) => {
            if (!playlist.contentProtection) return keySystemsArr;
            const keySystemsOptions = keySystems.reduce(((keySystemsObj, keySystem) => {
                const keySystemOptions = playlist.contentProtection[keySystem];
                if (keySystemOptions && keySystemOptions.pssh) keySystemsObj[keySystem] = {
                    pssh: keySystemOptions.pssh
                };
                return keySystemsObj;
            }), {});
            if (Object.keys(keySystemsOptions).length) keySystemsArr.push(keySystemsOptions);
            return keySystemsArr;
        }), []);
        const app_waitForKeySessionCreation = ({player, sourceKeySystems, audioMedia, mainPlaylists}) => {
            if (!player.eme.initializeMediaKeys) return Promise.resolve();
            const playlists = audioMedia ? mainPlaylists.concat([ audioMedia ]) : mainPlaylists;
            const keySystemsOptionsArr = app_getAllPsshKeySystemsOptions(playlists, Object.keys(sourceKeySystems));
            const initializationFinishedPromises = [];
            const keySessionCreatedPromises = [];
            keySystemsOptionsArr.forEach((keySystemsOptions => {
                keySessionCreatedPromises.push(new Promise(((resolve, reject) => {
                    player.tech_.one("keysessioncreated", resolve);
                })));
                initializationFinishedPromises.push(new Promise(((resolve, reject) => {
                    player.eme.initializeMediaKeys({
                        keySystems: keySystemsOptions
                    }, (err => {
                        if (err) {
                            reject(err);
                            return;
                        }
                        resolve();
                    }));
                })));
            }));
            return Promise.race([ Promise.all(initializationFinishedPromises), Promise.race(keySessionCreatedPromises) ]);
        };
        const app_setupEmeOptions = ({player, sourceKeySystems, media, audioMedia}) => {
            const sourceOptions = app_emeKeySystems(sourceKeySystems, media, audioMedia);
            if (!sourceOptions) return false;
            player.currentSource().keySystems = sourceOptions;
            if (sourceOptions && !player.eme) {
                app_videojs.log.warn("DRM encrypted source cannot be decrypted without a DRM plugin");
                return false;
            }
            return true;
        };
        const app_getVhsLocalStorage = () => {
            if (!app_window_default().localStorage) return null;
            const storedObject = app_window_default().localStorage.getItem(app_LOCAL_STORAGE_KEY);
            if (!storedObject) return null;
            try {
                return JSON.parse(storedObject);
            } catch (e) {
                return null;
            }
        };
        const app_updateVhsLocalStorage = options => {
            if (!app_window_default().localStorage) return false;
            let objectToStore = app_getVhsLocalStorage();
            objectToStore = objectToStore ? app_video_es_merge(objectToStore, options) : options;
            try {
                app_window_default().localStorage.setItem(app_LOCAL_STORAGE_KEY, JSON.stringify(objectToStore));
            } catch (e) {
                return false;
            }
            return objectToStore;
        };
        const app_expandDataUri = dataUri => {
            if (dataUri.toLowerCase().indexOf("data:application/vnd.videojs.vhs+json,") === 0) return JSON.parse(dataUri.substring(dataUri.indexOf(",") + 1));
            return dataUri;
        };
        const app_addOnRequestHook = (xhr, callback) => {
            if (!xhr._requestCallbackSet) xhr._requestCallbackSet = new Set;
            xhr._requestCallbackSet.add(callback);
        };
        const app_addOnResponseHook = (xhr, callback) => {
            if (!xhr._responseCallbackSet) xhr._responseCallbackSet = new Set;
            xhr._responseCallbackSet.add(callback);
        };
        const app_removeOnRequestHook = (xhr, callback) => {
            if (!xhr._requestCallbackSet) return;
            xhr._requestCallbackSet.delete(callback);
            if (!xhr._requestCallbackSet.size) delete xhr._requestCallbackSet;
        };
        const app_removeOnResponseHook = (xhr, callback) => {
            if (!xhr._responseCallbackSet) return;
            xhr._responseCallbackSet.delete(callback);
            if (!xhr._responseCallbackSet.size) delete xhr._responseCallbackSet;
        };
        app_Vhs.supportsNativeHls = function() {
            if (!app_document_default() || !app_document_default().createElement) return false;
            const video = app_document_default().createElement("video");
            if (!app_videojs.getTech("Html5").isSupported()) return false;
            const canPlay = [ "application/vnd.apple.mpegurl", "audio/mpegurl", "audio/x-mpegurl", "application/x-mpegurl", "video/x-mpegurl", "video/mpegurl", "application/mpegurl" ];
            return canPlay.some((function(canItPlay) {
                return /maybe|probably/i.test(video.canPlayType(canItPlay));
            }));
        }();
        app_Vhs.supportsNativeDash = function() {
            if (!app_document_default() || !app_document_default().createElement || !app_videojs.getTech("Html5").isSupported()) return false;
            return /maybe|probably/i.test(app_document_default().createElement("video").canPlayType("application/dash+xml"));
        }();
        app_Vhs.supportsTypeNatively = type => {
            if (type === "hls") return app_Vhs.supportsNativeHls;
            if (type === "dash") return app_Vhs.supportsNativeDash;
            return false;
        };
        app_Vhs.isSupported = function() {
            return app_videojs.log.warn("VHS is no longer a tech. Please remove it from " + "your player's techOrder.");
        };
        app_Vhs.xhr.onRequest = function(callback) {
            app_addOnRequestHook(app_Vhs.xhr, callback);
        };
        app_Vhs.xhr.onResponse = function(callback) {
            app_addOnResponseHook(app_Vhs.xhr, callback);
        };
        app_Vhs.xhr.offRequest = function(callback) {
            app_removeOnRequestHook(app_Vhs.xhr, callback);
        };
        app_Vhs.xhr.offResponse = function(callback) {
            app_removeOnResponseHook(app_Vhs.xhr, callback);
        };
        const app_Component = app_videojs.getComponent("Component");
        class app_VhsHandler extends app_Component {
            constructor(source, tech, options) {
                super(tech, options.vhs);
                if (typeof options.initialBandwidth === "number") this.options_.bandwidth = options.initialBandwidth;
                this.logger_ = app_logger("VhsHandler");
                if (tech.options_ && tech.options_.playerId) {
                    const _player = app_videojs.getPlayer(tech.options_.playerId);
                    this.player_ = _player;
                }
                this.tech_ = tech;
                this.source_ = source;
                this.stats = {};
                this.ignoreNextSeekingEvent_ = false;
                this.setOptions_();
                if (this.options_.overrideNative && tech.overrideNativeAudioTracks && tech.overrideNativeVideoTracks) {
                    tech.overrideNativeAudioTracks(true);
                    tech.overrideNativeVideoTracks(true);
                } else if (this.options_.overrideNative && (tech.featuresNativeVideoTracks || tech.featuresNativeAudioTracks)) throw new Error("Overriding native VHS requires emulated tracks. " + "See https://git.io/vMpjB");
                this.on(app_document_default(), [ "fullscreenchange", "webkitfullscreenchange", "mozfullscreenchange", "MSFullscreenChange" ], (event => {
                    const fullscreenElement = app_document_default().fullscreenElement || app_document_default().webkitFullscreenElement || app_document_default().mozFullScreenElement || app_document_default().msFullscreenElement;
                    if (fullscreenElement && fullscreenElement.contains(this.tech_.el())) this.playlistController_.fastQualityChange_(); else this.playlistController_.checkABR_();
                }));
                this.on(this.tech_, "seeking", (function() {
                    if (this.ignoreNextSeekingEvent_) {
                        this.ignoreNextSeekingEvent_ = false;
                        return;
                    }
                    this.setCurrentTime(this.tech_.currentTime());
                }));
                this.on(this.tech_, "error", (function() {
                    if (this.tech_.error() && this.playlistController_) this.playlistController_.pauseLoading();
                }));
                this.on(this.tech_, "play", this.play);
            }
            setOptions_(options = {}) {
                this.options_ = app_video_es_merge(this.options_, options);
                this.options_.withCredentials = this.options_.withCredentials || false;
                this.options_.limitRenditionByPlayerDimensions = this.options_.limitRenditionByPlayerDimensions === false ? false : true;
                this.options_.useDevicePixelRatio = this.options_.useDevicePixelRatio || false;
                this.options_.useBandwidthFromLocalStorage = typeof this.source_.useBandwidthFromLocalStorage !== "undefined" ? this.source_.useBandwidthFromLocalStorage : this.options_.useBandwidthFromLocalStorage || false;
                this.options_.useForcedSubtitles = this.options_.useForcedSubtitles || false;
                this.options_.useNetworkInformationApi = this.options_.useNetworkInformationApi || false;
                this.options_.useDtsForTimestampOffset = this.options_.useDtsForTimestampOffset || false;
                this.options_.customTagParsers = this.options_.customTagParsers || [];
                this.options_.customTagMappers = this.options_.customTagMappers || [];
                this.options_.cacheEncryptionKeys = this.options_.cacheEncryptionKeys || false;
                this.options_.llhls = this.options_.llhls === false ? false : true;
                this.options_.bufferBasedABR = this.options_.bufferBasedABR || false;
                if (typeof this.options_.playlistExclusionDuration !== "number") this.options_.playlistExclusionDuration = 60;
                if (typeof this.options_.bandwidth !== "number") if (this.options_.useBandwidthFromLocalStorage) {
                    const storedObject = app_getVhsLocalStorage();
                    if (storedObject && storedObject.bandwidth) {
                        this.options_.bandwidth = storedObject.bandwidth;
                        this.tech_.trigger({
                            type: "usage",
                            name: "vhs-bandwidth-from-local-storage"
                        });
                    }
                    if (storedObject && storedObject.throughput) {
                        this.options_.throughput = storedObject.throughput;
                        this.tech_.trigger({
                            type: "usage",
                            name: "vhs-throughput-from-local-storage"
                        });
                    }
                }
                if (typeof this.options_.bandwidth !== "number") this.options_.bandwidth = app_Config.INITIAL_BANDWIDTH;
                this.options_.enableLowInitialPlaylist = this.options_.enableLowInitialPlaylist && this.options_.bandwidth === app_Config.INITIAL_BANDWIDTH;
                [ "withCredentials", "useDevicePixelRatio", "customPixelRatio", "limitRenditionByPlayerDimensions", "bandwidth", "customTagParsers", "customTagMappers", "cacheEncryptionKeys", "playlistSelector", "initialPlaylistSelector", "bufferBasedABR", "liveRangeSafeTimeDelta", "llhls", "useForcedSubtitles", "useNetworkInformationApi", "useDtsForTimestampOffset", "exactManifestTimings", "leastPixelDiffSelector" ].forEach((option => {
                    if (typeof this.source_[option] !== "undefined") this.options_[option] = this.source_[option];
                }));
                this.limitRenditionByPlayerDimensions = this.options_.limitRenditionByPlayerDimensions;
                this.useDevicePixelRatio = this.options_.useDevicePixelRatio;
                const customPixelRatio = this.options_.customPixelRatio;
                if (typeof customPixelRatio === "number" && customPixelRatio >= 0) this.customPixelRatio = customPixelRatio;
            }
            setOptions(options = {}) {
                this.setOptions_(options);
            }
            src(src, type) {
                if (!src) return;
                this.setOptions_();
                this.options_.src = app_expandDataUri(this.source_.src);
                this.options_.tech = this.tech_;
                this.options_.externVhs = app_Vhs;
                this.options_.sourceType = app_simpleTypeFromSourceType(type);
                this.options_.seekTo = time => {
                    this.tech_.setCurrentTime(time);
                };
                this.options_.player_ = this.player_;
                this.playlistController_ = new app_PlaylistController(this.options_);
                const playbackWatcherOptions = app_video_es_merge({
                    liveRangeSafeTimeDelta: app_SAFE_TIME_DELTA
                }, this.options_, {
                    seekable: () => this.seekable(),
                    media: () => this.playlistController_.media(),
                    playlistController: this.playlistController_
                });
                this.playbackWatcher_ = new app_PlaybackWatcher(playbackWatcherOptions);
                this.attachStreamingEventListeners_();
                this.playlistController_.on("error", (() => {
                    const player = app_videojs.players[this.tech_.options_.playerId];
                    let error = this.playlistController_.error;
                    if (typeof error === "object" && !error.code) error.code = 3; else if (typeof error === "string") error = {
                        message: error,
                        code: 3
                    };
                    player.error(error);
                }));
                const defaultSelector = this.options_.bufferBasedABR ? app_Vhs.movingAverageBandwidthSelector(.55) : app_Vhs.STANDARD_PLAYLIST_SELECTOR;
                this.playlistController_.selectPlaylist = this.selectPlaylist ? this.selectPlaylist.bind(this) : defaultSelector.bind(this);
                this.playlistController_.selectInitialPlaylist = app_Vhs.INITIAL_PLAYLIST_SELECTOR.bind(this);
                this.playlists = this.playlistController_.mainPlaylistLoader_;
                this.mediaSource = this.playlistController_.mediaSource;
                Object.defineProperties(this, {
                    selectPlaylist: {
                        get() {
                            return this.playlistController_.selectPlaylist;
                        },
                        set(selectPlaylist) {
                            this.playlistController_.selectPlaylist = selectPlaylist.bind(this);
                        }
                    },
                    throughput: {
                        get() {
                            return this.playlistController_.mainSegmentLoader_.throughput.rate;
                        },
                        set(throughput) {
                            this.playlistController_.mainSegmentLoader_.throughput.rate = throughput;
                            this.playlistController_.mainSegmentLoader_.throughput.count = 1;
                        }
                    },
                    bandwidth: {
                        get() {
                            let playerBandwidthEst = this.playlistController_.mainSegmentLoader_.bandwidth;
                            const networkInformation = app_window_default().navigator.connection || app_window_default().navigator.mozConnection || app_window_default().navigator.webkitConnection;
                            const tenMbpsAsBitsPerSecond = 1e7;
                            if (this.options_.useNetworkInformationApi && networkInformation) {
                                const networkInfoBandwidthEstBitsPerSec = networkInformation.downlink * 1e3 * 1e3;
                                if (networkInfoBandwidthEstBitsPerSec >= tenMbpsAsBitsPerSecond && playerBandwidthEst >= tenMbpsAsBitsPerSecond) playerBandwidthEst = Math.max(playerBandwidthEst, networkInfoBandwidthEstBitsPerSec); else playerBandwidthEst = networkInfoBandwidthEstBitsPerSec;
                            }
                            return playerBandwidthEst;
                        },
                        set(bandwidth) {
                            this.playlistController_.mainSegmentLoader_.bandwidth = bandwidth;
                            this.playlistController_.mainSegmentLoader_.throughput = {
                                rate: 0,
                                count: 0
                            };
                        }
                    },
                    systemBandwidth: {
                        get() {
                            const invBandwidth = 1 / (this.bandwidth || 1);
                            let invThroughput;
                            if (this.throughput > 0) invThroughput = 1 / this.throughput; else invThroughput = 0;
                            const systemBitrate = Math.floor(1 / (invBandwidth + invThroughput));
                            return systemBitrate;
                        },
                        set() {
                            app_videojs.log.error('The "systemBandwidth" property is read-only');
                        }
                    }
                });
                if (this.options_.bandwidth) this.bandwidth = this.options_.bandwidth;
                if (this.options_.throughput) this.throughput = this.options_.throughput;
                Object.defineProperties(this.stats, {
                    bandwidth: {
                        get: () => this.bandwidth || 0,
                        enumerable: true
                    },
                    mediaRequests: {
                        get: () => this.playlistController_.mediaRequests_() || 0,
                        enumerable: true
                    },
                    mediaRequestsAborted: {
                        get: () => this.playlistController_.mediaRequestsAborted_() || 0,
                        enumerable: true
                    },
                    mediaRequestsTimedout: {
                        get: () => this.playlistController_.mediaRequestsTimedout_() || 0,
                        enumerable: true
                    },
                    mediaRequestsErrored: {
                        get: () => this.playlistController_.mediaRequestsErrored_() || 0,
                        enumerable: true
                    },
                    mediaTransferDuration: {
                        get: () => this.playlistController_.mediaTransferDuration_() || 0,
                        enumerable: true
                    },
                    mediaBytesTransferred: {
                        get: () => this.playlistController_.mediaBytesTransferred_() || 0,
                        enumerable: true
                    },
                    mediaSecondsLoaded: {
                        get: () => this.playlistController_.mediaSecondsLoaded_() || 0,
                        enumerable: true
                    },
                    mediaAppends: {
                        get: () => this.playlistController_.mediaAppends_() || 0,
                        enumerable: true
                    },
                    mainAppendsToLoadedData: {
                        get: () => this.playlistController_.mainAppendsToLoadedData_() || 0,
                        enumerable: true
                    },
                    audioAppendsToLoadedData: {
                        get: () => this.playlistController_.audioAppendsToLoadedData_() || 0,
                        enumerable: true
                    },
                    appendsToLoadedData: {
                        get: () => this.playlistController_.appendsToLoadedData_() || 0,
                        enumerable: true
                    },
                    timeToLoadedData: {
                        get: () => this.playlistController_.timeToLoadedData_() || 0,
                        enumerable: true
                    },
                    buffered: {
                        get: () => app_timeRangesToArray(this.tech_.buffered()),
                        enumerable: true
                    },
                    currentTime: {
                        get: () => this.tech_.currentTime(),
                        enumerable: true
                    },
                    currentSource: {
                        get: () => this.tech_.currentSource_,
                        enumerable: true
                    },
                    currentTech: {
                        get: () => this.tech_.name_,
                        enumerable: true
                    },
                    duration: {
                        get: () => this.tech_.duration(),
                        enumerable: true
                    },
                    main: {
                        get: () => this.playlists.main,
                        enumerable: true
                    },
                    playerDimensions: {
                        get: () => this.tech_.currentDimensions(),
                        enumerable: true
                    },
                    seekable: {
                        get: () => app_timeRangesToArray(this.tech_.seekable()),
                        enumerable: true
                    },
                    timestamp: {
                        get: () => Date.now(),
                        enumerable: true
                    },
                    videoPlaybackQuality: {
                        get: () => this.tech_.getVideoPlaybackQuality(),
                        enumerable: true
                    }
                });
                this.tech_.one("canplay", this.playlistController_.setupFirstPlay.bind(this.playlistController_));
                this.tech_.on("bandwidthupdate", (() => {
                    if (this.options_.useBandwidthFromLocalStorage) app_updateVhsLocalStorage({
                        bandwidth: this.bandwidth,
                        throughput: Math.round(this.throughput)
                    });
                }));
                this.playlistController_.on("selectedinitialmedia", (() => {
                    app_renditionSelectionMixin(this);
                }));
                this.playlistController_.sourceUpdater_.on("createdsourcebuffers", (() => {
                    this.setupEme_();
                }));
                this.on(this.playlistController_, "progress", (function() {
                    this.tech_.trigger("progress");
                }));
                this.on(this.playlistController_, "firstplay", (function() {
                    this.ignoreNextSeekingEvent_ = true;
                }));
                this.setupQualityLevels_();
                if (!this.tech_.el()) return;
                this.mediaSourceUrl_ = app_window_default().URL.createObjectURL(this.playlistController_.mediaSource);
                if ((app_videojs.browser.IS_ANY_SAFARI || app_videojs.browser.IS_IOS) && this.options_.overrideNative && this.options_.sourceType === "hls" && typeof this.tech_.addSourceElement === "function") {
                    this.tech_.addSourceElement(this.mediaSourceUrl_);
                    this.tech_.addSourceElement(this.source_.src);
                } else this.tech_.src(this.mediaSourceUrl_);
            }
            createKeySessions_() {
                const audioPlaylistLoader = this.playlistController_.mediaTypes_.AUDIO.activePlaylistLoader;
                this.logger_("waiting for EME key session creation");
                app_waitForKeySessionCreation({
                    player: this.player_,
                    sourceKeySystems: this.source_.keySystems,
                    audioMedia: audioPlaylistLoader && audioPlaylistLoader.media(),
                    mainPlaylists: this.playlists.main.playlists
                }).then((() => {
                    this.logger_("created EME key session");
                    this.playlistController_.sourceUpdater_.initializedEme();
                })).catch((err => {
                    this.logger_("error while creating EME key session", err);
                    this.player_.error({
                        message: "Failed to initialize media keys for EME",
                        code: 3
                    });
                }));
            }
            handleWaitingForKey_() {
                this.logger_("waitingforkey fired, attempting to create any new key sessions");
                this.createKeySessions_();
            }
            setupEme_() {
                const audioPlaylistLoader = this.playlistController_.mediaTypes_.AUDIO.activePlaylistLoader;
                const didSetupEmeOptions = app_setupEmeOptions({
                    player: this.player_,
                    sourceKeySystems: this.source_.keySystems,
                    media: this.playlists.media(),
                    audioMedia: audioPlaylistLoader && audioPlaylistLoader.media()
                });
                this.player_.tech_.on("keystatuschange", (e => {
                    this.playlistController_.updatePlaylistByKeyStatus(e.keyId, e.status);
                }));
                this.handleWaitingForKey_ = this.handleWaitingForKey_.bind(this);
                this.player_.tech_.on("waitingforkey", this.handleWaitingForKey_);
                if (!didSetupEmeOptions) {
                    this.playlistController_.sourceUpdater_.initializedEme();
                    return;
                }
                this.createKeySessions_();
            }
            setupQualityLevels_() {
                const player = app_videojs.players[this.tech_.options_.playerId];
                if (!player || !player.qualityLevels || this.qualityLevels_) return;
                this.qualityLevels_ = player.qualityLevels();
                this.playlistController_.on("selectedinitialmedia", (() => {
                    app_handleVhsLoadedMetadata(this.qualityLevels_, this);
                }));
                this.playlists.on("mediachange", (() => {
                    app_handleVhsMediaChange(this.qualityLevels_, this.playlists);
                }));
            }
            static version() {
                return {
                    "@videojs/http-streaming": app_version$4,
                    "mux.js": app_version$3,
                    "mpd-parser": app_version$2,
                    "m3u8-parser": app_version$1,
                    "aes-decrypter": app_video_es_version
                };
            }
            version() {
                return this.constructor.version();
            }
            canChangeType() {
                return app_SourceUpdater.canChangeType();
            }
            play() {
                this.playlistController_.play();
            }
            setCurrentTime(currentTime) {
                this.playlistController_.setCurrentTime(currentTime);
            }
            duration() {
                return this.playlistController_.duration();
            }
            seekable() {
                return this.playlistController_.seekable();
            }
            dispose() {
                if (this.playbackWatcher_) this.playbackWatcher_.dispose();
                if (this.playlistController_) this.playlistController_.dispose();
                if (this.qualityLevels_) this.qualityLevels_.dispose();
                if (this.tech_ && this.tech_.vhs) delete this.tech_.vhs;
                if (this.mediaSourceUrl_ && app_window_default().URL.revokeObjectURL) {
                    app_window_default().URL.revokeObjectURL(this.mediaSourceUrl_);
                    this.mediaSourceUrl_ = null;
                }
                if (this.tech_) this.tech_.off("waitingforkey", this.handleWaitingForKey_);
                super.dispose();
            }
            convertToProgramTime(time, callback) {
                return app_getProgramTime({
                    playlist: this.playlistController_.media(),
                    time,
                    callback
                });
            }
            seekToProgramTime(programTime, callback, pauseAfterSeek = true, retryCount = 2) {
                return app_seekToProgramTime({
                    programTime,
                    playlist: this.playlistController_.media(),
                    retryCount,
                    pauseAfterSeek,
                    seekTo: this.options_.seekTo,
                    tech: this.options_.tech,
                    callback
                });
            }
            setupXhrHooks_() {
                this.xhr.onRequest = callback => {
                    app_addOnRequestHook(this.xhr, callback);
                };
                this.xhr.onResponse = callback => {
                    app_addOnResponseHook(this.xhr, callback);
                };
                this.xhr.offRequest = callback => {
                    app_removeOnRequestHook(this.xhr, callback);
                };
                this.xhr.offResponse = callback => {
                    app_removeOnResponseHook(this.xhr, callback);
                };
                this.player_.trigger("xhr-hooks-ready");
            }
            attachStreamingEventListeners_() {
                const playlistControllerEvents = [ "seekablerangeschanged", "bufferedrangeschanged", "contentsteeringloadstart", "contentsteeringloadcomplete", "contentsteeringparsed" ];
                const playbackWatcher = [ "gapjumped", "playedrangeschanged" ];
                playlistControllerEvents.forEach((eventName => {
                    this.playlistController_.on(eventName, (metadata => {
                        this.player_.trigger(app_extends({}, metadata));
                    }));
                }));
                playbackWatcher.forEach((eventName => {
                    this.playbackWatcher_.on(eventName, (metadata => {
                        this.player_.trigger(app_extends({}, metadata));
                    }));
                }));
            }
        }
        const app_VhsSourceHandler = {
            name: "videojs-http-streaming",
            VERSION: app_version$4,
            canHandleSource(srcObj, options = {}) {
                const localOptions = app_video_es_merge(app_videojs.options, options);
                if (!localOptions.vhs.experimentalUseMMS && !app_browserSupportsCodec("avc1.4d400d,mp4a.40.2", false)) return false;
                return app_VhsSourceHandler.canPlayType(srcObj.type, localOptions);
            },
            handleSource(source, tech, options = {}) {
                const localOptions = app_video_es_merge(app_videojs.options, options);
                tech.vhs = new app_VhsHandler(source, tech, localOptions);
                tech.vhs.xhr = app_xhrFactory();
                tech.vhs.setupXhrHooks_();
                tech.vhs.src(source.src, source.type);
                return tech.vhs;
            },
            canPlayType(type, options) {
                const simpleType = app_simpleTypeFromSourceType(type);
                if (!simpleType) return "";
                const overrideNative = app_VhsSourceHandler.getOverrideNative(options);
                const supportsTypeNatively = app_Vhs.supportsTypeNatively(simpleType);
                const canUseMsePlayback = !supportsTypeNatively || overrideNative;
                return canUseMsePlayback ? "maybe" : "";
            },
            getOverrideNative(options = {}) {
                const {vhs = {}} = options;
                const defaultOverrideNative = !(app_videojs.browser.IS_ANY_SAFARI || app_videojs.browser.IS_IOS);
                const {overrideNative = defaultOverrideNative} = vhs;
                return overrideNative;
            }
        };
        const app_supportsNativeMediaSources = () => app_browserSupportsCodec("avc1.4d400d,mp4a.40.2", true);
        if (app_supportsNativeMediaSources()) app_videojs.getTech("Html5").registerSourceHandler(app_VhsSourceHandler, 0);
        app_videojs.VhsHandler = app_VhsHandler;
        app_videojs.VhsSourceHandler = app_VhsSourceHandler;
        app_videojs.Vhs = app_Vhs;
        if (!app_videojs.use) app_videojs.registerComponent("Vhs", app_Vhs);
        app_videojs.options.vhs = app_videojs.options.vhs || {};
        if (!app_videojs.getPlugin || !app_videojs.getPlugin("reloadSourceOnError")) app_videojs.registerPlugin("reloadSourceOnError", app_reloadSourceOnError);
        /*!
 * lightgallery | 2.8.2 | November 28th 2024
 * http://www.lightgalleryjs.com/
 * Copyright (c) 2020 Sachin Neravath;
 * @license GPLv3
 */
        /*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
        var app_assign = function() {
            app_assign = Object.assign || function __assign(t) {
                for (var s, i = 1, n = arguments.length; i < n; i++) {
                    s = arguments[i];
                    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
                }
                return t;
            };
            return app_assign.apply(this, arguments);
        };
        function app_spreadArrays() {
            for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
            var r = Array(s), k = 0;
            for (i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, 
            k++) r[k] = a[j];
            return r;
        }
        var app_lGEvents = {
            afterAppendSlide: "lgAfterAppendSlide",
            init: "lgInit",
            hasVideo: "lgHasVideo",
            containerResize: "lgContainerResize",
            updateSlides: "lgUpdateSlides",
            afterAppendSubHtml: "lgAfterAppendSubHtml",
            beforeOpen: "lgBeforeOpen",
            afterOpen: "lgAfterOpen",
            slideItemLoad: "lgSlideItemLoad",
            beforeSlide: "lgBeforeSlide",
            afterSlide: "lgAfterSlide",
            posterClick: "lgPosterClick",
            dragStart: "lgDragStart",
            dragMove: "lgDragMove",
            dragEnd: "lgDragEnd",
            beforeNextSlide: "lgBeforeNextSlide",
            beforePrevSlide: "lgBeforePrevSlide",
            beforeClose: "lgBeforeClose",
            afterClose: "lgAfterClose",
            rotateLeft: "lgRotateLeft",
            rotateRight: "lgRotateRight",
            flipHorizontal: "lgFlipHorizontal",
            flipVertical: "lgFlipVertical",
            autoplay: "lgAutoplay",
            autoplayStart: "lgAutoplayStart",
            autoplayStop: "lgAutoplayStop"
        };
        var app_lightGalleryCoreSettings = {
            mode: "lg-slide",
            easing: "ease",
            speed: 400,
            licenseKey: "0000-0000-000-0000",
            height: "100%",
            width: "100%",
            addClass: "",
            startClass: "lg-start-zoom",
            backdropDuration: 300,
            container: "",
            startAnimationDuration: 400,
            zoomFromOrigin: true,
            hideBarsDelay: 0,
            showBarsAfter: 1e4,
            slideDelay: 0,
            supportLegacyBrowser: true,
            allowMediaOverlap: false,
            videoMaxSize: "1280-720",
            loadYouTubePoster: true,
            defaultCaptionHeight: 0,
            ariaLabelledby: "",
            ariaDescribedby: "",
            resetScrollPosition: true,
            hideScrollbar: false,
            closable: true,
            swipeToClose: true,
            closeOnTap: true,
            showCloseIcon: true,
            showMaximizeIcon: false,
            loop: true,
            escKey: true,
            keyPress: true,
            trapFocus: true,
            controls: true,
            slideEndAnimation: true,
            hideControlOnEnd: false,
            mousewheel: false,
            getCaptionFromTitleOrAlt: true,
            appendSubHtmlTo: ".lg-sub-html",
            subHtmlSelectorRelative: false,
            preload: 2,
            numberOfSlideItemsInDom: 10,
            selector: "",
            selectWithin: "",
            nextHtml: "",
            prevHtml: "",
            index: 0,
            iframeWidth: "100%",
            iframeHeight: "100%",
            iframeMaxWidth: "100%",
            iframeMaxHeight: "100%",
            download: true,
            counter: true,
            appendCounterTo: ".lg-toolbar",
            swipeThreshold: 50,
            enableSwipe: true,
            enableDrag: true,
            dynamic: false,
            dynamicEl: [],
            extraProps: [],
            exThumbImage: "",
            isMobile: void 0,
            mobileSettings: {
                controls: false,
                showCloseIcon: false,
                download: false
            },
            plugins: [],
            strings: {
                closeGallery: "Close gallery",
                toggleMaximize: "Toggle maximize",
                previousSlide: "Previous slide",
                nextSlide: "Next slide",
                download: "Download",
                playVideo: "Play video",
                mediaLoadingFailed: "Oops... Failed to load content..."
            }
        };
        function app_initLgPolyfills() {
            (function() {
                if (typeof window.CustomEvent === "function") return false;
                function CustomEvent(event, params) {
                    params = params || {
                        bubbles: false,
                        cancelable: false,
                        detail: null
                    };
                    var evt = document.createEvent("CustomEvent");
                    evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
                    return evt;
                }
                window.CustomEvent = CustomEvent;
            })();
            (function() {
                if (!Element.prototype.matches) Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
            })();
        }
        var app_lgQuery = function() {
            function lgQuery(selector) {
                this.cssVenderPrefixes = [ "TransitionDuration", "TransitionTimingFunction", "Transform", "Transition" ];
                this.selector = this._getSelector(selector);
                this.firstElement = this._getFirstEl();
                return this;
            }
            lgQuery.generateUUID = function() {
                return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (function(c) {
                    var r = Math.random() * 16 | 0, v = c == "x" ? r : r & 3 | 8;
                    return v.toString(16);
                }));
            };
            lgQuery.prototype._getSelector = function(selector, context) {
                if (context === void 0) context = document;
                if (typeof selector !== "string") return selector;
                context = context || document;
                var fl = selector.substring(0, 1);
                if (fl === "#") return context.querySelector(selector); else return context.querySelectorAll(selector);
            };
            lgQuery.prototype._each = function(func) {
                if (!this.selector) return this;
                if (this.selector.length !== void 0) [].forEach.call(this.selector, func); else func(this.selector, 0);
                return this;
            };
            lgQuery.prototype._setCssVendorPrefix = function(el, cssProperty, value) {
                var property = cssProperty.replace(/-([a-z])/gi, (function(s, group1) {
                    return group1.toUpperCase();
                }));
                if (this.cssVenderPrefixes.indexOf(property) !== -1) {
                    el.style[property.charAt(0).toLowerCase() + property.slice(1)] = value;
                    el.style["webkit" + property] = value;
                    el.style["moz" + property] = value;
                    el.style["ms" + property] = value;
                    el.style["o" + property] = value;
                } else el.style[property] = value;
            };
            lgQuery.prototype._getFirstEl = function() {
                if (this.selector && this.selector.length !== void 0) return this.selector[0]; else return this.selector;
            };
            lgQuery.prototype.isEventMatched = function(event, eventName) {
                var eventNamespace = eventName.split(".");
                return event.split(".").filter((function(e) {
                    return e;
                })).every((function(e) {
                    return eventNamespace.indexOf(e) !== -1;
                }));
            };
            lgQuery.prototype.attr = function(attr, value) {
                if (value === void 0) {
                    if (!this.firstElement) return "";
                    return this.firstElement.getAttribute(attr);
                }
                this._each((function(el) {
                    el.setAttribute(attr, value);
                }));
                return this;
            };
            lgQuery.prototype.find = function(selector) {
                return app_$LG(this._getSelector(selector, this.selector));
            };
            lgQuery.prototype.first = function() {
                if (this.selector && this.selector.length !== void 0) return app_$LG(this.selector[0]); else return app_$LG(this.selector);
            };
            lgQuery.prototype.eq = function(index) {
                return app_$LG(this.selector[index]);
            };
            lgQuery.prototype.parent = function() {
                return app_$LG(this.selector.parentElement);
            };
            lgQuery.prototype.get = function() {
                return this._getFirstEl();
            };
            lgQuery.prototype.removeAttr = function(attributes) {
                var attrs = attributes.split(" ");
                this._each((function(el) {
                    attrs.forEach((function(attr) {
                        return el.removeAttribute(attr);
                    }));
                }));
                return this;
            };
            lgQuery.prototype.wrap = function(className) {
                if (!this.firstElement) return this;
                var wrapper = document.createElement("div");
                wrapper.className = className;
                this.firstElement.parentNode.insertBefore(wrapper, this.firstElement);
                this.firstElement.parentNode.removeChild(this.firstElement);
                wrapper.appendChild(this.firstElement);
                return this;
            };
            lgQuery.prototype.addClass = function(classNames) {
                if (classNames === void 0) classNames = "";
                this._each((function(el) {
                    classNames.split(" ").forEach((function(className) {
                        if (className) el.classList.add(className);
                    }));
                }));
                return this;
            };
            lgQuery.prototype.removeClass = function(classNames) {
                this._each((function(el) {
                    classNames.split(" ").forEach((function(className) {
                        if (className) el.classList.remove(className);
                    }));
                }));
                return this;
            };
            lgQuery.prototype.hasClass = function(className) {
                if (!this.firstElement) return false;
                return this.firstElement.classList.contains(className);
            };
            lgQuery.prototype.hasAttribute = function(attribute) {
                if (!this.firstElement) return false;
                return this.firstElement.hasAttribute(attribute);
            };
            lgQuery.prototype.toggleClass = function(className) {
                if (!this.firstElement) return this;
                if (this.hasClass(className)) this.removeClass(className); else this.addClass(className);
                return this;
            };
            lgQuery.prototype.css = function(property, value) {
                var _this = this;
                this._each((function(el) {
                    _this._setCssVendorPrefix(el, property, value);
                }));
                return this;
            };
            lgQuery.prototype.on = function(events, listener) {
                var _this = this;
                if (!this.selector) return this;
                events.split(" ").forEach((function(event) {
                    if (!Array.isArray(lgQuery.eventListeners[event])) lgQuery.eventListeners[event] = [];
                    lgQuery.eventListeners[event].push(listener);
                    _this.selector.addEventListener(event.split(".")[0], listener);
                }));
                return this;
            };
            lgQuery.prototype.once = function(event, listener) {
                var _this = this;
                this.on(event, (function() {
                    _this.off(event);
                    listener(event);
                }));
                return this;
            };
            lgQuery.prototype.off = function(event) {
                var _this = this;
                if (!this.selector) return this;
                Object.keys(lgQuery.eventListeners).forEach((function(eventName) {
                    if (_this.isEventMatched(event, eventName)) {
                        lgQuery.eventListeners[eventName].forEach((function(listener) {
                            _this.selector.removeEventListener(eventName.split(".")[0], listener);
                        }));
                        lgQuery.eventListeners[eventName] = [];
                    }
                }));
                return this;
            };
            lgQuery.prototype.trigger = function(event, detail) {
                if (!this.firstElement) return this;
                var customEvent = new CustomEvent(event.split(".")[0], {
                    detail: detail || null
                });
                this.firstElement.dispatchEvent(customEvent);
                return this;
            };
            lgQuery.prototype.load = function(url) {
                var _this = this;
                fetch(url).then((function(res) {
                    return res.text();
                })).then((function(html) {
                    _this.selector.innerHTML = html;
                }));
                return this;
            };
            lgQuery.prototype.html = function(html) {
                if (html === void 0) {
                    if (!this.firstElement) return "";
                    return this.firstElement.innerHTML;
                }
                this._each((function(el) {
                    el.innerHTML = html;
                }));
                return this;
            };
            lgQuery.prototype.append = function(html) {
                this._each((function(el) {
                    if (typeof html === "string") el.insertAdjacentHTML("beforeend", html); else el.appendChild(html);
                }));
                return this;
            };
            lgQuery.prototype.prepend = function(html) {
                this._each((function(el) {
                    if (typeof html === "string") el.insertAdjacentHTML("afterbegin", html); else if (html instanceof HTMLElement) el.insertBefore(html.cloneNode(true), el.firstChild);
                }));
                return this;
            };
            lgQuery.prototype.remove = function() {
                this._each((function(el) {
                    el.parentNode.removeChild(el);
                }));
                return this;
            };
            lgQuery.prototype.empty = function() {
                this._each((function(el) {
                    el.innerHTML = "";
                }));
                return this;
            };
            lgQuery.prototype.scrollTop = function(scrollTop) {
                if (scrollTop !== void 0) {
                    document.body.scrollTop = scrollTop;
                    document.documentElement.scrollTop = scrollTop;
                    return this;
                } else return window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
            };
            lgQuery.prototype.scrollLeft = function(scrollLeft) {
                if (scrollLeft !== void 0) {
                    document.body.scrollLeft = scrollLeft;
                    document.documentElement.scrollLeft = scrollLeft;
                    return this;
                } else return window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0;
            };
            lgQuery.prototype.offset = function() {
                if (!this.firstElement) return {
                    left: 0,
                    top: 0
                };
                var rect = this.firstElement.getBoundingClientRect();
                var bodyMarginLeft = app_$LG("body").style().marginLeft;
                return {
                    left: rect.left - parseFloat(bodyMarginLeft) + this.scrollLeft(),
                    top: rect.top + this.scrollTop()
                };
            };
            lgQuery.prototype.style = function() {
                if (!this.firstElement) return {};
                return this.firstElement.currentStyle || window.getComputedStyle(this.firstElement);
            };
            lgQuery.prototype.width = function() {
                var style = this.style();
                return this.firstElement.clientWidth - parseFloat(style.paddingLeft) - parseFloat(style.paddingRight);
            };
            lgQuery.prototype.height = function() {
                var style = this.style();
                return this.firstElement.clientHeight - parseFloat(style.paddingTop) - parseFloat(style.paddingBottom);
            };
            lgQuery.eventListeners = {};
            return lgQuery;
        }();
        function app_$LG(selector) {
            app_initLgPolyfills();
            return new app_lgQuery(selector);
        }
        var app_defaultDynamicOptions = [ "src", "sources", "subHtml", "subHtmlUrl", "html", "video", "poster", "slideName", "responsive", "srcset", "sizes", "iframe", "downloadUrl", "download", "width", "facebookShareUrl", "tweetText", "iframeTitle", "twitterShareUrl", "pinterestShareUrl", "pinterestText", "fbHtml", "disqusIdentifier", "disqusUrl" ];
        function app_convertToData(attr) {
            if (attr === "href") return "src";
            attr = attr.replace("data-", "");
            attr = attr.charAt(0).toLowerCase() + attr.slice(1);
            attr = attr.replace(/-([a-z])/g, (function(g) {
                return g[1].toUpperCase();
            }));
            return attr;
        }
        var app_lightgallery_es5_utils = {
            fetchCaptionFromUrl: function(url, element, insertMethod) {
                fetch(url).then((function(response) {
                    return response.text();
                })).then((function(htmlContent) {
                    if (insertMethod === "append") {
                        var contentDiv = '<div class="lg-sub-html">' + htmlContent + "</div>";
                        element.append(contentDiv);
                    } else element.html(htmlContent);
                }));
            },
            getSize: function(el, container, spacing, defaultLgSize) {
                if (spacing === void 0) spacing = 0;
                var LGel = app_$LG(el);
                var lgSize = LGel.attr("data-lg-size") || defaultLgSize;
                if (!lgSize) return;
                var isResponsiveSizes = lgSize.split(",");
                if (isResponsiveSizes[1]) {
                    var wWidth = window.innerWidth;
                    for (var i = 0; i < isResponsiveSizes.length; i++) {
                        var size_1 = isResponsiveSizes[i];
                        var responsiveWidth = parseInt(size_1.split("-")[2], 10);
                        if (responsiveWidth > wWidth) {
                            lgSize = size_1;
                            break;
                        }
                        if (i === isResponsiveSizes.length - 1) lgSize = size_1;
                    }
                }
                var size = lgSize.split("-");
                var width = parseInt(size[0], 10);
                var height = parseInt(size[1], 10);
                var cWidth = container.width();
                var cHeight = container.height() - spacing;
                var maxWidth = Math.min(cWidth, width);
                var maxHeight = Math.min(cHeight, height);
                var ratio = Math.min(maxWidth / width, maxHeight / height);
                return {
                    width: width * ratio,
                    height: height * ratio
                };
            },
            getTransform: function(el, container, top, bottom, imageSize) {
                if (!imageSize) return;
                var LGel = app_$LG(el).find("img").first();
                if (!LGel.get()) return;
                var containerRect = container.get().getBoundingClientRect();
                var wWidth = containerRect.width;
                var wHeight = container.height() - (top + bottom);
                var elWidth = LGel.width();
                var elHeight = LGel.height();
                var elStyle = LGel.style();
                var x = (wWidth - elWidth) / 2 - LGel.offset().left + (parseFloat(elStyle.paddingLeft) || 0) + (parseFloat(elStyle.borderLeft) || 0) + app_$LG(window).scrollLeft() + containerRect.left;
                var y = (wHeight - elHeight) / 2 - LGel.offset().top + (parseFloat(elStyle.paddingTop) || 0) + (parseFloat(elStyle.borderTop) || 0) + app_$LG(window).scrollTop() + top;
                var scX = elWidth / imageSize.width;
                var scY = elHeight / imageSize.height;
                var transform = "translate3d(" + (x *= -1) + "px, " + (y *= -1) + "px, 0) scale3d(" + scX + ", " + scY + ", 1)";
                return transform;
            },
            getIframeMarkup: function(iframeWidth, iframeHeight, iframeMaxWidth, iframeMaxHeight, src, iframeTitle) {
                var title = iframeTitle ? 'title="' + iframeTitle + '"' : "";
                return '<div class="lg-media-cont lg-has-iframe" style="width:' + iframeWidth + "; max-width:" + iframeMaxWidth + "; height: " + iframeHeight + "; max-height:" + iframeMaxHeight + '">\n                    <iframe class="lg-object" frameborder="0" ' + title + ' src="' + src + '"  allowfullscreen="true"></iframe>\n                </div>';
            },
            getImgMarkup: function(index, src, altAttr, srcset, sizes, sources) {
                var srcsetAttr = srcset ? 'srcset="' + srcset + '"' : "";
                var sizesAttr = sizes ? 'sizes="' + sizes + '"' : "";
                var imgMarkup = "<img " + altAttr + " " + srcsetAttr + "  " + sizesAttr + ' class="lg-object lg-image" data-index="' + index + '" src="' + src + '" />';
                var sourceTag = "";
                if (sources) {
                    var sourceObj = typeof sources === "string" ? JSON.parse(sources) : sources;
                    sourceTag = sourceObj.map((function(source) {
                        var attrs = "";
                        Object.keys(source).forEach((function(key) {
                            attrs += " " + key + '="' + source[key] + '"';
                        }));
                        return "<source " + attrs + "></source>";
                    }));
                }
                return "" + sourceTag + imgMarkup;
            },
            getResponsiveSrc: function(srcItms) {
                var rsWidth = [];
                var rsSrc = [];
                var src = "";
                for (var i = 0; i < srcItms.length; i++) {
                    var _src = srcItms[i].split(" ");
                    if (_src[0] === "") _src.splice(0, 1);
                    rsSrc.push(_src[0]);
                    rsWidth.push(_src[1]);
                }
                var wWidth = window.innerWidth;
                for (var j = 0; j < rsWidth.length; j++) if (parseInt(rsWidth[j], 10) > wWidth) {
                    src = rsSrc[j];
                    break;
                }
                return src;
            },
            isImageLoaded: function(img) {
                if (!img) return false;
                if (!img.complete) return false;
                if (img.naturalWidth === 0) return false;
                return true;
            },
            getVideoPosterMarkup: function(_poster, dummyImg, videoContStyle, playVideoString, _isVideo) {
                var videoClass = "";
                if (_isVideo && _isVideo.youtube) videoClass = "lg-has-youtube"; else if (_isVideo && _isVideo.vimeo) videoClass = "lg-has-vimeo"; else videoClass = "lg-has-html5";
                var _dummy = dummyImg;
                if (typeof dummyImg !== "string") _dummy = dummyImg.outerHTML;
                return '<div class="lg-video-cont ' + videoClass + '" style="' + videoContStyle + '">\n                <div class="lg-video-play-button">\n                <svg\n                    viewBox="0 0 20 20"\n                    preserveAspectRatio="xMidYMid"\n                    focusable="false"\n                    aria-labelledby="' + playVideoString + '"\n                    role="img"\n                    class="lg-video-play-icon"\n                >\n                    <title>' + playVideoString + '</title>\n                    <polygon class="lg-video-play-icon-inner" points="1,0 20,10 1,20"></polygon>\n                </svg>\n                <svg class="lg-video-play-icon-bg" viewBox="0 0 50 50" focusable="false">\n                    <circle cx="50%" cy="50%" r="20"></circle></svg>\n                <svg class="lg-video-play-icon-circle" viewBox="0 0 50 50" focusable="false">\n                    <circle cx="50%" cy="50%" r="20"></circle>\n                </svg>\n            </div>\n            ' + _dummy + '\n            <img class="lg-object lg-video-poster" src="' + _poster + '" />\n        </div>';
            },
            getFocusableElements: function(container) {
                var elements = container.querySelectorAll('a[href]:not([disabled]), button:not([disabled]), textarea:not([disabled]), input[type="text"]:not([disabled]), input[type="radio"]:not([disabled]), input[type="checkbox"]:not([disabled]), select:not([disabled])');
                var visibleElements = [].filter.call(elements, (function(element) {
                    var style = window.getComputedStyle(element);
                    return style.display !== "none" && style.visibility !== "hidden";
                }));
                return visibleElements;
            },
            getDynamicOptions: function(items, extraProps, getCaptionFromTitleOrAlt, exThumbImage) {
                var dynamicElements = [];
                var availableDynamicOptions = app_spreadArrays(app_defaultDynamicOptions, extraProps);
                [].forEach.call(items, (function(item) {
                    var dynamicEl = {};
                    for (var i = 0; i < item.attributes.length; i++) {
                        var attr = item.attributes[i];
                        if (attr.specified) {
                            var dynamicAttr = app_convertToData(attr.name);
                            var label = "";
                            if (availableDynamicOptions.indexOf(dynamicAttr) > -1) label = dynamicAttr;
                            if (label) dynamicEl[label] = attr.value;
                        }
                    }
                    var currentItem = app_$LG(item);
                    var alt = currentItem.find("img").first().attr("alt");
                    var title = currentItem.attr("title");
                    var thumb = exThumbImage ? currentItem.attr(exThumbImage) : currentItem.find("img").first().attr("src");
                    dynamicEl.thumb = thumb;
                    if (getCaptionFromTitleOrAlt && !dynamicEl.subHtml) dynamicEl.subHtml = title || alt || "";
                    dynamicEl.alt = alt || title || "";
                    dynamicElements.push(dynamicEl);
                }));
                console.log(dynamicElements, "dynamicElements");
                return dynamicElements;
            },
            isMobile: function() {
                return /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
            },
            isVideo: function(src, isHTML5VIdeo, index) {
                if (!src) if (isHTML5VIdeo) return {
                    html5: true
                }; else {
                    console.error("lightGallery :- data-src is not provided on slide item " + (index + 1) + ". Please make sure the selector property is properly configured. More info - https://www.lightgalleryjs.com/demos/html-markup/");
                    return;
                }
                var youtube = src.match(/\/\/(?:www\.)?youtu(?:\.be|be\.com|be-nocookie\.com)\/(?:watch\?v=|embed\/)?([a-z0-9\-\_\%]+)([\&|?][\S]*)*/i);
                var vimeo = src.match(/\/\/(?:www\.)?(?:player\.)?vimeo.com\/(?:video\/)?([0-9a-z\-_]+)(.*)?/i);
                var wistia = src.match(/https?:\/\/(.+)?(wistia\.com|wi\.st)\/(medias|embed)\/([0-9a-z\-_]+)(.*)/);
                if (youtube) return {
                    youtube
                }; else if (vimeo) return {
                    vimeo
                }; else if (wistia) return {
                    wistia
                };
            }
        };
        var app_lgId = 0;
        var app_LightGallery = function() {
            function LightGallery(element, options) {
                this.lgOpened = false;
                this.index = 0;
                this.plugins = [];
                this.lGalleryOn = false;
                this.lgBusy = false;
                this.currentItemsInDom = [];
                this.prevScrollTop = 0;
                this.bodyPaddingRight = 0;
                this.isDummyImageRemoved = false;
                this.dragOrSwipeEnabled = false;
                this.mediaContainerPosition = {
                    top: 0,
                    bottom: 0
                };
                if (!element) return this;
                app_lgId++;
                this.lgId = app_lgId;
                this.el = element;
                this.LGel = app_$LG(element);
                this.generateSettings(options);
                this.buildModules();
                if (this.settings.dynamic && this.settings.dynamicEl !== void 0 && !Array.isArray(this.settings.dynamicEl)) throw "When using dynamic mode, you must also define dynamicEl as an Array.";
                this.galleryItems = this.getItems();
                this.normalizeSettings();
                this.init();
                this.validateLicense();
                return this;
            }
            LightGallery.prototype.generateSettings = function(options) {
                this.settings = app_assign(app_assign({}, app_lightGalleryCoreSettings), options);
                if (this.settings.isMobile && typeof this.settings.isMobile === "function" ? this.settings.isMobile() : app_lightgallery_es5_utils.isMobile()) {
                    var mobileSettings = app_assign(app_assign({}, this.settings.mobileSettings), this.settings.mobileSettings);
                    this.settings = app_assign(app_assign({}, this.settings), mobileSettings);
                }
            };
            LightGallery.prototype.normalizeSettings = function() {
                if (this.settings.slideEndAnimation) this.settings.hideControlOnEnd = false;
                if (!this.settings.closable) this.settings.swipeToClose = false;
                this.zoomFromOrigin = this.settings.zoomFromOrigin;
                if (this.settings.dynamic) this.zoomFromOrigin = false;
                if (this.settings.container) {
                    var container = this.settings.container;
                    if (typeof container === "function") this.settings.container = container(); else if (typeof container === "string") {
                        var el = document.querySelector(container);
                        this.settings.container = el !== null && el !== void 0 ? el : document.body;
                    }
                } else this.settings.container = document.body;
                this.settings.preload = Math.min(this.settings.preload, this.galleryItems.length);
            };
            LightGallery.prototype.init = function() {
                var _this = this;
                this.addSlideVideoInfo(this.galleryItems);
                this.buildStructure();
                this.LGel.trigger(app_lGEvents.init, {
                    instance: this
                });
                if (this.settings.keyPress) this.keyPress();
                setTimeout((function() {
                    _this.enableDrag();
                    _this.enableSwipe();
                    _this.triggerPosterClick();
                }), 50);
                this.arrow();
                if (this.settings.mousewheel) this.mousewheel();
                if (!this.settings.dynamic) this.openGalleryOnItemClick();
            };
            LightGallery.prototype.openGalleryOnItemClick = function() {
                var _this = this;
                var _loop_1 = function(index) {
                    var element = this_1.items[index];
                    var $element = app_$LG(element);
                    var uuid = app_lgQuery.generateUUID();
                    $element.attr("data-lg-id", uuid).on("click.lgcustom-item-" + uuid, (function(e) {
                        e.preventDefault();
                        var currentItemIndex = _this.settings.index || index;
                        _this.openGallery(currentItemIndex, element);
                    }));
                };
                var this_1 = this;
                for (var index = 0; index < this.items.length; index++) _loop_1(index);
            };
            LightGallery.prototype.buildModules = function() {
                var _this = this;
                this.settings.plugins.forEach((function(plugin) {
                    _this.plugins.push(new plugin(_this, app_$LG));
                }));
            };
            LightGallery.prototype.validateLicense = function() {
                if (!this.settings.licenseKey) console.error("Please provide a valid license key"); else if (this.settings.licenseKey === "0000-0000-000-0000") console.warn("lightGallery: " + this.settings.licenseKey + " license key is not valid for production use");
            };
            LightGallery.prototype.getSlideItem = function(index) {
                return app_$LG(this.getSlideItemId(index));
            };
            LightGallery.prototype.getSlideItemId = function(index) {
                return "#lg-item-" + this.lgId + "-" + index;
            };
            LightGallery.prototype.getIdName = function(id) {
                return id + "-" + this.lgId;
            };
            LightGallery.prototype.getElementById = function(id) {
                return app_$LG("#" + this.getIdName(id));
            };
            LightGallery.prototype.manageSingleSlideClassName = function() {
                if (this.galleryItems.length < 2) this.outer.addClass("lg-single-item"); else this.outer.removeClass("lg-single-item");
            };
            LightGallery.prototype.buildStructure = function() {
                var _this = this;
                var container = this.$container && this.$container.get();
                if (container) return;
                var controls = "";
                var subHtmlCont = "";
                if (this.settings.controls) controls = '<button type="button" id="' + this.getIdName("lg-prev") + '" aria-label="' + this.settings.strings["previousSlide"] + '" class="lg-prev lg-icon"> ' + this.settings.prevHtml + ' </button>\n                <button type="button" id="' + this.getIdName("lg-next") + '" aria-label="' + this.settings.strings["nextSlide"] + '" class="lg-next lg-icon"> ' + this.settings.nextHtml + " </button>";
                if (this.settings.appendSubHtmlTo !== ".lg-item") subHtmlCont = '<div class="lg-sub-html" role="status" aria-live="polite"></div>';
                var addClasses = "";
                if (this.settings.allowMediaOverlap) addClasses += "lg-media-overlap ";
                var ariaLabelledby = this.settings.ariaLabelledby ? 'aria-labelledby="' + this.settings.ariaLabelledby + '"' : "";
                var ariaDescribedby = this.settings.ariaDescribedby ? 'aria-describedby="' + this.settings.ariaDescribedby + '"' : "";
                var containerClassName = "lg-container " + this.settings.addClass + " " + (document.body !== this.settings.container ? "lg-inline" : "");
                var closeIcon = this.settings.closable && this.settings.showCloseIcon ? '<button type="button" aria-label="' + this.settings.strings["closeGallery"] + '" id="' + this.getIdName("lg-close") + '" class="lg-close lg-icon"></button>' : "";
                var maximizeIcon = this.settings.showMaximizeIcon ? '<button type="button" aria-label="' + this.settings.strings["toggleMaximize"] + '" id="' + this.getIdName("lg-maximize") + '" class="lg-maximize lg-icon"></button>' : "";
                var template = '\n        <div class="' + containerClassName + '" id="' + this.getIdName("lg-container") + '" tabindex="-1" aria-modal="true" ' + ariaLabelledby + " " + ariaDescribedby + ' role="dialog"\n        >\n            <div id="' + this.getIdName("lg-backdrop") + '" class="lg-backdrop"></div>\n\n            <div id="' + this.getIdName("lg-outer") + '" class="lg-outer lg-use-css3 lg-css3 lg-hide-items ' + addClasses + ' ">\n\n              <div id="' + this.getIdName("lg-content") + '" class="lg-content">\n                <div id="' + this.getIdName("lg-inner") + '" class="lg-inner">\n                </div>\n                ' + controls + '\n              </div>\n                <div id="' + this.getIdName("lg-toolbar") + '" class="lg-toolbar lg-group">\n                    ' + maximizeIcon + "\n                    " + closeIcon + "\n                    </div>\n                    " + (this.settings.appendSubHtmlTo === ".lg-outer" ? subHtmlCont : "") + '\n                <div id="' + this.getIdName("lg-components") + '" class="lg-components">\n                    ' + (this.settings.appendSubHtmlTo === ".lg-sub-html" ? subHtmlCont : "") + "\n                </div>\n            </div>\n        </div>\n        ";
                app_$LG(this.settings.container).append(template);
                if (document.body !== this.settings.container) app_$LG(this.settings.container).css("position", "relative");
                this.outer = this.getElementById("lg-outer");
                this.$lgComponents = this.getElementById("lg-components");
                this.$backdrop = this.getElementById("lg-backdrop");
                this.$container = this.getElementById("lg-container");
                this.$inner = this.getElementById("lg-inner");
                this.$content = this.getElementById("lg-content");
                this.$toolbar = this.getElementById("lg-toolbar");
                this.$backdrop.css("transition-duration", this.settings.backdropDuration + "ms");
                var outerClassNames = this.settings.mode + " ";
                this.manageSingleSlideClassName();
                if (this.settings.enableDrag) outerClassNames += "lg-grab ";
                this.outer.addClass(outerClassNames);
                this.$inner.css("transition-timing-function", this.settings.easing);
                this.$inner.css("transition-duration", this.settings.speed + "ms");
                if (this.settings.download) this.$toolbar.append('<a id="' + this.getIdName("lg-download") + '" target="_blank" rel="noopener" aria-label="' + this.settings.strings["download"] + '" download class="lg-download lg-icon"></a>');
                this.counter();
                app_$LG(window).on("resize.lg.global" + this.lgId + " orientationchange.lg.global" + this.lgId, (function() {
                    _this.refreshOnResize();
                }));
                this.hideBars();
                this.manageCloseGallery();
                this.toggleMaximize();
                this.initModules();
            };
            LightGallery.prototype.refreshOnResize = function() {
                if (this.lgOpened) {
                    var currentGalleryItem = this.galleryItems[this.index];
                    var __slideVideoInfo = currentGalleryItem.__slideVideoInfo;
                    this.mediaContainerPosition = this.getMediaContainerPosition();
                    var _a = this.mediaContainerPosition, top_1 = _a.top, bottom = _a.bottom;
                    this.currentImageSize = app_lightgallery_es5_utils.getSize(this.items[this.index], this.outer, top_1 + bottom, __slideVideoInfo && this.settings.videoMaxSize);
                    if (__slideVideoInfo) this.resizeVideoSlide(this.index, this.currentImageSize);
                    if (this.zoomFromOrigin && !this.isDummyImageRemoved) {
                        var imgStyle = this.getDummyImgStyles(this.currentImageSize);
                        this.outer.find(".lg-current .lg-dummy-img").first().attr("style", imgStyle);
                    }
                    this.LGel.trigger(app_lGEvents.containerResize);
                }
            };
            LightGallery.prototype.resizeVideoSlide = function(index, imageSize) {
                var lgVideoStyle = this.getVideoContStyle(imageSize);
                var currentSlide = this.getSlideItem(index);
                currentSlide.find(".lg-video-cont").attr("style", lgVideoStyle);
            };
            LightGallery.prototype.updateSlides = function(items, index) {
                if (this.index > items.length - 1) this.index = items.length - 1;
                if (items.length === 1) this.index = 0;
                if (!items.length) {
                    this.closeGallery();
                    return;
                }
                var currentSrc = this.galleryItems[index].src;
                this.galleryItems = items;
                this.updateControls();
                this.$inner.empty();
                this.currentItemsInDom = [];
                var _index = 0;
                this.galleryItems.some((function(galleryItem, itemIndex) {
                    if (galleryItem.src === currentSrc) {
                        _index = itemIndex;
                        return true;
                    }
                    return false;
                }));
                this.currentItemsInDom = this.organizeSlideItems(_index, -1);
                this.loadContent(_index, true);
                this.getSlideItem(_index).addClass("lg-current");
                this.index = _index;
                this.updateCurrentCounter(_index);
                this.LGel.trigger(app_lGEvents.updateSlides);
            };
            LightGallery.prototype.getItems = function() {
                this.items = [];
                if (!this.settings.dynamic) {
                    if (this.settings.selector === "this") this.items.push(this.el); else if (this.settings.selector) if (typeof this.settings.selector === "string") if (this.settings.selectWithin) {
                        var selectWithin = app_$LG(this.settings.selectWithin);
                        this.items = selectWithin.find(this.settings.selector).get();
                    } else this.items = this.el.querySelectorAll(this.settings.selector); else this.items = this.settings.selector; else this.items = this.el.children;
                    return app_lightgallery_es5_utils.getDynamicOptions(this.items, this.settings.extraProps, this.settings.getCaptionFromTitleOrAlt, this.settings.exThumbImage);
                } else return this.settings.dynamicEl || [];
            };
            LightGallery.prototype.shouldHideScrollbar = function() {
                return this.settings.hideScrollbar && document.body === this.settings.container;
            };
            LightGallery.prototype.hideScrollbar = function() {
                if (!this.shouldHideScrollbar()) return;
                this.bodyPaddingRight = parseFloat(app_$LG("body").style().paddingRight);
                var bodyRect = document.documentElement.getBoundingClientRect();
                var scrollbarWidth = window.innerWidth - bodyRect.width;
                app_$LG(document.body).css("padding-right", scrollbarWidth + this.bodyPaddingRight + "px");
                app_$LG(document.body).addClass("lg-overlay-open");
            };
            LightGallery.prototype.resetScrollBar = function() {
                if (!this.shouldHideScrollbar()) return;
                app_$LG(document.body).css("padding-right", this.bodyPaddingRight + "px");
                app_$LG(document.body).removeClass("lg-overlay-open");
            };
            LightGallery.prototype.openGallery = function(index, element) {
                var _this = this;
                if (index === void 0) index = this.settings.index;
                if (this.lgOpened) return;
                this.lgOpened = true;
                this.outer.removeClass("lg-hide-items");
                this.hideScrollbar();
                this.$container.addClass("lg-show");
                var itemsToBeInsertedToDom = this.getItemsToBeInsertedToDom(index, index);
                this.currentItemsInDom = itemsToBeInsertedToDom;
                var items = "";
                itemsToBeInsertedToDom.forEach((function(item) {
                    items = items + '<div id="' + item + '" class="lg-item"></div>';
                }));
                this.$inner.append(items);
                this.addHtml(index);
                var transform = "";
                this.mediaContainerPosition = this.getMediaContainerPosition();
                var _a = this.mediaContainerPosition, top = _a.top, bottom = _a.bottom;
                if (!this.settings.allowMediaOverlap) this.setMediaContainerPosition(top, bottom);
                var __slideVideoInfo = this.galleryItems[index].__slideVideoInfo;
                if (this.zoomFromOrigin && element) {
                    this.currentImageSize = app_lightgallery_es5_utils.getSize(element, this.outer, top + bottom, __slideVideoInfo && this.settings.videoMaxSize);
                    transform = app_lightgallery_es5_utils.getTransform(element, this.outer, top, bottom, this.currentImageSize);
                }
                if (!this.zoomFromOrigin || !transform) {
                    this.outer.addClass(this.settings.startClass);
                    this.getSlideItem(index).removeClass("lg-complete");
                }
                var timeout = this.settings.zoomFromOrigin ? 100 : this.settings.backdropDuration;
                setTimeout((function() {
                    _this.outer.addClass("lg-components-open");
                }), timeout);
                this.index = index;
                this.LGel.trigger(app_lGEvents.beforeOpen);
                this.getSlideItem(index).addClass("lg-current");
                this.lGalleryOn = false;
                this.prevScrollTop = app_$LG(window).scrollTop();
                setTimeout((function() {
                    if (_this.zoomFromOrigin && transform) {
                        var currentSlide_1 = _this.getSlideItem(index);
                        currentSlide_1.css("transform", transform);
                        setTimeout((function() {
                            currentSlide_1.addClass("lg-start-progress lg-start-end-progress").css("transition-duration", _this.settings.startAnimationDuration + "ms");
                            _this.outer.addClass("lg-zoom-from-image");
                        }));
                        setTimeout((function() {
                            currentSlide_1.css("transform", "translate3d(0, 0, 0)");
                        }), 100);
                    }
                    setTimeout((function() {
                        _this.$backdrop.addClass("in");
                        _this.$container.addClass("lg-show-in");
                    }), 10);
                    setTimeout((function() {
                        if (_this.settings.trapFocus && document.body === _this.settings.container) _this.trapFocus();
                    }), _this.settings.backdropDuration + 50);
                    if (!_this.zoomFromOrigin || !transform) setTimeout((function() {
                        _this.outer.addClass("lg-visible");
                    }), _this.settings.backdropDuration);
                    _this.slide(index, false, false, false);
                    _this.LGel.trigger(app_lGEvents.afterOpen);
                }));
                if (document.body === this.settings.container) app_$LG("html").addClass("lg-on");
            };
            LightGallery.prototype.getMediaContainerPosition = function() {
                if (this.settings.allowMediaOverlap) return {
                    top: 0,
                    bottom: 0
                };
                var top = this.$toolbar.get().clientHeight || 0;
                var subHtml = this.outer.find(".lg-components .lg-sub-html").get();
                var captionHeight = this.settings.defaultCaptionHeight || subHtml && subHtml.clientHeight || 0;
                var thumbContainer = this.outer.find(".lg-thumb-outer").get();
                var thumbHeight = thumbContainer ? thumbContainer.clientHeight : 0;
                var bottom = thumbHeight + captionHeight;
                return {
                    top,
                    bottom
                };
            };
            LightGallery.prototype.setMediaContainerPosition = function(top, bottom) {
                if (top === void 0) top = 0;
                if (bottom === void 0) bottom = 0;
                this.$content.css("top", top + "px").css("bottom", bottom + "px");
            };
            LightGallery.prototype.hideBars = function() {
                var _this = this;
                setTimeout((function() {
                    _this.outer.removeClass("lg-hide-items");
                    if (_this.settings.hideBarsDelay > 0) {
                        _this.outer.on("mousemove.lg click.lg touchstart.lg", (function() {
                            _this.outer.removeClass("lg-hide-items");
                            clearTimeout(_this.hideBarTimeout);
                            _this.hideBarTimeout = setTimeout((function() {
                                _this.outer.addClass("lg-hide-items");
                            }), _this.settings.hideBarsDelay);
                        }));
                        _this.outer.trigger("mousemove.lg");
                    }
                }), this.settings.showBarsAfter);
            };
            LightGallery.prototype.initPictureFill = function($img) {
                if (this.settings.supportLegacyBrowser) try {
                    picturefill({
                        elements: [ $img.get() ]
                    });
                } catch (e) {
                    console.warn("lightGallery :- If you want srcset or picture tag to be supported for older browser please include picturefil javascript library in your document.");
                }
            };
            LightGallery.prototype.counter = function() {
                if (this.settings.counter) {
                    var counterHtml = '<div class="lg-counter" role="status" aria-live="polite">\n                <span id="' + this.getIdName("lg-counter-current") + '" class="lg-counter-current">' + (this.index + 1) + ' </span> /\n                <span id="' + this.getIdName("lg-counter-all") + '" class="lg-counter-all">' + this.galleryItems.length + " </span></div>";
                    this.outer.find(this.settings.appendCounterTo).append(counterHtml);
                }
            };
            LightGallery.prototype.addHtml = function(index) {
                var subHtml;
                var subHtmlUrl;
                if (this.galleryItems[index].subHtmlUrl) subHtmlUrl = this.galleryItems[index].subHtmlUrl; else subHtml = this.galleryItems[index].subHtml;
                if (!subHtmlUrl) if (subHtml) {
                    var fL = subHtml.substring(0, 1);
                    if (fL === "." || fL === "#") if (this.settings.subHtmlSelectorRelative && !this.settings.dynamic) subHtml = app_$LG(this.items).eq(index).find(subHtml).first().html(); else subHtml = app_$LG(subHtml).first().html();
                } else subHtml = "";
                if (this.settings.appendSubHtmlTo !== ".lg-item") if (subHtmlUrl) app_lightgallery_es5_utils.fetchCaptionFromUrl(subHtmlUrl, this.outer.find(".lg-sub-html"), "replace"); else this.outer.find(".lg-sub-html").html(subHtml); else {
                    var currentSlide = app_$LG(this.getSlideItemId(index));
                    if (subHtmlUrl) app_lightgallery_es5_utils.fetchCaptionFromUrl(subHtmlUrl, currentSlide, "append"); else currentSlide.append('<div class="lg-sub-html">' + subHtml + "</div>");
                }
                if (typeof subHtml !== "undefined" && subHtml !== null) if (subHtml === "") this.outer.find(this.settings.appendSubHtmlTo).addClass("lg-empty-html"); else this.outer.find(this.settings.appendSubHtmlTo).removeClass("lg-empty-html");
                this.LGel.trigger(app_lGEvents.afterAppendSubHtml, {
                    index
                });
            };
            LightGallery.prototype.preload = function(index) {
                for (var i = 1; i <= this.settings.preload; i++) {
                    if (i >= this.galleryItems.length - index) break;
                    this.loadContent(index + i, false);
                }
                for (var j = 1; j <= this.settings.preload; j++) {
                    if (index - j < 0) break;
                    this.loadContent(index - j, false);
                }
            };
            LightGallery.prototype.getDummyImgStyles = function(imageSize) {
                if (!imageSize) return "";
                return "width:" + imageSize.width + "px;\n                margin-left: -" + imageSize.width / 2 + "px;\n                margin-top: -" + imageSize.height / 2 + "px;\n                height:" + imageSize.height + "px";
            };
            LightGallery.prototype.getVideoContStyle = function(imageSize) {
                if (!imageSize) return "";
                return "width:" + imageSize.width + "px;\n                height:" + imageSize.height + "px";
            };
            LightGallery.prototype.getDummyImageContent = function($currentSlide, index, alt) {
                var $currentItem;
                if (!this.settings.dynamic) $currentItem = app_$LG(this.items).eq(index);
                if ($currentItem) {
                    var _dummyImgSrc = void 0;
                    if (!this.settings.exThumbImage) _dummyImgSrc = $currentItem.find("img").first().attr("src"); else _dummyImgSrc = $currentItem.attr(this.settings.exThumbImage);
                    if (!_dummyImgSrc) return "";
                    var imgStyle = this.getDummyImgStyles(this.currentImageSize);
                    var dummyImgContentImg = document.createElement("img");
                    dummyImgContentImg.alt = alt || "";
                    dummyImgContentImg.src = _dummyImgSrc;
                    dummyImgContentImg.className = "lg-dummy-img";
                    dummyImgContentImg.style.cssText = imgStyle;
                    $currentSlide.addClass("lg-first-slide");
                    this.outer.addClass("lg-first-slide-loading");
                    return dummyImgContentImg;
                }
                return "";
            };
            LightGallery.prototype.setImgMarkup = function(src, $currentSlide, index) {
                var currentGalleryItem = this.galleryItems[index];
                var alt = currentGalleryItem.alt, srcset = currentGalleryItem.srcset, sizes = currentGalleryItem.sizes, sources = currentGalleryItem.sources;
                var imgContent = "";
                var altAttr = alt ? 'alt="' + alt + '"' : "";
                if (this.isFirstSlideWithZoomAnimation()) imgContent = this.getDummyImageContent($currentSlide, index, altAttr); else imgContent = app_lightgallery_es5_utils.getImgMarkup(index, src, altAttr, srcset, sizes, sources);
                var picture = document.createElement("picture");
                picture.className = "lg-img-wrap";
                app_$LG(picture).append(imgContent);
                $currentSlide.prepend(picture);
            };
            LightGallery.prototype.onSlideObjectLoad = function($slide, isHTML5VideoWithoutPoster, onLoad, onError) {
                var mediaObject = $slide.find(".lg-object").first();
                if (app_lightgallery_es5_utils.isImageLoaded(mediaObject.get()) || isHTML5VideoWithoutPoster) onLoad(); else {
                    mediaObject.on("load.lg error.lg", (function() {
                        onLoad && onLoad();
                    }));
                    mediaObject.on("error.lg", (function() {
                        onError && onError();
                    }));
                }
            };
            LightGallery.prototype.onLgObjectLoad = function(currentSlide, index, delay, speed, isFirstSlide, isHTML5VideoWithoutPoster) {
                var _this = this;
                this.onSlideObjectLoad(currentSlide, isHTML5VideoWithoutPoster, (function() {
                    _this.triggerSlideItemLoad(currentSlide, index, delay, speed, isFirstSlide);
                }), (function() {
                    currentSlide.addClass("lg-complete lg-complete_");
                    currentSlide.html('<span class="lg-error-msg">' + _this.settings.strings["mediaLoadingFailed"] + "</span>");
                }));
            };
            LightGallery.prototype.triggerSlideItemLoad = function($currentSlide, index, delay, speed, isFirstSlide) {
                var _this = this;
                var currentGalleryItem = this.galleryItems[index];
                var _speed = isFirstSlide && this.getSlideType(currentGalleryItem) === "video" && !currentGalleryItem.poster ? speed : 0;
                setTimeout((function() {
                    $currentSlide.addClass("lg-complete lg-complete_");
                    _this.LGel.trigger(app_lGEvents.slideItemLoad, {
                        index,
                        delay: delay || 0,
                        isFirstSlide
                    });
                }), _speed);
            };
            LightGallery.prototype.isFirstSlideWithZoomAnimation = function() {
                return !!(!this.lGalleryOn && this.zoomFromOrigin && this.currentImageSize);
            };
            LightGallery.prototype.addSlideVideoInfo = function(items) {
                var _this = this;
                items.forEach((function(element, index) {
                    element.__slideVideoInfo = app_lightgallery_es5_utils.isVideo(element.src, !!element.video, index);
                    if (element.__slideVideoInfo && _this.settings.loadYouTubePoster && !element.poster && element.__slideVideoInfo.youtube) element.poster = "//img.youtube.com/vi/" + element.__slideVideoInfo.youtube[1] + "/maxresdefault.jpg";
                }));
            };
            LightGallery.prototype.loadContent = function(index, rec) {
                var _this = this;
                var currentGalleryItem = this.galleryItems[index];
                var $currentSlide = app_$LG(this.getSlideItemId(index));
                var poster = currentGalleryItem.poster, srcset = currentGalleryItem.srcset, sizes = currentGalleryItem.sizes, sources = currentGalleryItem.sources;
                var src = currentGalleryItem.src;
                var video = currentGalleryItem.video;
                var _html5Video = video && typeof video === "string" ? JSON.parse(video) : video;
                if (currentGalleryItem.responsive) {
                    var srcDyItms = currentGalleryItem.responsive.split(",");
                    src = app_lightgallery_es5_utils.getResponsiveSrc(srcDyItms) || src;
                }
                var videoInfo = currentGalleryItem.__slideVideoInfo;
                var lgVideoStyle = "";
                var iframe = !!currentGalleryItem.iframe;
                var isFirstSlide = !this.lGalleryOn;
                var delay = 0;
                if (isFirstSlide) if (this.zoomFromOrigin && this.currentImageSize) delay = this.settings.startAnimationDuration + 10; else delay = this.settings.backdropDuration + 10;
                if (!$currentSlide.hasClass("lg-loaded")) {
                    if (videoInfo) {
                        var _a = this.mediaContainerPosition, top_2 = _a.top, bottom = _a.bottom;
                        var videoSize = app_lightgallery_es5_utils.getSize(this.items[index], this.outer, top_2 + bottom, videoInfo && this.settings.videoMaxSize);
                        lgVideoStyle = this.getVideoContStyle(videoSize);
                    }
                    if (iframe) {
                        var markup = app_lightgallery_es5_utils.getIframeMarkup(this.settings.iframeWidth, this.settings.iframeHeight, this.settings.iframeMaxWidth, this.settings.iframeMaxHeight, src, currentGalleryItem.iframeTitle);
                        $currentSlide.prepend(markup);
                    } else if (poster) {
                        var dummyImg = "";
                        var hasStartAnimation = isFirstSlide && this.zoomFromOrigin && this.currentImageSize;
                        if (hasStartAnimation) dummyImg = this.getDummyImageContent($currentSlide, index, "");
                        markup = app_lightgallery_es5_utils.getVideoPosterMarkup(poster, dummyImg || "", lgVideoStyle, this.settings.strings["playVideo"], videoInfo);
                        $currentSlide.prepend(markup);
                    } else if (videoInfo) {
                        markup = '<div class="lg-video-cont " style="' + lgVideoStyle + '"></div>';
                        $currentSlide.prepend(markup);
                    } else {
                        this.setImgMarkup(src, $currentSlide, index);
                        if (srcset || sources) {
                            var $img = $currentSlide.find(".lg-object");
                            this.initPictureFill($img);
                        }
                    }
                    if (poster || videoInfo) this.LGel.trigger(app_lGEvents.hasVideo, {
                        index,
                        src,
                        html5Video: _html5Video,
                        hasPoster: !!poster
                    });
                    this.LGel.trigger(app_lGEvents.afterAppendSlide, {
                        index
                    });
                    if (this.lGalleryOn && this.settings.appendSubHtmlTo === ".lg-item") this.addHtml(index);
                }
                var _speed = 0;
                if (delay && !app_$LG(document.body).hasClass("lg-from-hash")) _speed = delay;
                if (this.isFirstSlideWithZoomAnimation()) {
                    setTimeout((function() {
                        $currentSlide.removeClass("lg-start-end-progress lg-start-progress").removeAttr("style");
                    }), this.settings.startAnimationDuration + 100);
                    if (!$currentSlide.hasClass("lg-loaded")) setTimeout((function() {
                        if (_this.getSlideType(currentGalleryItem) === "image") {
                            var alt = currentGalleryItem.alt;
                            var altAttr = alt ? 'alt="' + alt + '"' : "";
                            $currentSlide.find(".lg-img-wrap").append(app_lightgallery_es5_utils.getImgMarkup(index, src, altAttr, srcset, sizes, currentGalleryItem.sources));
                            if (srcset || sources) {
                                var $img = $currentSlide.find(".lg-object");
                                _this.initPictureFill($img);
                            }
                        }
                        if (_this.getSlideType(currentGalleryItem) === "image" || _this.getSlideType(currentGalleryItem) === "video" && poster) {
                            _this.onLgObjectLoad($currentSlide, index, delay, _speed, true, false);
                            _this.onSlideObjectLoad($currentSlide, !!(videoInfo && videoInfo.html5 && !poster), (function() {
                                _this.loadContentOnFirstSlideLoad(index, $currentSlide, _speed);
                            }), (function() {
                                _this.loadContentOnFirstSlideLoad(index, $currentSlide, _speed);
                            }));
                        }
                    }), this.settings.startAnimationDuration + 100);
                }
                $currentSlide.addClass("lg-loaded");
                if (!this.isFirstSlideWithZoomAnimation() || this.getSlideType(currentGalleryItem) === "video" && !poster) this.onLgObjectLoad($currentSlide, index, delay, _speed, isFirstSlide, !!(videoInfo && videoInfo.html5 && !poster));
                if ((!this.zoomFromOrigin || !this.currentImageSize) && $currentSlide.hasClass("lg-complete_") && !this.lGalleryOn) setTimeout((function() {
                    $currentSlide.addClass("lg-complete");
                }), this.settings.backdropDuration);
                this.lGalleryOn = true;
                if (rec === true) if (!$currentSlide.hasClass("lg-complete_")) $currentSlide.find(".lg-object").first().on("load.lg error.lg", (function() {
                    _this.preload(index);
                })); else this.preload(index);
            };
            LightGallery.prototype.loadContentOnFirstSlideLoad = function(index, $currentSlide, speed) {
                var _this = this;
                setTimeout((function() {
                    $currentSlide.find(".lg-dummy-img").remove();
                    $currentSlide.removeClass("lg-first-slide");
                    _this.outer.removeClass("lg-first-slide-loading");
                    _this.isDummyImageRemoved = true;
                    _this.preload(index);
                }), speed + 300);
            };
            LightGallery.prototype.getItemsToBeInsertedToDom = function(index, prevIndex, numberOfItems) {
                var _this = this;
                if (numberOfItems === void 0) numberOfItems = 0;
                var itemsToBeInsertedToDom = [];
                var possibleNumberOfItems = Math.max(numberOfItems, 3);
                possibleNumberOfItems = Math.min(possibleNumberOfItems, this.galleryItems.length);
                var prevIndexItem = "lg-item-" + this.lgId + "-" + prevIndex;
                if (this.galleryItems.length <= 3) {
                    this.galleryItems.forEach((function(_element, index) {
                        itemsToBeInsertedToDom.push("lg-item-" + _this.lgId + "-" + index);
                    }));
                    return itemsToBeInsertedToDom;
                }
                if (index < (this.galleryItems.length - 1) / 2) {
                    for (var idx = index; idx > index - possibleNumberOfItems / 2 && idx >= 0; idx--) itemsToBeInsertedToDom.push("lg-item-" + this.lgId + "-" + idx);
                    var numberOfExistingItems = itemsToBeInsertedToDom.length;
                    for (idx = 0; idx < possibleNumberOfItems - numberOfExistingItems; idx++) itemsToBeInsertedToDom.push("lg-item-" + this.lgId + "-" + (index + idx + 1));
                } else {
                    for (idx = index; idx <= this.galleryItems.length - 1 && idx < index + possibleNumberOfItems / 2; idx++) itemsToBeInsertedToDom.push("lg-item-" + this.lgId + "-" + idx);
                    numberOfExistingItems = itemsToBeInsertedToDom.length;
                    for (idx = 0; idx < possibleNumberOfItems - numberOfExistingItems; idx++) itemsToBeInsertedToDom.push("lg-item-" + this.lgId + "-" + (index - idx - 1));
                }
                if (this.settings.loop) if (index === this.galleryItems.length - 1) itemsToBeInsertedToDom.push("lg-item-" + this.lgId + "-" + 0); else if (index === 0) itemsToBeInsertedToDom.push("lg-item-" + this.lgId + "-" + (this.galleryItems.length - 1));
                if (itemsToBeInsertedToDom.indexOf(prevIndexItem) === -1) itemsToBeInsertedToDom.push("lg-item-" + this.lgId + "-" + prevIndex);
                return itemsToBeInsertedToDom;
            };
            LightGallery.prototype.organizeSlideItems = function(index, prevIndex) {
                var _this = this;
                var itemsToBeInsertedToDom = this.getItemsToBeInsertedToDom(index, prevIndex, this.settings.numberOfSlideItemsInDom);
                itemsToBeInsertedToDom.forEach((function(item) {
                    if (_this.currentItemsInDom.indexOf(item) === -1) _this.$inner.append('<div id="' + item + '" class="lg-item"></div>');
                }));
                this.currentItemsInDom.forEach((function(item) {
                    if (itemsToBeInsertedToDom.indexOf(item) === -1) app_$LG("#" + item).remove();
                }));
                return itemsToBeInsertedToDom;
            };
            LightGallery.prototype.getPreviousSlideIndex = function() {
                var prevIndex = 0;
                try {
                    var currentItemId = this.outer.find(".lg-current").first().attr("id");
                    prevIndex = parseInt(currentItemId.split("-")[3]) || 0;
                } catch (error) {
                    prevIndex = 0;
                }
                return prevIndex;
            };
            LightGallery.prototype.setDownloadValue = function(index) {
                if (this.settings.download) {
                    var currentGalleryItem = this.galleryItems[index];
                    var hideDownloadBtn = currentGalleryItem.downloadUrl === false || currentGalleryItem.downloadUrl === "false";
                    if (hideDownloadBtn) this.outer.addClass("lg-hide-download"); else {
                        var $download = this.getElementById("lg-download");
                        this.outer.removeClass("lg-hide-download");
                        $download.attr("href", currentGalleryItem.downloadUrl || currentGalleryItem.src);
                        if (currentGalleryItem.download) $download.attr("download", currentGalleryItem.download);
                    }
                }
            };
            LightGallery.prototype.makeSlideAnimation = function(direction, currentSlideItem, previousSlideItem) {
                var _this = this;
                if (this.lGalleryOn) previousSlideItem.addClass("lg-slide-progress");
                setTimeout((function() {
                    _this.outer.addClass("lg-no-trans");
                    _this.outer.find(".lg-item").removeClass("lg-prev-slide lg-next-slide");
                    if (direction === "prev") {
                        currentSlideItem.addClass("lg-prev-slide");
                        previousSlideItem.addClass("lg-next-slide");
                    } else {
                        currentSlideItem.addClass("lg-next-slide");
                        previousSlideItem.addClass("lg-prev-slide");
                    }
                    setTimeout((function() {
                        _this.outer.find(".lg-item").removeClass("lg-current");
                        currentSlideItem.addClass("lg-current");
                        _this.outer.removeClass("lg-no-trans");
                    }), 50);
                }), this.lGalleryOn ? this.settings.slideDelay : 0);
            };
            LightGallery.prototype.slide = function(index, fromTouch, fromThumb, direction) {
                var _this = this;
                var prevIndex = this.getPreviousSlideIndex();
                this.currentItemsInDom = this.organizeSlideItems(index, prevIndex);
                if (this.lGalleryOn && prevIndex === index) return;
                var numberOfGalleryItems = this.galleryItems.length;
                if (!this.lgBusy) {
                    if (this.settings.counter) this.updateCurrentCounter(index);
                    var currentSlideItem = this.getSlideItem(index);
                    var previousSlideItem_1 = this.getSlideItem(prevIndex);
                    var currentGalleryItem = this.galleryItems[index];
                    var videoInfo = currentGalleryItem.__slideVideoInfo;
                    this.outer.attr("data-lg-slide-type", this.getSlideType(currentGalleryItem));
                    this.setDownloadValue(index);
                    if (videoInfo) {
                        var _a = this.mediaContainerPosition, top_3 = _a.top, bottom = _a.bottom;
                        var videoSize = app_lightgallery_es5_utils.getSize(this.items[index], this.outer, top_3 + bottom, videoInfo && this.settings.videoMaxSize);
                        this.resizeVideoSlide(index, videoSize);
                    }
                    this.LGel.trigger(app_lGEvents.beforeSlide, {
                        prevIndex,
                        index,
                        fromTouch: !!fromTouch,
                        fromThumb: !!fromThumb
                    });
                    this.lgBusy = true;
                    clearTimeout(this.hideBarTimeout);
                    this.arrowDisable(index);
                    if (!direction) if (index < prevIndex) direction = "prev"; else if (index > prevIndex) direction = "next";
                    if (!fromTouch) this.makeSlideAnimation(direction, currentSlideItem, previousSlideItem_1); else {
                        this.outer.find(".lg-item").removeClass("lg-prev-slide lg-current lg-next-slide");
                        var touchPrev = void 0;
                        var touchNext = void 0;
                        if (numberOfGalleryItems > 2) {
                            touchPrev = index - 1;
                            touchNext = index + 1;
                            if (index === 0 && prevIndex === numberOfGalleryItems - 1) {
                                touchNext = 0;
                                touchPrev = numberOfGalleryItems - 1;
                            } else if (index === numberOfGalleryItems - 1 && prevIndex === 0) {
                                touchNext = 0;
                                touchPrev = numberOfGalleryItems - 1;
                            }
                        } else {
                            touchPrev = 0;
                            touchNext = 1;
                        }
                        if (direction === "prev") this.getSlideItem(touchNext).addClass("lg-next-slide"); else this.getSlideItem(touchPrev).addClass("lg-prev-slide");
                        currentSlideItem.addClass("lg-current");
                    }
                    if (!this.lGalleryOn) this.loadContent(index, true); else setTimeout((function() {
                        _this.loadContent(index, true);
                        if (_this.settings.appendSubHtmlTo !== ".lg-item") _this.addHtml(index);
                    }), this.settings.speed + 50 + (fromTouch ? 0 : this.settings.slideDelay));
                    setTimeout((function() {
                        _this.lgBusy = false;
                        previousSlideItem_1.removeClass("lg-slide-progress");
                        _this.LGel.trigger(app_lGEvents.afterSlide, {
                            prevIndex,
                            index,
                            fromTouch,
                            fromThumb
                        });
                    }), (this.lGalleryOn ? this.settings.speed + 100 : 100) + (fromTouch ? 0 : this.settings.slideDelay));
                }
                this.index = index;
            };
            LightGallery.prototype.updateCurrentCounter = function(index) {
                this.getElementById("lg-counter-current").html(index + 1 + "");
            };
            LightGallery.prototype.updateCounterTotal = function() {
                this.getElementById("lg-counter-all").html(this.galleryItems.length + "");
            };
            LightGallery.prototype.getSlideType = function(item) {
                if (item.__slideVideoInfo) return "video"; else if (item.iframe) return "iframe"; else return "image";
            };
            LightGallery.prototype.touchMove = function(startCoords, endCoords, e) {
                var distanceX = endCoords.pageX - startCoords.pageX;
                var distanceY = endCoords.pageY - startCoords.pageY;
                var allowSwipe = false;
                if (this.swipeDirection) allowSwipe = true; else if (Math.abs(distanceX) > 15) {
                    this.swipeDirection = "horizontal";
                    allowSwipe = true;
                } else if (Math.abs(distanceY) > 15) {
                    this.swipeDirection = "vertical";
                    allowSwipe = true;
                }
                if (!allowSwipe) return;
                var $currentSlide = this.getSlideItem(this.index);
                if (this.swipeDirection === "horizontal") {
                    e === null || e === void 0 ? void 0 : e.preventDefault();
                    this.outer.addClass("lg-dragging");
                    this.setTranslate($currentSlide, distanceX, 0);
                    var width = $currentSlide.get().offsetWidth;
                    var slideWidthAmount = width * 15 / 100;
                    var gutter = slideWidthAmount - Math.abs(distanceX * 10 / 100);
                    this.setTranslate(this.outer.find(".lg-prev-slide").first(), -width + distanceX - gutter, 0);
                    this.setTranslate(this.outer.find(".lg-next-slide").first(), width + distanceX + gutter, 0);
                } else if (this.swipeDirection === "vertical") if (this.settings.swipeToClose) {
                    e === null || e === void 0 ? void 0 : e.preventDefault();
                    this.$container.addClass("lg-dragging-vertical");
                    var opacity = 1 - Math.abs(distanceY) / window.innerHeight;
                    this.$backdrop.css("opacity", opacity);
                    var scale = 1 - Math.abs(distanceY) / (window.innerWidth * 2);
                    this.setTranslate($currentSlide, 0, distanceY, scale, scale);
                    if (Math.abs(distanceY) > 100) this.outer.addClass("lg-hide-items").removeClass("lg-components-open");
                }
            };
            LightGallery.prototype.touchEnd = function(endCoords, startCoords, event) {
                var _this = this;
                var distance;
                if (this.settings.mode !== "lg-slide") this.outer.addClass("lg-slide");
                setTimeout((function() {
                    _this.$container.removeClass("lg-dragging-vertical");
                    _this.outer.removeClass("lg-dragging lg-hide-items").addClass("lg-components-open");
                    var triggerClick = true;
                    if (_this.swipeDirection === "horizontal") {
                        distance = endCoords.pageX - startCoords.pageX;
                        var distanceAbs = Math.abs(endCoords.pageX - startCoords.pageX);
                        if (distance < 0 && distanceAbs > _this.settings.swipeThreshold) {
                            _this.goToNextSlide(true);
                            triggerClick = false;
                        } else if (distance > 0 && distanceAbs > _this.settings.swipeThreshold) {
                            _this.goToPrevSlide(true);
                            triggerClick = false;
                        }
                    } else if (_this.swipeDirection === "vertical") {
                        distance = Math.abs(endCoords.pageY - startCoords.pageY);
                        if (_this.settings.closable && _this.settings.swipeToClose && distance > 100) {
                            _this.closeGallery();
                            return;
                        } else _this.$backdrop.css("opacity", 1);
                    }
                    _this.outer.find(".lg-item").removeAttr("style");
                    if (triggerClick && Math.abs(endCoords.pageX - startCoords.pageX) < 5) {
                        var target = app_$LG(event.target);
                        if (_this.isPosterElement(target)) _this.LGel.trigger(app_lGEvents.posterClick);
                    }
                    _this.swipeDirection = void 0;
                }));
                setTimeout((function() {
                    if (!_this.outer.hasClass("lg-dragging") && _this.settings.mode !== "lg-slide") _this.outer.removeClass("lg-slide");
                }), this.settings.speed + 100);
            };
            LightGallery.prototype.enableSwipe = function() {
                var _this = this;
                var startCoords = {};
                var endCoords = {};
                var isMoved = false;
                var isSwiping = false;
                if (this.settings.enableSwipe) {
                    this.$inner.on("touchstart.lg", (function(e) {
                        _this.dragOrSwipeEnabled = true;
                        var $item = _this.getSlideItem(_this.index);
                        if ((app_$LG(e.target).hasClass("lg-item") || $item.get().contains(e.target)) && !_this.outer.hasClass("lg-zoomed") && !_this.lgBusy && e.touches.length === 1) {
                            isSwiping = true;
                            _this.touchAction = "swipe";
                            _this.manageSwipeClass();
                            startCoords = {
                                pageX: e.touches[0].pageX,
                                pageY: e.touches[0].pageY
                            };
                        }
                    }));
                    this.$inner.on("touchmove.lg", (function(e) {
                        if (isSwiping && _this.touchAction === "swipe" && e.touches.length === 1) {
                            endCoords = {
                                pageX: e.touches[0].pageX,
                                pageY: e.touches[0].pageY
                            };
                            _this.touchMove(startCoords, endCoords, e);
                            isMoved = true;
                        }
                    }));
                    this.$inner.on("touchend.lg", (function(event) {
                        if (_this.touchAction === "swipe") {
                            if (isMoved) {
                                isMoved = false;
                                _this.touchEnd(endCoords, startCoords, event);
                            } else if (isSwiping) {
                                var target = app_$LG(event.target);
                                if (_this.isPosterElement(target)) _this.LGel.trigger(app_lGEvents.posterClick);
                            }
                            _this.touchAction = void 0;
                            isSwiping = false;
                        }
                    }));
                }
            };
            LightGallery.prototype.enableDrag = function() {
                var _this = this;
                var startCoords = {};
                var endCoords = {};
                var isDraging = false;
                var isMoved = false;
                if (this.settings.enableDrag) {
                    this.outer.on("mousedown.lg", (function(e) {
                        _this.dragOrSwipeEnabled = true;
                        var $item = _this.getSlideItem(_this.index);
                        if (app_$LG(e.target).hasClass("lg-item") || $item.get().contains(e.target)) if (!_this.outer.hasClass("lg-zoomed") && !_this.lgBusy) {
                            e.preventDefault();
                            if (!_this.lgBusy) {
                                _this.manageSwipeClass();
                                startCoords = {
                                    pageX: e.pageX,
                                    pageY: e.pageY
                                };
                                isDraging = true;
                                _this.outer.get().scrollLeft += 1;
                                _this.outer.get().scrollLeft -= 1;
                                _this.outer.removeClass("lg-grab").addClass("lg-grabbing");
                                _this.LGel.trigger(app_lGEvents.dragStart);
                            }
                        }
                    }));
                    app_$LG(window).on("mousemove.lg.global" + this.lgId, (function(e) {
                        if (isDraging && _this.lgOpened) {
                            isMoved = true;
                            endCoords = {
                                pageX: e.pageX,
                                pageY: e.pageY
                            };
                            _this.touchMove(startCoords, endCoords);
                            _this.LGel.trigger(app_lGEvents.dragMove);
                        }
                    }));
                    app_$LG(window).on("mouseup.lg.global" + this.lgId, (function(event) {
                        if (!_this.lgOpened) return;
                        var target = app_$LG(event.target);
                        if (isMoved) {
                            isMoved = false;
                            _this.touchEnd(endCoords, startCoords, event);
                            _this.LGel.trigger(app_lGEvents.dragEnd);
                        } else if (_this.isPosterElement(target)) _this.LGel.trigger(app_lGEvents.posterClick);
                        if (isDraging) {
                            isDraging = false;
                            _this.outer.removeClass("lg-grabbing").addClass("lg-grab");
                        }
                    }));
                }
            };
            LightGallery.prototype.triggerPosterClick = function() {
                var _this = this;
                this.$inner.on("click.lg", (function(event) {
                    if (!_this.dragOrSwipeEnabled && _this.isPosterElement(app_$LG(event.target))) _this.LGel.trigger(app_lGEvents.posterClick);
                }));
            };
            LightGallery.prototype.manageSwipeClass = function() {
                var _touchNext = this.index + 1;
                var _touchPrev = this.index - 1;
                if (this.settings.loop && this.galleryItems.length > 2) if (this.index === 0) _touchPrev = this.galleryItems.length - 1; else if (this.index === this.galleryItems.length - 1) _touchNext = 0;
                this.outer.find(".lg-item").removeClass("lg-next-slide lg-prev-slide");
                if (_touchPrev > -1) this.getSlideItem(_touchPrev).addClass("lg-prev-slide");
                this.getSlideItem(_touchNext).addClass("lg-next-slide");
            };
            LightGallery.prototype.goToNextSlide = function(fromTouch) {
                var _this = this;
                var _loop = this.settings.loop;
                if (fromTouch && this.galleryItems.length < 3) _loop = false;
                if (!this.lgBusy) if (this.index + 1 < this.galleryItems.length) {
                    this.index++;
                    this.LGel.trigger(app_lGEvents.beforeNextSlide, {
                        index: this.index
                    });
                    this.slide(this.index, !!fromTouch, false, "next");
                } else if (_loop) {
                    this.index = 0;
                    this.LGel.trigger(app_lGEvents.beforeNextSlide, {
                        index: this.index
                    });
                    this.slide(this.index, !!fromTouch, false, "next");
                } else if (this.settings.slideEndAnimation && !fromTouch) {
                    this.outer.addClass("lg-right-end");
                    setTimeout((function() {
                        _this.outer.removeClass("lg-right-end");
                    }), 400);
                }
            };
            LightGallery.prototype.goToPrevSlide = function(fromTouch) {
                var _this = this;
                var _loop = this.settings.loop;
                if (fromTouch && this.galleryItems.length < 3) _loop = false;
                if (!this.lgBusy) if (this.index > 0) {
                    this.index--;
                    this.LGel.trigger(app_lGEvents.beforePrevSlide, {
                        index: this.index,
                        fromTouch
                    });
                    this.slide(this.index, !!fromTouch, false, "prev");
                } else if (_loop) {
                    this.index = this.galleryItems.length - 1;
                    this.LGel.trigger(app_lGEvents.beforePrevSlide, {
                        index: this.index,
                        fromTouch
                    });
                    this.slide(this.index, !!fromTouch, false, "prev");
                } else if (this.settings.slideEndAnimation && !fromTouch) {
                    this.outer.addClass("lg-left-end");
                    setTimeout((function() {
                        _this.outer.removeClass("lg-left-end");
                    }), 400);
                }
            };
            LightGallery.prototype.keyPress = function() {
                var _this = this;
                app_$LG(window).on("keydown.lg.global" + this.lgId, (function(e) {
                    if (_this.lgOpened && _this.settings.escKey === true && e.keyCode === 27) {
                        e.preventDefault();
                        if (_this.settings.allowMediaOverlap && _this.outer.hasClass("lg-can-toggle") && _this.outer.hasClass("lg-components-open")) _this.outer.removeClass("lg-components-open"); else _this.closeGallery();
                    }
                    if (_this.lgOpened && _this.galleryItems.length > 1) {
                        if (e.keyCode === 37) {
                            e.preventDefault();
                            _this.goToPrevSlide();
                        }
                        if (e.keyCode === 39) {
                            e.preventDefault();
                            _this.goToNextSlide();
                        }
                    }
                }));
            };
            LightGallery.prototype.arrow = function() {
                var _this = this;
                this.getElementById("lg-prev").on("click.lg", (function() {
                    _this.goToPrevSlide();
                }));
                this.getElementById("lg-next").on("click.lg", (function() {
                    _this.goToNextSlide();
                }));
            };
            LightGallery.prototype.arrowDisable = function(index) {
                if (!this.settings.loop && this.settings.hideControlOnEnd) {
                    var $prev = this.getElementById("lg-prev");
                    var $next = this.getElementById("lg-next");
                    if (index + 1 === this.galleryItems.length) $next.attr("disabled", "disabled").addClass("disabled"); else $next.removeAttr("disabled").removeClass("disabled");
                    if (index === 0) $prev.attr("disabled", "disabled").addClass("disabled"); else $prev.removeAttr("disabled").removeClass("disabled");
                }
            };
            LightGallery.prototype.setTranslate = function($el, xValue, yValue, scaleX, scaleY) {
                if (scaleX === void 0) scaleX = 1;
                if (scaleY === void 0) scaleY = 1;
                $el.css("transform", "translate3d(" + xValue + "px, " + yValue + "px, 0px) scale3d(" + scaleX + ", " + scaleY + ", 1)");
            };
            LightGallery.prototype.mousewheel = function() {
                var _this = this;
                var lastCall = 0;
                this.outer.on("wheel.lg", (function(e) {
                    if (!e.deltaY || _this.galleryItems.length < 2) return;
                    e.preventDefault();
                    var now = (new Date).getTime();
                    if (now - lastCall < 1e3) return;
                    lastCall = now;
                    if (e.deltaY > 0) _this.goToNextSlide(); else if (e.deltaY < 0) _this.goToPrevSlide();
                }));
            };
            LightGallery.prototype.isSlideElement = function(target) {
                return target.hasClass("lg-outer") || target.hasClass("lg-item") || target.hasClass("lg-img-wrap") || target.hasClass("lg-img-rotate");
            };
            LightGallery.prototype.isPosterElement = function(target) {
                var playButton = this.getSlideItem(this.index).find(".lg-video-play-button").get();
                return target.hasClass("lg-video-poster") || target.hasClass("lg-video-play-button") || playButton && playButton.contains(target.get());
            };
            LightGallery.prototype.toggleMaximize = function() {
                var _this = this;
                this.getElementById("lg-maximize").on("click.lg", (function() {
                    _this.$container.toggleClass("lg-inline");
                    _this.refreshOnResize();
                }));
            };
            LightGallery.prototype.invalidateItems = function() {
                for (var index = 0; index < this.items.length; index++) {
                    var element = this.items[index];
                    var $element = app_$LG(element);
                    $element.off("click.lgcustom-item-" + $element.attr("data-lg-id"));
                }
            };
            LightGallery.prototype.trapFocus = function() {
                var _this = this;
                this.$container.get().focus({
                    preventScroll: true
                });
                app_$LG(window).on("keydown.lg.global" + this.lgId, (function(e) {
                    if (!_this.lgOpened) return;
                    var isTabPressed = e.key === "Tab" || e.keyCode === 9;
                    if (!isTabPressed) return;
                    var focusableEls = app_lightgallery_es5_utils.getFocusableElements(_this.$container.get());
                    var firstFocusableEl = focusableEls[0];
                    var lastFocusableEl = focusableEls[focusableEls.length - 1];
                    if (e.shiftKey) {
                        if (document.activeElement === firstFocusableEl) {
                            lastFocusableEl.focus();
                            e.preventDefault();
                        }
                    } else if (document.activeElement === lastFocusableEl) {
                        firstFocusableEl.focus();
                        e.preventDefault();
                    }
                }));
            };
            LightGallery.prototype.manageCloseGallery = function() {
                var _this = this;
                if (!this.settings.closable) return;
                var mousedown = false;
                this.getElementById("lg-close").on("click.lg", (function() {
                    _this.closeGallery();
                }));
                if (this.settings.closeOnTap) {
                    this.outer.on("mousedown.lg", (function(e) {
                        var target = app_$LG(e.target);
                        if (_this.isSlideElement(target)) mousedown = true; else mousedown = false;
                    }));
                    this.outer.on("mousemove.lg", (function() {
                        mousedown = false;
                    }));
                    this.outer.on("mouseup.lg", (function(e) {
                        var target = app_$LG(e.target);
                        if (_this.isSlideElement(target) && mousedown) if (!_this.outer.hasClass("lg-dragging")) _this.closeGallery();
                    }));
                }
            };
            LightGallery.prototype.closeGallery = function(force) {
                var _this = this;
                if (!this.lgOpened || !this.settings.closable && !force) return 0;
                this.LGel.trigger(app_lGEvents.beforeClose);
                if (this.settings.resetScrollPosition && !this.settings.hideScrollbar) app_$LG(window).scrollTop(this.prevScrollTop);
                var currentItem = this.items[this.index];
                var transform;
                if (this.zoomFromOrigin && currentItem) {
                    var _a = this.mediaContainerPosition, top_4 = _a.top, bottom = _a.bottom;
                    var _b = this.galleryItems[this.index], __slideVideoInfo = _b.__slideVideoInfo, poster = _b.poster;
                    var imageSize = app_lightgallery_es5_utils.getSize(currentItem, this.outer, top_4 + bottom, __slideVideoInfo && poster && this.settings.videoMaxSize);
                    transform = app_lightgallery_es5_utils.getTransform(currentItem, this.outer, top_4, bottom, imageSize);
                }
                if (this.zoomFromOrigin && transform) {
                    this.outer.addClass("lg-closing lg-zoom-from-image");
                    this.getSlideItem(this.index).addClass("lg-start-end-progress").css("transition-duration", this.settings.startAnimationDuration + "ms").css("transform", transform);
                } else {
                    this.outer.addClass("lg-hide-items");
                    this.outer.removeClass("lg-zoom-from-image");
                }
                this.destroyModules();
                this.lGalleryOn = false;
                this.isDummyImageRemoved = false;
                this.zoomFromOrigin = this.settings.zoomFromOrigin;
                clearTimeout(this.hideBarTimeout);
                this.hideBarTimeout = false;
                app_$LG("html").removeClass("lg-on");
                this.outer.removeClass("lg-visible lg-components-open");
                this.$backdrop.removeClass("in").css("opacity", 0);
                var removeTimeout = this.zoomFromOrigin && transform ? Math.max(this.settings.startAnimationDuration, this.settings.backdropDuration) : this.settings.backdropDuration;
                this.$container.removeClass("lg-show-in");
                setTimeout((function() {
                    if (_this.zoomFromOrigin && transform) _this.outer.removeClass("lg-zoom-from-image");
                    _this.$container.removeClass("lg-show");
                    _this.resetScrollBar();
                    _this.$backdrop.removeAttr("style").css("transition-duration", _this.settings.backdropDuration + "ms");
                    _this.outer.removeClass("lg-closing " + _this.settings.startClass);
                    _this.getSlideItem(_this.index).removeClass("lg-start-end-progress");
                    _this.$inner.empty();
                    if (_this.lgOpened) _this.LGel.trigger(app_lGEvents.afterClose, {
                        instance: _this
                    });
                    if (_this.$container.get()) _this.$container.get().blur();
                    _this.lgOpened = false;
                }), removeTimeout + 100);
                return removeTimeout + 100;
            };
            LightGallery.prototype.initModules = function() {
                this.plugins.forEach((function(module) {
                    try {
                        module.init();
                    } catch (err) {
                        console.warn("lightGallery:- make sure lightGallery module is properly initiated");
                    }
                }));
            };
            LightGallery.prototype.destroyModules = function(destroy) {
                this.plugins.forEach((function(module) {
                    try {
                        if (destroy) module.destroy(); else module.closeGallery && module.closeGallery();
                    } catch (err) {
                        console.warn("lightGallery:- make sure lightGallery module is properly destroyed");
                    }
                }));
            };
            LightGallery.prototype.refresh = function(galleryItems) {
                if (!this.settings.dynamic) this.invalidateItems();
                if (galleryItems) this.galleryItems = galleryItems; else this.galleryItems = this.getItems();
                this.updateControls();
                this.openGalleryOnItemClick();
                this.LGel.trigger(app_lGEvents.updateSlides);
            };
            LightGallery.prototype.updateControls = function() {
                this.addSlideVideoInfo(this.galleryItems);
                this.updateCounterTotal();
                this.manageSingleSlideClassName();
            };
            LightGallery.prototype.destroyGallery = function() {
                this.destroyModules(true);
                if (!this.settings.dynamic) this.invalidateItems();
                app_$LG(window).off(".lg.global" + this.lgId);
                this.LGel.off(".lg");
                this.$container.remove();
            };
            LightGallery.prototype.destroy = function() {
                var closeTimeout = this.closeGallery(true);
                if (closeTimeout) setTimeout(this.destroyGallery.bind(this), closeTimeout); else this.destroyGallery();
                return closeTimeout;
            };
            return LightGallery;
        }();
        function app_lightGallery(el, options) {
            return new app_LightGallery(el, options);
        }
        const app_lightgallery_es5 = app_lightGallery;
        var app_lg_thumbnail_min = __webpack_require__(757);
        var app_lg_zoom_min = __webpack_require__(227);
        var app_lg_video_min = __webpack_require__(43);
        function app_initLightGallery(selector = "[data-gallery]") {
            const galleries = document.querySelectorAll(selector);
            if (!galleries.length) return;
            let galleryInstances = [];
            galleries.forEach((gallery => {
                const galleryInstance = app_lightgallery_es5(gallery, {
                    plugins: [ app_lg_zoom_min, app_lg_thumbnail_min, app_lg_video_min ],
                    licenseKey: "7EC452A9-0CFD441C7C-17C8456E",
                    speed: 500,
                    mobileSettings: {
                        controls: false,
                        showCloseIcon: true,
                        download: false
                    },
                    videojs: true,
                    videojsOptions: {
                        muted: false
                    }
                });
                let isGalleryOpen = false;
                function closeGalleryOnBack(event) {
                    if (isGalleryOpen) {
                        galleryInstance.closeGallery();
                        isGalleryOpen = false;
                        event.preventDefault();
                    }
                }
                gallery.addEventListener("lgAfterOpen", (() => {
                    isGalleryOpen = true;
                    history.pushState(null, null, document.URL);
                    window.addEventListener("popstate", closeGalleryOnBack);
                }));
                gallery.addEventListener("lgAfterClose", (() => {
                    isGalleryOpen = false;
                    history.replaceState(null, null, document.URL);
                    window.removeEventListener("popstate", closeGalleryOnBack);
                }));
                galleryInstances.push({
                    gallery,
                    instance: galleryInstance
                });
            }));
            return galleryInstances;
        }
        app_modules_flsModules.gallery = app_initLightGallery();
        class app_DynamicAdapt {
            constructor(type) {
                this.type = type;
            }
            init() {
                this.–æbjects = [];
                this.daClassname = "_dynamic_adapt_";
                this.nodes = [ ...document.querySelectorAll("[data-da]") ];
                this.nodes.forEach((node => {
                    const data = node.dataset.da.trim();
                    const dataArray = data.split(",");
                    const –æbject = {};
                    –æbject.element = node;
                    –æbject.parent = node.parentNode;
                    –æbject.destination = document.querySelector(`${dataArray[0].trim()}`);
                    –æbject.breakpoint = dataArray[1] ? dataArray[1].trim() : "767.98";
                    –æbject.place = dataArray[2] ? dataArray[2].trim() : "last";
                    –æbject.index = this.indexInParent(–æbject.parent, –æbject.element);
                    this.–æbjects.push(–æbject);
                }));
                this.arraySort(this.–æbjects);
                this.mediaQueries = this.–æbjects.map((({breakpoint}) => `(${this.type}-width: ${breakpoint / 16}em),${breakpoint}`)).filter(((item, index, self) => self.indexOf(item) === index));
                this.mediaQueries.forEach((media => {
                    const mediaSplit = media.split(",");
                    const matchMedia = window.matchMedia(mediaSplit[0]);
                    const mediaBreakpoint = mediaSplit[1];
                    const –æbjectsFilter = this.–æbjects.filter((({breakpoint}) => breakpoint === mediaBreakpoint));
                    matchMedia.addEventListener("change", (() => {
                        this.mediaHandler(matchMedia, –æbjectsFilter);
                    }));
                    this.mediaHandler(matchMedia, –æbjectsFilter);
                }));
            }
            mediaHandler(matchMedia, –æbjects) {
                if (matchMedia.matches) –æbjects.forEach((–æbject => {
                    this.moveTo(–æbject.place, –æbject.element, –æbject.destination);
                })); else –æbjects.forEach((({parent, element, index}) => {
                    if (element.classList.contains(this.daClassname)) this.moveBack(parent, element, index);
                }));
            }
            moveTo(place, element, destination) {
                element.classList.add(this.daClassname);
                if (place === "last" || place >= destination.children.length) {
                    destination.append(element);
                    return;
                }
                if (place === "first") {
                    destination.prepend(element);
                    return;
                }
                destination.children[place].before(element);
            }
            moveBack(parent, element, index) {
                element.classList.remove(this.daClassname);
                if (parent.children[index] !== void 0) parent.children[index].before(element); else parent.append(element);
            }
            indexInParent(parent, element) {
                return [ ...parent.children ].indexOf(element);
            }
            arraySort(arr) {
                if (this.type === "min") arr.sort(((a, b) => {
                    if (a.breakpoint === b.breakpoint) {
                        if (a.place === b.place) return 0;
                        if (a.place === "first" || b.place === "last") return -1;
                        if (a.place === "last" || b.place === "first") return 1;
                        return 0;
                    }
                    return a.breakpoint - b.breakpoint;
                })); else {
                    arr.sort(((a, b) => {
                        if (a.breakpoint === b.breakpoint) {
                            if (a.place === b.place) return 0;
                            if (a.place === "first" || b.place === "last") return 1;
                            if (a.place === "last" || b.place === "first") return -1;
                            return 0;
                        }
                        return b.breakpoint - a.breakpoint;
                    }));
                    return;
                }
            }
        }
        const app_da = new app_DynamicAdapt("max");
        app_da.init();
        document.addEventListener("DOMContentLoaded", (() => {
            document.querySelectorAll(".text-animation").forEach((textElement => {
                const delayStep = textElement.dataset.delayStep || 100;
                textElement.style.setProperty("--delay-step", `${delayStep}ms`);
                const delay = textElement.dataset.delay || 0;
                textElement.style.setProperty("--delay", `${delay}ms`);
                const words = textElement.innerText.split(" ");
                const fragment = document.createDocumentFragment();
                words.forEach((word => {
                    const span = document.createElement("span");
                    const innerSpan = document.createElement("span");
                    innerSpan.textContent = word;
                    span.appendChild(innerSpan);
                    fragment.appendChild(span);
                }));
                textElement.innerHTML = "";
                textElement.appendChild(fragment);
            }));
        }));
        window["FLS"] = false;
        app_addLoadedClass();
        app_menuInit();
        app_tabs();
        app_pageNavigation();
        app_headerScroll();
    })();
})();